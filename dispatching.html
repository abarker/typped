
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>3. Constructs and preconditioned dispatching &#8212; Typped  documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Example: Implementing a simple calculator" href="calculator_example.html" />
    <link rel="prev" title="2. Introduction to Pratt parsing and its terminology" href="pratt_parsing_intro.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="calculator_example.html" title="4. Example: Implementing a simple calculator"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pratt_parsing_intro.html" title="2. Introduction to Pratt parsing and its terminology"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="constructs-and-preconditioned-dispatching">
<h1>3. Constructs and preconditioned dispatching<a class="headerlink" href="#constructs-and-preconditioned-dispatching" title="Permalink to this headline">¶</a></h1>
<p>This section describes the use of preconditioned dispatching in the
<code class="docutils literal"><span class="pre">PrattParser</span></code> class.  Many Typped users will never need to explicitly use the
techniques described here, since the Typped parser comes with various built-in
methods which hide the use of precondition functions.  The calulator example,
for example, uses only built-in methods of the <code class="docutils literal"><span class="pre">PrattParser</span></code> class.  This
description is mainly for users who need to define their own, custom parsing
methods or those who are simply interested in the details of how dispatching
works.</p>
<div class="section" id="what-is-preconditioned-dispatching">
<h2>3.1. What is preconditioned dispatching?<a class="headerlink" href="#what-is-preconditioned-dispatching" title="Permalink to this headline">¶</a></h2>
<p>In a standard Pratt parser each token can have associated with it a single,
fixed head handler function, a single, fixed tail handler function, or one of
each.  Preconditioned dispatching generalizes this: Each token can have
multiple possible head and/or tail handler functions associated with it.  The
choice of which of the possible handler functions to use to process a token is
made at at the time the token is parsed, based on the conditions (e.g., the
parser and lexer state) at that time.  The conditions which can be taken into
account include, for example, the actual string value that the lexer matched in
the program text and the kind of token that is one peek ahead in the lexer.
Note that this generalized behavior in Typped is optional and can easily be
ignored if one only wants to use standard Pratt parser techniques.</p>
<p>Since in Pratt parsing each head and tail handler essentially parses a
different part of the grammar, the Typped packages uses an abstraction of
handler functions called a <strong>syntactic construct</strong>, or simply a <strong>construct</strong>.
A construct represents a particular kind of grammatical subexpression that is
parsed and returned by a handler function.  Since Pratt parsers are top-down
these grammatical parts tend to correspond to subtrees of the final expression
tree.  A construct containing a head handler will be called a <strong>head
construct</strong> and a construct containing a tail handler will be called a <strong>tail
construct</strong>.  Constructs also contain other attributes, as we will see.</p>
<p>In a standard Pratt parser a handler function is triggered whenever a
particular kind of token is consumed from the lexer in the <code class="docutils literal"><span class="pre">recursive_parse</span></code>
routine.  Either the head handler or the tail handler function associated
with that kind of token is run, depending on whether or not the token is the
first token in the subexpression being parsed.</p>
<p>In a preconditioned-dispatching Pratt parser each handler function is
associated with a unique construct, and each construct has associated with it
the label of a <strong>triggering token</strong> which triggers that construct as
potentially the one to use.  A single kind of token can potentially trigger
multiple constructs (either head constructs or tail constructs, depending on
the token’s position).</p>
<p>When a token is consumed in <code class="docutils literal"><span class="pre">recursive_parse</span></code> it triggers a collection of
constructs.  The choice of which one to actually use is based on the evaluation
of <strong>preconditions functions</strong> associated with the constructs.  Preconditions
functions are simply boolean-valued functions which are executed at the time
when a handler function is required.  A preconditions function which returns
true when evaluated is said to <strong>match</strong> in the current state.  The matching
construct with the highest <strong>preconditions priority</strong> is selected, and its
handler is run.</p>
<p>Constructs are implemented as instances of <code class="docutils literal"><span class="pre">Construct</span></code> objects.  They contain
the following attributes:</p>
<ul class="simple">
<li>a kind of token which triggers the construct</li>
<li>a head or tail handler function</li>
<li>a preconditions function</li>
<li>a preconditions priority</li>
<li>a string label for the construct</li>
<li>other data, such as evaluation functions and type signatures</li>
</ul>
<p>Constructs are <strong>registered</strong> with a parser instance in order to define a
particular grammar on the tokens of the language (the tokens must be separately
defined with <code class="docutils literal"><span class="pre">def_token</span></code>).  The preconditions priority is a number which
defaults to zero.</p>
<p>Whenever the <code class="docutils literal"><span class="pre">recursive_parse</span></code> routine consumes a particular kind of token
from the lexer, in a head or tail position, it sequentially executes the
preconditions functions for all the constructs triggered by that kind of
token, in that position.  The execution sequence is ordered by the
preconditions priority values.  The construct associated with the first
matching preconditions function is selected.  Its handler function is then
dispatched as the one to be run by the <code class="docutils literal"><span class="pre">recursive_parse</span></code> routine.  If there
is no clear winner among the highest-priority matching preconditions functions
(i.e., more than one match has the highest priority) then an exception is
raised.</p>
<p>This algorithm clearly reduces to ordinary Pratt parsing in the case where
there is at most one head construct and one tail construct per kind of token
and the preconditions functions always evaluate as true.</p>
</div>
<div class="section" id="using-dispatching">
<h2>3.2. Using dispatching<a class="headerlink" href="#using-dispatching" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">PrattParser</span></code> method which registers a construct with the parser is
called <code class="docutils literal"><span class="pre">def_construct</span></code>.  It is used, for example, inside the builtin methods
after defining the handler functions and any preconditions functions.  To
define custom constructs it needs to be explicitly called.</p>
<p>One of the optional arguments to <code class="docutils literal"><span class="pre">def_construct</span></code> is <code class="docutils literal"><span class="pre">precond_fun</span></code>, which
can be passed a function taking two parameters, <code class="docutils literal"><span class="pre">tok</span></code> and <code class="docutils literal"><span class="pre">lex</span></code>.  It should
return <code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code> (or the equivalent).  When a token is read in
<code class="docutils literal"><span class="pre">recursive_parse</span></code> all the preconditions functions for all the constructs
triggered by that kind of token are run in priority ordering until one is true.
The associated construct is the “winner” and is dispatched to be called.  When
the preconditions function is called, <code class="docutils literal"><span class="pre">tok</span></code> is the triggering token and
<code class="docutils literal"><span class="pre">lex</span></code> is the lexer.  (Usually <code class="docutils literal"><span class="pre">tok</span> <span class="pre">==</span> <span class="pre">lex.token</span></code>, except in the case of
some “virtual” tokens like null-space tokens and jop-tokens which are both
discussed in later sections.)</p>
<p>See the documentation for the <code class="docutils literal"><span class="pre">def_construct</span></code> method at
<a class="reference internal" href="typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_construct" title="typped.pratt_parser.PrattParser.def_construct"><code class="xref py py-meth docutils literal"><span class="pre">typped.pratt_parser.PrattParser.def_construct()</span></code></a>.  The basic
specification is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">def_construct</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span> <span class="n">handler_fun</span><span class="p">,</span> <span class="n">trigger_token_label</span><span class="p">,</span>
                  <span class="n">prec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">construct_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">precond_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precond_priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">val_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">eval_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ast_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">token_value_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dummy_handler</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</pre></div>
</div>
<p>For a simple example of defining a construct, see <a class="reference internal" href="basic_usage.html#example-parsing-a-simple-expression-without-using-builtins"><span class="std std-ref">Example: Parsing a simple expression without using builtins</span></a>.  A more general example is
given in the next section.</p>
</div>
<div class="section" id="example-defining-standard-functions-with-lookahead">
<h2>3.3. Example: Defining standard functions with lookahead<a class="headerlink" href="#example-defining-standard-functions-with-lookahead" title="Permalink to this headline">¶</a></h2>
<p>As an example of dispatching, consider the parsing of function evaluations such
as <code class="docutils literal"><span class="pre">f(x)</span></code> in a Pratt parser.   The “usual” way is to define a tail handler
for the left-paren token.  Then that symbol acts like an infix operator with
the function name as its first argument and the function arguments and closing
paren as its second argument.  If parentheses are also used for grouping then a
head-handler for left paren is defined for that use.  The resolution between
the two uses is based on whether the left paren is in a head or tail position
in a subexpression.  In the case of the function evaluation, the token for the
function name <code class="docutils literal"><span class="pre">f</span></code> is the head of the subexpression.</p>
<p>This usual way of parsing function evaluations can lead to complications in
more-complex grammars where left paren is used in various contexts.  If a
juxtaposition operator is being used, for example, then an expression like
<code class="docutils literal"><span class="pre">pi</span> <span class="pre">(x+y)</span></code> can cause problems with the usual method.  The name <code class="docutils literal"><span class="pre">pi</span></code> might
be a constant or a function name.  (At the least the left paren tail handler
would need to be conditioned on a space occurring before it, but this example
takes a different approach.)</p>
<p>By using a precondition that the lookahead token be a left paren with no
intervening space the head handler for a standard function identifier can parse
the whole subexpression rather than waiting to be picked up as the left operand of
the infix left paren operator.  A second, lower-priority default head handler
can still be defined for all other identifiers.  (Other preconditions can also
be placed on other head handlers for identifiers).  These two head handler
definitions are largely independent, except via their respective priorities.
They can occur in different sections of code, where the different constructs
are defined.  Both handlers are registered for the identifier token, and the
rest is handled automatically.</p>
<p>The code for this example can be found in a runnable form in the file
<a class="reference external" href="https://github.com/abarker/typped/blob/master/examples/example_stdfun_lookahead.py">example_stdfun_lookahead.py</a>.</p>
<p>In this example the <code class="docutils literal"><span class="pre">PrattParser</span></code> class is extended by creating a subclass
with additional methods.  In particular, a general method is added which parses
standard functions.  If a general method is not required then the code could
instead just define the handler and preconditions function and call
<code class="docutils literal"><span class="pre">def_construct</span></code>.</p>
<p>For a general parsing method it is not strictly necessary to create a subclass
of <code class="docutils literal"><span class="pre">PrattParser</span></code>.  An ordinary function can also be used.   Just rename the
<code class="docutils literal"><span class="pre">self</span></code> variable to something like <code class="docutils literal"><span class="pre">parser</span></code> and explicitly pass in a parser
instance when calling it.  Extending the class has the advantage that the newer
methods are called in the same way as the built-in ones, and the parser
instance’s namespace is convenient for accessing the function.</p>
<p>In this example the method <code class="docutils literal"><span class="pre">def_stdfun_lookahead</span></code> is added to the
<code class="docutils literal"><span class="pre">PrattParser</span></code>.  This is only an example, since the <code class="docutils literal"><span class="pre">PrattParser</span></code> class
already has a <code class="docutils literal"><span class="pre">def_stdfun</span></code> method which uses lookahead and also incorporates
types, etc.  Before calling this method all of the tokens involved must have
already been defined along with their labels (via the <code class="docutils literal"><span class="pre">def_token</span></code> method).
Ignored whitespace tokens must also have been defined already.  The lpar, rpar,
and comma tokens must already have been defined as literal tokens (via the
<code class="docutils literal"><span class="pre">def_literal</span></code> method).</p>
<p>Recall that the head-handler function will be called to process a subexpression
starting from the beginning.  That head-handler is then responsible for parsing
the full subexpression – though it can itself call <code class="docutils literal"><span class="pre">recursive_parse</span></code> to
parse sub-subexpressions.  We are defining a head-handler that only matches a
function name in the case where the peek token is an lpar with no intervening
space.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">define_parser_subclass</span><span class="p">():</span>

    <span class="k">class</span> <span class="nc">MyParser</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">PrattParser</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subclass and add a new method to the `PrattParser` class as an example.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Call the superclass initializer.&quot;&quot;&quot;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">MyParser</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">def_stdfun_lookahead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_token_label</span><span class="p">,</span> <span class="n">lpar_token_label</span><span class="p">,</span>
                                 <span class="n">rpar_token_label</span><span class="p">,</span> <span class="n">comma_token_label</span><span class="p">,</span> <span class="n">num_args</span><span class="p">,</span>
                                 <span class="n">precond_priority</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Define a standard function with a fixed number of arguments.&quot;&quot;&quot;</span>

            <span class="c1"># Define the preconditions function.</span>
            <span class="k">def</span> <span class="nf">preconditions</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
                <span class="n">peek_tok</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">peek_tok</span><span class="o">.</span><span class="n">ignored_before</span><span class="p">:</span> <span class="c1"># No space allowed between name and lpar.</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">peek_tok</span><span class="o">.</span><span class="n">token_label</span> <span class="o">!=</span> <span class="n">lpar_token_label</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="c1"># Define the head-handler function.</span>
            <span class="k">def</span> <span class="nf">head_handler</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
                <span class="c1"># Below match_next is for a precondition, so it will match and consume.</span>
                <span class="n">lex</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lpar_token_label</span><span class="p">,</span> <span class="n">raise_on_fail</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

                <span class="c1"># Read comma-separated subexpressions as arguments.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_args</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">tok</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">lex</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">comma_token_label</span><span class="p">,</span> <span class="n">raise_on_fail</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">lex</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">rpar_token_label</span><span class="p">,</span> <span class="n">raise_on_success</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># Error.</span>
                <span class="k">if</span> <span class="n">num_args</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tok</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                <span class="c1"># Consume closing paren.</span>
                <span class="n">lex</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">rpar_token_label</span><span class="p">,</span> <span class="n">raise_on_fail</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tok</span>

            <span class="c1"># Register the construct with the parser.</span>
            <span class="n">construct_label</span> <span class="o">=</span> <span class="s2">&quot;function call using precondition on function name&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">head_handler</span><span class="p">,</span> <span class="n">fname_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                               <span class="n">construct_label</span><span class="o">=</span><span class="n">construct_label</span><span class="p">,</span>
                               <span class="n">precond_fun</span><span class="o">=</span><span class="n">preconditions</span><span class="p">,</span>
                               <span class="n">precond_priority</span><span class="o">=</span><span class="n">precond_priority</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MyParser</span>
</pre></div>
</div>
<p>In parsing the full function call the handler defined above uses both the
helper function <code class="docutils literal"><span class="pre">match_next</span></code> as well as calls to the lexer and
<code class="docutils literal"><span class="pre">recursive_parse</span></code>.  Generally, tokens which will appear in the final parse
tree, even literal tokens, should be retrieved with <code class="docutils literal"><span class="pre">recursive_parse</span></code>.  That
is because it performs some extra processing the nodes such as setting their
actual types.  Tokens which do not appear in the final parse tree, such as the
final closing rpar token of the function arguments, can simply be consumed by
<code class="docutils literal"><span class="pre">match_next</span></code> or an explicit call to <code class="docutils literal"><span class="pre">lex.next()</span></code> and discarded.</p>
<p>The function defined above could be called as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">define_grammar</span><span class="p">(</span><span class="n">MyParser</span><span class="p">):</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">MyParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">def_default_whitespace</span><span class="p">()</span>

    <span class="n">tok</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">def_token</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_number&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">),</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_lpar&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\(&quot;</span><span class="p">),</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_rpar&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\)&quot;</span><span class="p">),</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_comma&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;,&quot;</span><span class="p">),</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_add&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;add&quot;</span><span class="p">),</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_sub&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;sub&quot;</span><span class="p">),</span>

    <span class="n">lit</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">def_literal</span>
    <span class="n">lit</span><span class="p">(</span><span class="s2">&quot;k_number&quot;</span><span class="p">)</span>
    <span class="n">lit</span><span class="p">(</span><span class="s2">&quot;k_lpar&quot;</span><span class="p">)</span>
    <span class="n">lit</span><span class="p">(</span><span class="s2">&quot;k_rpar&quot;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">def_stdfun_lookahead</span><span class="p">(</span><span class="s2">&quot;k_add&quot;</span><span class="p">,</span> <span class="s2">&quot;k_lpar&quot;</span><span class="p">,</span> <span class="s2">&quot;k_rpar&quot;</span><span class="p">,</span> <span class="s2">&quot;k_comma&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">def_stdfun_lookahead</span><span class="p">(</span><span class="s2">&quot;k_sub&quot;</span><span class="p">,</span> <span class="s2">&quot;k_lpar&quot;</span><span class="p">,</span> <span class="s2">&quot;k_rpar&quot;</span><span class="p">,</span> <span class="s2">&quot;k_comma&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">parser</span>
</pre></div>
</div>
<p>Now this code can be run:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">MyParser</span> <span class="o">=</span> <span class="n">define_parser_subclass</span><span class="p">()</span>
<span class="n">parser_instance</span> <span class="o">=</span> <span class="n">define_grammar</span><span class="p">(</span><span class="n">MyParser</span><span class="p">)</span>
<span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;add(4, sub(5,6))&quot;</span>
<span class="n">expr_tree</span> <span class="o">=</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">expr_tree</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>When run, the above code produces this output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">k_add</span><span class="p">,</span><span class="s1">&#39;add&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;4&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">k_sub</span><span class="p">,</span><span class="s1">&#39;sub&#39;</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;5&#39;</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;6&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>This example works, but is simplified from the actual <code class="docutils literal"><span class="pre">def_stdfun</span></code> method of
the Pratt parser class.  It assumes a fixed number of arguments and does not
make use of type data.  The function is still fairly general, though.  Note
that this function does not allow whitespace (ignored tokens) to occur between
the function name and the left parenthesis.  The preconditions function is
defined as a nested function, but it could alternately be passed in as another
argument to <code class="docutils literal"><span class="pre">def_stdfun</span></code> (along with its label).</p>
<div class="topic">
<p class="topic-title first">Two ways to parse identifiers</p>
<p>The Typped parser and lexer are both dynamic and can be updated on-the-fly.
This flexibility allows for a different style of defining identifiers than
is traditionally used.  Consider an example where function name
identifiers are being parsed.  Assume that the language being parsed has
some sort of definition mechanism where function names must be defined
before they are used.  (The principle is more general, including cases
where, say, functions and variables share the same namespace or for
kinds of token other than identifiers.)</p>
<p>In the traditional parser design a generic function-name identifier is
defined for the lexer and any further processing is done by the parser, based
on the actual string value found in the program text.  This allows a
fixed lexer to be used.  When the lexer is dynamic, though, it is possible
to define a new token for each definition of an identifier.</p>
<p>Suppose we have functions <code class="docutils literal"><span class="pre">add</span></code> and <code class="docutils literal"><span class="pre">exp</span></code>.  In the traditional approach
the lexer would identify each as a function name identifier, and return that
information along with the actual text string.  In the dynamic-lexer
approach you would define a new token for <code class="docutils literal"><span class="pre">add</span></code> at the time it is defined.
Similarly for the <code class="docutils literal"><span class="pre">exp</span></code> function.  The lexer would then return a unique
token for each function, pushing some of the parsing down to the lexer
level.</p>
<p>An advantage of the dynamic approach is that it can help to avoid
ambiguities in parsing complex languages.  The disadvantages are that it may
take slightly more space to define the new tokens, it may be slower to scan
with so many possible tokens, and the function names (and hence their
tokens) must be defined before being used.</p>
<p>A disadvantage of using a common identifier token for all function names is
evaluation functions then cannot be automatically associated with the
tokens.  To get around this the <code class="code docutils literal"><span class="pre">def_construct</span></code> method takes a keyword
argument <code class="code docutils literal"><span class="pre">value_key</span></code> can be passed strings like <code class="code docutils literal"><span class="pre">add</span></code> and <code class="code docutils literal"><span class="pre">exp</span></code>.  The
evaluation functions are then keyed on those values, too.  During lookup
the actual text string for the token is used to look back up the evaluation
function.</p>
<p>As far as the efficiency of defining many tokens, the Typped lexer is
designed to very efficiently scan large numbers of tokens provided they have
a simple pattern.  The <code class="code docutils literal"><span class="pre">Matcher</span></code> used by the lexer can use one of several
hybrid approaches.  For example, simple patterns (currently restricted to
fixed strings for this speedup) can be automatically stored in a trie data
structure and essentially all scanned in parallel by walking down the trie.
Their insert and delete time is linear in the pattern length.  So, while the
Typped parser can be used in either way, the use of dynamic token
definitions is worth considering.</p>
</div>
</div>
<div class="section" id="modifications-to-recursive-parse">
<h2>3.4. Modifications to <code class="docutils literal"><span class="pre">recursive_parse</span></code><a class="headerlink" href="#modifications-to-recursive-parse" title="Permalink to this headline">¶</a></h2>
<p>In generalizing to preconditioned dispatching the <code class="docutils literal"><span class="pre">recursive_parse</span></code> routine
is slightly modified from the one in the previous section.  A simplified
version is shown here:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">):</span>
    <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="n">head_handler</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">dispatch_handler</span><span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">lex</span><span class="p">)</span>
    <span class="n">processed_left</span> <span class="o">=</span> <span class="n">head_handler</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>
        <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">tail_handler</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">dispatch_handler</span><span class="p">(</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>
        <span class="n">processed_left</span> <span class="o">=</span> <span class="n">tail_handler</span><span class="p">()</span>
</pre></div>
</div>
<p>Instead of directly calling a fixed head or tail handler for a token, the
<code class="docutils literal"><span class="pre">recursive_parse</span></code> function instead calls a function <code class="docutils literal"><span class="pre">dispatch_handler</span></code>.
This function takes an argument which specifies whether to fetch a head or a
tail handler.  This function selects a construct, as described above, and
returns the handler function (which is actually a wrapper function that first
runs the handler and then does type checking on the returned subtree).  For
convenience the arguments to the handler are bound, since they are already
known.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Preconditioned dispatching is only a slight generalization of the usual
Pratt parser.  A similar thing could be accomplished with ordinary head and
tail functions via a case statement inside each one, performing different
actions based on the conditions at the time and ordered in the case
statement by priority. An advantage of using function dispatching instead
is that it allows for modularity in defining the head and tail handlers for
a particular kind of token.</p>
<p class="last">With dispatching, what would otherwise be a case statement in a handler
function is essentially split up into many separate functions, one for each
case.  So each case in such a case statement can be defined in the place
where that syntactic construct is generally being defined, rather than
having to be placed in one centralized and separate location.  This makes it
easier to create essentially independent functional interfaces for different
syntactical constructs.  For example, the <code class="code docutils literal"><span class="pre">PrattParser</span></code> class comes with
methods predefined to easily perform common syntax-related tasks such as
defining an infix operator, define a grouping operator, define a standard
function, etc.  If one big case statement were being used in a single head
or tail handler then that case statement would have to be modified for each
such method.</p>
</div>
</div>
<div class="section" id="uniqueness-of-constructs">
<h2>3.5. Uniqueness of constructs<a class="headerlink" href="#uniqueness-of-constructs" title="Permalink to this headline">¶</a></h2>
<p>Equality or non-equality of two constructs in the sense of being triggered by
identical conditions is determined by equality of triples of the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span> <span class="n">trigger_token_label</span><span class="p">,</span> <span class="n">precond_fun</span><span class="p">)</span>
</pre></div>
</div>
<p>The preconditions priority is not included because it determines the
interaction between different constructs match.  If two constructs match in the
above tuple but have different <code class="docutils literal"><span class="pre">precond_priority</span></code> values then one will always
shadow the other.  The shadowed construct will never run.</p>
<p>Unfortunately it is impractical to determine in general when two preconditions
functions are identical in the sense that they compute the same thing.</p>
<p>Recall that function overloading based on argument types is used for
syntactical constructs which parse the same (i.e., with the same preconditions
and using the same handler function) but which are then resolved into different
semantic objects based on the actual types of the arguments which are processed
at parse-time.  Overloading can also involve the type of the function’s return
value.</p>
<p>Overloading must be explicitly specified, via a call to the <code class="docutils literal"><span class="pre">overload</span></code> method
of a previously-defined construct instance.  Because of the difficulty of
determining equivalence of preconditions functions, described above,
overloading cannot be done by simply calling <code class="docutils literal"><span class="pre">def_construct</span></code> again with the
same arguments and a different type.</p>
<div class="topic">
<p class="topic-title first">Overloading versus preconditions functions</p>
<p>An alternative way that Typped could have implemented overloading would have
been to always use a unique construct label for each overload — perhaps by
appending a string representation of the type to the label.  But this would
also complicate the resolution of constructs.</p>
<p>Constructs as currently implemented must be uniquely resolvable
at parse-time.  They then uniquely determine the handler function to call.
If different preconditions labels are used for overloading then overloading
will cause multiple constructs to match as a normal thing.  These ties will not
be uniquely resolvable by a priority system.</p>
<p>To resolve an overload the expression must first be parsed to find the
actual types.  Resolving the actual types requires a handler function, which
is stored with a construct.  This is circular if separate constructs are
used for each overload.  One approach might be to assume that if there are
multiple constructs which match at the same priority then they all have the
same handler function.  You could then just pick one to call, but that could
mask some error conditions.  After the actual types are found a unique
construct would still need to be determined from among the matches in order
to access the associated evaluation function and AST data.  It seems simpler
to just to store all the overloaded signatures and their associated data
with a single construct.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Constructs and preconditioned dispatching</a><ul>
<li><a class="reference internal" href="#what-is-preconditioned-dispatching">3.1. What is preconditioned dispatching?</a></li>
<li><a class="reference internal" href="#using-dispatching">3.2. Using dispatching</a></li>
<li><a class="reference internal" href="#example-defining-standard-functions-with-lookahead">3.3. Example: Defining standard functions with lookahead</a></li>
<li><a class="reference internal" href="#modifications-to-recursive-parse">3.4. Modifications to <code class="docutils literal"><span class="pre">recursive_parse</span></code></a></li>
<li><a class="reference internal" href="#uniqueness-of-constructs">3.5. Uniqueness of constructs</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pratt_parsing_intro.html"
                        title="previous chapter">2. Introduction to Pratt parsing and its terminology</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="calculator_example.html"
                        title="next chapter">4. Example: Implementing a simple calculator</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/dispatching.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="calculator_example.html" title="4. Example: Implementing a simple calculator"
             >next</a> |</li>
        <li class="right" >
          <a href="pratt_parsing_intro.html" title="2. Introduction to Pratt parsing and its terminology"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>