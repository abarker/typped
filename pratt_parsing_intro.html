
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>2. Introduction to Pratt parsing and its terminology &#8212; Typped  documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. Constructs and preconditioned dispatching" href="dispatching.html" />
    <link rel="prev" title="1. Basic usage" href="basic_usage.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dispatching.html" title="3. Constructs and preconditioned dispatching"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basic_usage.html" title="1. Basic usage"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction-to-pratt-parsing-and-its-terminology">
<h1>2. Introduction to Pratt parsing and its terminology<a class="headerlink" href="#introduction-to-pratt-parsing-and-its-terminology" title="Permalink to this headline">¶</a></h1>
<p>This section provides an introduction to the general concept of Pratt
parsing, as well as the terminology used in the Typped documentation and
code.</p>
<div class="section" id="what-is-a-pratt-parser">
<h2>2.1. What is a Pratt parser?<a class="headerlink" href="#what-is-a-pratt-parser" title="Permalink to this headline">¶</a></h2>
<p>Pratt parsing is a type of parsing introduced by Vaughan Pratt in a 1973 paper
(see <a class="reference internal" href="#references"><span class="std std-ref">References</span></a>).  It is also known as “top-down operator-precedence
parsing” because it is a top-down, recursive algorithm which can easily handle
operator precedences.  Pratt describes it as a modification of the Floyd
operator-precedence parser to work top-down.  Pratt parsing fell into relative
obscurity for some years, but it has recently experienced something of a
revival.</p>
<p>The well-known recursive descent parsing algorithm is also a top-down,
recursive parsing method.  In recursive descent parsing each nonterminal in
the grammar of a language (BNF, EBNF, etc.) is associated with a function
which is designed to parse productions for that nonterminal.  By contrast, in a
Pratt parser each type of token has one or more functions associated with it.
These functions will be called <strong>handler functions</strong>, since they handle the
parsing for that particular kind of token.</p>
<p>Some of Pratt’s original terminology is less-than-intuitive in a modern
context.  That original terminology is still commonly used in descriptions of
Pratt parsing and in the example code.  The Typped package uses alternative
terminology which is hopefully more intuitive — at least in the context of a
Python implementation.  The correspondences between the terms in Pratt’s
original terminology and the terms used in Typped are noted below at the points
where the terms are defined.  They are also summarized in a table.</p>
</div>
<div class="section" id="basic-assumptions">
<h2>2.2. Basic assumptions<a class="headerlink" href="#basic-assumptions" title="Permalink to this headline">¶</a></h2>
<p>In this discussion it is assumed that a lexical scanner (lexer) has been
defined as <code class="docutils literal"><span class="pre">lex</span></code>.  The lexer is assumed to provide a <code class="docutils literal"><span class="pre">lex.next()</span></code> function
which returns the next token, and a <code class="docutils literal"><span class="pre">lex.peek()</span></code> function which peeks at the
next token without consuming it.  The <strong>current token</strong> is the last one
returned by <code class="docutils literal"><span class="pre">next</span></code>, and is also assumed to be available as <code class="docutils literal"><span class="pre">lex.token</span></code> from
the lexer.  The parser will consume tokens from the lexer.</p>
<p>Many of the presentations of the Pratt parser essentially fake a lexer with
one-token <code class="docutils literal"><span class="pre">peek</span></code> lookahead from a lexer without built-in lookahead.  This is
done by first calling <code class="docutils literal"><span class="pre">next</span></code> to get a token which acts as a peek.  Then, when
getting another token, this peek token is saved as the current token and
<code class="docutils literal"><span class="pre">next</span></code> is called to get the next peek token.  When the Pratt parser algorithm
is written assuming that the lexer provides both a <code class="docutils literal"><span class="pre">next</span></code> and a <code class="docutils literal"><span class="pre">peek</span></code>
function it requires slightly less code, and, more importantly, is easier to
follow.</p>
<p>A parser parses a <strong>program</strong> or an <strong>expression</strong> from text that is passed to
the parser’s <code class="docutils literal"><span class="pre">parse</span></code> function or method.  We assume that <code class="docutils literal"><span class="pre">parse</span></code> will be
passed both a lexer instance (initialized to recognize the tokens of the
language) and the expression to be parsed.  The <code class="docutils literal"><span class="pre">parse</span></code> function  initializes
the lexer with this text in order to tokenize it.  In this implementation of
Pratt parsing the <code class="docutils literal"><span class="pre">parse</span></code> method just sets things up and then calls
<code class="docutils literal"><span class="pre">recursive_parse</span></code> to recursively do the actual parsing.</p>
<p>In this writeup we tend to refer to the parsing of expressions, but it could
also be a full program being parsed.  Every expression is assumed to be made up
of <strong>subexpressions</strong>.  Subexpressions are defined by the grammar of the
language being parsed, including <strong>operator precedences</strong> for infix operators.
Subexpressions can be made up of sub-subexpressions, and so forth.  A Pratt
parser recursively parses these expressions, subexpressions, etc., top-down.</p>
<p>An <strong>expression tree</strong> is a tree for an expression such that each function or
operator corresponds to an interior node of the tree, and the
arguments/parameters of the function are the ordered child nodes.  The leaves
of an expression tree are the <strong>literal tokens</strong>, i.e., the tokens which act as
single-node subtrees in the final expression tree.  The other tokens appear in
the tree as interior nodes (e.g., tokens for infix operators like <code class="docutils literal"><span class="pre">*</span></code>).</p>
<p>A <strong>parse tree</strong> or <strong>derivation tree</strong>, on the other hand, corresponds to a
grammar.  The internal nodes all correspond to <strong>production rules</strong> in a
grammar.  In a parse tree each non-ignored token returned by the lexer (literal
and non-literal) ends up as a leaf node in the parse tree.  An <strong>abstract
syntax tree (AST)</strong> is an abstract representation of the information in a parse
tree or expression tree, in some format chosen to be convenient.  A Pratt
parser can produce any of the above kinds of trees, depending on how the
handler functions are defined, but naturally produces expression trees.  The
term <strong>syntax tree</strong> can generally refer to any of the above types of trees.</p>
<p>In common usage the <strong>parsing</strong> of text tends to refer to any kind of formal
decomposition into a predefined structure, particularly into a tree structure.
This may include parsing text to a derivation tree, an expression tree, an
AST, or the use of various ad hoc methods for breaking the text down into
components.  Informally, expression trees are often referred to as parse trees.</p>
<p>The <code class="docutils literal"><span class="pre">parse</span></code> function is assumed to return a syntax tree for the expression it
parses.  In general, many parsers do not return a syntax tree but instead
evaluate, interpret, or otherwise process the expressions as they go along.  We
assume that any such evaluation or interpretation is applied at a later stage,
based on the returned syntax tree.  Pratt parsers in general can easily
interpret or evaluate languages on-the-fly, but for simplicity the builtin
methods of the Typped package always form a syntax tree by default.  (If
type-checking is disabled then arbitrary Pratt Parsers can still be defined
using Typped.)</p>
</div>
<div class="section" id="operator-precedence">
<span id="id1"></span><h2>2.3. Operator precedence<a class="headerlink" href="#operator-precedence" title="Permalink to this headline">¶</a></h2>
<p>Consider this simple expression: <code class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">8</span></code> There are five tokens in this
expression: <code class="docutils literal"><span class="pre">2</span></code>, <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">5</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, and <code class="docutils literal"><span class="pre">8</span></code>.  Parsing this expression
should produce this expression tree:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">+</span>
   <span class="mi">2</span>
   <span class="o">*</span>
      <span class="mi">5</span>
      <span class="mi">8</span>
</pre></div>
</div>
<p>Here an indented column under a token represent its children/arguments.  Note
that the leaves of the tree are always literal tokens such as <code class="docutils literal"><span class="pre">2</span></code> and <code class="docutils literal"><span class="pre">5</span></code>,
which form their own subtrees.</p>
<p>In producing the parse tree above it has been assumed that the usual operator
precedence rules in mathematics hold: <code class="docutils literal"><span class="pre">*</span></code> has higher precedence than <code class="docutils literal"><span class="pre">+</span></code>.
In most computer languages this is implemented by assigning a fixed
<strong>precedence</strong> value to each operator, and the Pratt parser works the same way.</p>
<p>Every kind of token has a fixed, non-changing precedence value associated with
it.  This is called its <strong>token precedence</strong>.  The default token precedence
value is zero, which is also the minimum possible token precedence value.
Infix operators <em>must</em> have a token precedence &gt; 0, as we will see.  When it is
clear in the context the token precedence will simply be called the precedence.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Pratt’s terminology a token’s precedence is called its <strong>left binding
power</strong> or <strong>lbp</strong>.</p>
</div>
</div>
<div class="section" id="subexpressions">
<h2>2.4. Subexpressions<a class="headerlink" href="#subexpressions" title="Permalink to this headline">¶</a></h2>
<p>By definition, every subtree in a parse tree represents a subexpression.  The
token precedence values define the subexpression tree structure of
subexpressions with infix operators.  In the simple example expression above
the top-level expression is represented by the full tree, with root at the
operator <code class="docutils literal"><span class="pre">+</span></code>.  Each literal token also defines a (trivial) subexpression.
The subtree rooted at operator <code class="docutils literal"><span class="pre">*</span></code> defines a non-trivial subexpression which
corresponds to the string <code class="docutils literal"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">8</span></code> in the full expression.</p>
<p>In Pratt parsing recursion is used to parse subexpressions (starting top-down,
from the full expression).  A crucial distinction in this parsing method is
whether or not a token is the <em>first</em> token of the current subexpression or is
a <em>later</em> one.  Every subexpression has a first token, and some have later
tokens after the first one.  In the subexpression <code class="docutils literal"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">8</span></code> the token for <code class="docutils literal"><span class="pre">5</span></code>
is the first token, called the <strong>head</strong> token, and <code class="docutils literal"><span class="pre">*</span></code> and <code class="docutils literal"><span class="pre">8</span></code> are later
tokens, called <strong>tail</strong> tokens.</p>
<p>It was mentioned earler that in Pratt parsing each token can have one or more
<strong>handler functions</strong> defined for it.  The handler function for when the token
is the first token in a subexpression is called the <strong>head handler</strong> function.
The handler function for when the token is not the first token in a
subexpression is called the <strong>tail handler</strong> function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Pratt’s terminology the head handler function is called the <strong>null
denotation</strong> or <strong>nud</strong>.  The tail handler function is called the <strong>left
denotation</strong> or <strong>led</strong>.  The left denotation is passed the
previously-evaluated left part as an argument, while the null denotation
receives no such argument.  Pratt’s terminology can seem confusing since the
left denotation is actually called for tokens in the rightmost part of a
subexpression (the returned value becomes the new, evaluated left part).</p>
</div>
</div>
<div class="section" id="basic-parsing">
<h2>2.5. Basic parsing<a class="headerlink" href="#basic-parsing" title="Permalink to this headline">¶</a></h2>
<p>The parser parses text left-to-right, getting tokens sequentially from the
lexer.  The top-down recursion used in the main function <code class="docutils literal"><span class="pre">parse</span></code> is
implemented by calling another function, called <code class="docutils literal"><span class="pre">recursive_parse</span></code>.  Each call
of the <code class="docutils literal"><span class="pre">recursive_parse</span></code> function returns the parse tree for the largest
subexpression to the right of the current token (which is usually one subtree
of the full parse tree).  The <code class="docutils literal"><span class="pre">parse</span></code> function itself only performs some
initialization and then calls <code class="docutils literal"><span class="pre">recursive_parse</span></code> to obtain the parsed tree.
This is the basic code for <code class="docutils literal"><span class="pre">parse</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
    <span class="n">lex</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="n">parse_tree</span> <span class="o">=</span> <span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">parse_tree</span><span class="p">)</span>
</pre></div>
</div>
<p>Since the code for <code class="docutils literal"><span class="pre">parse</span></code> basically just makes a call to
<code class="docutils literal"><span class="pre">recursive_parse</span></code>, we need to focus on how <code class="docutils literal"><span class="pre">recursive_parse</span></code> works.  The
code for <code class="docutils literal"><span class="pre">recursive_parse</span></code> will be discussed next.  Notice that there are no
explicit recursive calls to <code class="docutils literal"><span class="pre">recursive_parse</span></code> inside <code class="docutils literal"><span class="pre">recursive_parse</span></code>.
This is because the recursion is really a mutual recursion: the head and tail
handler functions can call <code class="docutils literal"><span class="pre">recursive_parse</span></code> to evaluate subexpressions, and,
in turn, the <code class="docutils literal"><span class="pre">recursive_parse</span></code> function is the only place where head and tail
handler functions are ever called.  Head and tail handler functions will be
discussed after <code class="docutils literal"><span class="pre">recursive_parse</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">):</span>
    <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="n">processed_left</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">head_handler</span><span class="p">(</span><span class="n">lex</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>
        <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">processed_left</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">tail_handler</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">processed_left</span>
</pre></div>
</div>
<p>The first thing that <code class="docutils literal"><span class="pre">recursive_parse</span></code> does is get a token from the lexer as
the current token.  This token will always be the head token of the
subexpression, i.e., the first token of the subexpression (the full expression
is also considered a subexpression).  By definition <code class="docutils literal"><span class="pre">recursive_parse</span></code> is only
called when that condition holds.</p>
<p>The next thing that <code class="docutils literal"><span class="pre">recursive_parse</span></code> does is call the head handler function
for that head token.  It must have a head handler defined for it or else an
exception is raised.  The head handler for a token is a function that defines
the meaning or denotation of the token when it is the first token in a
subexpression.  It returns a partial parse tree.  The result is stored as
<code class="docutils literal"><span class="pre">processed_left</span></code>, which holds the processed leftmost part of the current
subexpression (currently just the result of the head handler evaluation on the
first token).</p>
<p>The <code class="docutils literal"><span class="pre">recursive_parse</span></code> function now needs to evaluate the rest of its current
subexpression, calling the tail handler in a while loop for each remaining
token in the tail of the subexpression.  The results each time will be combined
with the current <code class="docutils literal"><span class="pre">processed_left</span></code> to produce the new <code class="docutils literal"><span class="pre">processed_left</span></code>,
which will eventually be returned at the end as the final result.  The only
tricky part is how <code class="docutils literal"><span class="pre">recursive_parse</span></code> determines when it has reached the end
of its subexpression and should return its result.  This is where precedences
come into play.</p>
<p>Each call of <code class="docutils literal"><span class="pre">recursive_parse</span></code> is passed both a lexer and a numerical value
called the <strong>subexpression precedence</strong>.  The subexpression precedence is just
a number that gives the precedence of the subexpression that this call of
<code class="docutils literal"><span class="pre">recursive_parse</span></code> is processing.  This subexpression precedence value does
not change within a particular invocation of <code class="docutils literal"><span class="pre">recursive_parse</span></code>.  The
subexpression precedence is compared to the fixed token precedence for
individual tokens.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Pratt’s terminology the subexpression precedence is called the <strong>right
binding power</strong>, or <strong>rbp</strong>.  In the while loop the precedence or left
binding power of the next token (to the right) is compared to the current
subexpression on the left’s precedence or right binding power.</p>
</div>
<p>In particular, the while loop continues consuming tokens and calling their tail
handler functions until the subexpression precedence <code class="docutils literal"><span class="pre">subexp_prec</span></code> is less
than the precedence of the upcoming token, given by <code class="docutils literal"><span class="pre">lex.peek().prec()</span></code>.  You
can think of the loop ending when the power of the subexpression to bind to the
right and get another token (the subexpression’s precedence) is not strong
enough to overcome the power of the next token to bind to the left (the next
token’s token precedence value).  The subexpression ends when that occurs.  The
while loop is exited and <code class="docutils literal"><span class="pre">processed_left</span></code> is returned as the resulting
subtree for the subexpression.</p>
<p>The initial call of <code class="docutils literal"><span class="pre">recursive_parse</span></code> from <code class="docutils literal"><span class="pre">parse</span></code> always starts with a
subexpression precedence of 0 for the full expression.  Literal tokens and the
end token always have a token precedence of 0, and those are the only tokens
with that precedence.  So the full expression always ends when the next token
is the end token or the next token is a literal token, and the latter is an
error condition.</p>
<p>Generally, any token with only a head handler definition has a token precedence
of 0 and any token with a tail handler definition has a precedence greater than 0.
This can be seen in the while loop of <code class="docutils literal"><span class="pre">recursive_parse</span></code>: Since tail handlers
are only called inside the while loop the precedence of a token with a tail
<em>must</em> be greater than 0, or else it will always fail the test and thus can
never be called.  A token with only a head handler that does pass the test will
not have a tail handler to call.</p>
<p>This completes the discussion of the higher-level top-down recursion routines
<code class="docutils literal"><span class="pre">parse</span></code> and <code class="docutils literal"><span class="pre">recursive_parse</span></code>.  The next section discusses head and tail
handlers, to complete the mutual recursion.</p>
<p>This table summarizes the correspondence between Pratt’s terminology and the
terminology that is used in this documentation and in the code:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">This description</th>
<th class="head">Pratt’s terminology</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>token precedence</td>
<td>left binding power, lbp</td>
</tr>
<tr class="row-odd"><td>subexpression precedence</td>
<td>right binding power, rbp</td>
</tr>
<tr class="row-even"><td>head handler function</td>
<td>null denotation, nud</td>
</tr>
<tr class="row-odd"><td>tail handler function</td>
<td>left denotation, led</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="topic">
<p class="topic-title first">Some notes on this subsection.</p>
<ul class="simple">
<li>In the Typped package the <code class="docutils literal"><span class="pre">recursive_parse</span></code> function is a method of the
<code class="docutils literal"><span class="pre">TokenNode</span></code> class which represents tokens.  This is not necessary, since
it is essentially a static function.  The namespace is convenient, though,
because <code class="docutils literal"><span class="pre">recursive_parse</span></code> is generally called from handler functions
which are passed a token instance as an argument.  It also allows
<code class="docutils literal"><span class="pre">recursive_parse</span></code> to access to the corresponding <code class="docutils literal"><span class="pre">PrattParser</span></code>
instance (which is used for more advanced features). <p></li>
<li>The implementation of <code class="docutils literal"><span class="pre">recursive_parse</span></code> in the Typped package is
actually a generalization which calls a method <code class="docutils literal"><span class="pre">dispatcher_handler</span></code>,
passed either <code class="docutils literal"><span class="pre">HEAD</span></code> or <code class="docutils literal"><span class="pre">TAIL</span></code> as its first argument, instead of
<code class="docutils literal"><span class="pre">head_handler</span></code> and <code class="docutils literal"><span class="pre">tail_handler</span></code> (this will be discussed later).  The
general principle, however, is the same. <p></li>
<li>The <code class="docutils literal"><span class="pre">processed_left</span></code> structure can in general be a partial parse tree,
the result of a numerical evaluation, or anything else.  The handler
functions can build and return any processed form for their tokens.  The
Typped package, however, always builds an expression tree out of token
nodes (which can be evaluated later, if desired). <p></li>
<li>In the Typped package the handler functions are not made into
directly-callable methods of the token subclasses.  Instead, they are
stored with the <code class="code docutils literal"><span class="pre">PrattParser</span></code> instance in a <code class="docutils literal"><span class="pre">ConstructTable</span></code> object
instance.  Access is keyed in a tree by the token label as well as by
other data.  This is because the Typped package generalizes to allow for
multiple head and tail handlers, which are looked up and dispatched before
being called.  <p></li>
<li>Outside of an error condition the algorithm never even looks at the
precedence of a token having <em>only</em> a head handler (i.e., a token which can
only occur in the beginning position of an expression).  The precedence of
such a head-only token is usually taken to be 0, but it really does not
need to be defined at all.  So token precedences can be treated as
properties associated with tail-handler functions. <p></li>
</ul>
</div>
</div>
<div class="section" id="the-handler-functions-head-and-tail">
<h2>2.6. The handler functions head and tail<a class="headerlink" href="#the-handler-functions-head-and-tail" title="Permalink to this headline">¶</a></h2>
<p>In order for a token to be processed in an expression the token must have
defined for it either 1) a head handler function, 2) a tail handler function,
or 3) both.  As mentioned earlier, the head handler is called in evaluating a
subexpression when the token is the first token in a subexpression, and the
tail handler is called when the token appears at any other position in the
subexpression.  We have not yet described exactly what these functions do.</p>
<p>In general, there are no restrictions on what a head or tail handler can do.
They are simply functions which return some kind of value, which is then set to
the new <code class="docutils literal"><span class="pre">processed_left</span></code> variable in <code class="docutils literal"><span class="pre">recursive_parse</span></code>.  They could, for
example, call a completely different parser to parse a subexpression.  In an
evaluating parser they could evaluate the subexpression and return the result
(but the Typped parser always forms an expression tree and then evaluates it if
evaluation is to be done).  Below we describe what handler functions <em>usually</em>
do, and give an example of processing the simple expression <code class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">8</span></code> which
was previously discussed in the <a class="reference internal" href="#operator-precedence"><span class="std std-ref">Operator precedence</span></a> section.</p>
<div class="section" id="literal-tokens">
<h3>2.6.1. Literal tokens<a class="headerlink" href="#literal-tokens" title="Permalink to this headline">¶</a></h3>
<p>The literal tokens in a grammar always have a head handler, since the tokens
themselves are subtrees for their own subexpressions (i.e., they are leaves in
the expression tree).  The head handler for literal tokens is trivial: the head
function simply returns the token itself as the subtree.  Note that any mutual
recursion always ends with literal tokens because all the leaves of an
expression tree are literal tokens.  Thus their head handlers do not make any
further recursive calls.</p>
<p>Every token is represented by a unique subclass of the <code class="docutils literal"><span class="pre">TokenNode</span></code> class.
The precedence value defined for a token is saved as an attribute of the
corresponding subclass.  Instances of the subclass represent the actual scanned
tokens of that kind, with a string value.  The lexer returns such an instance
for every token it scans from the text.  The expression tree is built using the
scanned token instances (returned by the lexer) as the nodes of the tree.</p>
<p>The head handler will be made into a method of the subclass for the kind of
token it is associated with.  So the arguments are <code class="docutils literal"><span class="pre">self</span></code> and a lexer
instance <code class="docutils literal"><span class="pre">lex</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">head_handler_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>All other head and tail handlers are also made into methods for the
subtoken that they are associated with (but see the note below).</p>
</div>
<div class="section" id="non-literal-tokens">
<h3>2.6.2. Non-literal tokens<a class="headerlink" href="#non-literal-tokens" title="Permalink to this headline">¶</a></h3>
<p>Generally, head and tail handlers do two things while constructing the result
value to return: 1) they call <code class="docutils literal"><span class="pre">recursive_parse</span></code> to evaluate sub-subexpressions
of their subexpression, and 2) they possibly peek at and/or consume additional
tokens from the lexer.  This is the definition of the tail handler for the
<code class="docutils literal"><span class="pre">+</span></code> operator:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tail_handler_plus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prec</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>This tail handler (like all tail handlers) is passed the current
<code class="docutils literal"><span class="pre">processed_left</span></code> expression evaluation as the parameter <code class="docutils literal"><span class="pre">left</span></code>.  It needs
to build and return its parse subtree, with its own <code class="docutils literal"><span class="pre">+</span></code> node as the subtree
root.  The <code class="docutils literal"><span class="pre">left</span></code> argument passed in should contain the previously-evaluated
subtree for the left operand of <code class="docutils literal"><span class="pre">+</span></code>.  So that subtree is set as the left
child of the current <code class="docutils literal"><span class="pre">+</span></code> node.  To get the right operand, the
<code class="docutils literal"><span class="pre">recursive_parse</span></code> function is called.  It returns the subtree for the next
subexpression (following the current <code class="docutils literal"><span class="pre">+</span></code> token), which is set as the right
child of the <code class="docutils literal"><span class="pre">+</span></code> node.  The completed subtree is then returned.</p>
<p>The tail handler for the <code class="docutils literal"><span class="pre">*</span></code> operator is identical to the definition for
<code class="docutils literal"><span class="pre">+</span></code> except that it is associated with the subclass representing the token
<code class="docutils literal"><span class="pre">*</span></code>.  We will assume that the precedence defined for <code class="docutils literal"><span class="pre">+</span></code> is 3, and that the
precedence for <code class="docutils literal"><span class="pre">*</span></code> is 4.</p>
</div>
</div>
<div class="section" id="an-example-parse">
<h2>2.7. An example parse<a class="headerlink" href="#an-example-parse" title="Permalink to this headline">¶</a></h2>
<p>With the definitions above we can now parse the five tokens in the expression
<code class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">8</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">recursive_parse</span></code> code is repeated here for easy reference:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">):</span>
    <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="n">processed_left</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">head_handler</span><span class="p">(</span><span class="n">lex</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>
        <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">processed_left</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">tail_handler</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">processed_left</span>
</pre></div>
</div>
<p>The steps the Pratt parser takes in parsing this expression are described in
the box below.</p>
<div class="topic">
<p class="topic-title first">Parsing the expression <code class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">8</span></code></p>
<p>This is an rough English description of parsing the expression <code class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">5</span> <span class="pre">*</span> <span class="pre">8</span></code>
with a Pratt parser as defined above.  Indents occur on recursive calls, and
the corresponding dedents indicate a return to the previous level.  Remember
that this is a mutual recursion, between the <code class="docutils literal"><span class="pre">recursive_parse</span></code> routine and
the head and tail handler functions associated with tokens.  The tokens
themselves (represented by subclasses of <code class="docutils literal"><span class="pre">TokenNode</span></code>) are used as nodes in
the expression tree that the algorithm constructs.</p>
<p>The handler functions are as defined earlier.  The parsing proceeds as
follows:</p>
<blockquote>
<div><ul>
<li><p class="first">First, the <code class="docutils literal"><span class="pre">parse</span></code> function is called, passed a lexer instance <code class="docutils literal"><span class="pre">lex</span></code> and
the expression text to be parsed.  The <code class="docutils literal"><span class="pre">parse</span></code> function just initializes
the lexer with the text and then calls the <code class="docutils literal"><span class="pre">recursive_parse</span></code> on the full
expression to do the real work.  The full expression is always associated
with a subexpression precedence of zero, so the <code class="docutils literal"><span class="pre">subexp_prec</span></code> argument to
<code class="docutils literal"><span class="pre">recursive_parse</span></code> is 0 on this initial call.</p>
<blockquote>
<div><ul>
<li><p class="first">The <code class="docutils literal"><span class="pre">recursive_parse</span></code> function at the top level first consumes a token
from the lexer, which is the token for <code class="docutils literal"><span class="pre">2</span></code>.  It then and calls the head
handler associated with it.</p>
<blockquote>
<div><ul class="simple">
<li>The head handler for the token <code class="docutils literal"><span class="pre">2</span></code> returns the token for <code class="docutils literal"><span class="pre">2</span></code>
itself as the corresponding node in the subtree, since literal tokens
are their own subtrees (leaves) of the final expression tree.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Back in the top level of <code class="docutils literal"><span class="pre">recursive_parse</span></code> the <code class="docutils literal"><span class="pre">processed_left</span></code>
variable is set to the returned node, which is the token <code class="docutils literal"><span class="pre">2</span></code>.</p>
</li>
<li><p class="first">The while loop in <code class="docutils literal"><span class="pre">recursive_parse</span></code> is now run to handle the tail of
the expression.  It peeks ahead and sees that the <code class="docutils literal"><span class="pre">+</span></code> operator has a
higher token precedence than the current subexpression precedence of 0,
so the loop executes.  The loop code first consumes another token from
the lexer, which is the <code class="docutils literal"><span class="pre">+</span></code> token.  It then calls the tail handler
associated with the <code class="docutils literal"><span class="pre">+</span></code> token, passing it the current
<code class="docutils literal"><span class="pre">processed_left</span></code> (which currently points to the node <code class="docutils literal"><span class="pre">2</span></code>) as the
<code class="docutils literal"><span class="pre">left</span></code> argument.</p>
<blockquote>
<div><ul>
<li><p class="first">The tail handler for <code class="docutils literal"><span class="pre">+</span></code> sets the left child of the token/node for
<code class="docutils literal"><span class="pre">+</span></code> to be the passed-in subtree <code class="docutils literal"><span class="pre">left</span></code> (which is currently the
node <code class="docutils literal"><span class="pre">2</span></code>).  This sets the left operand for <code class="docutils literal"><span class="pre">+</span></code>.  To get the right
operand the tail handler for <code class="docutils literal"><span class="pre">+</span></code> then calls <code class="docutils literal"><span class="pre">recursive_parse</span></code>
recursively, passing in the value of 3 (which is the precedence value
we assumed for the <code class="docutils literal"><span class="pre">+</span></code> operator) as the subexpression precedence
argument <code class="docutils literal"><span class="pre">subexp_prec</span></code>.  Note how the operator’s precedence is
passed to the <code class="docutils literal"><span class="pre">recursive_parse</span></code> routine as the subexpression
precedence in the recursive call; to get right-association instead of
left-association the operator precedence <em>minus one</em> should instead be
passed in.</p>
<blockquote>
<div><ul>
<li><p class="first">This recursive call of <code class="docutils literal"><span class="pre">recursive_parse</span></code> consumes another token, the
token for <code class="docutils literal"><span class="pre">5</span></code>, and calls the head handler for that token.</p>
<blockquote>
<div><ul class="simple">
<li>The head handler returns the node for <code class="docutils literal"><span class="pre">5</span></code> as the subtree, since
it is a literal token.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The returned node/subtree for <code class="docutils literal"><span class="pre">5</span></code> is set as the initial value for
<code class="docutils literal"><span class="pre">processed_left</span></code> at this level of recursion.</p>
</li>
<li><p class="first">The while loop now peeks ahead and sees that the token precedence
of 4 for the <code class="docutils literal"><span class="pre">*</span></code> operator is greater than its own subexpression
precedence (<code class="docutils literal"><span class="pre">subexp_prec</span></code> at this level equals 3), so the loop
executes.  Inside the loop the next token, <code class="docutils literal"><span class="pre">*</span></code>, is consumed from
the lexer.  The tail handler for that token is called, passed the
<code class="docutils literal"><span class="pre">processed_left</span></code> value at this level of recursion as its <code class="docutils literal"><span class="pre">left</span></code>
argument (which currently points to the node <code class="docutils literal"><span class="pre">5</span></code>).</p>
<blockquote>
<div><ul>
<li><p class="first">The tail handler for <code class="docutils literal"><span class="pre">*</span></code> sets that passed-in <code class="docutils literal"><span class="pre">left</span></code> value to
be the left child of the <code class="docutils literal"><span class="pre">*</span></code> node, so the left child/operand
of <code class="docutils literal"><span class="pre">*</span></code> is set to the node for <code class="docutils literal"><span class="pre">5</span></code>.  It then calls
<code class="docutils literal"><span class="pre">recursive_parse</span></code> to get the right child/operand.  The <code class="docutils literal"><span class="pre">*</span></code>
token’s precedence value of 4 is passed to <code class="docutils literal"><span class="pre">recursive_parse</span></code>
as the subexpression precedence argument <code class="docutils literal"><span class="pre">subexp_prec</span></code>.</p>
<blockquote>
<div><ul>
<li><p class="first">This call of <code class="docutils literal"><span class="pre">recursive_parse</span></code> first consumes the token
<code class="docutils literal"><span class="pre">8</span></code> from the lexer and calls the head handler for it.</p>
<blockquote>
<div><ul class="simple">
<li>The head handler for <code class="docutils literal"><span class="pre">8</span></code> returns the node itself.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">processed_left</span></code> variable at this level of recursion is
now set to the returned node <code class="docutils literal"><span class="pre">8</span></code>.  The while loop peeks ahead and
sees the end-token, which always has a precedence of 0.  Since
that is less than the current subexpression precedence of 4, the
while loop does not execute.  The token <code class="docutils literal"><span class="pre">8</span></code> is returned.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The tail handler for <code class="docutils literal"><span class="pre">*</span></code> now sets the node/token <code class="docutils literal"><span class="pre">8</span></code> as the
right child of the <code class="docutils literal"><span class="pre">*</span></code> node.  It then returns the <code class="docutils literal"><span class="pre">*</span></code> node.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The while loop at this level of <code class="docutils literal"><span class="pre">recursive_parse</span></code> once again
peeks ahead but, upon seeing the end-token, does not execute.  So
the loop is exited and the subtree for <code class="docutils literal"><span class="pre">*</span></code> (which now has two
children, <code class="docutils literal"><span class="pre">5</span></code> and <code class="docutils literal"><span class="pre">8</span></code>) is returned.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The tail handler for <code class="docutils literal"><span class="pre">+</span></code> now sets the returned subtree (the subtree
for <code class="docutils literal"><span class="pre">*</span></code>, with its children already set) as the right subtree for the
<code class="docutils literal"><span class="pre">+</span></code> token/node.  The <code class="docutils literal"><span class="pre">+</span></code> token is returned as the root of the
subtree.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Back at the top level of <code class="docutils literal"><span class="pre">recursive_parse</span></code> the while loop looks ahead
and sees the end-token, so it does not execute.  The subtree for <code class="docutils literal"><span class="pre">+</span></code> is
returned to the <code class="docutils literal"><span class="pre">parse</span></code> routine.</p>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">parse</span></code> routine returns the result returned by the <code class="docutils literal"><span class="pre">recursive_parse</span></code>
call as its value.  So it returns the node for <code class="docutils literal"><span class="pre">+</span></code>, now with children
representing the expression tree shown earlier, as the final expression tree
of token nodes.</p>
</li>
</ul>
</div></blockquote>
</div>
<p>Note that when <code class="docutils literal"><span class="pre">recursive_parse</span></code> is called recursively in the tail of an
infix operator it is called with a <code class="docutils literal"><span class="pre">subexp_prec</span></code> argument equal to the
current node’s precedence.  That gives left-to-right precedence evaluation
(left associative) for infix operators with equal precedence values.  To get
right-to-left evaluation (right associative), <code class="docutils literal"><span class="pre">recursive_parse</span></code> should
instead be passed the current precedence <em>minus one</em> as the value for
<code class="docutils literal"><span class="pre">subexp_prec</span></code>.  Interested readers can consider the evaluation of <code class="docutils literal"><span class="pre">2</span> <span class="pre">^</span> <span class="pre">5</span> <span class="pre">^</span>
<span class="pre">8</span></code> (similar to the box above) in the case where for <code class="docutils literal"><span class="pre">^</span></code> is defined as left
associative.</p>
</div>
<div class="section" id="summary">
<h2>2.8. Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>In this section we introduced some basic parsing terminology, including heads
and tails of subexpressions.  The Pratt parser was then defined as a top-down,
mutually-recursive parsing algorithm.  The routines <code class="docutils literal"><span class="pre">parse</span></code> and
<code class="docutils literal"><span class="pre">recursive_parse</span></code> were defined and discussed.  Finally, head and tail handler
functions were discussed and an example parse was described in detail.</p>
<p>The Typped parser package generalizes this basic Pratt parser in a few ways.
These generalizations are discussed in later sections.  A generalization
allowing multiple, dispatched head and tail handler functions for tokens, based
on preconditions, is described in the next section.  Another generalization
modifies <code class="docutils literal"><span class="pre">recursive_parse</span></code> slightly to allow implicit juxtaposition operators
between tokens.  Type-definition and type-checking routines are also added.
Types are checked inside head and tail handlers by calling a function
<code class="docutils literal"><span class="pre">process_and_check_node</span></code> on the subtrees before they are returned.  Operator
overloading is also allowed, and is resolved during these checks.</p>
</div>
<div class="section" id="references">
<span id="id2"></span><h2>2.9. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p>Vaughan R. Pratt, “<a class="reference external" href="http://dl.acm.org/citation.cfm?id=512931">Top down operator precedence</a>,” 1973.
The original article, at the ACM site (paywall).</p>
<p>Fredrik Lundh, “<a class="reference external" href="http://effbot.org/zone/simple-top-down-parsing.htm">Simple Top-Down Parsing in Python</a>,” July 2008.  Excellent
explanation and good code examples in Python.  Influenced the design and
implementation of the Typped package.  Includes an example of parsing a subset
of Python expressions.  See also the <a class="reference external" href="http://effbot.org/zone/tdop-index.htm">related articles by Lundh on Pratt
parsing and lexing with regexes</a>.</p>
<p>Eli Bendersky, “<a class="reference external" href="http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/">Top-Down operator precedence parsing</a>,”
Jan. 2, 2010.  An article based on Lundh’s article above.  It also uses Python
and has some useful discussion.</p>
<p>Douglas Crockford, “<a class="reference external" href="http://javascript.crockford.com/tdop/tdop.html">Top Down Operator Precedence</a>,” Feb. 21, 2007.  Uses
JavaScript.</p>
<p>Bob Nystrom, “<a class="reference external" href="http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">Pratt Parsers: Expression Parsing Made Easy</a>,”
Mar. 19, 2011.  Uses Java.</p>
<p>For discussions of the relationship of Pratt parsing precedences to precedence
climbing, see Andy Chu’s “<a class="reference external" href="http://www.oilshell.org/blog/2016/11/01.html">Pratt Parsing and Precedence Climbing Are the Same
Algorithm</a>,” 2016 and Theodore
Norvell’s “<a class="reference external" href="https://www.engr.mun.ca/~theo/Misc/pratt_parsing.htm">From Precedence Climbing to Pratt Parsing</a>, 2016.  Chu also
discusses implementations of Pratt parsers at “<a class="reference external" href="http://www.oilshell.org/blog/2016/11/03.html">Pratt Parsing Without
Prototypal Inheritance, Global Variables, Virtual Dispatch, or Java</a>,” 2016.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. Introduction to Pratt parsing and its terminology</a><ul>
<li><a class="reference internal" href="#what-is-a-pratt-parser">2.1. What is a Pratt parser?</a></li>
<li><a class="reference internal" href="#basic-assumptions">2.2. Basic assumptions</a></li>
<li><a class="reference internal" href="#operator-precedence">2.3. Operator precedence</a></li>
<li><a class="reference internal" href="#subexpressions">2.4. Subexpressions</a></li>
<li><a class="reference internal" href="#basic-parsing">2.5. Basic parsing</a></li>
<li><a class="reference internal" href="#the-handler-functions-head-and-tail">2.6. The handler functions head and tail</a><ul>
<li><a class="reference internal" href="#literal-tokens">2.6.1. Literal tokens</a></li>
<li><a class="reference internal" href="#non-literal-tokens">2.6.2. Non-literal tokens</a></li>
</ul>
</li>
<li><a class="reference internal" href="#an-example-parse">2.7. An example parse</a></li>
<li><a class="reference internal" href="#summary">2.8. Summary</a></li>
<li><a class="reference internal" href="#references">2.9. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="basic_usage.html"
                        title="previous chapter">1. Basic usage</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dispatching.html"
                        title="next chapter">3. Constructs and preconditioned dispatching</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pratt_parsing_intro.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dispatching.html" title="3. Constructs and preconditioned dispatching"
             >next</a> |</li>
        <li class="right" >
          <a href="basic_usage.html" title="1. Basic usage"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>