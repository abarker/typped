
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>1. Basic usage &#8212; Typped  documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Introduction to Pratt parsing and its terminology" href="pratt_parsing_intro.html" />
    <link rel="prev" title="Typped: A framework for typed Pratt parsers employing dispatching" href="index.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pratt_parsing_intro.html" title="2. Introduction to Pratt parsing and its terminology"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Typped: A framework for typed Pratt parsers employing dispatching"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="basic-usage">
<h1>1. Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h1>
<p>This section gives an overview of the basic usage of the Typped package.  Later
sections go into many more details.  Executable code for the examples on this
page can be found in the file <a class="reference external" href="https://github.com/abarker/typped/blob/master/examples/basic_usage_section_examples.py">examples/basic_usage_examples.py</a>.</p>
<p>The <code class="docutils literal"><span class="pre">PrattParser</span></code> class is the main class provided by the Typped package.  It
is the only class that is needed for basic usage of the parser.</p>
<div class="section" id="example-parsing-a-simple-expression">
<h2>1.1. Example: Parsing a simple expression<a class="headerlink" href="#example-parsing-a-simple-expression" title="Permalink to this headline">¶</a></h2>
<p>This example parses simple expressions such as <code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">4</span></code> using the builtin
methods of the <code class="docutils literal"><span class="pre">PrattParser</span></code> class.  The builtin parsing methods that can be
called for a <code class="docutils literal"><span class="pre">PrattParser</span></code> instance are documented here:
<a class="reference internal" href="typped.builtin_parse_methods.html#module-typped.builtin_parse_methods" title="typped.builtin_parse_methods"><code class="xref py py-mod docutils literal"><span class="pre">typped.builtin_parse_methods</span></code></a>.  Only a few are used in this
example.  Example 2 will parse the same language without using any of the
builtin parsing methods.  Instead, it will directly use Pratt parsing
techniques.</p>
<p>The language consists of integers, identifiers representing integers, addition
and multiplication operators, and parentheses.  Types are not used in this
example.  Strings of the language are parsed to an expression tree.</p>
<ol class="arabic">
<li><p class="first">Create an instance of the <code class="docutils literal"><span class="pre">PrattParser</span></code> class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">typped</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">PrattParser</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p class="first">Define each token that will appear in the language, including a string label
and a regex to recognize that kind of token.  If necessary, the appropriate
<code class="docutils literal"><span class="pre">on_ties</span></code> values can be set to break ties in case of equal match lengths.
The lexer will always take the longest match over all the defined tokens,
with ties broken by any <code class="code docutils literal"><span class="pre">on_ties</span></code> values (which by default equal zero).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">def_default_whitespace</span><span class="p">()</span>
<span class="n">tok</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">def_token</span>
<span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_number&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">)</span>
<span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_lpar&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\(&quot;</span><span class="p">)</span>
<span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_rpar&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\)&quot;</span><span class="p">)</span>
<span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_ast&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\*&quot;</span><span class="p">)</span>
<span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_plus&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\+&quot;</span><span class="p">)</span>
<span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_identifier&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;[a-zA-Z_](?:\w*)&quot;</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In these examples the string <code class="docutils literal"><span class="pre">k_</span></code> is used by convention as a prefix for
token labels.  The prefix <code class="docutils literal"><span class="pre">t_</span></code> will be used for types.</p>
<p>The call to <code class="docutils literal"><span class="pre">def_default_whitespace</span></code> above sets up default whitespace.  It
is equivalent to the following code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">def_ignored_token</span><span class="p">(</span><span class="s2">&quot;k_space&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;[ \t]+&quot;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">def_ignored_token</span><span class="p">(</span><span class="s2">&quot;k_newline&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;[\n\f\r\v]+&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Whitespace is defined as space, tab, and newline characters and is set to be
ignored by the lexer.  The space and newline sequences are made into
separate tokens; both are ignored by the lexer.  (Ignored tokens can be
accessed via the <code class="docutils literal"><span class="pre">ignored_before</span></code> attribute of a token.)</p>
<p>It should be noted that the Typped lexer does not depend on the order in
which tokens are defined.  The longest matches are returned, with ties
broken by any <code class="docutils literal"><span class="pre">on_ties</span></code> values which are set in the <code class="docutils literal"><span class="pre">def_token</span></code> call.</p>
</li>
<li><p class="first">Define the syntactical elements of the language being parsed.  Any necessary
token labels must have already been defined (as in the previous step).  The
predefined syntax-definition methods of <code class="docutils literal"><span class="pre">PrattParser</span></code> take as arguments
token labels, type information, etc.</p>
<p>Note that literal tokens must still be defined as syntactical elements of
the grammar being parsed, after being defined as tokens.  The token
definition just creates a kind of token to be scanned and returned by the
lexer.  If typing is being used then any type information should also be set
for the literal tokens since they are the leaves of the expression trees.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">def_literal</span><span class="p">(</span><span class="s2">&quot;k_number&quot;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">def_literal</span><span class="p">(</span><span class="s2">&quot;k_identifier&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Infix operators are defined below, with a precedence of 10 for addition and 20
for multiplication.  Both are left-associative.  Parentheses for grouping are
also defined.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">def_infix_op</span><span class="p">(</span><span class="s2">&quot;k_plus&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">def_infix_op</span><span class="p">(</span><span class="s2">&quot;k_ast&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">)</span>

<span class="n">parser</span><span class="o">.</span><span class="n">def_bracket_pair</span><span class="p">(</span><span class="s2">&quot;k_lpar&quot;</span><span class="p">,</span> <span class="s2">&quot;k_rpar&quot;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Pass the parser instance a string of text to parse, and save the returned
expression tree.  The returned tree has token instances as its nodes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">result_tree</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;x + (4 + 3)*5&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_tree</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">())</span>
</pre></div>
</div>
<p>The result of running the above code is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">k_plus</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">k_identifier</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">k_ast</span><span class="p">,</span><span class="s1">&#39;*&#39;</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">k_lpar</span><span class="p">,</span><span class="s1">&#39;(&#39;</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">k_plus</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;4&#39;</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;3&#39;</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;5&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
</li>
</ol>
<p>See “<a class="reference internal" href="calculator_example.html#example-implementing-a-simple-calculator"><span class="std std-ref">Example: Implementing a simple calculator</span></a>” for a
similar example with many more features and which also evaluates the
expressions.</p>
</div>
<div class="section" id="example-parsing-a-simple-expression-without-using-builtins">
<h2>1.2. Example: Parsing a simple expression without using builtins<a class="headerlink" href="#example-parsing-a-simple-expression-without-using-builtins" title="Permalink to this headline">¶</a></h2>
<p>This example parses the same language as Example 1, but none of the builtin
parsing routines of the <code class="docutils literal"><span class="pre">PrattParser</span></code> class are used.  Raw Pratt parsing is
used, explicitly defining the head and tail handler functions and registering
them with the parser as a construct.  (Head and tail handler functions are
called null denotations and left denotations, respectively, in traditional
Pratt Parser terminology.)</p>
<p>See the section “<a class="reference internal" href="pratt_parsing_intro.html#introduction-to-pratt-parsing-and-its-terminology"><span class="std std-ref">Introduction to Pratt parsing and its terminology</span></a>” for background information.  A construct here can be thought
of as simply a container class that holds a token label and a corresponding
head or tail handler function which is triggered by that kind of token (though
actually constructs are more general than that).  See the section
“<a class="reference internal" href="dispatching.html#constructs-and-preconditioned-dispatching"><span class="std std-ref">Constructs and preconditioned dispatching</span></a>” for more
information on constructs.</p>
<p>The definitions of the initial parser instance and the tokens are exactly the
same in this example as in the previous example, so that portion of the code
above is not repeated.  The below discussion starts at Step 3 above, assuming
the code for steps 1 and 2 has already been run.</p>
<p>First we define the literal tokens, which are tokens that represent themselves
in the final expression tree.  The head handler function for such a token
simply returns the token itself.  Such a head-handler function is registered
with the parser for each kind of token which should be a token literal:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">literal_head_handler</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tok</span>
<span class="n">parser</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">literal_head_handler</span><span class="p">,</span> <span class="s2">&quot;k_number&quot;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">literal_head_handler</span><span class="p">,</span> <span class="s2">&quot;k_identifier&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we define the infix operators, starting with addition.  First, we need a
tail handler function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infix_op_tail_handler_10</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
    <span class="n">tok</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1"># Use 9 for right assoc.</span>
    <span class="k">return</span> <span class="n">tok</span>
</pre></div>
</div>
<p>This handler function has a hardcoded left-association precedence value of 10
(for right-association 9 would be used instead).  When called, the <code class="docutils literal"><span class="pre">tok</span></code>
parameter will hold the token for the <code class="docutils literal"><span class="pre">&quot;k_plus&quot;</span></code> operator which triggers this
particular handler function.  The function simply sets the left child of
<code class="docutils literal"><span class="pre">tok</span></code> to the passed-in <code class="docutils literal"><span class="pre">left</span></code> argument (which holds the expression to the
left that was already processed).  It sets the right child to the result of the
<code class="docutils literal"><span class="pre">recursive_parse</span></code> function, which parses the next expression.  So the left
and right operands are both set to expressions.</p>
<p>The <code class="docutils literal"><span class="pre">def_construct</span></code> method is now used to register the handler with the
parser as a head-handler triggered by <code class="docutils literal"><span class="pre">&quot;k_plus&quot;</span></code> tokens:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">parser</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">infix_op_tail_handler_10</span><span class="p">,</span> <span class="s2">&quot;k_plus&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the precedence value of 10 is also passed to <code class="docutils literal"><span class="pre">def_construct</span></code>.</p>
<p>The construct for parsing <code class="docutils literal"><span class="pre">+</span></code> operators has now been defined for the
language.  The code for multiplication is similar, except that a precedence of
20 is hardcoded:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">infix_op_tail_handler_20</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
    <span class="n">tok</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span> <span class="c1"># Use 19 for right assoc.</span>
    <span class="k">return</span> <span class="n">tok</span>
<span class="n">parser</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">infix_op_tail_handler_20</span><span class="p">,</span> <span class="s2">&quot;k_ast&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we need to define the construct for parsing parentheses.  This is done
by defining a head-handler for the left parenthesis token.  The handler just
calls <code class="docutils literal"><span class="pre">recursive_parse</span></code> to get the expression inside the parentheses,
consumes the closing parenthesis, and returns the expression inside:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">paren_head_handler</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">lex</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="s2">&quot;k_rpar&quot;</span><span class="p">,</span> <span class="n">raise_on_fail</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr</span> <span class="c1"># Do not include the parens themselves, just the arg.</span>
<span class="n">parser</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">paren_head_handler</span><span class="p">,</span> <span class="s2">&quot;k_lpar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This finishes the definition of the parser for the simple language, without
using any of the builtin parsing methods.  Now this code can be run:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">result_tree</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;x + (4 + 3)*5&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_tree</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">())</span>
</pre></div>
</div>
<p>The result is shown here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">k_plus</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">k_identifier</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">k_ast</span><span class="p">,</span><span class="s1">&#39;*&#39;</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">k_plus</span><span class="p">,</span><span class="s1">&#39;+&#39;</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;4&#39;</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;3&#39;</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">k_number</span><span class="p">,</span><span class="s1">&#39;5&#39;</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Notice that the expression tree created using the <code class="docutils literal"><span class="pre">def_bracket_pair</span></code> builtin
in Example 1 included the <code class="docutils literal"><span class="pre">k_lpar</span></code> token in the tree.  This handler function
does not; it simply returns the expression inside the parentheses.  To get that
kind of behavior with <code class="docutils literal"><span class="pre">def_bracket_pair</span></code> you can set the keyword <code class="docutils literal"><span class="pre">in_tree</span></code>
to false.</p>
<p>The builtin methods of <code class="docutils literal"><span class="pre">PrattParser</span></code> are basically just wrapper functions
that do things like defining and registering handler functions behind the
scenes.  They are written for much more generality than the above code, and
they tend to have various options.  If you need to write your own wrapper
functions it can be useful to look at the code for the builtin parse routines
in the file <code class="docutils literal"><span class="pre">builtin_parse_methods.py</span></code> documented in
<a class="reference internal" href="typped.builtin_parse_methods.html#module-typped.builtin_parse_methods" title="typped.builtin_parse_methods"><code class="xref py py-mod docutils literal"><span class="pre">typped.builtin_parse_methods</span></code></a>.</p>
</div>
<div class="section" id="example-a-simple-string-and-number-language-with-evaluation-and-dynamic-typing">
<h2>1.3. Example: A simple string and number language with evaluation and dynamic typing<a class="headerlink" href="#example-a-simple-string-and-number-language-with-evaluation-and-dynamic-typing" title="Permalink to this headline">¶</a></h2>
<p>This next example is a simple language that operates on both quoted strings and
integers.  The only allowed operations are addition and multiplication.  The
operations on integers give the usual results.  The operations on strings are
like in Python: addition concatenates and multiplication of a string by an
integer (on the left or right) repeats it that many times.  Addition of strings
and integers is a syntax error.</p>
<p>Identifier variables can also be defined and assigned values.  This example
uses dynamic typing, like an interpreted language.  Type errors are reported at
parse-time, based on the types implicitly defined by the previously-executed
coded.  For example, assigning <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">&quot;house&quot;</span></code> implicitly defines <code class="docutils literal"><span class="pre">x</span></code> as a
string.</p>
<p>This example illustrates how to define evaluation functions to interpret the
parsed expression trees.  It also shows how to use the basic type mechanism.
The example code in the <code class="docutils literal"><span class="pre">examples</span></code> directory runs the language in a
read-evaluate-print loop (REPL).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">setup_string_language_parser_dynamic_typing</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;A simple dynamically-typed language that uses `+` to add integers and</span>
<span class="sd">    concatenate strings.  Multiplication of a number by a string repeats the</span>
<span class="sd">    string.  Multiplication of a string by a string is not defined.  It also</span>
<span class="sd">    has simple variables which can represent either numbers or strings.&quot;&quot;&quot;</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">PrattParser</span><span class="p">()</span>

    <span class="c1"># Define the tokens.</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">def_default_whitespace</span><span class="p">()</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">def_token</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_int&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;-?\d+&quot;</span><span class="p">)</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_lpar&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\(&quot;</span><span class="p">)</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_rpar&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\)&quot;</span><span class="p">)</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_ast&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\*&quot;</span><span class="p">)</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_plus&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\+&quot;</span><span class="p">)</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_equals&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_identifier&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;[a-zA-Z_](?:\w*)&quot;</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tok</span><span class="p">(</span><span class="s2">&quot;k_string&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;(</span><span class="se">\&quot;</span><span class="s2">(.|[\r\n])*?</span><span class="se">\&quot;</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="c1"># Define the types.</span>

    <span class="n">t_int</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">def_type</span><span class="p">(</span><span class="s2">&quot;t_int&quot;</span><span class="p">)</span> <span class="c1"># Integer type.</span>
    <span class="n">t_str</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">def_type</span><span class="p">(</span><span class="s2">&quot;t_str&quot;</span><span class="p">)</span> <span class="c1"># String type.</span>

    <span class="c1"># Define the syntax of the language, supplying evaluation functions.</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">def_literal</span><span class="p">(</span><span class="s2">&quot;k_int&quot;</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="n">t_int</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">def_literal</span><span class="p">(</span><span class="s2">&quot;k_string&quot;</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="n">t_str</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">def_literal_typed_from_dict</span><span class="p">(</span><span class="s2">&quot;k_identifier&quot;</span><span class="p">,</span> <span class="n">create_eval_fun</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                       <span class="n">default_type</span><span class="o">=</span><span class="n">t_int</span><span class="p">,</span> <span class="n">default_eval_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">def_bracket_pair</span><span class="p">(</span><span class="s2">&quot;k_lpar&quot;</span><span class="p">,</span> <span class="s2">&quot;k_rpar&quot;</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">())</span>

    <span class="n">infix</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">def_infix_op</span>
    <span class="n">infix</span><span class="p">(</span><span class="s2">&quot;k_plus&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
          <span class="n">val_type</span><span class="o">=</span><span class="n">t_int</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="p">[</span><span class="n">t_int</span><span class="p">,</span> <span class="n">t_int</span><span class="p">],</span>
          <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">())</span>
    <span class="n">infix</span><span class="p">(</span><span class="s2">&quot;k_plus&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
          <span class="n">val_type</span><span class="o">=</span><span class="n">t_str</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="p">[</span><span class="n">t_str</span><span class="p">,</span> <span class="n">t_str</span><span class="p">],</span>
          <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">()[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">infix</span><span class="p">(</span><span class="s2">&quot;k_ast&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
          <span class="n">val_type</span><span class="o">=</span><span class="n">t_int</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="p">[</span><span class="n">t_int</span><span class="p">,</span> <span class="n">t_int</span><span class="p">],</span>
          <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">()</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">())</span>
    <span class="n">infix</span><span class="p">(</span><span class="s2">&quot;k_ast&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
          <span class="n">val_type</span><span class="o">=</span><span class="n">t_str</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="p">[</span><span class="n">t_str</span><span class="p">,</span> <span class="n">t_int</span><span class="p">],</span>
          <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span>
                   <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">())</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">))</span>
    <span class="n">infix</span><span class="p">(</span><span class="s2">&quot;k_ast&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
          <span class="n">val_type</span><span class="o">=</span><span class="n">t_str</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="p">[</span><span class="n">t_int</span><span class="p">,</span> <span class="n">t_str</span><span class="p">],</span>
          <span class="n">eval_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span>
                   <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">eval_subtree</span><span class="p">())</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">))</span>

    <span class="c1"># Define assignment as an infix equals operator.</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">def_assignment_op_dynamic</span><span class="p">(</span><span class="s2">&quot;k_equals&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;k_identifier&quot;</span><span class="p">,</span>
                                     <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allowed_types</span><span class="o">=</span><span class="p">[</span><span class="n">t_int</span><span class="p">,</span> <span class="n">t_str</span><span class="p">],</span>
                                     <span class="n">create_eval_fun</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span>
</pre></div>
</div>
</div>
<div class="section" id="example-4-a-simple-string-and-number-language-with-evaluation-and-static-typing">
<h2>1.4. Example 4: A simple string and number language with evaluation and static typing<a class="headerlink" href="#example-4-a-simple-string-and-number-language-with-evaluation-and-static-typing" title="Permalink to this headline">¶</a></h2>
<p>The language being parsed in this example is basically the same as the previous
one except that the language is statically typed rather than dynamically typed.
This is like parsing a statically-typed compiled language.  Type errors are
caught at parse-time, before any interpretation or translation into machine
code.  This language translates the simple string-number language to Python
code, which is then executed</p>
<p>Static typing in a language requires some mechanism for declaring types (either
implicitly or explicitly).  This language has a C-like type declaration syntax.
None of the builtin parse methods work for this special-purpose construct, so a
new construct is defined for type declarations.  Builtin methods are used for
the rest of the parsing.</p>
<p>This example illustrates how to use static typing and how to define custom
parsing functions when the builtin methods are not sufficient.  The example
code in the <code class="docutils literal"><span class="pre">examples</span></code> directory runs the language in a read-evaluate-print
loop.  It prints out the parsed expression tree, the translation to Python,
and the result of evaluating the Python code with Python’s <code class="docutils literal"><span class="pre">eval</span></code>.</p>
<p>The definitions of the parser instance, tokens, and types are basically the
same as in Example 3.</p>
<div class="section" id="defining-a-new-construct-for-type-definitions">
<h3>1.4.1. Defining a new construct for type definitions<a class="headerlink" href="#defining-a-new-construct-for-type-definitions" title="Permalink to this headline">¶</a></h3>
<p>We want to allow C-style typed variable declarations like the following in the
language:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">x</span>
<span class="nb">str</span> <span class="n">y</span>
</pre></div>
</div>
<p>Since the builtin parsing methods do not cover this, we need to define a new
construct and register it with the parser.  Later sections will cover this
in more detail, so readers can skim this subsection for now if necessary.</p>
<p>There are several ways to do this parsing.  We could define new tokens for the
keywords <code class="docutils literal"><span class="pre">int</span></code> and <code class="docutils literal"><span class="pre">str</span></code> (or a token for all such keywords) with a higher
<code class="docutils literal"><span class="pre">on_ties</span></code> value than general identifiers.  Then we would have the handler
functions for those tokens do the corresponding parsing.  Instead, we use
preconditioned dispatching on identifier tokens.  In this way, a different
head-handler function can be dispatched to handle a type name identifier versus
a general identifier.  This makes it easy to add new type names later (since
they are stored in a dict).</p>
<p>In this example we have used a precondition on a head-handler function instead
of using a tail-handler function defined for identifiers.  A tail-handler could
have been used, but in that case <code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">4</span></code> would be more difficult to
parse.  The <code class="docutils literal"><span class="pre">recursive_parse</span></code> routine would consume the <code class="docutils literal"><span class="pre">x</span></code> as an operator,
left value of <code class="docutils literal"><span class="pre">int</span></code>.  The expression <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">4</span></code> could not then be evaluated in
the usual way with <code class="docutils literal"><span class="pre">recursive_parse</span></code> without going back one token in the
lexer (such as with the <code class="docutils literal"><span class="pre">go_back</span></code> method).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. Basic usage</a><ul>
<li><a class="reference internal" href="#example-parsing-a-simple-expression">1.1. Example: Parsing a simple expression</a></li>
<li><a class="reference internal" href="#example-parsing-a-simple-expression-without-using-builtins">1.2. Example: Parsing a simple expression without using builtins</a></li>
<li><a class="reference internal" href="#example-a-simple-string-and-number-language-with-evaluation-and-dynamic-typing">1.3. Example: A simple string and number language with evaluation and dynamic typing</a></li>
<li><a class="reference internal" href="#example-4-a-simple-string-and-number-language-with-evaluation-and-static-typing">1.4. Example 4: A simple string and number language with evaluation and static typing</a><ul>
<li><a class="reference internal" href="#defining-a-new-construct-for-type-definitions">1.4.1. Defining a new construct for type definitions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Typped: A framework for typed Pratt parsers employing dispatching</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pratt_parsing_intro.html"
                        title="next chapter">2. Introduction to Pratt parsing and its terminology</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/basic_usage.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pratt_parsing_intro.html" title="2. Introduction to Pratt parsing and its terminology"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Typped: A framework for typed Pratt parsers employing dispatching"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>