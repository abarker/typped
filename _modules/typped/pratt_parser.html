
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>typped.pratt_parser &#8212; Typped  documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for typped.pratt_parser</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">A general Pratt parser module that uses dispatching of handler functions and</span>
<span class="sd">can check types.  The API is documented here.  See the general Sphinx</span>
<span class="sd">documentation for Typped for how to use the class and examples.</span>

<span class="sd">User-accessible parser attributes</span>
<span class="sd">=================================</span>

<span class="sd">User accessible attributes are mostly the same as the initialization</span>
<span class="sd">keywords to the `PrattParser` initializer.  Most are read-only, but</span>
<span class="sd">some can be changed between parses.</span>

<span class="sd">User-accessible token attributes</span>
<span class="sd">================================</span>

<span class="sd">Token instances straight from a `Lexer` instance have certain attributes set,</span>
<span class="sd">as documented in the `lexer` module.  In particular, the `token_label`,</span>
<span class="sd">`value`, and `children` attributes are commonly used.  The `pratt_parser`</span>
<span class="sd">module defines its own subclass of the `TokenNode` class, which additionally</span>
<span class="sd">assigns some extra attributes when tokens are defined.  The parsing process</span>
<span class="sd">also sets several user-accessible attributes.</span>

<span class="sd">Attributes set on `TokenNode` subclasses (representing kinds of tokens):</span>

<span class="sd">* `token_label`</span>

<span class="sd">Attributes set on token instances (scanned tokens) during parsing:</span>

<span class="sd">* `parser_instance` -- the parser instance that parsed the token</span>
<span class="sd">* `original_formal_sig` -- a `TypeSig` instance of the resolved original formal signature</span>
<span class="sd">* `expanded_formal_sig` -- a `TypeSig` instance of the expanded formal signature</span>
<span class="sd">* `actual_sig` -- a `TypeSig` instance of the actual signature</span>
<span class="sd">* `construct_label` -- the string label of the winning preconditions function</span>

<span class="sd">Note that both `original_formal_sig` and `expanded_formal_sig` are set to the</span>
<span class="sd">string `&quot;Unresolved&quot;` before the token is parsed.  The actual signature is</span>
<span class="sd">found during parsing and type-checking.  Out of all possible overloads in the</span>
<span class="sd">original formal signatures associated with the token (via `modify_token`) the</span>
<span class="sd">one which matches the actual arguments is chosen.  The expanded formal</span>
<span class="sd">signature is the same as the original formal signature except that wildcards,</span>
<span class="sd">etc., are expanded in the attempt to match the actual arguments.</span>

<span class="sd">These two attributes are actually properties which look up the value if</span>
<span class="sd">necessary (to avoid unnecessary lookups during parsing).  They both only</span>
<span class="sd">work after parsing, since they use the `original_formal_sig` to look up</span>
<span class="sd">the corresponding data or function.</span>

<span class="sd">* `ast_data` -- any AST data that was set with the construct for the resolved type</span>
<span class="sd">* `eval_fun` -- any eval_fun that was set with the construct for the resolved type</span>

<span class="sd">Optional attributes that can be set to a node inside a handler:</span>

<span class="sd">* `not_in_tree` -- set on a root node returned by the handler to hide it</span>
<span class="sd">* `process_and_check_kwargs` -- a kwargs dict to pass to type-checking routine</span>

<span class="sd">Implementation details</span>
<span class="sd">======================</span>

<span class="sd">This section gives a general overview of the lower-level details of the</span>
<span class="sd">`PrattParser` implementation.</span>

<span class="sd">The basic class structure</span>
<span class="sd">-------------------------</span>

<span class="sd">TODO: Update diagram to and discussion to have ConstructTable.</span>

<span class="sd">There are five basic classes, with instances which interact.  The main class is</span>
<span class="sd">the `PrattParser` class, which users will mostly interact with.  The overall</span>
<span class="sd">relationships are shown in this image, with discussion below.</span>

<span class="sd">.. image:: relationshipsBetweenMainClasses.svg</span>
<span class="sd">    :width: 600px</span>
<span class="sd">    :align: center</span>

<span class="sd">The next three classes are defined in the lexer module, although one is</span>
<span class="sd">redefined here.  They are the `TokenSubclass`, `TokenTable`, and `Lexer`</span>
<span class="sd">classes.</span>

<span class="sd">A `Lexer` instance is always initialized with a `TokenTable` instance, whether</span>
<span class="sd">it is passed-in as an argument or created internally as an empty token table.</span>
<span class="sd">A `PrattParser` instance always creates its own token table and then passes</span>
<span class="sd">that to the lexer, which it also creates.</span>

<span class="sd">Every `PrattParser` instance contains a fixed `TokenTable` instance, which</span>
<span class="sd">never changes (except for the tokens in it).  So each token-table created by a</span>
<span class="sd">parser can save a pointer back to the parser which &quot;owns&quot; it.  Each</span>
<span class="sd">`PrattParser` instance also contains a `Lexer` instance, which contains</span>
<span class="sd">a pointer to a parser instance (so the lexer can access the parser).</span>

<span class="sd">The `TokenSubclass` class is a subclass of the `TokenNode` class (which is</span>
<span class="sd">defined in the lexer module).  The subclassing adds many additional methods and</span>
<span class="sd">attributes which are needed in the parsing application.  The `TokenSubclass`</span>
<span class="sd">class is actually defined inside a factory function, called</span>
<span class="sd">`token_subclass_factory`, which produces a different subclass to represent each</span>
<span class="sd">kind of token that is defined (tokens are defined via the `def_token` method of</span>
<span class="sd">`PrattParser`).  Instances of those subclasses represent the actual tokens</span>
<span class="sd">(i.e., tokens scanned and returned by the lexer containing individual</span>
<span class="sd">text-string values).</span>

<span class="sd">A `TokenTable` instance is basically a dict for holding all the defined</span>
<span class="sd">token-subclasses.  But it also has related methods and attributes associated</span>
<span class="sd">with it.  It is where all new tokens are ultimately created and defined, for</span>
<span class="sd">example (although other classes like the parser class can add extra attributes</span>
<span class="sd">to the created tokens).</span>

<span class="sd">A `TokenTable` instance contains all the tokens defined for a language, and</span>
<span class="sd">stays with the `PrattParser` instance which created it (from which the tokens</span>
<span class="sd">were necessarily defined).  A `Lexer` instance can use different `TokenTable`</span>
<span class="sd">instances, possibly switching on-the-fly.  A lexer instance always has a</span>
<span class="sd">pointer to its *current* token-table instance, but that can change on-the-fly</span>
<span class="sd">(such as when separate parsers are swapped in to parse sub-languages in the</span>
<span class="sd">same text stream).  This is used when parser instances call other parser</span>
<span class="sd">instances.</span>

<span class="sd">Tokens defined by a parser also save a pointer to their defining parser, since</span>
<span class="sd">the token-table has a fixed association to the parser.</span>

<span class="sd">Tokens also need to know their current lexer instance because they need to call</span>
<span class="sd">the `next` and `peek` methods, if nothing else.  This is equivalent to the</span>
<span class="sd">token table knowing its current lexer instance.  So, whenever a token table is</span>
<span class="sd">associated with a lexer using the lexer&#39;s `set_token_table` method it is also</span>
<span class="sd">given a pointer to that lexer as an attribute.</span>

<span class="sd">The final class of the five is the `TypeTable` class.  This is essentially a</span>
<span class="sd">dict to store all the defined types, but it also provides a nice place to</span>
<span class="sd">define many methods for acting on types.  It is defined in the `pratt_types`</span>
<span class="sd">module and imported.</span>

<span class="sd">Using different parsers inside handler functions</span>
<span class="sd">------------------------------------------------</span>

<span class="sd">It is useful to be able to call different `PrattParser` instances from inside</span>
<span class="sd">handler functions in order to parse subexpressions which are defined as</span>
<span class="sd">sublanguages, having their own parsers.  The implementation supports this as</span>
<span class="sd">follows.</span>

<span class="sd">Essentially, a common lexer is passed around and told which token table (and</span>
<span class="sd">hence parser) to use at any given time.  It would be possible to pass around a</span>
<span class="sd">text stream of unprocessed text, but then the lexers would need to be</span>
<span class="sd">initialized each time, and saving information like line numbers and columns in</span>
<span class="sd">the text would need to move to the text stream object.</span>

<span class="sd">The `parse` routine of a `PrattParser` takes an optional lexer argument, which</span>
<span class="sd">is used by sub-parsers instead of the default lexer.  When parsing a</span>
<span class="sd">sublanguage with a different parser the the `TokenTable` instance of the lexer</span>
<span class="sd">is set to be the same as the token table instance of the *current* parser</span>
<span class="sd">(using the lexer&#39;s `set_token_table` method).  So you can call the `parse`</span>
<span class="sd">method of a *different* parser instance from within a handler function, passing</span>
<span class="sd">that other parser&#39;s `parse` function the *current* parser&#39;s lexer as an</span>
<span class="sd">argument.  The lexer will use the token table of the new parser but still read</span>
<span class="sd">from the same text stream as the current parser.</span>

<span class="sd">Note that a sublanguage program (or expression or wff) must always be parsed</span>
<span class="sd">from the beginning, so the `parse` method is called.  When this parser reaches</span>
<span class="sd">the end, where it would normally stop, the symbol table of the lexer is</span>
<span class="sd">restored to the symbol table of the current parser (again using the lexer&#39;s</span>
<span class="sd">`set_token_table` method).</span>

<span class="sd">A sublanguage expression can end when the lexer doesn&#39;t recognize a token, or</span>
<span class="sd">when it would normally return a parsed expression.</span>

<span class="sd">Code</span>
<span class="sd">====</span>

<span class="sd">In reading the code, the correspondence between the naming convention used here</span>
<span class="sd">and Pratt&#39;s original naming conventions is given in this table:</span>

<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| This code                        | Pratt&#39;s terminology      |</span>
<span class="sd">+==================================+==========================+</span>
<span class="sd">| token precedence                 | left binding power, lbp  |</span>
<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| subexpression precedence         | right binding power, rbp |</span>
<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| head handler function            | null denotation, nud     |</span>
<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| tail handler function            | left denotation, led     |</span>
<span class="sd">+----------------------------------+--------------------------+</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="c1"># Run tests when invoked as a script.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pytest_helper</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">([</span><span class="s2">&quot;../../test/test_ebnf_classes_and_operators.py&quot;</span><span class="p">,</span>
                              <span class="s2">&quot;../../test/test_example_expression_grammar.py&quot;</span><span class="p">,</span>
                              <span class="s2">&quot;../../test/test_example_calculator.py&quot;</span><span class="p">,</span>
                              <span class="s2">&quot;../../test/test_example_calculator_identifier_keyed_on_values.py&quot;</span><span class="p">,</span>
                              <span class="s2">&quot;../../test/test_parser_called_from_parser.py&quot;</span><span class="p">,</span>
                              <span class="s2">&quot;../../test/test_pratt_types.py&quot;</span><span class="p">,</span>
                              <span class="s2">&quot;../../test/test_basic_usage_section_examples.py&quot;</span><span class="p">,</span>
                              <span class="s2">&quot;../../test/test_pratt_parser.py&quot;</span><span class="p">,</span>
                              <span class="p">],</span> <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>

<span class="kn">from</span> <span class="nn">.shared_settings_and_exceptions</span> <span class="k">import</span> <span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">TAIL</span><span class="p">,</span> <span class="n">ParserException</span><span class="p">,</span>
        <span class="n">NoHandlerFunctionDefined</span><span class="p">,</span> <span class="n">CalledBeginTokenHandler</span><span class="p">,</span> <span class="n">CalledEndTokenHandler</span><span class="p">,</span>
        <span class="n">DEFAULT_ALWAYS_TRUE_PRECOND_FUN</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.lexer</span> <span class="k">import</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">TokenNode</span><span class="p">,</span> <span class="n">TokenTable</span>
<span class="kn">from</span> <span class="nn">.pratt_types</span> <span class="k">import</span> <span class="n">TypeTable</span><span class="p">,</span> <span class="n">TypeSig</span><span class="p">,</span> <span class="n">TypeErrorInParsedLanguage</span>
<span class="kn">from</span> <span class="nn">.pratt_constructs</span> <span class="k">import</span> <span class="n">ConstructTable</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">builtin_parse_methods</span><span class="p">,</span> <span class="n">predefined_token_sets</span>

<span class="c1"># TODO: Add an symbol=None option to def_token (maybe also to lexer and</span>
<span class="c1"># just pass to that).  It should be used like symbol=&quot;(&quot; to define an</span>
<span class="c1"># alternative name that can be used in some contexts to refer to the</span>
<span class="c1"># token.  If token label not found, could then auto-search symbols... or</span>
<span class="c1"># make it explicit.  Essentially just an alias useful in grammar specs.</span>

<span class="c1"># TODO: clarify when tokens are assigned the parser_instance attribute, if they</span>
<span class="c1"># are at all.  Currently the lexer is passed a function hook that adds the</span>
<span class="c1"># parser instance associated with the lexer&#39;s current token table to every</span>
<span class="c1"># token as, an attribute.  Seems OK, including for parsers calling parsers, but</span>
<span class="c1"># consider and update docs and comments where not yet changed.</span>
<span class="c1">#</span>
<span class="c1"># The extra_data attribute is now temporarily added to trigger tokens.  Is</span>
<span class="c1"># that enough access to parser_instance?  Probably not, since we need to</span>
<span class="c1"># get parser options.</span>

<span class="c1"># Note that the eval_fun stuff could also be used to also do a conversion to</span>
<span class="c1"># AST.  Also at some point add &quot;eval on the fly&quot; capability (not too hard, but</span>
<span class="c1"># extra complexity).</span>

<span class="c1"># Later, consider serialization of defined parsers, such as with JSON or (at</span>
<span class="c1"># least) pickle http://www.discoversdk.com/blog/python-serialization-with-pickle</span>
<span class="c1"># If a TokenTable is made to fully define a parser then you only need to save that...</span>
<span class="c1"># but you need to clutter it with non-token data.</span>

<span class="c1"># As a debugging tool it would be nice to have a method to list of all the</span>
<span class="c1"># precond funs that MUST be mutually exclusive in order to guarantee never</span>
<span class="c1"># having a tie.  Then the user can make sure they are exclusive, or else change</span>
<span class="c1"># the priorities.  Gives a define-time check, not having to wait until</span>
<span class="c1"># parse-time (perhaps waiting for some obscure combination).  Shouldn&#39;t be too</span>
<span class="c1"># hard to write.</span>

<span class="c1">#</span>
<span class="c1"># TokenNode</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;The `TokenNode` base class is defined in `lexer.py`.  It contains some of</span>
<span class="sd">the basic, general methods that apply to tokens and nodes in token trees.</span>
<span class="sd">Methods particular to an application need to be defined in a subclass.  The</span>
<span class="sd">function `token_subclass_factory` returns a subclass of `TokenNode` which</span>
<span class="sd">represents tokens with a given token label.  The `PrattParser` class sets this</span>
<span class="sd">function to be used by its `TokenTable` instance in order to</span>
<span class="sd">create a token subclass for each kind of token.  Many methods particular to the</span>
<span class="sd">`PrattParser` application are added to the subclass.&quot;&quot;&quot;</span>

<span class="c1"># TODO: Since TokenNode now has a metaclass anyway, why not just use it to</span>
<span class="c1"># generate the new instances instead of the factory function?  The factory</span>
<span class="c1"># function is maybe simpler, but Sphinx does not properly document the</span>
<span class="c1"># TokenNode class defined inside it.</span>
<span class="c1">#</span>
<span class="c1"># Alternative: Define the base class in module scope in the usual way, and</span>
<span class="c1"># then have the factory function just subclass it again (from some trivial</span>
<span class="c1"># stub) to represent particular kinds of tokens.</span>

<div class="viewcode-block" id="TokenSubclassMeta"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.TokenSubclassMeta">[docs]</a><span class="k">class</span> <span class="nc">TokenSubclassMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A trivial metaclass that will actually create the `TokenSubclass`</span>
<span class="sd">    objects.  Since tokens are represented by classes, rather than instances,</span>
<span class="sd">    this is necessary in order to change their `__repr__` (the defalt one is</span>
<span class="sd">    ugly for tokens) and to overload operators to work for token operands</span>
<span class="sd">    in the EBNF-like grammar.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="n">new_class</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TokenSubclassMeta</span><span class="p">,</span> <span class="n">mcs</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>

        <span class="c1"># Below is ugly, but avoids mutual import problems.  Used as an easy</span>
        <span class="c1"># way to define token addition so that it works in the grammars defined</span>
        <span class="c1"># by the ebnf_classes_and_operators module.</span>
        <span class="kn">from</span> <span class="nn">.ebnf_classes_and_operators</span> <span class="k">import</span> <span class="p">(</span>
                                     <span class="n">Tok</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Prec</span><span class="p">,</span> <span class="n">nExactly</span><span class="p">,</span> <span class="n">nOrMore</span><span class="p">,</span> <span class="n">Repeat</span><span class="p">)</span>
        <span class="c1"># These are saved in a dict below because if they are made attributes</span>
        <span class="c1"># then Python 2 complains about &quot;TypeError: unbound method Tok() must</span>
        <span class="c1"># be called with TokenClass_k_lpar instance as first argument (got</span>
        <span class="c1"># TokenSubclassMeta instance instead)&quot;.</span>
        <span class="n">new_class</span><span class="o">.</span><span class="n">prod_rule_funs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;Tok&quot;</span><span class="p">:</span> <span class="n">Tok</span><span class="p">,</span>
                <span class="s2">&quot;Not&quot;</span><span class="p">:</span> <span class="n">Not</span><span class="p">,</span>
                <span class="s2">&quot;Prec&quot;</span><span class="p">:</span> <span class="n">Prec</span><span class="p">,</span>
                <span class="s2">&quot;nExactly&quot;</span><span class="p">:</span> <span class="n">nExactly</span><span class="p">,</span>
                <span class="s2">&quot;nOrMore&quot;</span><span class="p">:</span> <span class="n">nOrMore</span><span class="p">,</span>
                <span class="s2">&quot;Repeat&quot;</span><span class="p">:</span> <span class="n">Repeat</span><span class="p">,</span>
                <span class="p">}</span>
        <span class="k">return</span> <span class="n">new_class</span>

    <span class="c1">#</span>
    <span class="c1"># Define a nicer-looking __repr__, since the classes represent tokens.</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The representation for tokens.  Tokens are commonly used in the</span>
<span class="sd">        code but, being classes, have an ugly default `__repr__` when printed out.</span>
<span class="sd">        In this metaclass we can define a better `__repr__` for tokens.&quot;&quot;&quot;</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;TokenClass_</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">token_label</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span>

    <span class="c1">#</span>
    <span class="c1"># These overloads work with the ebnf_classes_and_operators module.</span>
    <span class="c1">#</span>

    <span class="c1"># TODO: Could have a flag to turn overloads on and off, maybe.</span>
    <span class="c1"># Might want to turn off when not processing a grammar expression</span>
    <span class="c1"># using the tokens, but it really shouldn&#39;t matter much.</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Addition of two tokens is defined to simply return a tuple of</span>
<span class="sd">        both tokens.  This is so raw tokens can be used in the operator</span>
<span class="sd">        overloaded form of defining production rules for a grammar.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;Tok&quot;</span><span class="p">](</span><span class="bp">cls</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The right version of `__add__` above.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left_other</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;Tok&quot;</span><span class="p">](</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `|` symbol simply converts this object into an `ItemList`</span>
<span class="sd">        and then calls `__or__` for those objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;Tok&quot;</span><span class="p">](</span><span class="bp">cls</span><span class="p">)</span> <span class="o">|</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__ror__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The right version of `__or__` above.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">left_other</span> <span class="o">|</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;Tok&quot;</span><span class="p">](</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The expression `n*token` for an int `n` is &quot;n occurrences of&quot;</span>
<span class="sd">        `token`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;Repeat&quot;</span><span class="p">](</span><span class="n">left_other</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The expression `n**token` for an int `n` is &quot;n or more occurrences of&quot;</span>
<span class="sd">        `token`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;nOrMore&quot;</span><span class="p">](</span><span class="n">left_other</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the `~` operator for production rule grammars.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;Not&quot;</span><span class="p">](</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the bracket indexing operator for production rule grammars</span>
<span class="sd">        to set the precedence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod_rule_funs</span><span class="p">[</span><span class="s2">&quot;Prec&quot;</span><span class="p">](</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span></div>

<div class="viewcode-block" id="token_subclass_factory"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.token_subclass_factory">[docs]</a><span class="k">def</span> <span class="nf">token_subclass_factory</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;This function is called from the `create_token_subclass` method of</span>
<span class="sd">    `TokenTable` when it needs to create a new subclass to begin</span>
<span class="sd">    with.  It should not be called directly.</span>

<span class="sd">    Create and return a new token subclass which will be modified and used</span>
<span class="sd">    to represent a particular kind of token.  Specifically, each scanned token</span>
<span class="sd">    matching the regex defined for tokens with a given token label is</span>
<span class="sd">    represented as an instance of the subclass created by calling this function</span>
<span class="sd">    (with further attributes, such as the token label, added to it).</span>

<span class="sd">    Using a separate subclass for each token label allows for attributes</span>
<span class="sd">    specific to a kind of token (including head and tail handler methods) to</span>
<span class="sd">    later be added to the class itself without conflicts.  This function</span>
<span class="sd">    returns a bare-bones subclass without any head or tail functions, etc.&quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">TokenSubclass</span><span class="p">(</span><span class="n">TokenSubclassMeta</span><span class="p">(</span><span class="s2">&quot;TokenSubclass&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{}),</span> <span class="n">TokenNode</span><span class="p">):</span>
    <span class="c1">#class TokenSubclass(TokenNode, metaclass=TokenSubclassMeta):  # Python 3</span>
    <span class="c1">#class TokenSubclass(TokenNode):                               # No metaclass.</span>
        <span class="sd">&quot;&quot;&quot;The factory function returns this class to represent tokens.  It is a</span>
<span class="sd">        subclass of the `TokenNode` class, defined in the lexer module.&quot;&quot;&quot;</span>
        <span class="n">static_prec</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># The prec value for this kind of token, with default zero.</span>
        <span class="n">token_label</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Set to the actual value later, by create_token_subclass.</span>
        <span class="c1">#parser_instance = None # Set by recursive_parse. AVOID if not needed.</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize an instance of the subclass for a token of the kind</span>
<span class="sd">            labeled with `token_label`.  The `value` is the actual parsed</span>
<span class="sd">            string from the text.  This instance represents the token.&quot;&quot;&quot;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">TokenSubclass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span> <span class="c1"># Call base class __init__.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># Set from lex.token_generator; static value=None.</span>

            <span class="c1"># The `expanded_formal_sig` attr is set upon parsing.  It is the</span>
            <span class="c1"># expanded form of one of the formal sigs which were registered</span>
            <span class="c1"># with the token (the expansion handles wildcards, repeat options,</span>
            <span class="c1"># etc.)  It is the signature which matched the actual args.  The</span>
            <span class="c1"># `self.expanded_formal_sig` has an attribute `original_formal_sig`</span>
            <span class="c1"># which is the original, unexpanded formal signature that matched</span>
            <span class="c1"># (after expansion) the actual arguments.  After parsing it is set</span>
            <span class="c1"># as the token attribute `original_formal_sig`.  This is important</span>
            <span class="c1"># because the `eval_fun` and `ast_data` for tokens are saved in</span>
            <span class="c1"># dicts keyed by the original signature at the time when they are</span>
            <span class="c1"># defined (via `modify_token`).  So we need the resolved original</span>
            <span class="c1"># signature to look up the value.  (Note that if overloading on</span>
            <span class="c1"># return types is turned off then these dicts are keyed only on the</span>
            <span class="c1"># argument portion of the original typesig.)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_formal_sig</span> <span class="o">=</span> <span class="s2">&quot;Unresolved&quot;</span> <span class="c1"># The matching orig sig.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span> <span class="o">=</span> <span class="s2">&quot;Unresolved&quot;</span> <span class="c1"># Expanded version of above.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actual_sig</span> <span class="o">=</span> <span class="s2">&quot;Unresolved&quot;</span> <span class="c1"># The actual signature.</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">prec</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return the precedence for the token.  This is currently a static</span>
<span class="sd">            value for each type of token.  Later it may be dynamic value</span>
<span class="sd">            associated with the particular tail function which is selected in a</span>
<span class="sd">            given context. Update: may become an attribute of a construct and</span>
<span class="sd">            no longer of a token.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">static_prec</span>

        <span class="k">def</span> <span class="nf">process_not_in_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Removes any immediate children which have `not_in_tree` set.&quot;&quot;&quot;</span>
            <span class="n">modified_children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;not_in_tree&quot;</span><span class="p">):</span>
                    <span class="n">modified_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">modified_children</span> <span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">modified_children</span>

        <span class="k">def</span> <span class="nf">process_and_check_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">construct</span><span class="p">,</span>
                                   <span class="n">val_type_override</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_vals_override</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">typesig_override</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;This routine is automatically called just after a handler</span>
<span class="sd">            function returns a subtree.  It is called for the root of the</span>
<span class="sd">            returned subtree.  It sets some attributes and checks that the</span>
<span class="sd">            actual types match some defined type signature for the function.</span>

<span class="sd">            If `val_type_override` is set to a `TypeObject` instance then the</span>
<span class="sd">            return type of both the `expanded_formal_sig` and the `actual_sig`</span>
<span class="sd">            for the node is set to that type *after* the first pass of</span>
<span class="sd">            processing and type-checking for the subtree is finished.  (This</span>
<span class="sd">            option does not currently work for two-pass checking when</span>
<span class="sd">            overloading on return types is used.)  This option is useful for</span>
<span class="sd">            handling things like parentheses and brackets which inherit the</span>
<span class="sd">            type of their child (assuming the parens and brackets are kept as</span>
<span class="sd">            nodes in the parse tree and not eliminated).  The override value is</span>
<span class="sd">            used for type-checking farther up the expression tree.</span>

<span class="sd">            If `all_vals_override` is set to a `TypeObject` instance then all</span>
<span class="sd">            the possible signatures have their `val_type` changed to that type</span>
<span class="sd">            *before* any checking is done.  This should work for both one and</span>
<span class="sd">            two-pass checking, but no check is made for producing duplicate</span>
<span class="sd">            types due to the `val_type` changes.</span>

<span class="sd">            The `typesig_override` argument must be a `TypeSig` instance.  If</span>
<span class="sd">            set it will be *assigned* to the node as its only possible</span>
<span class="sd">            `expanded_formal_sig` before type checking (instead of looking up</span>
<span class="sd">            the registered ones).  Type checking then proceeds as usual.&quot;&quot;&quot;</span>

            <span class="c1"># Get all the sigs registered for the node&#39;s construct.</span>
            <span class="k">if</span> <span class="n">typesig_override</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">all_possible_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">typesig_override</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_possible_sigs</span> <span class="o">=</span> <span class="n">construct</span><span class="o">.</span><span class="n">original_sigs</span>
            <span class="k">if</span> <span class="n">all_vals_override</span><span class="p">:</span>
                <span class="n">all_possible_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">TypeSig</span><span class="p">(</span><span class="n">all_vals_override</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span>
                                                      <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">all_possible_sigs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_sigs</span> <span class="o">=</span> <span class="n">all_possible_sigs</span> <span class="c1"># Temporary attribute.</span>

            <span class="c1"># Do the actual checking.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">overload_on_ret_types</span><span class="p">:</span> <span class="c1"># One-pass.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_types_one_pass</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Two-pass.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_types_first_of_two_passes</span><span class="p">()</span>
                <span class="c1"># If we have a *unique* matching sig, run pass two on the</span>
                <span class="c1"># subtree.  In this case, since the signature is fixed by</span>
                <span class="c1"># argument types (regardless of where the top-down pass</span>
                <span class="c1"># starts from) we can in this case resolve the types in the</span>
                <span class="c1"># subtree early.  Note `check_types_in_tree_second_pass` is</span>
                <span class="c1"># also called on the root node from the `parse` method.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># matching_sigs set by _check_types</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">check_types_in_tree_second_pass</span><span class="p">()</span>

            <span class="c1"># Implement val_type override if set.</span>
            <span class="k">if</span> <span class="n">val_type_override</span><span class="p">:</span>
                <span class="c1"># Note that the original_formal_sig attribute was already set.</span>
                <span class="c1"># The ast_data and eval_fun are keyed on that.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="p">(</span><span class="n">val_type_override</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">actual_sig</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="p">(</span><span class="n">val_type_override</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_types_one_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Utility function called from `process_and_check_node` to check</span>
<span class="sd">            the actual types against their signatures when overloading is only on</span>
<span class="sd">            argument types.&quot;&quot;&quot;</span>
            <span class="n">all_possible_sigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_sigs</span>

            <span class="c1"># One-pass, each child c has a unique c.expanded_formal_sig already set.</span>
            <span class="n">list_of_child_sig_lists</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>

            <span class="c1"># Reduce to only the signatures that the types of the children match.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="o">.</span><span class="n">get_all_matching_expanded_sigs</span><span class="p">(</span>
                                      <span class="n">all_possible_sigs</span><span class="p">,</span> <span class="n">list_of_child_sig_lists</span><span class="p">,</span>
                                      <span class="n">tnode</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># Below all_possible_sigs is saved ONLY for printing error messages.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_sigs</span> <span class="o">=</span> <span class="n">all_possible_sigs</span>

            <span class="c1"># No overloading on return types so we can finalize the actual types.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">,</span>
                        <span class="s2">&quot;Ambiguous type resolution: The actual argument types match&quot;</span>
                        <span class="s2">&quot; multiple signatures.&quot;</span><span class="p">)</span>

            <span class="c1"># Found a unique signature; set the node&#39;s expanded_formal_sig attribute.</span>
            <span class="c1"># Saved sig used for eval_fun resolution, ast_data, semantic action, etc.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_formal_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">original_formal_sig</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actual_sig</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span>
                                      <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">actual_sig</span><span class="o">.</span><span class="n">val_type</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">])</span>

            <span class="c1"># Delete some temporary attributes no longer needed.</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;matching_sigs&quot;</span><span class="p">)</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;all_possible_sigs&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_types_first_of_two_passes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Utility function called from `process_and_check_node` to do the</span>
<span class="sd">            first pass in checking the actual types against their signatures.</span>
<span class="sd">            Two-pass checking is needed for overloading on return types.  First</span>
<span class="sd">            pass goes up the tree, second pass goes back down.&quot;&quot;&quot;</span>
            <span class="n">all_possible_sigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_sigs</span>

            <span class="c1"># First pass case, multiple sigs in child&#39;s self.matching_sigs list.</span>
            <span class="n">list_of_child_sig_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">matching_sigs</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>

            <span class="c1"># Reduce to only the signatures that the types of the children match.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="o">.</span><span class="n">get_all_matching_expanded_sigs</span><span class="p">(</span>
                                      <span class="n">all_possible_sigs</span><span class="p">,</span> <span class="n">list_of_child_sig_lists</span><span class="p">,</span>
                                      <span class="n">tnode</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">check_types_in_tree_second_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Recursively run the second pass on the token subtree with the</span>
<span class="sd">            `self` node as the root.</span>

<span class="sd">            This method currently still needs to be explicitly called for the</span>
<span class="sd">            root of the final parse tree, from the `PrattParser` method</span>
<span class="sd">            `parse`, as well as from the checking routines here to do partial</span>
<span class="sd">            checks on subtrees which are already resolvable.&quot;&quot;&quot;</span>
            <span class="n">unresolved_children</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s2">&quot;matching_sigs&quot;</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_types_pass_two</span><span class="p">()</span> <span class="c1"># Call first on self to do top-down.</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">unresolved_children</span><span class="p">:</span> <span class="c1"># Recurse on unprocessed children.</span>
                <span class="n">child</span><span class="o">.</span><span class="n">check_types_in_tree_second_pass</span><span class="p">()</span>
            <span class="c1"># Delete childrens&#39; matching_sigs lists after they are no longer needed.</span>
            <span class="c1"># This also acts as an indicator that the node has been resolved.</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">unresolved_children</span><span class="p">:</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;matching_sigs&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
                <span class="c1"># The final pass in _check_types that deletes these attrs doesn&#39;t get</span>
                <span class="c1"># run on root, so it is explicitly done here when `root` flag is true.</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;matching_sigs&quot;</span><span class="p">)</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;all_possible_sigs&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_types_pass_two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;A second pass is only used when overloading on return types is</span>
<span class="sd">            allowed.  It is a top-down pass where each node chooses a unique</span>
<span class="sd">            final signature for each of its children.  It depends on the</span>
<span class="sd">            node attribute `self.matching_sigs` having been set in the first</span>
<span class="sd">            pass.&quot;&quot;&quot;</span>
            <span class="c1"># On FIRST pass: on the way *up* the tree (after getting the</span>
            <span class="c1"># literal tokens, the leaves of the tree) get all the signature</span>
            <span class="c1"># types for a node which match in arguments for *some* possible</span>
            <span class="c1"># return-type choice of the children.  Same as the one-pass</span>
            <span class="c1"># version, but now sets of possibilities are allowed and state is</span>
            <span class="c1"># saved for the second pass to use: the list of matching sigs is</span>
            <span class="c1"># temporarily saved with the node in the self.matched_sigs</span>
            <span class="c1"># attribute.</span>
            <span class="c1">#</span>
            <span class="c1"># Summary: first pass, bottom-up, find all sigs that match possible</span>
            <span class="c1"># val_types of the node&#39;s children, across all arguments.</span>
            <span class="c1">#</span>
            <span class="c1"># After the first pass the root should have a unique sig; if not</span>
            <span class="c1"># there is ambiguity.  (Each node saved a set of sigs that is</span>
            <span class="c1"># satisfiable by some realizable choice of child sigs, and parents</span>
            <span class="c1"># can force children to assume any of their possible types).</span>
            <span class="c1">#</span>
            <span class="c1"># On SECOND pass: On the way *down* the tree, parents choose one</span>
            <span class="c1"># sig as final for each child and set it in that child&#39;s node as</span>
            <span class="c1"># the new self.matching_sigs.  This should always be a unique sig;</span>
            <span class="c1"># otherwise there is ambibuity.  Recursively called on children.</span>
            <span class="c1">#</span>
            <span class="c1"># Summary: second pass, top-down, root is unique and parents assign</span>
            <span class="c1"># and set the (unique) signature for each of their children.</span>
            <span class="c1">#</span>
            <span class="c1"># Note that this algorithm works just as well if the second pass is</span>
            <span class="c1"># run on each subtree as soon as the subtree root has a unique</span>
            <span class="c1"># signature, and the recursion only goes down to subtrees with</span>
            <span class="c1"># roots having a unique signature.  This yields partial results and</span>
            <span class="c1"># some error conditions sooner, and is what is implemented here.</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># The root case needs this.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">,</span>
                        <span class="s2">&quot;Ambiguous type resolution (second pass).  Possible type &quot;</span>
                        <span class="s2">&quot;assignments for the children/arguments of the token node match&quot;</span>
                        <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2"> possible node signatures: </span><span class="si">{1}</span><span class="s2">.  Uniqueness is required.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">))</span>

            <span class="c1"># We have a unique signature; set the node&#39;s type attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_formal_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">original_formal_sig</span>
            <span class="c1"># Start setting the actual signature; children will fill arg types</span>
            <span class="c1"># when resolved.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">actual_sig</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="p">[])</span>

            <span class="c1"># Set the actual_sig arg_type for the parent (appending in sequence with others).</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parent_args_so_far</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">actual_sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span>
                <span class="n">parent_args_so_far</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">actual_sig</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">actual_sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span>
                                                 <span class="n">parent_args_so_far</span><span class="p">)</span>

            <span class="c1"># Update the matching_sigs attribute for each child (should be singleton).</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;matching_sigs&quot;</span><span class="p">):</span>
                    <span class="k">continue</span> <span class="c1"># Already resolved.</span>
                <span class="n">matched_sigs</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="o">.</span><span class="n">get_child_sigs_matching_return_arg_type</span><span class="p">(</span>
                                      <span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">[</span><span class="n">count</span><span class="p">],</span>
                                      <span class="n">child</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">)</span>
                <span class="c1"># From the first pass, we know at least one child sig matches.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_sigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="c1"># Debug.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_sigs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Recursion could catch this on the next step, but better err msg.</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">(</span><span class="n">matched_sigs</span><span class="p">,</span>
                        <span class="s2">&quot;Token node has multiple signatures with return type matching &quot;</span>
                        <span class="s2">&quot;type of parent (pass two). Parent expects type &#39;</span><span class="si">{0}</span><span class="s2">&#39;.  Defined&quot;</span>
                        <span class="s2">&quot; signatures are: </span><span class="si">{1}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">))</span>
                <span class="n">child</span><span class="o">.</span><span class="n">matching_sigs</span> <span class="o">=</span> <span class="n">matched_sigs</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">_raise_type_mismatch_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matching_sigs</span><span class="p">,</span> <span class="n">basic_msg</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Raise an error, printing a helpful diagnostic message.  Assumes</span>
<span class="sd">            that `_check_types` has been called (to set `self.all_possible_sigs`).&quot;&quot;&quot;</span>
            <span class="c1"># TODO: Will the self.expanded_formal_sig *ever* be resolved when this routine is</span>
            <span class="c1"># called?  If not, then it is not very useful and message could be reworded.</span>
            <span class="n">diagnostic</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;  The current token has value &#39;</span><span class="si">{0}</span><span class="s2">&#39; and label &#39;</span><span class="si">{1}</span><span class="s2">&#39;.  &quot;</span>
                         <span class="s2">&quot; Its expanded formal signature is </span><span class="si">{2}</span><span class="s2">.  The&quot;</span>
                         <span class="s2">&quot; children/arguments have token labels and values of </span><span class="si">{3}</span><span class="s2"> and &quot;</span>
                         <span class="s2">&quot;value types </span><span class="si">{4}</span><span class="s2">.  The list of matching signatures &quot;</span>
                         <span class="s2">&quot;is </span><span class="si">{5}</span><span class="s2">.  The list of possible signatures was </span><span class="si">{6}</span><span class="s2">&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="p">,</span>
                             <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">summary_repr</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">),</span>
                             <span class="c1"># Note this below can be &quot;Unresolved&quot;, better message?</span>
                             <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">val_type</span>
                                  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                                  <span class="k">else</span> <span class="n">c</span><span class="o">.</span><span class="n">expanded_formal_sig</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">),</span>
                             <span class="n">matching_sigs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_possible_sigs</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">TypeErrorInParsedLanguage</span><span class="p">(</span><span class="n">basic_msg</span> <span class="o">+</span> <span class="n">diagnostic</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Evaluations and semantic actions.</span>
        <span class="c1">#</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">eval_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return the evaluation function saved with the winning construct</span>
<span class="sd">            dispatched for the token.  Must be called after parsing because the</span>
<span class="sd">            `original_formal_sig` attribute and others must be set on the token</span>
<span class="sd">            instance.&quot;&quot;&quot;</span>
            <span class="n">orig_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_formal_sig</span> <span class="c1"># Set during parsing.</span>
            <span class="n">construct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct</span> <span class="c1"># Set during parsing, winning construct.</span>
            <span class="k">return</span> <span class="n">construct</span><span class="o">.</span><span class="n">get_eval_fun</span><span class="p">(</span><span class="n">orig_sig</span><span class="p">,</span> <span class="n">token_value_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">ast_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return the ast data saved with the winning construct dispatched</span>
<span class="sd">            for the token.  Must be called after parsing because the</span>
<span class="sd">            `original_formal_sig` attribute and others must be set on the token</span>
<span class="sd">            instance.&quot;&quot;&quot;</span>
            <span class="n">orig_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_formal_sig</span> <span class="c1"># Set during parsing.</span>
            <span class="n">construct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct</span> <span class="c1"># Set during parsing, winning construct.</span>
            <span class="k">return</span> <span class="n">construct</span><span class="o">.</span><span class="n">get_ast_data</span><span class="p">(</span><span class="n">orig_sig</span><span class="p">,</span> <span class="n">token_value_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">eval_subtree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Run the saved evaluation function on the token, if one was</span>
<span class="sd">            registered with it.  Returns `None` if no evaluation function is found.&quot;&quot;&quot;</span>
            <span class="n">orig_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_formal_sig</span> <span class="c1"># Set during parsing.</span>
            <span class="n">eval_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_fun</span> <span class="c1"># Property method above.</span>

            <span class="c1"># TODO: Consider if returning None is better than raising exception...</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">eval_fun</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># TODO: Consider if special exception should be raised.</span>
            <span class="c1">#if not eval_fun:</span>
            <span class="c1">#    raise ParserException(&quot;An evaluation function is needed for token with &quot;</span>
            <span class="c1">#            &quot;value &#39;{0}&#39; and label &#39;{1}&#39; but no defined and matching &quot;</span>
            <span class="c1">#            &quot;evaluation function was found in the dict of eval functions.  &quot;</span>
            <span class="c1">#            &quot;The resolved original signature is {2} and the resolve expanded&quot;</span>
            <span class="c1">#            &quot; signature is {3}.  The resolved construct_label is {4}.  The &quot;</span>
            <span class="c1">#            &quot;token&#39;s eval_fun_dict is:\n   {5}.&quot;</span>
            <span class="c1">#            .format(self.value, self.token_label, orig_sig, sig,</span>
            <span class="c1">#                    self.construct_label, self.eval_fun_dict))</span>

            <span class="k">return</span> <span class="n">eval_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># The main recursive_parse function.</span>
        <span class="c1">#</span>

        <span class="k">def</span> <span class="nf">get_jop_token_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns an instance of the jop token iff one should be inferred in the</span>
<span class="sd">            current context; otherwise returns `None`.&quot;&quot;&quot;</span>
            <span class="c1"># TODO: extra_data arg now holds subexp_prec as field.</span>
            <span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span>
            <span class="n">dispatch_handler</span> <span class="o">=</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">construct_table</span><span class="o">.</span><span class="n">dispatch_handler</span>

            <span class="c1"># Not if jop token is undefined for the parser.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Not if at end of expression.</span>
            <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">is_end_token</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Not if the ignored token for jop is set but not present.</span>
            <span class="k">if</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_ignored_token_label</span> <span class="ow">and</span> <span class="p">(</span>
                          <span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_ignored_token_label</span>
                          <span class="ow">not</span> <span class="ow">in</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">ignored_before_labels</span><span class="p">()):</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># Now infer a jop, but only if 1) its prec would satisfy the while loop</span>
            <span class="c1"># in `recursive_parse` as an ordinary token, 2) the next token has</span>
            <span class="c1"># a head handler defined in the conditions when the jop will need</span>
            <span class="c1"># to run its head handler, and 3) the next token similarly has no</span>
            <span class="c1"># tail handler in the context.</span>
            <span class="k">if</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>
                <span class="c1"># Provisionally infer a jop; create a subclass instance for its token.</span>
                <span class="c1">#</span>
                <span class="c1"># Todo: Maybe for jop and null-string tokens define methods</span>
                <span class="c1"># get_jop_token_instance() which gets the token but calls the</span>
                <span class="c1"># lexer to dress it up more like a &quot;real&quot; token, with ignored_before</span>
                <span class="c1"># and line numbers, etc. (without putting it in the buffer, of course).</span>
                <span class="n">jop_instance</span> <span class="o">=</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">jop_instance</span><span class="o">.</span><span class="n">extra_data</span> <span class="o">=</span> <span class="n">extra_data</span>

                <span class="c1"># This is a little inefficient (since it uses a `go_back` call)</span>
                <span class="c1"># but we need to be sure that when the tail handler of the jop</span>
                <span class="c1"># is called and it reads a token that that token has a head</span>
                <span class="c1"># handler defined for it *in that precondition context*.</span>
                <span class="c1"># Otherwise, no jop will be inferred.  We also make sure that</span>
                <span class="c1"># it has no tail handler in the context, since then it would be</span>
                <span class="c1"># a lower-precedence (lower precedence because we broke out of</span>
                <span class="c1"># the loop above) infix or postfix operator, and no jop is</span>
                <span class="c1"># inferred before another operator).</span>
                <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Dispatch here WITHOUT CALLING, since calling will consume</span>
                    <span class="c1"># another token; also, deeper-level recursions could cause false</span>
                    <span class="c1"># results to come up the recursion chain.  We are just testing</span>
                    <span class="c1"># what handlers are defined for the token.</span>
                    <span class="n">_peek_head_handler</span><span class="p">,</span> <span class="n">head_construct</span> <span class="o">=</span> <span class="n">dispatch_handler</span><span class="p">(</span>
                                                   <span class="n">HEAD</span><span class="p">,</span> <span class="n">curr_token</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span> <span class="c1"># Found head handler, now make sure it has no tail handler.</span>
                        <span class="n">_peek_tail_handler</span><span class="p">,</span> <span class="n">tail_construct</span> <span class="o">=</span> <span class="n">dispatch_handler</span><span class="p">(</span>
                                   <span class="n">TAIL</span><span class="p">,</span> <span class="n">curr_token</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">NoHandlerFunctionDefined</span><span class="p">:</span>
                        <span class="c1"># This is the only case where an actual token is returned.</span>
                        <span class="k">return</span> <span class="n">jop_instance</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span>
                <span class="k">except</span> <span class="n">NoHandlerFunctionDefined</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span> <span class="c1"># No precondition matches, assume no jop.</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="c1">#delattr(curr_token, &quot;extra_data&quot;) # Only needed if pushback below, not go_back.</span>
                    <span class="n">lex</span><span class="o">.</span><span class="n">go_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">dispatch_null_string_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head_or_tail</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">,</span>
                                         <span class="n">extra_data</span><span class="p">,</span> <span class="n">processed_left</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Check for any possible matching null-string token handlers;</span>
<span class="sd">            return the token and the matching handler if one is found.</span>

<span class="sd">            Note that the precedence for a null-string token is set to</span>
<span class="sd">            `subexpr_prec`, so it would always have activated the while loop if</span>
<span class="sd">            it were a real token.&quot;&quot;&quot;</span>
            <span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span>
            <span class="n">dispatch_handler</span> <span class="o">=</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">construct_table</span><span class="o">.</span><span class="n">dispatch_handler</span>
            <span class="c1"># See if a null-string token is set and a handler matches preconds.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">null_string_token_label</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: Later don&#39;t re-create each time, save one.</span>
                <span class="n">null_string_token</span> <span class="o">=</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">null_string_token_subclass</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">null_string_token</span><span class="o">.</span><span class="n">extra_data</span> <span class="o">=</span> <span class="n">extra_data</span>

            <span class="n">curr_token</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">handler_fun</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">construct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">handler_fun</span><span class="p">,</span> <span class="n">construct</span> <span class="o">=</span> <span class="n">dispatch_handler</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span>
                                                          <span class="n">null_string_token</span><span class="p">,</span>
                                                          <span class="n">lex</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>
                <span class="n">curr_token</span> <span class="o">=</span> <span class="n">null_string_token</span>
            <span class="k">except</span> <span class="n">NoHandlerFunctionDefined</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">curr_token</span><span class="p">,</span> <span class="n">handler_fun</span><span class="p">,</span> <span class="n">construct</span>

        <span class="k">def</span> <span class="nf">recursive_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">,</span> <span class="n">only_head</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Parse a subexpression as defined by token precedences. Return</span>
<span class="sd">            the result of the evaluation.  Recursively builds up the final</span>
<span class="sd">            result in `processed_left`, which is the tree for the part of the</span>
<span class="sd">            full expression to the left of the current token.</span>

<span class="sd">            The list `lookbehind` saves all the previously evaluated</span>
<span class="sd">            subexpressions at this level of recursion (i.e., at the top level</span>
<span class="sd">            in the same subexpression) and passes it to the dispatched tail</span>
<span class="sd">            handlers, in case that routine wants to make use of it.  For</span>
<span class="sd">            example, the ordinal position of the token in the top level of the</span>
<span class="sd">            subexpression can be calculated from the length of `lookbehind`.</span>

<span class="sd">            This function is made a method of `TokenSubclass` so that handler</span>
<span class="sd">            functions can easily call it by using `tok.recursive_parse`, and</span>
<span class="sd">            also so that it can access the lexer without it needing to be</span>
<span class="sd">            passed as an argument.  It is basically a static function,</span>
<span class="sd">            though.</span>

<span class="sd">            The `extra_data` attribute is set for all triggering tokens, and is</span>
<span class="sd">            guaranteed to be available for precondition functions and for</span>
<span class="sd">            handler functions.  It is set before any dispatches or recursive calls,</span>
<span class="sd">            and is deleted from the token after the recursive call.  It is an</span>
<span class="sd">            advanced feature which most users will not need.&quot;&quot;&quot;</span>
            <span class="c1"># Note that all the dispatching functions set the `extra_data`</span>
            <span class="c1"># attribute of their token before the dispatching is done, but they</span>
            <span class="c1"># do not update `extra_data` itself in any way.</span>

            <span class="c1"># Note on below code: It is tempting for efficiency to define a jop</span>
            <span class="c1"># and null-string token instance, save it, and only use it when</span>
            <span class="c1"># necessary (replacing it only when used).  But some things need to</span>
            <span class="c1"># be considered.</span>
            <span class="c1">#</span>
            <span class="c1"># Now that handlers are not with tokens, that is no longer a</span>
            <span class="c1"># concern... TODO go ahead and do this.</span>
            <span class="c1">#</span>
            <span class="c1"># Is there any special attribute or other thing that is assigned on</span>
            <span class="c1"># creation which might change?  Either way, you should probably add</span>
            <span class="c1"># extra things like line numbers to mimic ordinary tokens. Note</span>
            <span class="c1"># that currently you only really pay the creation cost if you</span>
            <span class="c1"># actually use the jop or null-string feature, but a lot of dummy</span>
            <span class="c1"># instances are created if you do.</span>

            <span class="c1"># This err check catches some cases of tokens defined via Lexer, not all.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;token_kind&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;All tokens used in the parser must be&quot;</span>
                        <span class="s2">&quot; defined in via parser&#39;s methods, not the lexer&#39;s.&quot;</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Initialize, and set some shorter aliases.</span>
            <span class="c1">#</span>

            <span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span>
            <span class="n">dispatch_handler</span> <span class="o">=</span> <span class="n">parser_instance</span><span class="o">.</span><span class="n">construct_table</span><span class="o">.</span><span class="n">dispatch_handler</span>
            <span class="n">lex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span><span class="o">.</span><span class="n">lex</span>
            <span class="n">extra_data</span> <span class="o">=</span> <span class="n">ExtraDataTuple</span><span class="p">(</span><span class="n">lookbehind</span><span class="o">=</span><span class="p">[],</span> <span class="n">constructs</span><span class="o">=</span><span class="p">[],</span>
                                        <span class="n">subexp_prec</span><span class="o">=</span><span class="n">subexp_prec</span><span class="p">)</span>

            <span class="c1">#</span>
            <span class="c1"># Start the actual Pratt parsing recursion.</span>
            <span class="c1">#</span>

            <span class="n">curr_token</span><span class="p">,</span> <span class="n">head_handler</span><span class="p">,</span> <span class="n">construct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch_null_string_handler</span><span class="p">(</span>
                                                     <span class="n">HEAD</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_token</span><span class="p">:</span> <span class="c1"># No null-string token fired, so use normal next() call.</span>
                <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">head_handler</span><span class="p">,</span> <span class="n">construct</span> <span class="o">=</span> <span class="n">dispatch_handler</span><span class="p">(</span>
                                                     <span class="n">HEAD</span><span class="p">,</span> <span class="n">curr_token</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">)</span>

            <span class="n">extra_data</span><span class="o">.</span><span class="n">constructs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">construct</span><span class="p">)</span>

            <span class="c1"># TODO: Should the root of processed_left be set for is_head instead, for</span>
            <span class="c1"># general case?  Or set &quot;head_trigger_token&quot; to label instead of None?</span>
            <span class="c1"># Consider how lookup will work in usual and general cases of arbitrary</span>
            <span class="c1"># token as subtree root.</span>
            <span class="n">curr_token</span><span class="o">.</span><span class="n">is_head</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Used to look up eval_fun and ast_data later.</span>

            <span class="n">processed_left</span> <span class="o">=</span> <span class="n">head_handler</span><span class="p">()</span>

            <span class="nb">delattr</span><span class="p">(</span><span class="n">curr_token</span><span class="p">,</span> <span class="s2">&quot;extra_data&quot;</span><span class="p">)</span> <span class="c1"># Delete after recurse, allow mem cleanup.</span>
            <span class="n">extra_data</span><span class="o">.</span><span class="n">lookbehind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed_left</span><span class="p">)</span>
            <span class="n">extra_data</span><span class="o">.</span><span class="n">constructs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">construct</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">only_head</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">processed_left</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

                <span class="c1">#</span>
                <span class="c1"># The loop below is the main loop in ordinary Pratt parsing.  The</span>
                <span class="c1"># Outer loop is ONLY for the special case when a jop is defined.</span>
                <span class="c1">#</span>

                <span class="c1"># TODO: Consider modification like code below to allow</span>
                <span class="c1"># precedences per constuct, which also makes &quot;prec - 1&quot; no</span>
                <span class="c1"># longer necessary for right assoc when property is set for the</span>
                <span class="c1"># construct itself.  See what performance hit it has, one</span>
                <span class="c1"># go_back per subexpression.  Note that jops use a single</span>
                <span class="c1"># go_back already when they are defined...</span>
                <span class="c1">#</span>
                <span class="c1"># The ugly comment-string code below works.  It just pulls the</span>
                <span class="c1"># token-dispatching out to before the precedence test.</span>
                <span class="c1"># Obviously could then use some cleanup and refactoring, too.</span>
                <span class="c1"># Consider possible interactions with jop and null-string</span>
                <span class="c1"># tokens, but they don&#39;t do a `next` call anyway.  (Is it</span>
                <span class="c1"># better to pull out the ns_token dispatch, at least?  In</span>
                <span class="c1"># regular code, how to get null-string to appear at end of a</span>
                <span class="c1"># subexpression?)</span>
                <span class="c1">#</span>
                <span class="c1"># Argument it works: This code is doing exactly the same</span>
                <span class="c1"># dispatching as it would inside the loop test, but it is doing</span>
                <span class="c1"># it before the loop test.  The loop test never modifies</span>
                <span class="c1"># anything.  If the test fails the effects of the dispatches</span>
                <span class="c1"># are undone.</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                while True:</span>
<span class="sd">                    #err = None</span>
<span class="sd">                    ns_token, tail_handler, construct = self.dispatch_null_string_handler(</span>
<span class="sd">                                    TAIL, lex, subexp_prec, extra_data, processed_left)</span>
<span class="sd">                    if ns_token:</span>
<span class="sd">                        curr_token = ns_token</span>
<span class="sd">                        peek_prec = lex.token.prec()</span>
<span class="sd">                        #peek_prec = construct.prec() # Switch to this...</span>
<span class="sd">                    else:</span>
<span class="sd">                        curr_token = lex.next()</span>
<span class="sd">                        try:</span>
<span class="sd">                            tail_handler, construct = dispatch_handler(TAIL, curr_token,</span>
<span class="sd">                                                            lex, extra_data, processed_left)</span>
<span class="sd">                            peek_prec = lex.token.prec()</span>
<span class="sd">                            #peek_prec = construct.prec() # Switch to this...</span>
<span class="sd">                        except NoHandlerFunctionDefined as e:</span>
<span class="sd">                            # If no construct at all then can&#39;t have tail handler so</span>
<span class="sd">                            # prec should be 0.  But if it fails due to a precond,</span>
<span class="sd">                            # token itself could still have a prec &gt; 0.  In that case</span>
<span class="sd">                            # it will get inside the loop and fail, but it really</span>
<span class="sd">                            # shouldn&#39;t have gotten inside.</span>
<span class="sd">                            #</span>
<span class="sd">                            # Only one test changes, and new one is commented out in</span>
<span class="sd">                            # the test file under the old one.</span>
<span class="sd">                            #err = e</span>
<span class="sd">                            peek_prec = -1 # Always fail test and break.</span>
<span class="sd">                            #peek_prec = lex.token.prec()</span>

<span class="sd">                    #test_assoc = False if err else (peek_prec == subexp_prec and</span>
<span class="sd">                    #                                construct.assoc == &quot;right&quot;)</span>
<span class="sd">                    test_assoc = peek_prec == subexp_prec and construct.assoc == &quot;right&quot;</span>
<span class="sd">                    if peek_prec &gt; subexp_prec or test_assoc:</span>
<span class="sd">                        #if err: # Error would have been found inside loop, now above.</span>
<span class="sd">                        #    raise err # Avoid error msg changing (makes test fail).</span>
<span class="sd">                        processed_left = tail_handler()</span>
<span class="sd">                        delattr(curr_token, &quot;extra_data&quot;)</span>
<span class="sd">                        extra_data.lookbehind.append(processed_left)</span>
<span class="sd">                        extra_data.constructs.append(construct)</span>
<span class="sd">                    else:</span>
<span class="sd">                        if not ns_token:</span>
<span class="sd">                            lex.go_back(1)</span>
<span class="sd">                        break</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>

                    <span class="n">curr_token</span><span class="p">,</span> <span class="n">tail_handler</span><span class="p">,</span> <span class="n">construct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch_null_string_handler</span><span class="p">(</span>
                                    <span class="n">TAIL</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_token</span><span class="p">:</span> <span class="c1"># No null handler fired off, get regular way.</span>
                        <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                        <span class="n">tail_handler</span><span class="p">,</span> <span class="n">construct</span> <span class="o">=</span> <span class="n">dispatch_handler</span><span class="p">(</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">curr_token</span><span class="p">,</span>
                                                        <span class="n">lex</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>

                    <span class="n">processed_left</span> <span class="o">=</span> <span class="n">tail_handler</span><span class="p">()</span>
                    <span class="nb">delattr</span><span class="p">(</span><span class="n">curr_token</span><span class="p">,</span> <span class="s2">&quot;extra_data&quot;</span><span class="p">)</span>
                    <span class="n">extra_data</span><span class="o">.</span><span class="n">lookbehind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed_left</span><span class="p">)</span>
                    <span class="n">extra_data</span><span class="o">.</span><span class="n">constructs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">construct</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Broke out of main loop, determine whether or not to infer a jop.</span>
                <span class="c1">#</span>

                <span class="n">jop_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_jop_token_instance</span><span class="p">(</span>
                                         <span class="n">lex</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">jop_instance</span><span class="p">:</span>
                    <span class="n">jop_tail_handler</span><span class="p">,</span> <span class="n">construct</span> <span class="o">=</span> <span class="n">dispatch_handler</span><span class="p">(</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">jop_instance</span><span class="p">,</span>
                                                        <span class="n">lex</span><span class="p">,</span> <span class="n">extra_data</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">)</span>
                    <span class="n">processed_left</span> <span class="o">=</span> <span class="n">jop_tail_handler</span><span class="p">()</span>
                    <span class="nb">delattr</span><span class="p">(</span><span class="n">jop_instance</span><span class="p">,</span> <span class="s2">&quot;extra_data&quot;</span><span class="p">)</span>
                    <span class="n">extra_data</span><span class="o">.</span><span class="n">lookbehind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed_left</span><span class="p">)</span>
                    <span class="n">extra_data</span><span class="o">.</span><span class="n">constructs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">construct</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="k">return</span> <span class="n">processed_left</span>

        <span class="c1">#</span>
        <span class="c1"># Copying instances of tokens.</span>
        <span class="c1">#</span>

        <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return a shallow copy of the token.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Some representations that apply to the subclasses.</span>
        <span class="c1">#</span>

        <span class="k">def</span> <span class="nf">summary_repr_with_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;A short summary repr of the node, without its children.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s2">&quot;,&#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span>
                    <span class="s2">&quot;&#39;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expanded_formal_sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">tree_repr_with_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Token representation as the root of a parse subtree, with formatting.</span>
<span class="sd">            The optional `indent` parameter can be either an indent string or else</span>
<span class="sd">            an integer for the number of spaces to indent.  Note that the ordinary</span>
<span class="sd">            `tree_repr` method without types is also available, inherited from</span>
<span class="sd">            the base node object.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num_indent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indent</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">num_indent</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_repr_with_types</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">tree_repr_with_types</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">string</span>

        <span class="k">def</span> <span class="nf">string_repr_with_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;A string repr for the tree that includes type information.&quot;&quot;&quot;</span>
            <span class="n">string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_repr_with_types</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;(&quot;</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">string_repr_with_types</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
            <span class="k">return</span> <span class="n">string</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">class_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Print out the `TokenSubclass` classes (representing tokens) in a</span>
<span class="sd">            nice way.  The default is hard to read.&quot;&quot;&quot;</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Token(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">token_label</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">string</span>

    <span class="k">return</span> <span class="n">TokenSubclass</span> <span class="c1"># Return from token_subclass_factory function.</span></div>

<span class="c1">#</span>
<span class="c1"># Parser</span>
<span class="c1">#</span>

<div class="viewcode-block" id="lexer_add_parser_instance_attribute"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.lexer_add_parser_instance_attribute">[docs]</a><span class="k">def</span> <span class="nf">lexer_add_parser_instance_attribute</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Passed to lexer to add a `parser_instance` attribute to each token it</span>
<span class="sd">    returns.  This attribute is added to instances at the lexer, from its</span>
<span class="sd">    current token table, because of the case where parsers call other parsers.</span>
<span class="sd">    (It is not added to general token subclasses in `def_token_master` because</span>
<span class="sd">    parsers could potentially share token subclasses.)&quot;&quot;&quot;</span>
    <span class="n">token</span><span class="o">.</span><span class="n">parser_instance</span> <span class="o">=</span> <span class="n">lexer</span><span class="o">.</span><span class="n">token_table</span><span class="o">.</span><span class="n">parser_instance</span> <span class="c1"># From token table.</span>
    <span class="k">return</span> <span class="n">token</span></div>

<span class="c1"># Could also add parser_instance and construct as fields of the extra data tuple.</span>
<span class="c1"># Could extra_data also be passed to handler functions?  Nice to have construct</span>
<span class="c1"># instance available there, perhaps.  TODO: Consider.</span>
<span class="n">ExtraDataTuple</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;ExtraHandlerData&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;lookbehind&quot;</span><span class="p">,</span>
                                                 <span class="s2">&quot;constructs&quot;</span><span class="p">,</span>
                                                 <span class="s2">&quot;subexp_prec&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="PrattParser"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser">[docs]</a><span class="k">class</span> <span class="nc">PrattParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A parser object.  Each parser object contains a table of defined tokens,</span>
<span class="sd">    a lexer, a table of constructs, and a table of defined types.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_peek_tokens</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">max_deque_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">lexer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">default_begin_end_tokens</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">type_table</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">skip_type_checking</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">overload_on_arg_types</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">overload_on_ret_types</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">partial_expressions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">parser_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">raise_on_equal_priority_preconds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the parser.</span>

<span class="sd">        The `max_peek_tokens` parameter is an optional arbitrary limit on the</span>
<span class="sd">        level of peeks allowed in the lexer.  Setting to 1 limits it to a</span>
<span class="sd">        single token lookahead.  The default setting `None` gives</span>
<span class="sd">        peek-on-demand as far ahead as requested.</span>

<span class="sd">        The `max_deque_size` parameter is an optional limit on the size of the</span>
<span class="sd">        deque that the lexer keeps for previous tokens, the current token, and</span>
<span class="sd">        requested peek tokens.  The default is for it to grow arbitrarily</span>
<span class="sd">        (though it is reset on each parse).  Needs to be large enough for the</span>
<span class="sd">        max level of peeks required plus the max `go_back` level required.</span>

<span class="sd">        If a `Lexer` instance is passed in the parser will use that lexer and</span>
<span class="sd">        its token table, otherwise a new lexer is created.  The any other lexer</span>
<span class="sd">        options are ignored.</span>

<span class="sd">        No default begin and end functions will be set if a lexer is passed in,</span>
<span class="sd">        regardless of the value of `default_begin_end_tokens`.  Otherwise,</span>
<span class="sd">        default begin and end tokens will be defined unless</span>
<span class="sd">        `default_begin_end_tokens` is set false (note that creating them by</span>
<span class="sd">        default is the opposite of the default behavior for the lower-level</span>
<span class="sd">        Lexer class).</span>

<span class="sd">        Setting `skip_type_checking=True` is slightly faster since typing is</span>
<span class="sd">        not being used at all.  Note that overloading depends on type-checking</span>
<span class="sd">        to resolve the actual types, so this flag implies that the overload</span>
<span class="sd">        flags are all false.  The default is false.  It should be possible to</span>
<span class="sd">        define types, use them during testing, and then turn checking off ---</span>
<span class="sd">        provided overloading is not used to get different evaluation functions</span>
<span class="sd">        or AST data elements for different overloads.</span>

<span class="sd">        The `overload_on_arg_types` flag specifies whether or not to overload</span>
<span class="sd">        on argument types.  The default is true.  Cannot be changed after</span>
<span class="sd">        initialization.</span>

<span class="sd">        Setting `overload_on_ret_types` also overloads on argument types.  It</span>
<span class="sd">        requires an extra walk of the token tree, and implies overloading on</span>
<span class="sd">        argument types.  The default is false.  Cannot be changed after</span>
<span class="sd">        initialization.</span>

<span class="sd">        If `partial_expressions` is set true then no check will be made in the</span>
<span class="sd">        `parse` method to see if the parsing consumed up to the end-token in</span>
<span class="sd">        the lexer.  Multiple expression text can be parsed by repeatedly</span>
<span class="sd">        calling `parse` when this option is true and checking whether the</span>
<span class="sd">        lexer&#39;s current token is the end-token.</span>

<span class="sd">        The `parser_label` is an optional descriptive string for a parser.</span>
<span class="sd">        These can be useful in debugging when they appear in error messages,</span>
<span class="sd">        especially when working with multiple parser instances.</span>

<span class="sd">        If `raise_on_equal_priority_preconds` is true then an exception will be</span>
<span class="sd">        raised if two precondition functions are registered with the same</span>
<span class="sd">        trigger token in the same head or tail position which have the same</span>
<span class="sd">        precondition priority.  The default is false, and the first-defined</span>
<span class="sd">        matching precondition function of the same priority will win any</span>
<span class="sd">        competition when several are true.  This option can be used to ensure</span>
<span class="sd">        at language define-time that there is no definition-order dependence in</span>
<span class="sd">        dispatching.  If two such preconditions functions are mutually</span>
<span class="sd">        exclusive there is no problem with them having the same priority, but</span>
<span class="sd">        this condition cannot be checked by a program.  A small difference can</span>
<span class="sd">        be added.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parser_label</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parser_label</span> <span class="o">=</span> <span class="n">parser_label</span> <span class="c1"># Set first, for error messages.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parser_label</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1">## Type-checking options below; these cannot be changed after initialization.</span>
        <span class="k">if</span> <span class="n">overload_on_ret_types</span><span class="p">:</span>
            <span class="n">overload_on_arg_types</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Overload on ret implies overload on args.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_type_checking</span> <span class="o">=</span> <span class="n">skip_type_checking</span> <span class="c1"># Skip all type checks, faster.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_type_checking</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_arg_types</span> <span class="o">=</span> <span class="n">overload_on_arg_types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_ret_types</span> <span class="o">=</span> <span class="n">overload_on_ret_types</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Overloading requires type checking.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_arg_types</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_ret_types</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># If exceptions are not raised on ties then with non-mutually-exclusive</span>
        <span class="c1"># precond functions the first-set one will have precedence when they</span>
        <span class="c1"># are both true.  Need to define this before registering any handlers (</span>
        <span class="c1"># which is done below in `def_begin_end_tokens`).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_on_equal_priority_preconds</span> <span class="o">=</span> <span class="n">raise_on_equal_priority_preconds</span>
        <span class="c1">#self.raise_on_equal_priority_preconds = True # DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">construct_table</span> <span class="o">=</span> <span class="n">ConstructTable</span><span class="p">(</span><span class="n">parser_instance</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># Dict of constructs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_construct_label_number</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># For unique precondition labels.</span>

        <span class="k">if</span> <span class="n">lexer</span><span class="p">:</span> <span class="c1"># Lexer passed in.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span> <span class="o">=</span> <span class="n">lexer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span> <span class="o">=</span> <span class="n">lexer</span><span class="o">.</span><span class="n">token_table</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># No Lexer passed in.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span> <span class="o">=</span> <span class="n">TokenTable</span><span class="p">(</span>
                                <span class="n">token_subclass_factory_fun</span><span class="o">=</span><span class="n">token_subclass_factory</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span> <span class="o">=</span> <span class="n">Lexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_table</span><span class="p">,</span>
                             <span class="n">max_peek_tokens</span><span class="o">=</span><span class="n">max_peek_tokens</span><span class="p">,</span>
                             <span class="n">max_deque_size</span><span class="o">=</span><span class="n">max_deque_size</span><span class="p">,</span>
                             <span class="n">default_begin_end_tokens</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Set the begin and end tokens unless the user specified not to.</span>
            <span class="k">if</span> <span class="n">default_begin_end_tokens</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">def_begin_end_tokens</span><span class="p">()</span> <span class="c1"># Use function&#39;s defaults.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">default_helper_exception</span> <span class="o">=</span> <span class="n">ParserException</span> <span class="c1"># Default for match_next, etc.</span>
        <span class="c1"># Add mod function to lexer here, works even if they passed in a lexer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">final_mod_function</span> <span class="o">=</span> <span class="n">lexer_add_parser_instance_attribute</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span><span class="o">.</span><span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span> <span class="c1"># Give token table ref to parser.</span>

        <span class="k">if</span> <span class="n">type_table</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span> <span class="o">=</span> <span class="n">type_table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span> <span class="o">=</span> <span class="n">TypeTable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_lookahead_tokens</span> <span class="o">=</span> <span class="n">max_peek_tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_label</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Label of the jop token, if any.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># The actual jop token, if defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_label</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Label of the null-string token, if any.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_subclass</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># The actual null-string token, if any.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">partial_expressions</span> <span class="o">=</span> <span class="n">partial_expressions</span> <span class="c1"># Whether to parse multiple expressions.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pstate_stack</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Stack of production rules used in grammar parsing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top_level_production</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># If true, require grammar parses to consume to end.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disable_pstate_processing</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Set to temporarily disable grammar parsing.</span>

    <span class="c1">#</span>
    <span class="c1"># Methods defining tokens.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="PrattParser.def_token_master"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_token_master">[docs]</a>    <span class="k">def</span> <span class="nf">def_token_master</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">token_kind</span><span class="o">=</span><span class="s2">&quot;regular&quot;</span><span class="p">,</span> <span class="n">ignored_token_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">matcher_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The master method for defining tokens; all the convenience methods</span>
<span class="sd">        actually call it.  Allows for factoring out some common code and</span>
<span class="sd">        keeping the attributes of all the different kinds of tokens up-to-date.</span>
<span class="sd">        This routine calls the underlying lexer&#39;s `def_token` to get tokens and</span>
<span class="sd">        then adds extra attributes needed by the `PrattParser` class.</span>

<span class="sd">        The `token_kind` argument must be one of the following strings:</span>
<span class="sd">        `&quot;regular&quot;`, `&quot;ignored&quot;`, `&quot;begin&quot;`, `&quot;end&quot;`, `&quot;jop&quot;`, or</span>
<span class="sd">        `&quot;null-string&quot;`.  The `ignored_token_label` is used only when defining</span>
<span class="sd">        a jop.</span>

<span class="sd">        Tokens can be shared between parsers if all their properties are the</span>
<span class="sd">        same.  Note that for now this includes the precedence value for any</span>
<span class="sd">        tail handlers (since that is made a token attribute).  Null-string and</span>
<span class="sd">        jop tokens are the exception, but they are special in that they are</span>
<span class="sd">        never returned by the lexer, only by a particular parser.&quot;&quot;&quot;</span>
        <span class="n">token_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span>

        <span class="k">if</span> <span class="n">token_kind</span> <span class="o">==</span> <span class="s2">&quot;regular&quot;</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">token_table</span><span class="o">.</span><span class="n">def_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span>
                       <span class="n">on_ties</span><span class="o">=</span><span class="n">on_ties</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span> <span class="n">matcher_options</span><span class="o">=</span><span class="n">matcher_options</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">token_kind</span> <span class="o">==</span> <span class="s2">&quot;ignored&quot;</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">token_table</span><span class="o">.</span><span class="n">def_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span>
                       <span class="n">on_ties</span><span class="o">=</span><span class="n">on_ties</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">matcher_options</span><span class="o">=</span><span class="n">matcher_options</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">token_kind</span> <span class="o">==</span> <span class="s2">&quot;begin&quot;</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">token_table</span><span class="o">.</span><span class="n">def_begin_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">begin_token_label</span> <span class="o">=</span> <span class="n">token_label</span>
            <span class="c1"># Define dummy handlers for the begin-token, just to catch errors.</span>
            <span class="k">def</span> <span class="nf">begin_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Dummy head handler for begin-tokens.&quot;&quot;&quot;</span>
                <span class="k">raise</span> <span class="n">CalledBeginTokenHandler</span><span class="p">(</span><span class="s2">&quot;Called head-handler for begin token.&quot;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">begin_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Dummy tail-handler for begin-tokens.&quot;&quot;&quot;</span>
                <span class="k">raise</span> <span class="n">CalledBeginTokenHandler</span><span class="p">(</span><span class="s2">&quot;Called tail-handler for begin token.&quot;</span><span class="p">)</span>
            <span class="n">tok</span><span class="o">.</span><span class="n">token_kind</span> <span class="o">=</span> <span class="n">token_kind</span> <span class="c1"># Needed before calls to def_construct.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">begin_head</span><span class="p">,</span> <span class="n">token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">begin_tail</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">dummy_handler</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">begin_token_subclass</span> <span class="o">=</span> <span class="n">tok</span>

        <span class="k">elif</span> <span class="n">token_kind</span> <span class="o">==</span> <span class="s2">&quot;end&quot;</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">token_table</span><span class="o">.</span><span class="n">def_end_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_token_label</span> <span class="o">=</span> <span class="n">token_label</span>
            <span class="c1"># Define dummy handlers for the end-token, just to catch errors.</span>
            <span class="k">def</span> <span class="nf">end_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Dummy head handler for end-tokens.&quot;&quot;&quot;</span>
                <span class="k">raise</span> <span class="n">CalledEndTokenHandler</span><span class="p">(</span><span class="s2">&quot;Called head-handler for end token.&quot;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">end_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Dummy tail-handler for end-tokens.&quot;&quot;&quot;</span>
                <span class="k">raise</span> <span class="n">CalledEndTokenHandler</span><span class="p">(</span><span class="s2">&quot;Called tail-handler for end token.&quot;</span><span class="p">)</span>
            <span class="n">tok</span><span class="o">.</span><span class="n">token_kind</span> <span class="o">=</span> <span class="n">token_kind</span> <span class="c1"># Needed before calls to def_construct.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">end_head</span><span class="p">,</span> <span class="n">token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">def_construct</span><span class="p">(</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">end_tail</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">dummy_handler</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end_token_subclass</span> <span class="o">=</span> <span class="n">tok</span>

        <span class="k">elif</span> <span class="n">token_kind</span> <span class="o">==</span> <span class="s2">&quot;jop&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;A jop token is already defined.  It must be &quot;</span>
                                      <span class="s2">&quot;undefined before defining a new one.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_label</span> <span class="o">=</span> <span class="n">token_label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jop_ignored_token_label</span> <span class="o">=</span> <span class="n">ignored_token_label</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">token_table</span><span class="o">.</span><span class="n">def_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span> <span class="o">=</span> <span class="n">tok</span>
            <span class="n">tok</span><span class="o">.</span><span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span> <span class="c1"># Special token, never returned by lexer.</span>

        <span class="k">elif</span> <span class="n">token_kind</span> <span class="o">==</span> <span class="s2">&quot;null-string&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_subclass</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;A null-string token is already defined.  It&quot;</span>
                         <span class="s2">&quot; must be undefined before defining an new one.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_label</span> <span class="o">=</span> <span class="n">token_label</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">token_table</span><span class="o">.</span><span class="n">def_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_subclass</span> <span class="o">=</span> <span class="n">tok</span>
            <span class="n">tok</span><span class="o">.</span><span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span> <span class="c1"># Special token, never returned by lexer.</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;Bad call to def_token_master, with unrecognized&quot;</span>
                    <span class="s1">&#39; string &quot;</span><span class="si">{0}</span><span class="s1">&quot; for the keyword argument token_kind.&#39;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">token_kind</span><span class="p">))</span>

        <span class="n">tok</span><span class="o">.</span><span class="n">token_kind</span> <span class="o">=</span> <span class="n">token_kind</span>
        <span class="n">tok</span><span class="o">.</span><span class="n">is_head</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Set true in recursive_parse if instance parses as a head.</span>
        <span class="k">return</span> <span class="n">tok</span></div>

<div class="viewcode-block" id="PrattParser.def_token"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_token">[docs]</a>    <span class="k">def</span> <span class="nf">def_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">matcher_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a token.  Use this instead of the Lexer `def_token` method,</span>
<span class="sd">        since it adds extra attributes to the tokens.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_token_master</span><span class="p">(</span><span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span> <span class="n">on_ties</span><span class="p">,</span> <span class="n">ignore</span><span class="p">,</span>
                              <span class="n">token_kind</span><span class="o">=</span><span class="s2">&quot;regular&quot;</span><span class="p">,</span> <span class="n">matcher_options</span><span class="o">=</span><span class="n">matcher_options</span><span class="p">)</span></div>

<div class="viewcode-block" id="PrattParser.def_ignored_token"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_ignored_token">[docs]</a>    <span class="k">def</span> <span class="nf">def_ignored_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">matcher_options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A convenience function to define a token with `ignored=True`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_token_master</span><span class="p">(</span><span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span> <span class="n">on_ties</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">token_kind</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">,</span> <span class="n">matcher_options</span><span class="o">=</span><span class="n">matcher_options</span><span class="p">)</span></div>

<div class="viewcode-block" id="PrattParser.def_begin_end_tokens"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_begin_end_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">def_begin_end_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin_token_label</span><span class="o">=</span><span class="s2">&quot;k_begin&quot;</span><span class="p">,</span>
                                   <span class="n">end_token_label</span><span class="o">=</span><span class="s2">&quot;k_end&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls the `Lexer` method to define begin- and end-tokens.  The</span>
<span class="sd">        subclasses are then given initial head and tail functions for use in</span>
<span class="sd">        the Pratt parser.  To use the `PrattParser` this method must be called,</span>
<span class="sd">        not the method of `Lexer` with the same name (since it also creates</span>
<span class="sd">        head and tail handler functions that raise exceptions for better error</span>
<span class="sd">        messages).  The default is to call this method automatically on</span>
<span class="sd">        initialization, with the default token labels for the begin and end</span>
<span class="sd">        tokens.  If the flag `default_begin_end_tokens` is set false on</span>
<span class="sd">        `PrattParser` initalization then the user must call this function</span>
<span class="sd">        (setting whatever token labels are desired).  Returns a tuple</span>
<span class="sd">        containing the new begin and end `TokenNode` subclasses.&quot;&quot;&quot;</span>
        <span class="n">begin_tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_token_master</span><span class="p">(</span><span class="n">begin_token_label</span><span class="p">,</span> <span class="n">token_kind</span><span class="o">=</span><span class="s2">&quot;begin&quot;</span><span class="p">)</span>
        <span class="n">end_tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_token_master</span><span class="p">(</span><span class="n">end_token_label</span><span class="p">,</span> <span class="n">token_kind</span><span class="o">=</span><span class="s2">&quot;end&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">begin_tok</span><span class="p">,</span> <span class="n">end_tok</span></div>

<div class="viewcode-block" id="PrattParser.def_jop_token"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_jop_token">[docs]</a>    <span class="k">def</span> <span class="nf">def_jop_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jop_token_label</span><span class="p">,</span> <span class="n">ignored_token_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a token for the juxtaposition operator.  This token has no</span>
<span class="sd">        regex pattern.  An instance is inserted in `recursive_parse` when it is</span>
<span class="sd">        inferred to be present.  This method must be explicitly called before a</span>
<span class="sd">        juxtaposition operator can be used (i.e., before `def_jop`).  The</span>
<span class="sd">        parameter `jop_token_label` is the label for the newly-created token</span>
<span class="sd">        representing the juxtaposition operator.  The `ignored_token_label`</span>
<span class="sd">        parameter is the label of an ignored token which must be present for a</span>
<span class="sd">        jop to be inferred.  Some already-defined token is required; usually it</span>
<span class="sd">        will be a token for spaces and tabs.  If set to `None` then no ignored</span>
<span class="sd">        space at all is required (i.e., the operands can be right next to each</span>
<span class="sd">        other).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_token_master</span><span class="p">(</span><span class="n">jop_token_label</span><span class="p">,</span>
                                     <span class="n">ignored_token_label</span><span class="o">=</span><span class="n">ignored_token_label</span><span class="p">,</span>
                                     <span class="n">token_kind</span><span class="o">=</span><span class="s2">&quot;jop&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PrattParser.def_null_string_token"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_null_string_token">[docs]</a>    <span class="k">def</span> <span class="nf">def_null_string_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">null_string_token_label</span><span class="o">=</span><span class="s2">&quot;k_null-string&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the null-string token.  This token has no regex pattern.  An</span>
<span class="sd">        instance is inserted in `recursive_parse` when it is inferred to be</span>
<span class="sd">        present based.  This method must be called before a</span>
<span class="sd">        null-string can be used.  The parameter `null_string_token_label` is</span>
<span class="sd">        the label for the newly-created tok representing it.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">def_token_master</span><span class="p">(</span><span class="n">null_string_token_label</span><span class="p">,</span>
                                     <span class="n">token_kind</span><span class="o">=</span><span class="s2">&quot;null-string&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PrattParser.get_token"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.get_token">[docs]</a>    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the token with the label `token_label`.  The reverse</span>
<span class="sd">        operation, getting a label from a token instance, can be done by</span>
<span class="sd">        looking at the `token_label` attribute of the token.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span><span class="p">[</span><span class="n">token_label</span><span class="p">]</span></div>

    <span class="c1">#</span>
    <span class="c1"># Undefine tokens.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="PrattParser.undef_token"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.undef_token">[docs]</a>    <span class="k">def</span> <span class="nf">undef_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A method for undefining any token defined by the `PrattParser` methods.</span>
<span class="sd">        Since the `token_kind` was set for all tokens when they were defined</span>
<span class="sd">        it knows how to undelete any kind of token.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Make sure this is up-to-date with the what the token_master class does.</span>
        <span class="n">token_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="n">token_table</span><span class="p">[</span><span class="n">token_label</span><span class="p">]</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">token_kind</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;jop&quot;</span><span class="p">:</span>
            <span class="n">token_table</span><span class="o">.</span><span class="n">undef_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jop_token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_label</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jop_ignored_token_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;null-string&quot;</span><span class="p">:</span>
            <span class="n">token_table</span><span class="o">.</span><span class="n">undef_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_subclass</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">null_string_token_label</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">null_string_ignored_token_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">token_table</span><span class="o">.</span><span class="n">undef_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Methods to define and undefine constructs.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="PrattParser.def_construct"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_construct">[docs]</a>    <span class="k">def</span> <span class="nf">def_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head_or_tail</span><span class="p">,</span> <span class="n">handler_fun</span><span class="p">,</span> <span class="n">trigger_token_label</span><span class="p">,</span>
                      <span class="n">prec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">construct_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precond_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">precond_priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">eval_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ast_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">token_value_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">dummy_handler</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a construct and register it with the token with label</span>
<span class="sd">        `trigger_token_label`.  A token with that label must already be in the</span>
<span class="sd">        token table or an exception will be raised.</span>

<span class="sd">        Stores the construct instance in the parser&#39;s construct table and also</span>
<span class="sd">        return the construct instance.</span>

<span class="sd">        The `head_or_tail` argument should be set to either `HEAD` or `TAIL`.</span>
<span class="sd">        If `head_or_tail==TAIL` then the operator precedence will be set to</span>
<span class="sd">        `prec`.  For a head handler the `prec` value is ignored and effectively</span>
<span class="sd">        set to zero.  For a tail handler a `prec` value greater than zero is</span>
<span class="sd">        required or else an exception will be raised (unless `dummy_handler` is</span>
<span class="sd">        set true).  Similarly, an exception is raised for a non-zero `prec`</span>
<span class="sd">        value for a head-handler (the default value).</span>

<span class="sd">        The `construct_label` is an optional string value which can result in</span>
<span class="sd">        better error messages.</span>

<span class="sd">        The `eval_fun` and the `ast_data` arguments are saved in dicts</span>
<span class="sd">        associated with the type signature.</span>

<span class="sd">        If `token_value_key` is set to a string value then that value will be</span>
<span class="sd">        part of the key tuple for saving AST data and evaluation functions.</span>
<span class="sd">        This can be used, for example, when overloading a generic identifier</span>
<span class="sd">        with different evaluation functions for when the identifier value is</span>
<span class="sd">        `sin`, `cos`, etc.  In looking up the AST data and evaluation function</span>
<span class="sd">        the parsed token&#39;s actual string value (from the program text) is used</span>
<span class="sd">        as the key.  If any overload of a particular construct provides a</span>
<span class="sd">        `token_value_key` string then all the other overloads for that</span>
<span class="sd">        construct must also (for the time being, at least).&quot;&quot;&quot;</span>
        <span class="c1"># Note that the parser_instance attribute of tokens is not necessarily</span>
        <span class="c1"># set yet when this method is called.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_types</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;The arg_types argument to token_subclass must&quot;</span>
                    <span class="s2">&quot; be None or an iterable returning type labels (e.g., a list&quot;</span>
                    <span class="s2">&quot; or tuple).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">head_or_tail</span> <span class="o">==</span> <span class="n">TAIL</span> <span class="ow">and</span> <span class="n">prec</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dummy_handler</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;Attempt to define a construct for trigger token&quot;</span>
                    <span class="s2">&quot; &#39;</span><span class="si">{0}</span><span class="s2">&#39; with a tail hander and a precedence of zero or less.&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trigger_token_label</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">head_or_tail</span> <span class="o">==</span> <span class="n">HEAD</span> <span class="ow">and</span> <span class="n">prec</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dummy_handler</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;Attempt to define a construct for trigger token&quot;</span>
                    <span class="s2">&quot; &#39;</span><span class="si">{0}</span><span class="s2">&#39; with a head hander and a precedence not equal to zero.&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trigger_token_label</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">precond_fun</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precond_fun</span> <span class="o">=</span> <span class="n">DEFAULT_ALWAYS_TRUE_PRECOND_FUN</span>

        <span class="k">if</span> <span class="n">trigger_token_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_table</span><span class="p">:</span>
            <span class="n">trigger_token_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">(</span><span class="n">trigger_token_label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;In call to def_construct: subclass for&quot;</span>
                    <span class="s2">&quot; token labeled &#39;</span><span class="si">{0}</span><span class="s2">&#39; has not been defined.  Maybe try&quot;</span>
                    <span class="s2">&quot; calling def_token first.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trigger_token_label</span><span class="p">))</span>
            <span class="c1"># Below line formerly just created a subclass, but that can mask errors!</span>
            <span class="c1">#TokenSubclass = self.token_table.create_token_subclass(token_label)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trigger_token_subclass</span><span class="p">,</span> <span class="s2">&quot;token_kind&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;Token with label &#39;</span><span class="si">{0}</span><span class="s2">&#39;  must be defined by the&quot;</span>
                                  <span class="s2">&quot; parser&#39;s def_token method, not the lexer&#39;s method.&quot;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trigger_token_label</span><span class="p">))</span>

        <span class="c1"># TODO: Precedence is currently saved as a token attribute.  Consider</span>
        <span class="c1"># saving it in the construct instead.  See main Sphinx docs, unimplemented</span>
        <span class="c1"># generalizations.</span>
        <span class="k">if</span> <span class="n">head_or_tail</span> <span class="o">==</span> <span class="n">TAIL</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">trigger_token_subclass</span><span class="o">.</span><span class="n">static_prec</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span>
                    <span class="n">prec</span> <span class="o">!=</span> <span class="n">trigger_token_subclass</span><span class="o">.</span><span class="n">static_prec</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s2">&quot;Redefining the precedence of the triggering&quot;</span>
                        <span class="s2">&quot; token subclass &#39;</span><span class="si">{0}</span><span class="s2">&#39; to a new value </span><span class="si">{1}</span><span class="s2"> not equal&quot;</span>
                        <span class="s2">&quot; to the previous nonzero value of </span><span class="si">{2}</span><span class="s2">.&quot;</span>
                        <span class="s2">&quot; The original precedence will never be used.  To actually&quot;</span>
                        <span class="s2">&quot; reset the value, set trigger_token_label.static_prec=0&quot;</span>
                        <span class="s2">&quot; explicitly before this call to def_construct.  Currently&quot;</span>
                        <span class="s2">&quot; all operators with the same triggering token must have&quot;</span>
                        <span class="s2">&quot; the same precedence value, regardless of preconditions.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trigger_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span>
                                <span class="n">trigger_token_subclass</span><span class="o">.</span><span class="n">static_prec</span><span class="p">))</span>
            <span class="n">trigger_token_subclass</span><span class="o">.</span><span class="n">static_prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="c1"># Ignore prec for heads; will stay 0.</span>

        <span class="c1"># Create the type sig object.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_type_checking</span><span class="p">:</span>
            <span class="n">type_sig</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_sig</span> <span class="o">=</span> <span class="n">TypeSig</span><span class="p">(</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span>

        <span class="c1"># Register the handler funs.</span>
        <span class="n">construct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_table</span><span class="o">.</span><span class="n">register_construct</span><span class="p">(</span>
                                          <span class="n">head_or_tail</span><span class="o">=</span><span class="n">head_or_tail</span><span class="p">,</span>
                                          <span class="n">trigger_token_subclass</span><span class="o">=</span><span class="n">trigger_token_subclass</span><span class="p">,</span>
                                          <span class="n">handler_fun</span><span class="o">=</span><span class="n">handler_fun</span><span class="p">,</span>
                                          <span class="n">precond_fun</span><span class="o">=</span><span class="n">precond_fun</span><span class="p">,</span>
                                          <span class="n">precond_priority</span><span class="o">=</span><span class="n">precond_priority</span><span class="p">,</span>
                                          <span class="n">construct_label</span><span class="o">=</span><span class="n">construct_label</span><span class="p">,</span>
                                          <span class="n">type_sig</span><span class="o">=</span><span class="n">type_sig</span><span class="p">,</span>
                                          <span class="n">eval_fun</span><span class="o">=</span><span class="n">eval_fun</span><span class="p">,</span>
                                          <span class="n">ast_data</span><span class="o">=</span><span class="n">ast_data</span><span class="p">,</span>
                                          <span class="n">token_value_key</span><span class="o">=</span><span class="n">token_value_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">construct</span></div>

<div class="viewcode-block" id="PrattParser.undef_construct"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.undef_construct">[docs]</a>    <span class="k">def</span> <span class="nf">undef_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">construct</span><span class="p">,</span> <span class="n">type_sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">token_value_key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Undefine a construct.  If `type_sig` is passed a `TypeSig` instance then</span>
<span class="sd">        only that overload is deleted.  If `token_value_key` is also defined then</span>
<span class="sd">        only that token key is unregistered.  Otherwise the full construct is</span>
<span class="sd">        removed from the parser&#39;s construct table.&quot;&quot;&quot;</span>
        <span class="c1"># Note users themselves could unregister the overloads if they have the</span>
        <span class="c1"># construct instance.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">construct_table</span><span class="o">.</span><span class="n">unregister_construct</span><span class="p">(</span><span class="n">construct</span><span class="p">,</span> <span class="n">type_sig</span><span class="p">,</span> <span class="n">token_value_key</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Methods dealing with types.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="PrattParser.def_type"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.def_type">[docs]</a>    <span class="k">def</span> <span class="nf">def_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a type associated with the name `type_label`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span><span class="o">.</span><span class="n">create_typeobject</span><span class="p">(</span><span class="n">type_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="PrattParser.undef_type"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.undef_type">[docs]</a>    <span class="k">def</span> <span class="nf">undef_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Undefine the type associated with the name `type_label`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span><span class="o">.</span><span class="n">undef_typeobject</span><span class="p">(</span><span class="n">type_label</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># The main parse routines.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="PrattParser.parse_from_lexer"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.parse_from_lexer">[docs]</a>    <span class="k">def</span> <span class="nf">parse_from_lexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lexer_to_use</span><span class="p">,</span> <span class="n">pstate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The same as the `parse` method, but a lexer_to_use is already assumed to be</span>
<span class="sd">        initialized.  This is ONLY used when one parser instance calls another</span>
<span class="sd">        parser instance (implicitly, via the handler functions of its tokens).</span>
<span class="sd">        The outer parser calls this routine of the inner, subexpression parser.</span>
<span class="sd">        Such a call to another parser would look something like::</span>

<span class="sd">            alternate_parser.parse_from_lexer(lexer_to_use)</span>

<span class="sd">        where `lexer_to_use` is the lexer_to_use of the outer parser.  This routine</span>
<span class="sd">        temporarily swaps the token table for the passed-in lexer_to_use to be the</span>
<span class="sd">        token table for this parser (remember that this parser is the inner</span>
<span class="sd">        parser when this routine is called).&quot;&quot;&quot;</span>
        <span class="c1"># Note you do not need to set the type_table, since the tokens always</span>
        <span class="c1"># have fixed references to their own parser instance.</span>

        <span class="c1"># Set up to read from lexer_to_use, after setting its token table to</span>
        <span class="c1"># be the token table for this parser (this is the inner parser).</span>

        <span class="c1"># Temporarily change new lexer&#39;s token table.</span>
        <span class="n">lexer_to_use_usual_table</span> <span class="o">=</span> <span class="n">lexer_to_use</span><span class="o">.</span><span class="n">token_table</span>
        <span class="n">lexer_to_use</span><span class="o">.</span><span class="n">set_token_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_table</span><span class="p">)</span>

        <span class="c1"># Swap the lexer in.</span>
        <span class="n">usual_lexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span> <span class="o">=</span> <span class="n">lexer_to_use</span> <span class="c1"># Swap the lexer.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">parsed_subexpression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;IGNORED&quot;</span><span class="p">,</span> <span class="n">pstate</span><span class="o">=</span><span class="n">pstate</span><span class="p">,</span>
                                    <span class="n">partial_expressions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">skip_lex_setup</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParserException</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in `parse_from_lexer` method, in call to `parse` method&quot;</span>
                    <span class="s2">&quot; using a different parser&#39;s lexer for a subexpression.&quot;</span><span class="p">,</span>
                    <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Restore the temporary lexer&#39;s token table.</span>
            <span class="n">lexer_to_use</span><span class="o">.</span><span class="n">set_token_table</span><span class="p">(</span><span class="n">lexer_to_use_usual_table</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span> <span class="o">=</span> <span class="n">usual_lexer</span>
        <span class="k">return</span> <span class="n">parsed_subexpression</span></div>

<div class="viewcode-block" id="PrattParser.parse"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.PrattParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">,</span> <span class="n">pstate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partial_expressions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                      <span class="n">skip_lex_setup</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The main routine for parsing a full program or expression.  Users of</span>
<span class="sd">        the class should call this method to perform the parsing operations</span>
<span class="sd">        (after defining a grammar, of course).</span>

<span class="sd">        Unless there was a parsing failure or `partial_expressions` is true</span>
<span class="sd">        then the lexer is left with the end-token as the current token.</span>

<span class="sd">        If the `pstate` variable is set then the value will be pushed as the</span>
<span class="sd">        initial state on the production rule stack `pstate_stack`.  The stack</span>
<span class="sd">        is then cleared after a successful call.  (Set the parser attribute</span>
<span class="sd">        directly for more control.)</span>

<span class="sd">        The parser&#39;s `partial_expressions` attribute will be used unless it is</span>
<span class="sd">        overridden by the parameter `partial_expressions` here.  When it is</span>
<span class="sd">        true no check is made for the end-token after `recursive_parse` returns</span>
<span class="sd">        a value.    The lexer will be left at the last token consumed, so a</span>
<span class="sd">        check for the end-token will tell when all the text was consumed.</span>
<span class="sd">        Users are responsible for making sure their grammars are suitable for</span>
<span class="sd">        this kind of parsing if the option is set.</span>

<span class="sd">        If the `skip_lex_setup` parameter is true then the text `program` is</span>
<span class="sd">        ignored and lexer setup is skipped.  This is generally ONLY used when</span>
<span class="sd">        multiple parsers are parsing from a common text stream, and `parse` is</span>
<span class="sd">        called from the method `parse_from_lexer`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pstate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstate_stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">pstate</span><span class="p">]</span> <span class="c1"># For parsing production rule grammars.</span>
        <span class="k">if</span> <span class="n">partial_expressions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">partial_expressions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_expressions</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_lex_setup</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
        <span class="n">begin_tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">token</span> <span class="c1"># Get the first token to access recursive_parse.</span>
        <span class="n">parse_tree</span> <span class="o">=</span> <span class="n">begin_tok</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Finalize type-checking for root when overloading on return types.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_ret_types</span><span class="p">:</span>
            <span class="n">parse_tree</span><span class="o">.</span><span class="n">check_types_in_tree_second_pass</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># See if we reached the end of the token stream.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">is_end_token</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">partial_expressions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">IncompleteParseException</span><span class="p">(</span><span class="s2">&quot;Parsing never reached the end of&quot;</span>
                <span class="s2">&quot; the text.  Parsing stopped with tokens still in the lexer.&quot;</span>
                <span class="s2">&quot;  No syntax element was recognized. The last-parsed token had&quot;</span>
                <span class="s2">&quot; value &#39;</span><span class="si">{0}</span><span class="s2">&#39; and label &#39;</span><span class="si">{1}</span><span class="s2">&#39;.  Parsing stopped before a token&quot;</span>
                <span class="s2">&quot; in the lexer with value &#39;</span><span class="si">{2}</span><span class="s2">&#39; and label &#39;</span><span class="si">{3}</span><span class="s2">&#39;.  The partial&quot;</span>
                <span class="s2">&quot; result returned is:</span><span class="se">\n</span><span class="si">{4}</span><span class="s2">&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span>
                        <span class="n">parse_tree</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">pstate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstate_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">parse_tree</span></div></div>

<span class="c1">#</span>
<span class="c1"># Copy the convenience functions from builtin_parse_methods to the PrattParser class.</span>
<span class="c1">#</span>

<span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">builtin_parse_methods</span><span class="o">.</span><span class="n">parse_methods</span><span class="p">:</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">PrattParser</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

<span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">predefined_token_sets</span><span class="o">.</span><span class="n">token_defining_methods</span><span class="p">:</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">PrattParser</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Exceptions</span>
<span class="c1">#</span>

<div class="viewcode-block" id="IncompleteParseException"><a class="viewcode-back" href="../../typped.pratt_parser.html#typped.pratt_parser.IncompleteParseException">[docs]</a><span class="k">class</span> <span class="nc">IncompleteParseException</span><span class="p">(</span><span class="n">ParserException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Only raised at the end of the `PrattParser` function `parse` if tokens</span>
<span class="sd">    remain in the lexer after the parser finishes its parsing.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>