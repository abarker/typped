
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>11. Appendix A: Possible (but currently unimplemented) generalizations &#8212; Typped  documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="10.10. typped.matcher" href="typped.matcher.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="typped.matcher.html" title="10.10. typped.matcher"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="appendix-a-possible-but-currently-unimplemented-generalizations">
<h1>11. Appendix A: Possible (but currently unimplemented) generalizations<a class="headerlink" href="#appendix-a-possible-but-currently-unimplemented-generalizations" title="Permalink to this headline">¶</a></h1>
<p>The following subsections discuss some possible generalizations which are not
currently implemented.</p>
<div class="section" id="modifiable-token-precedence-values">
<h2>11.1. Modifiable token precedence values<a class="headerlink" href="#modifiable-token-precedence-values" title="Permalink to this headline">¶</a></h2>
<p>Currently the <code class="docutils literal"><span class="pre">PrattParser</span></code> class has the restriction that every token must
have a fixed precedence.  Even under different preconditions the precedence
must be the same.  This is not a huge restriction, but there is the question of
how it could be removed.  A reasonable generalization is to define precedence
values to be attributes of tail handler functions or, in the Typped case,
attributes of constructs that hold tail handler functions.  (Recall
that precedences have no effect on head handler parsing.)</p>
<p>Assume each tail handler function can have an arbitrary precedence.  In this
case different preconditions can cause handlers functions with different
precedences to be dispatched.</p>
<p>The implementation problem arises in the <code class="docutils literal"><span class="pre">recursive_parse</span></code> function.  In the
loop for tail handlers there is always a lookahead to the precedence of the
next token (which is compared to the subexpression precedence).  So we need to
find the precedence of the <code class="code docutils literal"><span class="pre">peek(1)</span></code> token.  Precedence can vary according to
which tail handler (construct) <em>would be</em> dispatched, so we need to determine
that.  But which construct “wins” the dispatching can vary according to the
conditions at the time when that peek token itself is processed.</p>
<p>There are ways to get a reasonable version of this, subject to some
limitations.  You essentially step the lexer ahead to approximate the time when
the peek token would be processed, look up the handler/construct, get its
precedence value, and then step the lexer back.  This adds complexity and an
extra <code class="code docutils literal"><span class="pre">go_back</span></code> operation per subexpression for a feature that would probably
be little-used.  It is not currently implemented (but there is currently
commented-out code that could be adapted to do it).  Interactions with other
features, such as jops, would also need to be considered.</p>
</div>
<div class="section" id="subexpression-lookahead">
<h2>11.2. Subexpression lookahead<a class="headerlink" href="#subexpression-lookahead" title="Permalink to this headline">¶</a></h2>
<p>In this generalization you would be able to use lookahead to the next
subexpression, not just the next token.  The advantage of this kind of
lookahead is that infix operator overloading can then depend on the types (or
other properties) of both of the fully-resolved operands, not just the left
operand and the raw lookahead tokens.</p>
<p>Preconditioning on a token lookahead just after a subexpression lookahead could
be one way (not the best way) to resolve things like ternary operations where
the first operator is also an operator by itself: <code class="docutils literal"><span class="pre">x</span> <span class="pre">?</span> <span class="pre">y</span></code> versus <code class="docutils literal"><span class="pre">x</span> <span class="pre">?</span> <span class="pre">y</span> <span class="pre">:</span>
<span class="pre">z</span></code>.  Similarly, an if-then with optional else could be resolved that way: <code class="docutils literal"><span class="pre">if</span>
<span class="pre">&lt;test&gt;</span> <span class="pre">then</span> <span class="pre">&lt;action&gt;</span></code> versus <code class="docutils literal"><span class="pre">if</span> <span class="pre">&lt;test&gt;</span> <span class="pre">then</span> <span class="pre">&lt;action&gt;</span> <span class="pre">else</span> <span class="pre">&lt;other-action&gt;</span></code>.
The tail handler for processing the first operator can be chosen dependent on
the token type two tokens ahead.</p>
<p>This would be a useful feature, but it would obviously be more expensive since
full subexpressions would have to be provisionally parsed.  It has the
potential to interact with other features, such as the jop feature.  So the
implementation would need to be carefully considered.  Some limited form of
this is likely to be implemented at some point, if only to allow for full
overloading on types.</p>
<p>The required number of <code class="docutils literal"><span class="pre">go_back</span></code> lexer operations on failure could be limited
by possibly allowing preconditions functions to specify a subexpression
lookahead, preferably after the constraints based on available data are
satisfied.  You can already do something similar inside a precondition or
handler function if you really must.  You can save the state of the lexer, call
<code class="docutils literal"><span class="pre">recursive_parse</span></code> to get a subexpression, and then restore the state of the
lexer.</p>
</div>
<div class="section" id="constructs-with-multiple-possible-trigger-tokens">
<h2>11.3. Constructs with multiple possible trigger tokens<a class="headerlink" href="#constructs-with-multiple-possible-trigger-tokens" title="Permalink to this headline">¶</a></h2>
<p>The current implementation follows the Pratt parsing scheme of having handlers
associated with triggering tokens, as well as the head or tail position.  In
general, the looking at the current kind of token could instead be implemented
as part of the preconditions functions.</p>
<p>This would be less efficient in the sense that many more preconditions
functions would potentially need to be sequentially run find the handler for a
given token.  (The current implementation uses a tree to quickly go to a
smaller set of constructs, based on the head or tail property and the token
label.) There are, however, optimizations which could be applied to make this
more efficient.  Preconditions functions would become more complex, since every
construct which is based on the current kind of token (formerly the triggering
token) would need to explicitly specify which kinds of tokens in some way.</p>
<p>The current setup follows Pratt parsing more closely, and the equivalent to the
above is to declare multiple constructs, one for each kind of triggering token.
A null-string token could also be used to do something similar.</p>
</div>
<div class="section" id="more-complex-types">
<h2>11.4. More complex types<a class="headerlink" href="#more-complex-types" title="Permalink to this headline">¶</a></h2>
<p>Generally we might want:</p>
<blockquote>
<div><ul class="simple">
<li>Heirarchies of types and subtypes, with reasonable notions of type equivalence
defined.</li>
<li>Unions.</li>
<li>Automatic conversions.</li>
<li>Parameterized types or templates.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="floating-point-precedence-values">
<h2>11.5. Floating point precedence values<a class="headerlink" href="#floating-point-precedence-values" title="Permalink to this headline">¶</a></h2>
<p>The builtin functions that set right associativity currently assume that the
precedence values are ints.  The examples also use ints.  As explained
below, this is not strictly required.  Limited precision floating point values
already work in the current framework, provided a different value is subtracted
to get right associativity.</p>
<p>Notice that in the while loop of <code class="code docutils literal"><span class="pre">recursive_parse</span></code> the comparison is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>
</pre></div>
</div>
<p>Assume that precedence values are ints.  Consider a tail handler for, say,
infix <code class="code docutils literal"><span class="pre">*</span></code> with a precedence of 5 and left associativity.  Say we process
<code class="code docutils literal"><span class="pre">2*2*2</span></code>.   The head handler for the full expression calls <code class="code docutils literal"><span class="pre">recursive_parse</span></code> to
process the first <code class="code docutils literal"><span class="pre">*</span></code> (with <code class="code docutils literal"><span class="pre">2</span></code> as the <code class="code docutils literal"><span class="pre">processed_left</span></code> value).</p>
<p>For left associativity the subexpression precedence of 5 is passed to this
<code class="code docutils literal"><span class="pre">recursive_parse</span></code> call.  When the loop in that call of <code class="code docutils literal"><span class="pre">recursive_parse</span></code> peeks
at the second <code class="code docutils literal"><span class="pre">*</span></code> token, with a precedence of 5, it breaks and returns because
5 &gt; 5 is false.</p>
<p>If instead the subexpression precedence had been 4, for right associativity,
the peek would again see the second <code class="code docutils literal"><span class="pre">*</span></code> token with a precedence 5, but since 5
&gt; 4 loop would continue.  It continues until it sees a token with precedence
strictly greater than 4, and then it breaks.</p>
<p>Notice that in the latter case the behavior with respect to peeking a token
with token precedence of 4 is still the same as in the first case.  The
subexpression precedence for right associativity just needs to be less than 5
and greater than or equal to the next lowest precedence value (which in this
case is 4 because we assumed ints).</p>
<p>Precedences are only used in comparisons, and the only arithmetic on
precedences is subtracting from a precedence value to get a subexpression
precedence that is smaller, but not too small.  This means that we could
equally well have used 5 - 0.1 as the subexpression precedence in the latter
case of right associativity.</p>
<p>In general any kind of objects can be used for precedences, provided
comparisons work correctly for them and there is a way to get a slightly
smaller value that is still greater than or equal to the next smaller
precedence value.  In particular, precedences can be floating point numbers
restricted in precision to some number of digits.  If we restrict to three
digits of precision then precedences like 4.333 and 2.111 are allowed.  To get
the slightly lower value for right associativity just subtract 0.00001 instead
of 1.</p>
<p>This kind of thing is easy to implement, and has been tested, but is it a good
idea?  As of now the Typped builtins that set right associativity assume
precedences are ints.  In tweaking precedences during development sometimes
float precedences might be useful.  There is a slight loss of efficiency in the
comparison operations when floats are involved, but probably not enough to be a
problem.  (If it is implemented later it would still be backward compatible with
using ints.)</p>
<p>As a possible alternative, just after precedence values are defined and passed
to <code class="docutils literal"><span class="pre">def_construct</span></code> they could always be multiplied by, say, 1000 and then
rounded to an int.  Then internally the representation would be as ints but to
the user they would look like limited-precision floats.  Subtracting one for
right associativity still works, and all parse-time comparisons are of ints.
The any error messages would need to convert the values back, however.
A exception could be raised if the rounding changed the value or if the
resulting int would overflow.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">11. Appendix A: Possible (but currently unimplemented) generalizations</a><ul>
<li><a class="reference internal" href="#modifiable-token-precedence-values">11.1. Modifiable token precedence values</a></li>
<li><a class="reference internal" href="#subexpression-lookahead">11.2. Subexpression lookahead</a></li>
<li><a class="reference internal" href="#constructs-with-multiple-possible-trigger-tokens">11.3. Constructs with multiple possible trigger tokens</a></li>
<li><a class="reference internal" href="#more-complex-types">11.4. More complex types</a></li>
<li><a class="reference internal" href="#floating-point-precedence-values">11.5. Floating point precedence values</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="typped.matcher.html"
                        title="previous chapter">10.10. typped.matcher</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/other_possible_generalizations.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="typped.matcher.html" title="10.10. typped.matcher"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>