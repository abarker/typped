/* Generated by Cython 0.26.1 */

/* BEGIN: Cython Metadata
{
    "distutils": {
        "extra_compile_args": [
            "-O1"
        ],
        "name": "typped.pratt_parser",
        "sources": [
            "src/typped/pratt_parser.py"
        ]
    },
    "module_name": "typped.pratt_parser"
}
END: Cython Metadata */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_26_1"
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#define __PYX_COMMA ,
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x03030000 || (PY_MAJOR_VERSION == 2 && PY_VERSION_HEX >= 0x02070000)
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYTYPE_LOOKUP
    #define CYTHON_USE_PYTYPE_LOOKUP 0
  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
    #define CYTHON_USE_PYTYPE_LOOKUP 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #ifndef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL 1
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
  #undef SHIFT
  #undef BASE
  #undef MASK
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX < 0x030700A0 || !defined(METH_FASTCALL)
  #ifndef METH_FASTCALL
     #define METH_FASTCALL 0x80
  #endif
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject **args, Py_ssize_t nargs);
  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject **args,
                                                          Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#ifndef __has_attribute
  #define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
  #define __has_cpp_attribute(x) 0
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
#ifdef _MSC_VER
    #ifndef _MSC_STDINT_H_
        #if _MSC_VER < 1300
           typedef unsigned char     uint8_t;
           typedef unsigned int      uint32_t;
        #else
           typedef unsigned __int8   uint8_t;
           typedef unsigned __int32  uint32_t;
        #endif
    #endif
#else
   #include <stdint.h>
#endif
#ifndef CYTHON_FALLTHROUGH
  #ifdef __cplusplus
    #if __has_cpp_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH [[fallthrough]]
    #elif __has_cpp_attribute(clang::fallthrough)
      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
    #endif
  #endif
  #ifndef CYTHON_FALLTHROUGH
    #if __has_attribute(fallthrough) || (defined(__GNUC__) && defined(__attribute__))
      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
    #else
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
#endif

#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #elif defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif


#define __PYX_ERR(f_index, lineno, Ln_error) \
{ \
  __pyx_filename = __pyx_f[f_index]; __pyx_lineno = lineno; __pyx_clineno = __LINE__; goto Ln_error; \
}

#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__typped__pratt_parser
#define __PYX_HAVE_API__typped__pratt_parser
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER) && defined (_M_X64)
    #define __Pyx_sst_abs(value) _abs64(value)
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_cython_runtime;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "src/typped/pratt_parser.py",
};

/*--- Type declarations ---*/
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory;
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error;
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr;
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr;
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types;
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr;

/* "typped/pratt_parser.py":359
 *         return cls.prod_rule_funs["Prec"](cls, arg)
 * 
 * def token_subclass_factory():             # <<<<<<<<<<<<<<
 *     """This function is called from the `create_token_subclass` method of
 *     `TokenTable` when it needs to create a new subclass to begin
 */
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory {
  PyObject_HEAD
  PyObject *__pyx_v_TokenSubclass;
};


/* "typped/pratt_parser.py":642
 *             return
 * 
 *         def _raise_type_mismatch_error(self, matching_sigs, basic_msg):             # <<<<<<<<<<<<<<
 *             """Raise an error, printing a helpful diagnostic message.  Assumes
 *             that `_check_types` has been called (to set `self.all_possible_sigs`)."""
 */
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error {
  PyObject_HEAD
  PyObject *__pyx_v_self;
};


/* "typped/pratt_parser.py":654
 *                          .format(self.value, self.token_label,
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),             # <<<<<<<<<<<<<<
 *                              list(c.expanded_formal_sig.val_type
 *                                  if not isinstance(c.expanded_formal_sig, str)
 */
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr {
  PyObject_HEAD
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *__pyx_outer_scope;
  PyObject *__pyx_v_c;
};


/* "typped/pratt_parser.py":655
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),
 *                              list(c.expanded_formal_sig.val_type             # <<<<<<<<<<<<<<
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig
 */
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr {
  PyObject_HEAD
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *__pyx_outer_scope;
  PyObject *__pyx_v_c;
};


/* "typped/pratt_parser.py":946
 *             return string
 * 
 *         def string_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 */
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types {
  PyObject_HEAD
  PyObject *__pyx_v_self;
};


/* "typped/pratt_parser.py":951
 *             if self.children:
 *                 string += "("
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)             # <<<<<<<<<<<<<<
 *                 string += ")"
 *             return string
 */
struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr {
  PyObject_HEAD
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *__pyx_outer_scope;
  PyObject *__pyx_v_c;
  PyObject *__pyx_t_0;
  Py_ssize_t __pyx_t_1;
  PyObject *(*__pyx_t_2)(PyObject *);
};


/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* GetModuleGlobalName.proto */
static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyFunctionFastCall.proto */
#if CYTHON_FAST_PYCALL
#define __Pyx_PyFunction_FastCall(func, args, nargs)\
    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs);
#else
#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
#endif
#endif

/* PyCFunctionFastCall.proto */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
#else
#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
#endif

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* ImportFrom.proto */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

/* PyObjectSetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o,n,NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* None.proto */
static CYTHON_INLINE void __Pyx_RaiseClosureNameError(const char *varname);

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* GetAttr.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);

/* HasAttr.proto */
static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);

/* ListAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

/* PyObjectCallMethod1.proto */
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

/* append.proto */
static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x);

/* ListCompAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

/* GetItemInt.proto */
#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

/* PyIntBinop.proto */
#if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
#endif

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = PyThreadState_GET();
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* PySequenceContains.proto */
static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
    int result = PySequence_Contains(seq, item);
    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
}

/* SaveResetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
#else
#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
#endif

/* PyErrExceptionMatches.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
#else
#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
#endif

/* GetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* SwapException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* RaiseTooManyValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

/* RaiseNeedMoreValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

/* IterFinish.proto */
static CYTHON_INLINE int __Pyx_IterFinish(void);

/* UnpackItemEndCheck.proto */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);

/* StringJoin.proto */
#if PY_MAJOR_VERSION < 3
#define __Pyx_PyString_Join __Pyx_PyBytes_Join
#define __Pyx_PyBaseString_Join(s, v) (PyUnicode_CheckExact(s) ? PyUnicode_Join(s, v) : __Pyx_PyBytes_Join(s, v))
#else
#define __Pyx_PyString_Join PyUnicode_Join
#define __Pyx_PyBaseString_Join PyUnicode_Join
#endif
#if CYTHON_COMPILING_IN_CPYTHON
    #if PY_MAJOR_VERSION < 3
    #define __Pyx_PyBytes_Join _PyString_Join
    #else
    #define __Pyx_PyBytes_Join _PyBytes_Join
    #endif
#else
static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values);
#endif

/* CalculateMetaclass.proto */
static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);

/* FetchCommonType.proto */
static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);

/* CythonFunction.proto */
#define __Pyx_CyFunction_USED 1
#include <structmember.h>
#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
#define __Pyx_CYFUNCTION_CCLASS        0x04
#define __Pyx_CyFunction_GetClosure(f)\
    (((__pyx_CyFunctionObject *) (f))->func_closure)
#define __Pyx_CyFunction_GetClassObj(f)\
    (((__pyx_CyFunctionObject *) (f))->func_classobj)
#define __Pyx_CyFunction_Defaults(type, f)\
    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
typedef struct {
    PyCFunctionObject func;
#if PY_VERSION_HEX < 0x030500A0
    PyObject *func_weakreflist;
#endif
    PyObject *func_dict;
    PyObject *func_name;
    PyObject *func_qualname;
    PyObject *func_doc;
    PyObject *func_globals;
    PyObject *func_code;
    PyObject *func_closure;
    PyObject *func_classobj;
    void *defaults;
    int defaults_pyobjects;
    int flags;
    PyObject *defaults_tuple;
    PyObject *defaults_kwdict;
    PyObject *(*defaults_getter)(PyObject *);
    PyObject *func_annotations;
} __pyx_CyFunctionObject;
static PyTypeObject *__pyx_CyFunctionType = 0;
#define __Pyx_CyFunction_NewEx(ml, flags, qualname, self, module, globals, code)\
    __Pyx_CyFunction_New(__pyx_CyFunctionType, ml, flags, qualname, self, module, globals, code)
static PyObject *__Pyx_CyFunction_New(PyTypeObject *, PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *self,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
                                                         size_t size,
                                                         int pyobjects);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
                                                            PyObject *tuple);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
                                                             PyObject *dict);
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
                                                              PyObject *dict);
static int __pyx_CyFunction_init(void);

/* ClassMethod.proto */
#include "descrobject.h"
static PyObject* __Pyx_Method_ClassMethod(PyObject *method);

/* Py3ClassCreate.proto */
static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                           PyObject *mkw, PyObject *modname, PyObject *doc);
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);

/* IncludeStringH.proto */
#include <string.h>

/* BytesEquals.proto */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);

/* UnicodeEquals.proto */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);

/* StrEquals.proto */
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
#else
#define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
#endif

/* CLineInTraceback.proto */
static int __Pyx_CLineForTraceback(int c_line);

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* CoroutineBase.proto */
typedef PyObject *(*__pyx_coroutine_body_t)(PyObject *, PyObject *);
typedef struct {
    PyObject_HEAD
    __pyx_coroutine_body_t body;
    PyObject *closure;
    PyObject *exc_type;
    PyObject *exc_value;
    PyObject *exc_traceback;
    PyObject *gi_weakreflist;
    PyObject *classobj;
    PyObject *yieldfrom;
    PyObject *gi_name;
    PyObject *gi_qualname;
    PyObject *gi_modulename;
    int resume_label;
    char is_running;
} __pyx_CoroutineObject;
static __pyx_CoroutineObject *__Pyx__Coroutine_New(
    PyTypeObject *type, __pyx_coroutine_body_t body, PyObject *closure,
    PyObject *name, PyObject *qualname, PyObject *module_name);
static int __Pyx_Coroutine_clear(PyObject *self);
#if 1 || PY_VERSION_HEX < 0x030300B0
static int __Pyx_PyGen_FetchStopIterationValue(PyObject **pvalue);
#else
#define __Pyx_PyGen_FetchStopIterationValue(pvalue) PyGen_FetchStopIterationValue(pvalue)
#endif

/* PatchModuleWithCoroutine.proto */
static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code);

/* PatchGeneratorABC.proto */
static int __Pyx_patch_abc(void);

/* Generator.proto */
#define __Pyx_Generator_USED
static PyTypeObject *__pyx_GeneratorType = 0;
#define __Pyx_Generator_CheckExact(obj) (Py_TYPE(obj) == __pyx_GeneratorType)
#define __Pyx_Generator_New(body, closure, name, qualname, module_name)\
    __Pyx__Coroutine_New(__pyx_GeneratorType, body, closure, name, qualname, module_name)
static PyObject *__Pyx_Generator_Next(PyObject *self);
static int __pyx_Generator_init(void);

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'typped.pratt_parser' */
static PyTypeObject *__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory = 0;
static PyTypeObject *__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error = 0;
static PyTypeObject *__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_2_genexpr = 0;
static PyTypeObject *__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_3_genexpr = 0;
static PyTypeObject *__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types = 0;
static PyTypeObject *__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_5_genexpr = 0;
#define __Pyx_MODULE_NAME "typped.pratt_parser"
int __pyx_module_is_main_typped__pratt_parser = 0;

/* Implementation of 'typped.pratt_parser' */
static PyObject *__pyx_builtin_object;
static PyObject *__pyx_builtin_super;
static PyObject *__pyx_builtin_property;
static PyObject *__pyx_builtin_enumerate;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_print;
static const char __pyx_k_c[] = "c";
static const char __pyx_k_s[] = "s";
static const char __pyx_k_v[] = "-v";
static const char __pyx_k__6[] = "<";
static const char __pyx_k__7[] = ",'";
static const char __pyx_k__8[] = "',";
static const char __pyx_k__9[] = ">";
static const char __pyx_k_or[] = "__or__";
static const char __pyx_k_Not[] = "Not";
static const char __pyx_k_Tok[] = "Tok";
static const char __pyx_k__10[] = "";
static const char __pyx_k__11[] = " ";
static const char __pyx_k__12[] = "\n";
static const char __pyx_k__13[] = "(";
static const char __pyx_k__14[] = ",";
static const char __pyx_k__15[] = ")";
static const char __pyx_k_add[] = "__add__";
static const char __pyx_k_arg[] = "arg";
static const char __pyx_k_cls[] = "cls";
static const char __pyx_k_dct[] = "dct";
static const char __pyx_k_doc[] = "__doc__";
static const char __pyx_k_end[] = "end";
static const char __pyx_k_jop[] = "jop";
static const char __pyx_k_lex[] = "lex";
static const char __pyx_k_mcs[] = "mcs";
static const char __pyx_k_new[] = "__new__";
static const char __pyx_k_ror[] = "__ror__";
static const char __pyx_k_sys[] = "sys";
static const char __pyx_k_tok[] = "tok";
static const char __pyx_k_HEAD[] = "HEAD";
static const char __pyx_k_Prec[] = "Prec";
static const char __pyx_k_TAIL[] = "TAIL";
static const char __pyx_k_args[] = "args";
static const char __pyx_k_copy[] = "copy";
static const char __pyx_k_file[] = "file";
static const char __pyx_k_init[] = "__init__";
static const char __pyx_k_join[] = "join";
static const char __pyx_k_kind[] = "kind";
static const char __pyx_k_left[] = "left";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_name[] = "name";
static const char __pyx_k_next[] = "next";
static const char __pyx_k_peek[] = "peek";
static const char __pyx_k_prec[] = "prec";
static const char __pyx_k_radd[] = "__radd__";
static const char __pyx_k_repr[] = "__repr__";
static const char __pyx_k_rmul[] = "__rmul__";
static const char __pyx_k_root[] = "root";
static const char __pyx_k_rpow[] = "__rpow__";
static const char __pyx_k_self[] = "self";
static const char __pyx_k_send[] = "send";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_Lexer[] = "Lexer";
static const char __pyx_k_bases[] = "bases";
static const char __pyx_k_begin[] = "begin";
static const char __pyx_k_child[] = "child";
static const char __pyx_k_close[] = "close";
static const char __pyx_k_count[] = "count";
static const char __pyx_k_k_end[] = "k_end";
static const char __pyx_k_label[] = "label";
static const char __pyx_k_lexer[] = "lexer";
static const char __pyx_k_other[] = "other";
static const char __pyx_k_parse[] = "parse";
static const char __pyx_k_print[] = "print";
static const char __pyx_k_super[] = "super";
static const char __pyx_k_throw[] = "throw";
static const char __pyx_k_tnode[] = "tnode";
static const char __pyx_k_token[] = "token";
static const char __pyx_k_value[] = "value";
static const char __pyx_k_Repeat[] = "Repeat";
static const char __pyx_k_append[] = "append";
static const char __pyx_k_copy_2[] = "__copy__";
static const char __pyx_k_format[] = "format";
static const char __pyx_k_ignore[] = "ignore";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_indent[] = "indent";
static const char __pyx_k_invert[] = "__invert__";
static const char __pyx_k_method[] = "method";
static const char __pyx_k_module[] = "__module__";
static const char __pyx_k_name_2[] = "__name__";
static const char __pyx_k_object[] = "object";
static const char __pyx_k_parent[] = "parent";
static const char __pyx_k_pstate[] = "pstate";
static const char __pyx_k_stderr[] = "stderr";
static const char __pyx_k_string[] = "string";
static const char __pyx_k_IGNORED[] = "IGNORED";
static const char __pyx_k_Token_0[] = "Token({0})";
static const char __pyx_k_TypeSig[] = "TypeSig";
static const char __pyx_k_end_tok[] = "end_tok";
static const char __pyx_k_genexpr[] = "genexpr";
static const char __pyx_k_getitem[] = "__getitem__";
static const char __pyx_k_go_back[] = "go_back";
static const char __pyx_k_ignored[] = "ignored";
static const char __pyx_k_is_head[] = "is_head";
static const char __pyx_k_k_begin[] = "k_begin";
static const char __pyx_k_nOrMore[] = "nOrMore";
static const char __pyx_k_on_ties[] = "on_ties";
static const char __pyx_k_prepare[] = "__prepare__";
static const char __pyx_k_program[] = "program";
static const char __pyx_k_regular[] = "regular";
static const char __pyx_k_ast_data[] = "ast_data";
static const char __pyx_k_children[] = "children";
static const char __pyx_k_def_type[] = "def_type";
static const char __pyx_k_end_head[] = "end_head";
static const char __pyx_k_end_tail[] = "end_tail";
static const char __pyx_k_eval_fun[] = "eval_fun";
static const char __pyx_k_nExactly[] = "nExactly";
static const char __pyx_k_orig_sig[] = "orig_sig";
static const char __pyx_k_property[] = "property";
static const char __pyx_k_qualname[] = "__qualname__";
static const char __pyx_k_set_text[] = "set_text";
static const char __pyx_k_type_sig[] = "type_sig";
static const char __pyx_k_val_type[] = "val_type";
static const char __pyx_k_TokenNode[] = "TokenNode";
static const char __pyx_k_TypeTable[] = "TypeTable";
static const char __pyx_k_arg_types[] = "arg_types";
static const char __pyx_k_basic_msg[] = "basic_msg";
static const char __pyx_k_begin_tok[] = "begin_tok";
static const char __pyx_k_construct[] = "construct";
static const char __pyx_k_def_token[] = "def_token";
static const char __pyx_k_enumerate[] = "enumerate";
static const char __pyx_k_get_token[] = "get_token";
static const char __pyx_k_metaclass[] = "__metaclass__";
static const char __pyx_k_new_class[] = "new_class";
static const char __pyx_k_tree_repr[] = "tree_repr";
static const char __pyx_k_value_key[] = "value_key";
static const char __pyx_k_TokenTable[] = "TokenTable";
static const char __pyx_k_Unresolved[] = "Unresolved";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_actual_sig[] = "actual_sig";
static const char __pyx_k_begin_head[] = "begin_head";
static const char __pyx_k_begin_tail[] = "begin_tail";
static const char __pyx_k_class_repr[] = "class_repr";
static const char __pyx_k_curr_token[] = "curr_token";
static const char __pyx_k_diagnostic[] = "diagnostic";
static const char __pyx_k_left_other[] = "left_other";
static const char __pyx_k_lookbehind[] = "lookbehind";
static const char __pyx_k_num_indent[] = "num_indent";
static const char __pyx_k_parse_tree[] = "parse_tree";
static const char __pyx_k_script_run[] = "script_run";
static const char __pyx_k_token_kind[] = "token_kind";
static const char __pyx_k_type_label[] = "type_label";
static const char __pyx_k_type_table[] = "type_table";
static const char __pyx_k_undef_type[] = "undef_type";
static const char __pyx_k_PrattParser[] = "PrattParser";
static const char __pyx_k_handler_fun[] = "handler_fun";
static const char __pyx_k_not_in_tree[] = "not_in_tree";
static const char __pyx_k_null_string[] = "null-string";
static const char __pyx_k_pratt_types[] = "pratt_types";
static const char __pyx_k_precond_fun[] = "precond_fun";
static const char __pyx_k_pytest_args[] = "pytest_args";
static const char __pyx_k_static_prec[] = "static_prec";
static const char __pyx_k_subexp_prec[] = "subexp_prec";
static const char __pyx_k_token_label[] = "token_label";
static const char __pyx_k_token_table[] = "token_table";
static const char __pyx_k_undef_token[] = "undef_token";
static const char __pyx_k_usual_lexer[] = "usual_lexer";
static const char __pyx_k_all_handlers[] = "all_handlers";
static const char __pyx_k_eval_subtree[] = "eval_subtree";
static const char __pyx_k_get_ast_data[] = "get_ast_data";
static const char __pyx_k_get_eval_fun[] = "get_eval_fun";
static const char __pyx_k_head_handler[] = "head_handler";
static const char __pyx_k_head_or_tail[] = "head_or_tail";
static const char __pyx_k_is_end_token[] = "is_end_token";
static const char __pyx_k_jop_instance[] = "jop_instance";
static const char __pyx_k_lexer_to_use[] = "lexer_to_use";
static const char __pyx_k_matched_sigs[] = "matched_sigs";
static const char __pyx_k_pstate_stack[] = "pstate_stack";
static const char __pyx_k_regex_string[] = "regex_string";
static const char __pyx_k_summary_repr[] = "summary_repr";
static const char __pyx_k_tail_handler[] = "tail_handler";
static const char __pyx_k_TokenClass__0[] = "TokenClass_{0}";
static const char __pyx_k_TokenSubclass[] = "TokenSubclass";
static const char __pyx_k_def_construct[] = "def_construct";
static const char __pyx_k_def_end_token[] = "def_end_token";
static const char __pyx_k_def_jop_token[] = "def_jop_token";
static const char __pyx_k_dummy_handler[] = "dummy_handler";
static const char __pyx_k_k_null_string[] = "k_null-string";
static const char __pyx_k_matching_sigs[] = "matching_sigs";
static const char __pyx_k_original_sigs[] = "original_sigs";
static const char __pyx_k_parse_methods[] = "parse_methods";
static const char __pyx_k_precond_label[] = "precond_label";
static const char __pyx_k_pytest_helper[] = "pytest_helper";
static const char __pyx_k_string_prefix[] = "string_prefix";
static const char __pyx_k_ConstructTable[] = "ConstructTable";
static const char __pyx_k_max_deque_size[] = "max_deque_size";
static const char __pyx_k_processed_left[] = "processed_left";
static const char __pyx_k_prod_rule_funs[] = "prod_rule_funs";
static const char __pyx_k_skip_lex_setup[] = "skip_lex_setup";
static const char __pyx_k_token_subclass[] = "token_subclass";
static const char __pyx_k_ParserException[] = "ParserException";
static const char __pyx_k_construct_table[] = "construct_table";
static const char __pyx_k_def_begin_token[] = "def_begin_token";
static const char __pyx_k_end_token_label[] = "end_token_label";
static const char __pyx_k_jop_token_label[] = "jop_token_label";
static const char __pyx_k_matcher_options[] = "matcher_options";
static const char __pyx_k_max_peek_tokens[] = "max_peek_tokens";
static const char __pyx_k_parser_instance[] = "parser_instance";
static const char __pyx_k_recursive_parse[] = "recursive_parse";
static const char __pyx_k_set_token_table[] = "set_token_table";
static const char __pyx_k_undef_construct[] = "undef_construct";
static const char __pyx_k_autolabel_prefix[] = "autolabel_prefix";
static const char __pyx_k_def_token_master[] = "def_token_master";
static const char __pyx_k_dispatch_handler[] = "dispatch_handler";
static const char __pyx_k_parse_from_lexer[] = "parse_from_lexer";
static const char __pyx_k_pratt_constructs[] = "pratt_constructs";
static const char __pyx_k_precond_priority[] = "precond_priority";
static const char __pyx_k_typesig_override[] = "typesig_override";
static const char __pyx_k_undef_typeobject[] = "undef_typeobject";
static const char __pyx_k_PrattParser_parse[] = "PrattParser.parse";
static const char __pyx_k_TokenSubclassMeta[] = "TokenSubclassMeta";
static const char __pyx_k_all_possible_sigs[] = "all_possible_sigs";
static const char __pyx_k_all_vals_override[] = "all_vals_override";
static const char __pyx_k_begin_token_label[] = "begin_token_label";
static const char __pyx_k_create_typeobject[] = "create_typeobject";
static const char __pyx_k_def_ignored_token[] = "def_ignored_token";
static const char __pyx_k_modified_children[] = "modified_children";
static const char __pyx_k_null_string_token[] = "null_string_token";
static const char __pyx_k_peek_head_handler[] = "_peek_head_handler";
static const char __pyx_k_peek_tail_handler[] = "_peek_tail_handler";
static const char __pyx_k_saved_subexp_prec[] = "saved_subexp_prec";
static const char __pyx_k_val_type_override[] = "val_type_override";
static const char __pyx_k_PrattParser___init[] = "PrattParser.__init__";
static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
static const char __pyx_k_end_token_subclass[] = "end_token_subclass";
static const char __pyx_k_final_mod_function[] = "final_mod_function";
static const char __pyx_k_jop_token_subclass[] = "jop_token_subclass";
static const char __pyx_k_parent_args_so_far[] = "parent_args_so_far";
static const char __pyx_k_register_construct[] = "register_construct";
static const char __pyx_k_skip_type_checking[] = "skip_type_checking";
static const char __pyx_k_0___uniquelabel___1[] = "{0}__uniquelabel__{1}";
static const char __pyx_k_expanded_formal_sig[] = "expanded_formal_sig";
static const char __pyx_k_ignored_token_label[] = "ignored_token_label";
static const char __pyx_k_original_formal_sig[] = "original_formal_sig";
static const char __pyx_k_partial_expressions[] = "partial_expressions";
static const char __pyx_k_process_not_in_tree[] = "process_not_in_tree";
static const char __pyx_k_trigger_token_label[] = "trigger_token_label";
static const char __pyx_k_typped_pratt_parser[] = "typped.pratt_parser";
static const char __pyx_k_unresolved_children[] = "unresolved_children";
static const char __pyx_k_PrattParser_def_type[] = "PrattParser.def_type";
static const char __pyx_k_begin_token_subclass[] = "begin_token_subclass";
static const char __pyx_k_check_types_one_pass[] = "_check_types_one_pass";
static const char __pyx_k_check_types_pass_two[] = "_check_types_pass_two";
static const char __pyx_k_def_begin_end_tokens[] = "def_begin_end_tokens";
static const char __pyx_k_num_lookahead_tokens[] = "num_lookahead_tokens";
static const char __pyx_k_parsed_subexpression[] = "parsed_subexpression";
static const char __pyx_k_top_level_production[] = "top_level_production";
static const char __pyx_k_tree_repr_with_types[] = "tree_repr_with_types";
static const char __pyx_k_unregister_construct[] = "unregister_construct";
static const char __pyx_k_CalledEndTokenHandler[] = "CalledEndTokenHandler";
static const char __pyx_k_PrattParser_def_token[] = "PrattParser.def_token";
static const char __pyx_k_PrattParser_get_token[] = "PrattParser.get_token";
static const char __pyx_k_builtin_parse_methods[] = "builtin_parse_methods";
static const char __pyx_k_def_null_string_token[] = "def_null_string_token";
static const char __pyx_k_ignored_before_labels[] = "ignored_before_labels";
static const char __pyx_k_overload_on_arg_types[] = "overload_on_arg_types";
static const char __pyx_k_overload_on_ret_types[] = "overload_on_ret_types";
static const char __pyx_k_predefined_token_sets[] = "predefined_token_sets";
static const char __pyx_k_PrattParser_undef_type[] = "PrattParser.undef_type";
static const char __pyx_k_TokenSubclassMeta___or[] = "TokenSubclassMeta.__or__";
static const char __pyx_k_get_jop_token_instance[] = "get_jop_token_instance";
static const char __pyx_k_process_and_check_node[] = "process_and_check_node";
static const char __pyx_k_string_repr_with_types[] = "string_repr_with_types";
static const char __pyx_k_token_defining_methods[] = "token_defining_methods";
static const char __pyx_k_token_subclass_factory[] = "token_subclass_factory";
static const char __pyx_k_CalledBeginTokenHandler[] = "CalledBeginTokenHandler";
static const char __pyx_k_PrattParser_undef_token[] = "PrattParser.undef_token";
static const char __pyx_k_TokenSubclassMeta___add[] = "TokenSubclassMeta.__add__";
static const char __pyx_k_TokenSubclassMeta___new[] = "TokenSubclassMeta.__new__";
static const char __pyx_k_TokenSubclassMeta___ror[] = "TokenSubclassMeta.__ror__";
static const char __pyx_k_jop_ignored_token_label[] = "jop_ignored_token_label";
static const char __pyx_k_list_of_child_sig_lists[] = "list_of_child_sig_lists";
static const char __pyx_k_null_string_token_label[] = "null_string_token_label";
static const char __pyx_k_summary_repr_with_types[] = "summary_repr_with_types";
static const char __pyx_k_IncompleteParseException[] = "IncompleteParseException";
static const char __pyx_k_NoHandlerFunctionDefined[] = "NoHandlerFunctionDefined";
static const char __pyx_k_TokenSubclassMeta___radd[] = "TokenSubclassMeta.__radd__";
static const char __pyx_k_TokenSubclassMeta___repr[] = "TokenSubclassMeta.__repr__";
static const char __pyx_k_TokenSubclassMeta___rmul[] = "TokenSubclassMeta.__rmul__";
static const char __pyx_k_TokenSubclassMeta___rpow[] = "TokenSubclassMeta.__rpow__";
static const char __pyx_k_default_begin_end_tokens[] = "default_begin_end_tokens";
static const char __pyx_k_default_helper_exception[] = "default_helper_exception";
static const char __pyx_k_lexer_to_use_usual_table[] = "lexer_to_use_usual_table";
static const char __pyx_k_test_test_pratt_types_py[] = "../../test/test_pratt_types.py";
static const char __pyx_k_PrattParser_def_construct[] = "PrattParser.def_construct";
static const char __pyx_k_PrattParser_def_jop_token[] = "PrattParser.def_jop_token";
static const char __pyx_k_TypeErrorInParsedLanguage[] = "TypeErrorInParsedLanguage";
static const char __pyx_k_next_unique_precond_label[] = "_next_unique_precond_label";
static const char __pyx_k_raise_type_mismatch_error[] = "_raise_type_mismatch_error";
static const char __pyx_k_test_test_pratt_parser_py[] = "../../test/test_pratt_parser.py";
static const char __pyx_k_TokenSubclassMeta___invert[] = "TokenSubclassMeta.__invert__";
static const char __pyx_k_ebnf_classes_and_operators[] = "ebnf_classes_and_operators";
static const char __pyx_k_null_string_token_subclass[] = "null_string_token_subclass";
static const char __pyx_k_src_typped_pratt_parser_py[] = "src/typped/pratt_parser.py";
static const char __pyx_k_token_subclass_factory_fun[] = "token_subclass_factory_fun";
static const char __pyx_k_PrattParser_undef_construct[] = "PrattParser.undef_construct";
static const char __pyx_k_TokenSubclassMeta___getitem[] = "TokenSubclassMeta.__getitem__";
static const char __pyx_k_default_always_true_precond[] = "default_always_true_precond";
static const char __pyx_k_PrattParser_def_token_master[] = "PrattParser.def_token_master";
static const char __pyx_k_PrattParser_parse_from_lexer[] = "PrattParser.parse_from_lexer";
static const char __pyx_k_default_precond_label_number[] = "default_precond_label_number";
static const char __pyx_k_default_unique_precond_label[] = "default_unique_precond_label";
static const char __pyx_k_PrattParser_def_ignored_token[] = "PrattParser.def_ignored_token";
static const char __pyx_k_get_all_matching_expanded_sigs[] = "get_all_matching_expanded_sigs";
static const char __pyx_k_shared_settings_and_exceptions[] = "shared_settings_and_exceptions";
static const char __pyx_k_A_general_Pratt_parser_module_t[] = "\n\nA general Pratt parser module that uses dispatching of handler functions and\ncan check types.  The API is documented here.  See the general Sphinx\ndocumentation for Typped for how to use the class and examples.\n\nAPI details\n===========\n\nThese are some aspects of the API that are not covered by the function signatures\nand docstrings below.\n\nExtra attributes added to tokens\n--------------------------------\n\nToken instances straight from a `Lexer` instance have certain attributes set,\nas documented in the `lexer` module.  In particular, the `token_label`,\n`value`, and `children` attributes are commonly used.  The `pratt_parser`\nmodule defines its own subclass of the `TokenNode` class, which additionally\nassigns some extra attributes when tokens are defined.  The parsing process\nalso sets several user-accessible attributes.\n\nAttributes set on `TokenNode` subclasses (representing kinds of tokens):\n\n* `token_label`\n\nAttributes set on token instances (scanned tokens) during parsing:\n\n* `parser_instance` -- the parser instance that parsed the token\n* `original_formal_sig` -- a `TypeSig` instance of the resolved original formal signature\n* `expanded_formal_sig` -- a `TypeSig` instance of the expanded formal signature\n* `actual_sig` -- a `TypeSig` instance of the actual signature\n* `precond_label` -- the string label of the winning preconditions function\n\nNote that both `original_formal_sig` and `expanded_formal_sig` are set to the\nstring `\"Unresolved\"` before the token is parsed.  The actual signature is\nfound during parsing and type-checking.  Out of all possible overloads in the\noriginal formal signatures associated with the token (via `modify_token`) the\none which matches the actual arguments is chosen.  The expanded formal\nsignature is the same as the original formal signature except that wildcards,\netc., are expanded in the attempt to match the actual arguments.\n\nThese two attributes are actually properties which look up the"" value if\nnecessary (to avoid unnecessary lookups during parsing).  They both only\nwork after parsing, since they use the `original_formal_sig` to look up\nthe corresponding data or function.\n\n* `ast_data` -- any AST data that was set with the construct for the resolved type\n* `eval_fun` -- any eval_fun that was set with the construct for the resolved type\n\nOptional attributes that can be set to a node inside a handler:\n\n* `not_in_tree` -- set on a root node returned by the handler to hide it\n* `process_and_check_kwargs` -- kwargs dict to pass to type-checking routine\n\nImplementation details\n======================\n\nThis section gives a general overview of the lower-level details of the\n`PrattParser` implementation.\n\nThe basic class structure\n-------------------------\n\nTODO: Update diagram to and discussion to have ConstructTable.\n\nThere are five basic classes, with instances which interact.  The main class is\nthe `PrattParser` class, which users will mostly interact with.  The overall\nrelationships are shown in this image, with discussion below.\n\n.. image:: relationshipsBetweenMainClasses.svg\n    :width: 600px\n    :align: center\n\nThe next three classes are defined in the lexer module, although one is\nredefined here.  They are the `TokenSubclass`, `TokenTable`, and `Lexer`\nclasses.\n\nA `Lexer` instance is always initialized with a `TokenTable` instance, whether\nit is passed-in as an argument or created internally as an empty token table.\nA `PrattParser` instance always creates its own token table and then passes\nthat to the lexer, which it also creates.\n\nEvery `PrattParser` instance contains a fixed `TokenTable` instance, which\nnever changes (except for the tokens in it).  So each token-table created by a\nparser can save a pointer back to the parser which \"owns\" it.  Each\n`PrattParser` instance also contains a `Lexer` instance, which contains\na pointer to a parser instance (so the lexer can access the parser).\n\nThe `Toke""nSubclass` class is a subclass of the `TokenNode` class (which is\ndefined in the lexer module).  The subclassing adds many additional methods and\nattributes which are needed in the parsing application.  The `TokenSubclass`\nclass is actually defined inside a factory function, called\n`token_subclass_factory`, which produces a different subclass to represent each\nkind of token that is defined (tokens are defined via the `def_token` method of\n`PrattParser`).  Instances of those subclasses represent the actual tokens\n(i.e., tokens scanned and returned by the lexer containing individual\ntext-string values).\n\nA `TokenTable` instance is basically a dict for holding all the defined\ntoken-subclasses.  But it also has related methods and attributes associated\nwith it.  It is where all new tokens are ultimately created and defined, for\nexample (although other classes like the parser class can add extra attributes\nto the created tokens).\n\nA `TokenTable` instance contains all the tokens defined for a language, and\nstays with the `PrattParser` instance which created it (from which the tokens\nwere necessarily defined).  A `Lexer` instance can use different `TokenTable`\ninstances, possibly switching on-the-fly.  A lexer instance always has a\npointer to its *current* token-table instance, but that can change on-the-fly\n(such as when separate parsers are swapped in to parse sub-languages in the\nsame text stream).  This is used when parser instances call other parser\ninstances.\n\nTokens defined by a parser also save a pointer to their defining parser, since\nthe token-table has a fixed association to the parser.\n\nTokens also need to know their current lexer instance because they need to call\nthe `next` and `peek` methods, if nothing else.  This is equivalent to the\ntoken table knowing its current lexer instance.  So, whenever a token table is\nassociated with a lexer using the lexer's `set_token_table` method it is also\ngiven a pointer to that lexer as an a""ttribute.\n\nThe final class of the five is the `TypeTable` class.  This is essentially a\ndict to store all the defined types, but it also provides a nice place to\ndefine many methods for acting on types.  It is defined in the `pratt_types`\nmodule and imported.\n\nUsing different parsers inside handler functions\n------------------------------------------------\n\nIt is useful to be able to call different `PrattParser` instances from inside\nhandler functions in order to parse subexpressions which are defined as\nsublanguages, having their own parsers.  The implementation supports this as\nfollows.\n\nEssentially, a common lexer is passed around and told which token table (and\nhence parser) to use at any given time.  It would be possible to pass around a\ntext stream of unprocessed text, but then the lexers would need to be\ninitialized each time, and saving information like line numbers and columns in\nthe text would need to move to the text stream object.\n\nThe `parse` routine of a `PrattParser` takes an optional lexer argument, which\nwill be used instead of the default lexer.  But, it first temporarily sets the\n`TokenTable` instance of the lexer to be the same as the token table instance\nof the *current* parser (using the lexer's `set_token_table` method).  So you\ncan call the `parse` method of a *different* parser instance from within a\nhandler function, passing that other parser's `parse` function the *current*\nparser's lexer as an argument.  (Recall that handler functions are associated\nwith tokens, but defined in the context of a parser/token-table.) So the lexer\nwill use the token table of the new parser but still read from the same text\nstream as the current parser.  Note that a sublanguage must always be parsed\nfrom the beginning, so `parse` must be called.  When this parser fails (with\ncertain exceptions? needed with multi-expression?) the subexpression is assumed\nto be parsed, and the symbol table of the lexer is restored to the symbol t""able\nof the current parser (again using the lexer's `set_token_table` method).\n\nConsider: Is the condition that prec=0, or only a head handler, sufficient to\nassume the end\077\077?  Does normal multi-expression work?  WHAT CONDITIONS DOES\nTHIS IMPOSE ON THE SUBLANGUAGES?\n\nNote that the parser or the lexer can determine when a sublanguage expression\nends: either the lexer doesn't recognize a token or else the parser cannot find\na handler, or a handler fails to find what it expects and raises an exception.\n\nWhat if the lexer keeps a stack of symbol tables, and pops one off whenever it\nfails?  Still, you could have lookahead which is correctly lexed in the top\nlanguage but then fails to match a handler function.\n\nCode\n====\n\nIn reading the code, the correspondence between the naming convention used here\nand Pratt's original naming conventions is given in this table:\n\n+----------------------------------+--------------------------+\n| This code                        | Pratt's terminology      |\n+==================================+==========================+\n| token precedence                 | left binding power, lbp  |\n+----------------------------------+--------------------------+\n| subexpression precedence         | right binding power, rbp |\n+----------------------------------+--------------------------+\n| head handler function            | null denotation, nud     |\n+----------------------------------+--------------------------+\n| tail handler function            | left denotation, led     |\n+----------------------------------+--------------------------+\n\n";
static const char __pyx_k_DEFAULT_ALWAYS_TRUE_PRECOND_FUN[] = "DEFAULT_ALWAYS_TRUE_PRECOND_FUN";
static const char __pyx_k_The_arg_types_argument_to_token[] = "The arg_types argument to token_subclass must be None or an iterable returning type labels (e.g., a list or tuple).";
static const char __pyx_k_The_current_token_has_value_0_a[] = "  The current token has value '{0}' and label '{1}'.   Its expanded formal signature is {2}.  The children/arguments have token labels and values of {3} and value types {4}.  The list of matching signatures is {5}.  The list of possible signatures was {6}";
static const char __pyx_k_Value_of_autolabel_prefix_value[] = "Value of autolabel_prefix value must be None or a string.  Instead got: {0}";
static const char __pyx_k_check_types_first_of_two_passes[] = "_check_types_first_of_two_passes";
static const char __pyx_k_check_types_in_tree_second_pass[] = "check_types_in_tree_second_pass";
static const char __pyx_k_null_string_ignored_token_label[] = "null_string_ignored_token_label";
static const char __pyx_k_test_test_basic_usage_section_e[] = "../../test/test_basic_usage_section_examples.py";
static const char __pyx_k_test_test_ebnf_classes_and_oper[] = "../../test/test_ebnf_classes_and_operators.py";
static const char __pyx_k_test_test_example_calculator_id[] = "../../test/test_example_calculator_identifier_keyed_on_values.py";
static const char __pyx_k_test_test_example_calculator_py[] = "../../test/test_example_calculator.py";
static const char __pyx_k_test_test_parser_called_from_pa[] = "../../test/test_parser_called_from_parser.py";
static const char __pyx_k_A_jop_token_is_already_defined_I[] = "A jop token is already defined.  It must be undefined before defining a new one.";
static const char __pyx_k_A_null_string_token_is_already_d[] = "A null-string token is already defined.  It must be undefined before defining an new one.";
static const char __pyx_k_A_parser_object_Each_parser_obje[] = "A parser object.  Each parser object contains its own token table for tokens\n    and its own lexer.";
static const char __pyx_k_A_trivial_metaclass_that_will_ac[] = "A trivial metaclass that will actually create the `TokenSubclass`\n    objects.  Since tokens are represented by classes, rather than instances,\n    this is necessary in order to change their `__repr__` (the defalt one is\n    ugly for tokens) and to overload operators to work for token operands\n    in the EBNF-like grammar.";
static const char __pyx_k_All_tokens_used_in_the_parser_mu[] = "All tokens used in the parser must be defined in via parser's methods, not the lexer's.";
static const char __pyx_k_Ambiguous_type_resolution_The_ac[] = "Ambiguous type resolution: The actual argument types match multiple signatures.";
static const char __pyx_k_Ambiguous_type_resolution_second[] = "Ambiguous type resolution (second pass).  Possible type assignments for the children/arguments of the token node match {0} possible node signatures: {1}.  Uniqueness is required.";
static const char __pyx_k_Attempt_to_define_a_construct_fo[] = "Attempt to define a construct for trigger token '{0}' with a tail hander and a precedence of zero or less.";
static const char __pyx_k_Bad_call_to_def_token_master_wit[] = "Bad call to def_token_master, with unrecognized string \"{0}\" for the keyword argument token_kind.";
static const char __pyx_k_Call_to_def_construct_with_preco[] = "Call to def_construct with precond_label set to '{0}', but no precond_fun was provided.";
static const char __pyx_k_Called_head_handler_for_begin_to[] = "Called head-handler for begin token.";
static const char __pyx_k_Called_head_handler_for_end_toke[] = "Called head-handler for end token.";
static const char __pyx_k_Called_tail_handler_for_begin_to[] = "Called tail-handler for begin token.";
static const char __pyx_k_Called_tail_handler_for_end_toke[] = "Called tail-handler for end token.";
static const char __pyx_k_DEFAULT_ALWAYS_TRUE_PRECOND_LABE[] = "DEFAULT_ALWAYS_TRUE_PRECOND_LABEL";
static const char __pyx_k_DEFAULT_PRECOND_AUTOLABEL_PREFIX[] = "DEFAULT_PRECOND_AUTOLABEL_PREFIX";
static const char __pyx_k_Error_in_parse_from_lexer_method[] = "Error in `parse_from_lexer` method, in call to `parse` method using a different parser's lexer for a subexpression.";
static const char __pyx_k_In_call_to_def_construct_subclas[] = "In call to def_construct: subclass for token labeled '{0}' has not been defined.  Maybe try calling def_token first.";
static const char __pyx_k_Only_raised_at_the_end_of_the_Pr[] = "Only raised at the end of the `PrattParser` function `parse` if tokens\n    remain in the lexer after the parser finishes its parsing.";
static const char __pyx_k_Parsing_never_reached_the_end_of[] = "Parsing never reached the end of the text.  Parsing stopped with tokens still in the lexer.  No syntax element was recognized. The last-parsed token had value '{0}' and label '{1}'.  Parsing stopped before a token in the lexer with value '{2}' and label '{3}'.  The partial result returned is:\n{4}";
static const char __pyx_k_PrattParser__next_unique_precond[] = "PrattParser._next_unique_precond_label";
static const char __pyx_k_PrattParser_def_begin_end_tokens[] = "PrattParser.def_begin_end_tokens";
static const char __pyx_k_PrattParser_def_null_string_toke[] = "PrattParser.def_null_string_token";
static const char __pyx_k_PrattParser_def_token_master_loc[] = "PrattParser.def_token_master.<locals>.begin_head";
static const char __pyx_k_The_factory_function_returns_thi[] = "The factory function returns this class to represent tokens.  It is a\n        subclass of the `TokenNode` class, defined in the lexer module.";
static const char __pyx_k_Token_node_has_multiple_signatur[] = "Token node has multiple signatures with return type matching type of parent (pass two). Parent expects type '{0}'.  Defined signatures are: {1}.";
static const char __pyx_k_get_child_sigs_matching_return_a[] = "get_child_sigs_matching_return_arg_type";
static const char __pyx_k_get_null_string_token_and_handle[] = "get_null_string_token_and_handler";
static const char __pyx_k_lexer_add_parser_instance_attrib[] = "lexer_add_parser_instance_attribute";
static const char __pyx_k_raise_on_equal_priority_preconds[] = "raise_on_equal_priority_preconds";
static const char __pyx_k_token_subclass_factory_locals_To[] = "token_subclass_factory.<locals>.TokenSubclass._raise_type_mismatch_error.<locals>.genexpr";
static const char __pyx_k_Attempt_to_define_a_construct_fo_2[] = "Attempt to define a construct for trigger token '{0}' with a head hander and a precedence not equal to zero.";
static const char __pyx_k_PrattParser_def_token_master_loc_2[] = "PrattParser.def_token_master.<locals>.begin_tail";
static const char __pyx_k_PrattParser_def_token_master_loc_3[] = "PrattParser.def_token_master.<locals>.end_head";
static const char __pyx_k_PrattParser_def_token_master_loc_4[] = "PrattParser.def_token_master.<locals>.end_tail";
static const char __pyx_k_token_subclass_factory_locals_To_2[] = "token_subclass_factory.<locals>.TokenSubclass.string_repr_with_types.<locals>.genexpr";
static const char __pyx_k_token_subclass_factory_locals_To_3[] = "token_subclass_factory.<locals>.TokenSubclass";
static const char __pyx_k_token_subclass_factory_locals_To_4[] = "token_subclass_factory.<locals>.TokenSubclass.__init__";
static const char __pyx_k_token_subclass_factory_locals_To_5[] = "token_subclass_factory.<locals>.TokenSubclass.prec";
static const char __pyx_k_token_subclass_factory_locals_To_6[] = "token_subclass_factory.<locals>.TokenSubclass.dispatch_handler";
static const char __pyx_k_token_subclass_factory_locals_To_7[] = "token_subclass_factory.<locals>.TokenSubclass.process_not_in_tree";
static const char __pyx_k_token_subclass_factory_locals_To_8[] = "token_subclass_factory.<locals>.TokenSubclass.process_and_check_node";
static const char __pyx_k_token_subclass_factory_locals_To_9[] = "token_subclass_factory.<locals>.TokenSubclass._check_types_one_pass";
static const char __pyx_k_token_subclass_factory_locals_To_10[] = "token_subclass_factory.<locals>.TokenSubclass._check_types_first_of_two_passes";
static const char __pyx_k_token_subclass_factory_locals_To_11[] = "token_subclass_factory.<locals>.TokenSubclass.check_types_in_tree_second_pass";
static const char __pyx_k_token_subclass_factory_locals_To_12[] = "token_subclass_factory.<locals>.TokenSubclass._check_types_pass_two";
static const char __pyx_k_token_subclass_factory_locals_To_13[] = "token_subclass_factory.<locals>.TokenSubclass._raise_type_mismatch_error";
static const char __pyx_k_token_subclass_factory_locals_To_14[] = "token_subclass_factory.<locals>.TokenSubclass.eval_fun";
static const char __pyx_k_token_subclass_factory_locals_To_15[] = "token_subclass_factory.<locals>.TokenSubclass.ast_data";
static const char __pyx_k_token_subclass_factory_locals_To_16[] = "token_subclass_factory.<locals>.TokenSubclass.eval_subtree";
static const char __pyx_k_token_subclass_factory_locals_To_17[] = "token_subclass_factory.<locals>.TokenSubclass.get_jop_token_instance";
static const char __pyx_k_token_subclass_factory_locals_To_18[] = "token_subclass_factory.<locals>.TokenSubclass.get_null_string_token_and_handler";
static const char __pyx_k_token_subclass_factory_locals_To_19[] = "token_subclass_factory.<locals>.TokenSubclass.recursive_parse";
static const char __pyx_k_token_subclass_factory_locals_To_20[] = "token_subclass_factory.<locals>.TokenSubclass.__copy__";
static const char __pyx_k_token_subclass_factory_locals_To_21[] = "token_subclass_factory.<locals>.TokenSubclass.summary_repr_with_types";
static const char __pyx_k_token_subclass_factory_locals_To_22[] = "token_subclass_factory.<locals>.TokenSubclass.tree_repr_with_types";
static const char __pyx_k_token_subclass_factory_locals_To_23[] = "token_subclass_factory.<locals>.TokenSubclass.string_repr_with_types";
static const char __pyx_k_token_subclass_factory_locals_To_24[] = "token_subclass_factory.<locals>.TokenSubclass.class_repr";
static PyObject *__pyx_kp_s_0___uniquelabel___1;
static PyObject *__pyx_kp_s_A_jop_token_is_already_defined_I;
static PyObject *__pyx_kp_s_A_null_string_token_is_already_d;
static PyObject *__pyx_kp_s_A_parser_object_Each_parser_obje;
static PyObject *__pyx_kp_s_A_trivial_metaclass_that_will_ac;
static PyObject *__pyx_kp_s_All_tokens_used_in_the_parser_mu;
static PyObject *__pyx_kp_s_Ambiguous_type_resolution_The_ac;
static PyObject *__pyx_kp_s_Ambiguous_type_resolution_second;
static PyObject *__pyx_kp_s_Attempt_to_define_a_construct_fo;
static PyObject *__pyx_kp_s_Attempt_to_define_a_construct_fo_2;
static PyObject *__pyx_kp_s_Bad_call_to_def_token_master_wit;
static PyObject *__pyx_kp_s_Call_to_def_construct_with_preco;
static PyObject *__pyx_n_s_CalledBeginTokenHandler;
static PyObject *__pyx_n_s_CalledEndTokenHandler;
static PyObject *__pyx_kp_s_Called_head_handler_for_begin_to;
static PyObject *__pyx_kp_s_Called_head_handler_for_end_toke;
static PyObject *__pyx_kp_s_Called_tail_handler_for_begin_to;
static PyObject *__pyx_kp_s_Called_tail_handler_for_end_toke;
static PyObject *__pyx_n_s_ConstructTable;
static PyObject *__pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_FUN;
static PyObject *__pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_LABE;
static PyObject *__pyx_n_s_DEFAULT_PRECOND_AUTOLABEL_PREFIX;
static PyObject *__pyx_kp_s_Error_in_parse_from_lexer_method;
static PyObject *__pyx_n_s_HEAD;
static PyObject *__pyx_n_s_IGNORED;
static PyObject *__pyx_kp_s_In_call_to_def_construct_subclas;
static PyObject *__pyx_n_s_IncompleteParseException;
static PyObject *__pyx_n_s_Lexer;
static PyObject *__pyx_n_s_NoHandlerFunctionDefined;
static PyObject *__pyx_n_s_Not;
static PyObject *__pyx_kp_s_Only_raised_at_the_end_of_the_Pr;
static PyObject *__pyx_n_s_ParserException;
static PyObject *__pyx_kp_s_Parsing_never_reached_the_end_of;
static PyObject *__pyx_n_s_PrattParser;
static PyObject *__pyx_n_s_PrattParser___init;
static PyObject *__pyx_n_s_PrattParser__next_unique_precond;
static PyObject *__pyx_n_s_PrattParser_def_begin_end_tokens;
static PyObject *__pyx_n_s_PrattParser_def_construct;
static PyObject *__pyx_n_s_PrattParser_def_ignored_token;
static PyObject *__pyx_n_s_PrattParser_def_jop_token;
static PyObject *__pyx_n_s_PrattParser_def_null_string_toke;
static PyObject *__pyx_n_s_PrattParser_def_token;
static PyObject *__pyx_n_s_PrattParser_def_token_master;
static PyObject *__pyx_n_s_PrattParser_def_token_master_loc;
static PyObject *__pyx_n_s_PrattParser_def_token_master_loc_2;
static PyObject *__pyx_n_s_PrattParser_def_token_master_loc_3;
static PyObject *__pyx_n_s_PrattParser_def_token_master_loc_4;
static PyObject *__pyx_n_s_PrattParser_def_type;
static PyObject *__pyx_n_s_PrattParser_get_token;
static PyObject *__pyx_n_s_PrattParser_parse;
static PyObject *__pyx_n_s_PrattParser_parse_from_lexer;
static PyObject *__pyx_n_s_PrattParser_undef_construct;
static PyObject *__pyx_n_s_PrattParser_undef_token;
static PyObject *__pyx_n_s_PrattParser_undef_type;
static PyObject *__pyx_n_s_Prec;
static PyObject *__pyx_n_s_Repeat;
static PyObject *__pyx_n_s_TAIL;
static PyObject *__pyx_kp_s_The_arg_types_argument_to_token;
static PyObject *__pyx_kp_s_The_current_token_has_value_0_a;
static PyObject *__pyx_kp_s_The_factory_function_returns_thi;
static PyObject *__pyx_n_s_Tok;
static PyObject *__pyx_kp_s_TokenClass__0;
static PyObject *__pyx_n_s_TokenNode;
static PyObject *__pyx_n_s_TokenSubclass;
static PyObject *__pyx_n_s_TokenSubclassMeta;
static PyObject *__pyx_n_s_TokenSubclassMeta___add;
static PyObject *__pyx_n_s_TokenSubclassMeta___getitem;
static PyObject *__pyx_n_s_TokenSubclassMeta___invert;
static PyObject *__pyx_n_s_TokenSubclassMeta___new;
static PyObject *__pyx_n_s_TokenSubclassMeta___or;
static PyObject *__pyx_n_s_TokenSubclassMeta___radd;
static PyObject *__pyx_n_s_TokenSubclassMeta___repr;
static PyObject *__pyx_n_s_TokenSubclassMeta___rmul;
static PyObject *__pyx_n_s_TokenSubclassMeta___ror;
static PyObject *__pyx_n_s_TokenSubclassMeta___rpow;
static PyObject *__pyx_n_s_TokenTable;
static PyObject *__pyx_kp_s_Token_0;
static PyObject *__pyx_kp_s_Token_node_has_multiple_signatur;
static PyObject *__pyx_n_s_TypeErrorInParsedLanguage;
static PyObject *__pyx_n_s_TypeSig;
static PyObject *__pyx_n_s_TypeTable;
static PyObject *__pyx_n_s_Unresolved;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_kp_s_Value_of_autolabel_prefix_value;
static PyObject *__pyx_kp_s__10;
static PyObject *__pyx_kp_s__11;
static PyObject *__pyx_kp_s__12;
static PyObject *__pyx_kp_s__13;
static PyObject *__pyx_kp_s__14;
static PyObject *__pyx_kp_s__15;
static PyObject *__pyx_kp_s__6;
static PyObject *__pyx_kp_s__7;
static PyObject *__pyx_kp_s__8;
static PyObject *__pyx_kp_s__9;
static PyObject *__pyx_n_s_actual_sig;
static PyObject *__pyx_n_s_add;
static PyObject *__pyx_n_s_all_handlers;
static PyObject *__pyx_n_s_all_possible_sigs;
static PyObject *__pyx_n_s_all_vals_override;
static PyObject *__pyx_n_s_append;
static PyObject *__pyx_n_s_arg;
static PyObject *__pyx_n_s_arg_types;
static PyObject *__pyx_n_s_args;
static PyObject *__pyx_n_s_ast_data;
static PyObject *__pyx_n_s_autolabel_prefix;
static PyObject *__pyx_n_s_bases;
static PyObject *__pyx_n_s_basic_msg;
static PyObject *__pyx_n_s_begin;
static PyObject *__pyx_n_s_begin_head;
static PyObject *__pyx_n_s_begin_tail;
static PyObject *__pyx_n_s_begin_tok;
static PyObject *__pyx_n_s_begin_token_label;
static PyObject *__pyx_n_s_begin_token_subclass;
static PyObject *__pyx_n_s_builtin_parse_methods;
static PyObject *__pyx_n_s_c;
static PyObject *__pyx_n_s_check_types_first_of_two_passes;
static PyObject *__pyx_n_s_check_types_in_tree_second_pass;
static PyObject *__pyx_n_s_check_types_one_pass;
static PyObject *__pyx_n_s_check_types_pass_two;
static PyObject *__pyx_n_s_child;
static PyObject *__pyx_n_s_children;
static PyObject *__pyx_n_s_class_repr;
static PyObject *__pyx_n_s_cline_in_traceback;
static PyObject *__pyx_n_s_close;
static PyObject *__pyx_n_s_cls;
static PyObject *__pyx_n_s_construct;
static PyObject *__pyx_n_s_construct_table;
static PyObject *__pyx_n_s_copy;
static PyObject *__pyx_n_s_copy_2;
static PyObject *__pyx_n_s_count;
static PyObject *__pyx_n_s_create_typeobject;
static PyObject *__pyx_n_s_curr_token;
static PyObject *__pyx_n_s_dct;
static PyObject *__pyx_n_s_def_begin_end_tokens;
static PyObject *__pyx_n_s_def_begin_token;
static PyObject *__pyx_n_s_def_construct;
static PyObject *__pyx_n_s_def_end_token;
static PyObject *__pyx_n_s_def_ignored_token;
static PyObject *__pyx_n_s_def_jop_token;
static PyObject *__pyx_n_s_def_null_string_token;
static PyObject *__pyx_n_s_def_token;
static PyObject *__pyx_n_s_def_token_master;
static PyObject *__pyx_n_s_def_type;
static PyObject *__pyx_n_s_default_always_true_precond;
static PyObject *__pyx_n_s_default_begin_end_tokens;
static PyObject *__pyx_n_s_default_helper_exception;
static PyObject *__pyx_n_s_default_precond_label_number;
static PyObject *__pyx_n_s_default_unique_precond_label;
static PyObject *__pyx_n_s_diagnostic;
static PyObject *__pyx_n_s_dispatch_handler;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_n_s_dummy_handler;
static PyObject *__pyx_n_s_ebnf_classes_and_operators;
static PyObject *__pyx_n_s_end;
static PyObject *__pyx_n_s_end_head;
static PyObject *__pyx_n_s_end_tail;
static PyObject *__pyx_n_s_end_tok;
static PyObject *__pyx_n_s_end_token_label;
static PyObject *__pyx_n_s_end_token_subclass;
static PyObject *__pyx_n_s_enumerate;
static PyObject *__pyx_n_s_eval_fun;
static PyObject *__pyx_n_s_eval_subtree;
static PyObject *__pyx_n_s_expanded_formal_sig;
static PyObject *__pyx_n_s_file;
static PyObject *__pyx_n_s_final_mod_function;
static PyObject *__pyx_n_s_format;
static PyObject *__pyx_n_s_genexpr;
static PyObject *__pyx_n_s_get_all_matching_expanded_sigs;
static PyObject *__pyx_n_s_get_ast_data;
static PyObject *__pyx_n_s_get_child_sigs_matching_return_a;
static PyObject *__pyx_n_s_get_eval_fun;
static PyObject *__pyx_n_s_get_jop_token_instance;
static PyObject *__pyx_n_s_get_null_string_token_and_handle;
static PyObject *__pyx_n_s_get_token;
static PyObject *__pyx_n_s_getitem;
static PyObject *__pyx_n_s_go_back;
static PyObject *__pyx_n_s_handler_fun;
static PyObject *__pyx_n_s_head_handler;
static PyObject *__pyx_n_s_head_or_tail;
static PyObject *__pyx_n_s_ignore;
static PyObject *__pyx_n_s_ignored;
static PyObject *__pyx_n_s_ignored_before_labels;
static PyObject *__pyx_n_s_ignored_token_label;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_indent;
static PyObject *__pyx_n_s_init;
static PyObject *__pyx_n_s_invert;
static PyObject *__pyx_n_s_is_end_token;
static PyObject *__pyx_n_s_is_head;
static PyObject *__pyx_n_s_join;
static PyObject *__pyx_n_s_jop;
static PyObject *__pyx_n_s_jop_ignored_token_label;
static PyObject *__pyx_n_s_jop_instance;
static PyObject *__pyx_n_s_jop_token_label;
static PyObject *__pyx_n_s_jop_token_subclass;
static PyObject *__pyx_n_s_k_begin;
static PyObject *__pyx_n_s_k_end;
static PyObject *__pyx_kp_s_k_null_string;
static PyObject *__pyx_n_s_kind;
static PyObject *__pyx_n_s_label;
static PyObject *__pyx_n_s_left;
static PyObject *__pyx_n_s_left_other;
static PyObject *__pyx_n_s_lex;
static PyObject *__pyx_n_s_lexer;
static PyObject *__pyx_n_s_lexer_add_parser_instance_attrib;
static PyObject *__pyx_n_s_lexer_to_use;
static PyObject *__pyx_n_s_lexer_to_use_usual_table;
static PyObject *__pyx_n_s_list_of_child_sig_lists;
static PyObject *__pyx_n_s_lookbehind;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_matched_sigs;
static PyObject *__pyx_n_s_matcher_options;
static PyObject *__pyx_n_s_matching_sigs;
static PyObject *__pyx_n_s_max_deque_size;
static PyObject *__pyx_n_s_max_peek_tokens;
static PyObject *__pyx_n_s_mcs;
static PyObject *__pyx_n_s_metaclass;
static PyObject *__pyx_n_s_method;
static PyObject *__pyx_n_s_modified_children;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_nExactly;
static PyObject *__pyx_n_s_nOrMore;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_name_2;
static PyObject *__pyx_n_s_new;
static PyObject *__pyx_n_s_new_class;
static PyObject *__pyx_n_s_next;
static PyObject *__pyx_n_s_next_unique_precond_label;
static PyObject *__pyx_n_s_not_in_tree;
static PyObject *__pyx_kp_s_null_string;
static PyObject *__pyx_n_s_null_string_ignored_token_label;
static PyObject *__pyx_n_s_null_string_token;
static PyObject *__pyx_n_s_null_string_token_label;
static PyObject *__pyx_n_s_null_string_token_subclass;
static PyObject *__pyx_n_s_num_indent;
static PyObject *__pyx_n_s_num_lookahead_tokens;
static PyObject *__pyx_n_s_object;
static PyObject *__pyx_n_s_on_ties;
static PyObject *__pyx_n_s_or;
static PyObject *__pyx_n_s_orig_sig;
static PyObject *__pyx_n_s_original_formal_sig;
static PyObject *__pyx_n_s_original_sigs;
static PyObject *__pyx_n_s_other;
static PyObject *__pyx_n_s_overload_on_arg_types;
static PyObject *__pyx_n_s_overload_on_ret_types;
static PyObject *__pyx_n_s_parent;
static PyObject *__pyx_n_s_parent_args_so_far;
static PyObject *__pyx_n_s_parse;
static PyObject *__pyx_n_s_parse_from_lexer;
static PyObject *__pyx_n_s_parse_methods;
static PyObject *__pyx_n_s_parse_tree;
static PyObject *__pyx_n_s_parsed_subexpression;
static PyObject *__pyx_n_s_parser_instance;
static PyObject *__pyx_n_s_partial_expressions;
static PyObject *__pyx_n_s_peek;
static PyObject *__pyx_n_s_peek_head_handler;
static PyObject *__pyx_n_s_peek_tail_handler;
static PyObject *__pyx_n_s_pratt_constructs;
static PyObject *__pyx_n_s_pratt_types;
static PyObject *__pyx_n_s_prec;
static PyObject *__pyx_n_s_precond_fun;
static PyObject *__pyx_n_s_precond_label;
static PyObject *__pyx_n_s_precond_priority;
static PyObject *__pyx_n_s_predefined_token_sets;
static PyObject *__pyx_n_s_prepare;
static PyObject *__pyx_n_s_print;
static PyObject *__pyx_n_s_process_and_check_node;
static PyObject *__pyx_n_s_process_not_in_tree;
static PyObject *__pyx_n_s_processed_left;
static PyObject *__pyx_n_s_prod_rule_funs;
static PyObject *__pyx_n_s_program;
static PyObject *__pyx_n_s_property;
static PyObject *__pyx_n_s_pstate;
static PyObject *__pyx_n_s_pstate_stack;
static PyObject *__pyx_n_s_pytest_args;
static PyObject *__pyx_n_s_pytest_helper;
static PyObject *__pyx_n_s_qualname;
static PyObject *__pyx_n_s_radd;
static PyObject *__pyx_n_s_raise_on_equal_priority_preconds;
static PyObject *__pyx_n_s_raise_type_mismatch_error;
static PyObject *__pyx_n_s_recursive_parse;
static PyObject *__pyx_n_s_regex_string;
static PyObject *__pyx_n_s_register_construct;
static PyObject *__pyx_n_s_regular;
static PyObject *__pyx_n_s_repr;
static PyObject *__pyx_n_s_rmul;
static PyObject *__pyx_n_s_root;
static PyObject *__pyx_n_s_ror;
static PyObject *__pyx_n_s_rpow;
static PyObject *__pyx_n_s_s;
static PyObject *__pyx_n_s_saved_subexp_prec;
static PyObject *__pyx_n_s_script_run;
static PyObject *__pyx_n_s_self;
static PyObject *__pyx_n_s_send;
static PyObject *__pyx_n_s_set_text;
static PyObject *__pyx_n_s_set_token_table;
static PyObject *__pyx_n_s_shared_settings_and_exceptions;
static PyObject *__pyx_n_s_skip_lex_setup;
static PyObject *__pyx_n_s_skip_type_checking;
static PyObject *__pyx_kp_s_src_typped_pratt_parser_py;
static PyObject *__pyx_n_s_static_prec;
static PyObject *__pyx_n_s_stderr;
static PyObject *__pyx_n_s_string;
static PyObject *__pyx_n_s_string_prefix;
static PyObject *__pyx_n_s_string_repr_with_types;
static PyObject *__pyx_n_s_subexp_prec;
static PyObject *__pyx_n_s_summary_repr;
static PyObject *__pyx_n_s_summary_repr_with_types;
static PyObject *__pyx_n_s_super;
static PyObject *__pyx_n_s_sys;
static PyObject *__pyx_n_s_tail_handler;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_kp_s_test_test_basic_usage_section_e;
static PyObject *__pyx_kp_s_test_test_ebnf_classes_and_oper;
static PyObject *__pyx_kp_s_test_test_example_calculator_id;
static PyObject *__pyx_kp_s_test_test_example_calculator_py;
static PyObject *__pyx_kp_s_test_test_parser_called_from_pa;
static PyObject *__pyx_kp_s_test_test_pratt_parser_py;
static PyObject *__pyx_kp_s_test_test_pratt_types_py;
static PyObject *__pyx_n_s_throw;
static PyObject *__pyx_n_s_tnode;
static PyObject *__pyx_n_s_tok;
static PyObject *__pyx_n_s_token;
static PyObject *__pyx_n_s_token_defining_methods;
static PyObject *__pyx_n_s_token_kind;
static PyObject *__pyx_n_s_token_label;
static PyObject *__pyx_n_s_token_subclass;
static PyObject *__pyx_n_s_token_subclass_factory;
static PyObject *__pyx_n_s_token_subclass_factory_fun;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_10;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_11;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_12;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_13;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_14;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_15;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_16;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_17;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_18;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_19;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_2;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_20;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_21;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_22;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_23;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_24;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_3;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_4;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_5;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_6;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_7;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_8;
static PyObject *__pyx_n_s_token_subclass_factory_locals_To_9;
static PyObject *__pyx_n_s_token_table;
static PyObject *__pyx_n_s_top_level_production;
static PyObject *__pyx_n_s_tree_repr;
static PyObject *__pyx_n_s_tree_repr_with_types;
static PyObject *__pyx_n_s_trigger_token_label;
static PyObject *__pyx_n_s_type_label;
static PyObject *__pyx_n_s_type_sig;
static PyObject *__pyx_n_s_type_table;
static PyObject *__pyx_n_s_typesig_override;
static PyObject *__pyx_n_s_typped_pratt_parser;
static PyObject *__pyx_n_s_undef_construct;
static PyObject *__pyx_n_s_undef_token;
static PyObject *__pyx_n_s_undef_type;
static PyObject *__pyx_n_s_undef_typeobject;
static PyObject *__pyx_n_s_unregister_construct;
static PyObject *__pyx_n_s_unresolved_children;
static PyObject *__pyx_n_s_usual_lexer;
static PyObject *__pyx_kp_s_v;
static PyObject *__pyx_n_s_val_type;
static PyObject *__pyx_n_s_val_type_override;
static PyObject *__pyx_n_s_value;
static PyObject *__pyx_n_s_value_key;
static PyObject *__pyx_pf_6typped_12pratt_parser_DEFAULT_ALWAYS_TRUE_PRECOND_FUN(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_lex, CYTHON_UNUSED PyObject *__pyx_v_lookbehind); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta___new__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_mcs, PyObject *__pyx_v_name, PyObject *__pyx_v_bases, PyObject *__pyx_v_dct); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_2__repr__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_4__add__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_other); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_6__radd__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_8__or__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_other); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_10__ror__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_12__rmul__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_14__rpow__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_16__invert__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_18__getitem__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_arg); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass___init__(PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_value); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_2prec(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_4dispatch_handler(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_lex, PyObject *__pyx_v_left, PyObject *__pyx_v_lookbehind); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_6process_not_in_tree(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_8process_and_check_node(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_construct, PyObject *__pyx_v_val_type_override, PyObject *__pyx_v_all_vals_override, PyObject *__pyx_v_typesig_override); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_10_check_types_one_pass(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_12_check_types_first_of_two_passes(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_14check_types_in_tree_second_pass(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_root); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_16_check_types_pass_two(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_3genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_18_raise_type_mismatch_error(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_matching_sigs, PyObject *__pyx_v_basic_msg); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_20eval_fun(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22ast_data(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_24eval_subtree(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26get_jop_token_instance(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_lex, PyObject *__pyx_v_processed_left, PyObject *__pyx_v_lookbehind, PyObject *__pyx_v_subexp_prec); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_28get_null_string_token_and_handler(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_lex, PyObject *__pyx_v_subexp_prec, PyObject *__pyx_v_processed_left, PyObject *__pyx_v_lookbehind); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_30recursive_parse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_subexp_prec, PyObject *__pyx_v_processed_left, PyObject *__pyx_v_lookbehind); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_32__copy__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_34summary_repr_with_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_36tree_repr_with_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indent); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22string_repr_with_types_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_38string_repr_with_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_40class_repr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_2token_subclass_factory(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_4lexer_add_parser_instance_attribute(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_lexer, PyObject *__pyx_v_token); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_max_peek_tokens, PyObject *__pyx_v_max_deque_size, PyObject *__pyx_v_lexer, PyObject *__pyx_v_default_begin_end_tokens, PyObject *__pyx_v_type_table, PyObject *__pyx_v_skip_type_checking, PyObject *__pyx_v_overload_on_arg_types, PyObject *__pyx_v_overload_on_ret_types, PyObject *__pyx_v_partial_expressions, PyObject *__pyx_v_raise_on_equal_priority_preconds); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_2_next_unique_precond_label(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_autolabel_prefix); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_begin_head(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_2begin_tail(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex, CYTHON_UNUSED PyObject *__pyx_v_left); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_4end_head(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_6end_tail(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex, CYTHON_UNUSED PyObject *__pyx_v_left); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_4def_token_master(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label, PyObject *__pyx_v_regex_string, PyObject *__pyx_v_on_ties, PyObject *__pyx_v_ignore, PyObject *__pyx_v_token_kind, PyObject *__pyx_v_ignored_token_label, PyObject *__pyx_v_matcher_options); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_6def_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label, PyObject *__pyx_v_regex_string, PyObject *__pyx_v_on_ties, PyObject *__pyx_v_ignore, PyObject *__pyx_v_matcher_options); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_8def_ignored_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label, PyObject *__pyx_v_regex_string, PyObject *__pyx_v_on_ties, PyObject *__pyx_v_matcher_options); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_10def_begin_end_tokens(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_begin_token_label, PyObject *__pyx_v_end_token_label); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_12def_jop_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_jop_token_label, PyObject *__pyx_v_ignored_token_label); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_14def_null_string_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_null_string_token_label); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16get_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_18undef_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_20def_construct(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_handler_fun, PyObject *__pyx_v_trigger_token_label, PyObject *__pyx_v_prec, PyObject *__pyx_v_precond_label, PyObject *__pyx_v_precond_fun, PyObject *__pyx_v_precond_priority, PyObject *__pyx_v_val_type, PyObject *__pyx_v_arg_types, PyObject *__pyx_v_eval_fun, PyObject *__pyx_v_ast_data, PyObject *__pyx_v_value_key, PyObject *__pyx_v_autolabel_prefix, PyObject *__pyx_v_dummy_handler); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_22undef_construct(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_trigger_token_label, PyObject *__pyx_v_precond_label, PyObject *__pyx_v_val_type, PyObject *__pyx_v_arg_types, PyObject *__pyx_v_all_handlers); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_24def_type(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_type_label); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_26undef_type(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_type_label); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_28parse_from_lexer(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_lexer_to_use, PyObject *__pyx_v_pstate); /* proto */
static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_30parse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_program, PyObject *__pyx_v_pstate, PyObject *__pyx_v_partial_expressions, PyObject *__pyx_v_skip_lex_setup); /* proto */
static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_2_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_3_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_5_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_4;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__16;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__23;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__35;
static PyObject *__pyx_tuple__37;
static PyObject *__pyx_tuple__39;
static PyObject *__pyx_tuple__41;
static PyObject *__pyx_tuple__43;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__49;
static PyObject *__pyx_tuple__50;
static PyObject *__pyx_tuple__52;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__60;
static PyObject *__pyx_tuple__62;
static PyObject *__pyx_tuple__64;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__66;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__68;
static PyObject *__pyx_tuple__70;
static PyObject *__pyx_tuple__72;
static PyObject *__pyx_tuple__74;
static PyObject *__pyx_tuple__76;
static PyObject *__pyx_tuple__77;
static PyObject *__pyx_tuple__78;
static PyObject *__pyx_tuple__79;
static PyObject *__pyx_tuple__80;
static PyObject *__pyx_tuple__81;
static PyObject *__pyx_tuple__82;
static PyObject *__pyx_tuple__84;
static PyObject *__pyx_tuple__86;
static PyObject *__pyx_tuple__88;
static PyObject *__pyx_tuple__90;
static PyObject *__pyx_tuple__92;
static PyObject *__pyx_tuple__94;
static PyObject *__pyx_tuple__96;
static PyObject *__pyx_tuple__98;
static PyObject *__pyx_tuple__100;
static PyObject *__pyx_tuple__102;
static PyObject *__pyx_tuple__104;
static PyObject *__pyx_tuple__106;
static PyObject *__pyx_tuple__108;
static PyObject *__pyx_tuple__110;
static PyObject *__pyx_tuple__111;
static PyObject *__pyx_tuple__113;
static PyObject *__pyx_tuple__114;
static PyObject *__pyx_tuple__116;
static PyObject *__pyx_tuple__117;
static PyObject *__pyx_tuple__119;
static PyObject *__pyx_tuple__120;
static PyObject *__pyx_tuple__122;
static PyObject *__pyx_tuple__123;
static PyObject *__pyx_tuple__125;
static PyObject *__pyx_tuple__126;
static PyObject *__pyx_tuple__128;
static PyObject *__pyx_tuple__130;
static PyObject *__pyx_tuple__131;
static PyObject *__pyx_tuple__133;
static PyObject *__pyx_tuple__135;
static PyObject *__pyx_tuple__137;
static PyObject *__pyx_tuple__138;
static PyObject *__pyx_tuple__140;
static PyObject *__pyx_tuple__141;
static PyObject *__pyx_tuple__143;
static PyObject *__pyx_tuple__145;
static PyObject *__pyx_tuple__147;
static PyObject *__pyx_tuple__148;
static PyObject *__pyx_tuple__150;
static PyObject *__pyx_codeobj__17;
static PyObject *__pyx_codeobj__19;
static PyObject *__pyx_codeobj__21;
static PyObject *__pyx_codeobj__24;
static PyObject *__pyx_codeobj__26;
static PyObject *__pyx_codeobj__29;
static PyObject *__pyx_codeobj__31;
static PyObject *__pyx_codeobj__33;
static PyObject *__pyx_codeobj__36;
static PyObject *__pyx_codeobj__38;
static PyObject *__pyx_codeobj__40;
static PyObject *__pyx_codeobj__42;
static PyObject *__pyx_codeobj__44;
static PyObject *__pyx_codeobj__46;
static PyObject *__pyx_codeobj__48;
static PyObject *__pyx_codeobj__51;
static PyObject *__pyx_codeobj__54;
static PyObject *__pyx_codeobj__56;
static PyObject *__pyx_codeobj__58;
static PyObject *__pyx_codeobj__61;
static PyObject *__pyx_codeobj__63;
static PyObject *__pyx_codeobj__69;
static PyObject *__pyx_codeobj__71;
static PyObject *__pyx_codeobj__73;
static PyObject *__pyx_codeobj__75;
static PyObject *__pyx_codeobj__83;
static PyObject *__pyx_codeobj__85;
static PyObject *__pyx_codeobj__87;
static PyObject *__pyx_codeobj__89;
static PyObject *__pyx_codeobj__91;
static PyObject *__pyx_codeobj__93;
static PyObject *__pyx_codeobj__95;
static PyObject *__pyx_codeobj__97;
static PyObject *__pyx_codeobj__99;
static PyObject *__pyx_codeobj__101;
static PyObject *__pyx_codeobj__103;
static PyObject *__pyx_codeobj__105;
static PyObject *__pyx_codeobj__107;
static PyObject *__pyx_codeobj__109;
static PyObject *__pyx_codeobj__112;
static PyObject *__pyx_codeobj__115;
static PyObject *__pyx_codeobj__118;
static PyObject *__pyx_codeobj__121;
static PyObject *__pyx_codeobj__124;
static PyObject *__pyx_codeobj__127;
static PyObject *__pyx_codeobj__129;
static PyObject *__pyx_codeobj__132;
static PyObject *__pyx_codeobj__134;
static PyObject *__pyx_codeobj__136;
static PyObject *__pyx_codeobj__139;
static PyObject *__pyx_codeobj__142;
static PyObject *__pyx_codeobj__144;
static PyObject *__pyx_codeobj__146;
static PyObject *__pyx_codeobj__149;

/* "typped/pratt_parser.py":244
 * DEFAULT_ALWAYS_TRUE_PRECOND_LABEL = "default_always_true_precond"
 * 
 * def DEFAULT_ALWAYS_TRUE_PRECOND_FUN(lex, lookbehind):             # <<<<<<<<<<<<<<
 *     """The default precondition function; always returns true."""
 *     return True
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_1DEFAULT_ALWAYS_TRUE_PRECOND_FUN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_DEFAULT_ALWAYS_TRUE_PRECOND_FUN[] = "The default precondition function; always returns true.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_1DEFAULT_ALWAYS_TRUE_PRECOND_FUN = {"DEFAULT_ALWAYS_TRUE_PRECOND_FUN", (PyCFunction)__pyx_pw_6typped_12pratt_parser_1DEFAULT_ALWAYS_TRUE_PRECOND_FUN, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_DEFAULT_ALWAYS_TRUE_PRECOND_FUN};
static PyObject *__pyx_pw_6typped_12pratt_parser_1DEFAULT_ALWAYS_TRUE_PRECOND_FUN(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_lex = 0;
  CYTHON_UNUSED PyObject *__pyx_v_lookbehind = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("DEFAULT_ALWAYS_TRUE_PRECOND_FUN (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_lex,&__pyx_n_s_lookbehind,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lookbehind)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("DEFAULT_ALWAYS_TRUE_PRECOND_FUN", 1, 2, 2, 1); __PYX_ERR(0, 244, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "DEFAULT_ALWAYS_TRUE_PRECOND_FUN") < 0)) __PYX_ERR(0, 244, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_lex = values[0];
    __pyx_v_lookbehind = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("DEFAULT_ALWAYS_TRUE_PRECOND_FUN", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 244, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.DEFAULT_ALWAYS_TRUE_PRECOND_FUN", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_DEFAULT_ALWAYS_TRUE_PRECOND_FUN(__pyx_self, __pyx_v_lex, __pyx_v_lookbehind);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_DEFAULT_ALWAYS_TRUE_PRECOND_FUN(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_lex, CYTHON_UNUSED PyObject *__pyx_v_lookbehind) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("DEFAULT_ALWAYS_TRUE_PRECOND_FUN", 0);

  /* "typped/pratt_parser.py":246
 * def DEFAULT_ALWAYS_TRUE_PRECOND_FUN(lex, lookbehind):
 *     """The default precondition function; always returns true."""
 *     return True             # <<<<<<<<<<<<<<
 * 
 * #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":244
 * DEFAULT_ALWAYS_TRUE_PRECOND_LABEL = "default_always_true_precond"
 * 
 * def DEFAULT_ALWAYS_TRUE_PRECOND_FUN(lex, lookbehind):             # <<<<<<<<<<<<<<
 *     """The default precondition function; always returns true."""
 *     return True
 */

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":276
 *     ugly for tokens) and to overload operators to work for token operands
 *     in the EBNF-like grammar."""
 *     def __new__(mcs, name, bases, dct):             # <<<<<<<<<<<<<<
 *         new_class = super(TokenSubclassMeta, mcs).__new__(mcs, name, bases, dct)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_1__new__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_1__new__ = {"__new__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_1__new__, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_1__new__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_mcs = 0;
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_bases = 0;
  PyObject *__pyx_v_dct = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__new__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_mcs,&__pyx_n_s_name,&__pyx_n_s_bases,&__pyx_n_s_dct,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mcs)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__new__", 1, 4, 4, 1); __PYX_ERR(0, 276, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_bases)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__new__", 1, 4, 4, 2); __PYX_ERR(0, 276, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_dct)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__new__", 1, 4, 4, 3); __PYX_ERR(0, 276, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__new__") < 0)) __PYX_ERR(0, 276, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_mcs = values[0];
    __pyx_v_name = values[1];
    __pyx_v_bases = values[2];
    __pyx_v_dct = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__new__", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 276, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__new__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta___new__(__pyx_self, __pyx_v_mcs, __pyx_v_name, __pyx_v_bases, __pyx_v_dct);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta___new__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_mcs, PyObject *__pyx_v_name, PyObject *__pyx_v_bases, PyObject *__pyx_v_dct) {
  PyObject *__pyx_v_new_class = NULL;
  PyObject *__pyx_v_Tok = NULL;
  PyObject *__pyx_v_Not = NULL;
  PyObject *__pyx_v_Prec = NULL;
  PyObject *__pyx_v_nExactly = NULL;
  PyObject *__pyx_v_nOrMore = NULL;
  PyObject *__pyx_v_Repeat = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__new__", 0);

  /* "typped/pratt_parser.py":277
 *     in the EBNF-like grammar."""
 *     def __new__(mcs, name, bases, dct):
 *         new_class = super(TokenSubclassMeta, mcs).__new__(mcs, name, bases, dct)             # <<<<<<<<<<<<<<
 * 
 *         # Below is ugly, but avoids mutual import problems.  Used as an easy
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_TokenSubclassMeta); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
  __Pyx_INCREF(__pyx_v_mcs);
  __Pyx_GIVEREF(__pyx_v_mcs);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_mcs);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_new); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 277, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_mcs, __pyx_v_name, __pyx_v_bases, __pyx_v_dct};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 4+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_mcs, __pyx_v_name, __pyx_v_bases, __pyx_v_dct};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 4+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(4+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 277, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_mcs);
    __Pyx_GIVEREF(__pyx_v_mcs);
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_mcs);
    __Pyx_INCREF(__pyx_v_name);
    __Pyx_GIVEREF(__pyx_v_name);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_name);
    __Pyx_INCREF(__pyx_v_bases);
    __Pyx_GIVEREF(__pyx_v_bases);
    PyTuple_SET_ITEM(__pyx_t_5, 2+__pyx_t_4, __pyx_v_bases);
    __Pyx_INCREF(__pyx_v_dct);
    __Pyx_GIVEREF(__pyx_v_dct);
    PyTuple_SET_ITEM(__pyx_t_5, 3+__pyx_t_4, __pyx_v_dct);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 277, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_new_class = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":282
 *         # way to define token addition so that it works in the grammars defined
 *         # by the ebnf_classes_and_operators module.
 *         from .ebnf_classes_and_operators import (Tok, Not, Prec, nExactly, nOrMore, Repeat)             # <<<<<<<<<<<<<<
 *         # These are saved in a dict below because if they are made attributes
 *         # then Python 2 complains about "TypeError: unbound method Tok() must
 */
  __pyx_t_1 = PyList_New(6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_Tok);
  __Pyx_GIVEREF(__pyx_n_s_Tok);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Tok);
  __Pyx_INCREF(__pyx_n_s_Not);
  __Pyx_GIVEREF(__pyx_n_s_Not);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_Not);
  __Pyx_INCREF(__pyx_n_s_Prec);
  __Pyx_GIVEREF(__pyx_n_s_Prec);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_Prec);
  __Pyx_INCREF(__pyx_n_s_nExactly);
  __Pyx_GIVEREF(__pyx_n_s_nExactly);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_s_nExactly);
  __Pyx_INCREF(__pyx_n_s_nOrMore);
  __Pyx_GIVEREF(__pyx_n_s_nOrMore);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_n_s_nOrMore);
  __Pyx_INCREF(__pyx_n_s_Repeat);
  __Pyx_GIVEREF(__pyx_n_s_Repeat);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_n_s_Repeat);
  __pyx_t_3 = __Pyx_Import(__pyx_n_s_ebnf_classes_and_operators, __pyx_t_1, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_Tok); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_Tok = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_Not); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_Not = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_Prec); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_Prec = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_nExactly); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_nExactly = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_nOrMore); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_nOrMore = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_Repeat); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_Repeat = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":288
 *         # TokenSubclassMeta instance instead)".
 *         new_class.prod_rule_funs = {
 *                 "Tok": Tok,             # <<<<<<<<<<<<<<
 *                 "Not": Not,
 *                 "Prec": Prec,
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 288, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_Tok, __pyx_v_Tok) < 0) __PYX_ERR(0, 288, __pyx_L1_error)

  /* "typped/pratt_parser.py":289
 *         new_class.prod_rule_funs = {
 *                 "Tok": Tok,
 *                 "Not": Not,             # <<<<<<<<<<<<<<
 *                 "Prec": Prec,
 *                 "nExactly": nExactly,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_Not, __pyx_v_Not) < 0) __PYX_ERR(0, 288, __pyx_L1_error)

  /* "typped/pratt_parser.py":290
 *                 "Tok": Tok,
 *                 "Not": Not,
 *                 "Prec": Prec,             # <<<<<<<<<<<<<<
 *                 "nExactly": nExactly,
 *                 "nOrMore": nOrMore,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_Prec, __pyx_v_Prec) < 0) __PYX_ERR(0, 288, __pyx_L1_error)

  /* "typped/pratt_parser.py":291
 *                 "Not": Not,
 *                 "Prec": Prec,
 *                 "nExactly": nExactly,             # <<<<<<<<<<<<<<
 *                 "nOrMore": nOrMore,
 *                 "Repeat": Repeat,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_nExactly, __pyx_v_nExactly) < 0) __PYX_ERR(0, 288, __pyx_L1_error)

  /* "typped/pratt_parser.py":292
 *                 "Prec": Prec,
 *                 "nExactly": nExactly,
 *                 "nOrMore": nOrMore,             # <<<<<<<<<<<<<<
 *                 "Repeat": Repeat,
 *                 }
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_nOrMore, __pyx_v_nOrMore) < 0) __PYX_ERR(0, 288, __pyx_L1_error)

  /* "typped/pratt_parser.py":293
 *                 "nExactly": nExactly,
 *                 "nOrMore": nOrMore,
 *                 "Repeat": Repeat,             # <<<<<<<<<<<<<<
 *                 }
 *         return new_class
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_Repeat, __pyx_v_Repeat) < 0) __PYX_ERR(0, 288, __pyx_L1_error)

  /* "typped/pratt_parser.py":287
 *         # be called with TokenClass_k_lpar instance as first argument (got
 *         # TokenSubclassMeta instance instead)".
 *         new_class.prod_rule_funs = {             # <<<<<<<<<<<<<<
 *                 "Tok": Tok,
 *                 "Not": Not,
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_new_class, __pyx_n_s_prod_rule_funs, __pyx_t_3) < 0) __PYX_ERR(0, 287, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":295
 *                 "Repeat": Repeat,
 *                 }
 *         return new_class             # <<<<<<<<<<<<<<
 * 
 *     #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_new_class);
  __pyx_r = __pyx_v_new_class;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":276
 *     ugly for tokens) and to overload operators to work for token operands
 *     in the EBNF-like grammar."""
 *     def __new__(mcs, name, bases, dct):             # <<<<<<<<<<<<<<
 *         new_class = super(TokenSubclassMeta, mcs).__new__(mcs, name, bases, dct)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__new__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_new_class);
  __Pyx_XDECREF(__pyx_v_Tok);
  __Pyx_XDECREF(__pyx_v_Not);
  __Pyx_XDECREF(__pyx_v_Prec);
  __Pyx_XDECREF(__pyx_v_nExactly);
  __Pyx_XDECREF(__pyx_v_nOrMore);
  __Pyx_XDECREF(__pyx_v_Repeat);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":301
 *     #
 * 
 *     def __repr__(cls):             # <<<<<<<<<<<<<<
 *         """The representation for tokens.  Tokens are commonly used in the
 *         code but, being classes, have an ugly default `__repr__` when printed out.
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_3__repr__(PyObject *__pyx_self, PyObject *__pyx_v_cls); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_2__repr__[] = "The representation for tokens.  Tokens are commonly used in the\n        code but, being classes, have an ugly default `__repr__` when printed out.\n        In this metaclass we can define a better `__repr__` for tokens.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_3__repr__ = {"__repr__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_3__repr__, METH_O, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_2__repr__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_3__repr__(PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__repr__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_2__repr__(__pyx_self, ((PyObject *)__pyx_v_cls));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_2__repr__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_v_string = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__repr__", 0);

  /* "typped/pratt_parser.py":305
 *         code but, being classes, have an ugly default `__repr__` when printed out.
 *         In this metaclass we can define a better `__repr__` for tokens."""
 *         string = "TokenClass_{0}".format(cls.token_label)             # <<<<<<<<<<<<<<
 *         return string
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_TokenClass__0, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 305, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_token_label); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 305, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 305, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 305, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 305, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 305, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 305, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_string = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":306
 *         In this metaclass we can define a better `__repr__` for tokens."""
 *         string = "TokenClass_{0}".format(cls.token_label)
 *         return string             # <<<<<<<<<<<<<<
 * 
 *     #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_string);
  __pyx_r = __pyx_v_string;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":301
 *     #
 * 
 *     def __repr__(cls):             # <<<<<<<<<<<<<<
 *         """The representation for tokens.  Tokens are commonly used in the
 *         code but, being classes, have an ugly default `__repr__` when printed out.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__repr__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_string);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":321
 *     # should catch most accidentals just because of that.
 * 
 *     def __add__(cls, other):             # <<<<<<<<<<<<<<
 *         """Addition of two tokens is defined to simply return a tuple of
 *         both tokens.  This is so raw tokens can be used in the operator
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_5__add__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_4__add__[] = "Addition of two tokens is defined to simply return a tuple of\n        both tokens.  This is so raw tokens can be used in the operator\n        overloaded form of defining production rules for a grammar.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_5__add__ = {"__add__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_5__add__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_4__add__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_5__add__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_cls = 0;
  PyObject *__pyx_v_other = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__add__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_other,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_other)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__add__", 1, 2, 2, 1); __PYX_ERR(0, 321, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__add__") < 0)) __PYX_ERR(0, 321, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_cls = values[0];
    __pyx_v_other = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__add__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 321, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__add__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_4__add__(__pyx_self, __pyx_v_cls, __pyx_v_other);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_4__add__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_other) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__add__", 0);

  /* "typped/pratt_parser.py":325
 *         both tokens.  This is so raw tokens can be used in the operator
 *         overloaded form of defining production rules for a grammar."""
 *         return cls.prod_rule_funs["Tok"](cls) + other             # <<<<<<<<<<<<<<
 * 
 *     def __radd__(cls, left_other):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 325, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_Tok); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 325, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_cls); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 325, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 325, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 325, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 325, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_cls);
      __Pyx_GIVEREF(__pyx_v_cls);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_cls);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 325, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_v_other); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 325, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":321
 *     # should catch most accidentals just because of that.
 * 
 *     def __add__(cls, other):             # <<<<<<<<<<<<<<
 *         """Addition of two tokens is defined to simply return a tuple of
 *         both tokens.  This is so raw tokens can be used in the operator
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__add__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":327
 *         return cls.prod_rule_funs["Tok"](cls) + other
 * 
 *     def __radd__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__add__` above."""
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_7__radd__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_6__radd__[] = "The right version of `__add__` above.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_7__radd__ = {"__radd__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_7__radd__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_6__radd__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_7__radd__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_cls = 0;
  PyObject *__pyx_v_left_other = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__radd__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_left_other,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left_other)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__radd__", 1, 2, 2, 1); __PYX_ERR(0, 327, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__radd__") < 0)) __PYX_ERR(0, 327, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_cls = values[0];
    __pyx_v_left_other = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__radd__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 327, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__radd__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_6__radd__(__pyx_self, __pyx_v_cls, __pyx_v_left_other);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_6__radd__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__radd__", 0);

  /* "typped/pratt_parser.py":329
 *     def __radd__(cls, left_other):
 *         """The right version of `__add__` above."""
 *         return left_other + cls.prod_rule_funs["Tok"](cls)             # <<<<<<<<<<<<<<
 * 
 *     def __or__(cls, other):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_Tok); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_cls); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 329, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 329, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 329, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 329, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_cls);
      __Pyx_GIVEREF(__pyx_v_cls);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_cls);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 329, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyNumber_Add(__pyx_v_left_other, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":327
 *         return cls.prod_rule_funs["Tok"](cls) + other
 * 
 *     def __radd__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__add__` above."""
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__radd__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":331
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __or__(cls, other):             # <<<<<<<<<<<<<<
 *         """The `|` symbol simply converts this object into an `ItemList`
 *         and then calls `__or__` for those objects."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_9__or__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_8__or__[] = "The `|` symbol simply converts this object into an `ItemList`\n        and then calls `__or__` for those objects.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_9__or__ = {"__or__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_9__or__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_8__or__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_9__or__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_cls = 0;
  PyObject *__pyx_v_other = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__or__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_other,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_other)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__or__", 1, 2, 2, 1); __PYX_ERR(0, 331, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__or__") < 0)) __PYX_ERR(0, 331, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_cls = values[0];
    __pyx_v_other = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__or__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 331, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__or__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_8__or__(__pyx_self, __pyx_v_cls, __pyx_v_other);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_8__or__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_other) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__or__", 0);

  /* "typped/pratt_parser.py":334
 *         """The `|` symbol simply converts this object into an `ItemList`
 *         and then calls `__or__` for those objects."""
 *         return cls.prod_rule_funs["Tok"](cls) | other             # <<<<<<<<<<<<<<
 * 
 *     def __ror__(cls, left_other):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 334, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_Tok); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 334, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_cls); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 334, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 334, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 334, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 334, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_cls);
      __Pyx_GIVEREF(__pyx_v_cls);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_cls);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 334, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyNumber_Or(__pyx_t_1, __pyx_v_other); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 334, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":331
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __or__(cls, other):             # <<<<<<<<<<<<<<
 *         """The `|` symbol simply converts this object into an `ItemList`
 *         and then calls `__or__` for those objects."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__or__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":336
 *         return cls.prod_rule_funs["Tok"](cls) | other
 * 
 *     def __ror__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__or__` above."""
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_11__ror__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_10__ror__[] = "The right version of `__or__` above.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_11__ror__ = {"__ror__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_11__ror__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_10__ror__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_11__ror__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_cls = 0;
  PyObject *__pyx_v_left_other = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__ror__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_left_other,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left_other)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__ror__", 1, 2, 2, 1); __PYX_ERR(0, 336, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__ror__") < 0)) __PYX_ERR(0, 336, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_cls = values[0];
    __pyx_v_left_other = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__ror__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 336, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__ror__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_10__ror__(__pyx_self, __pyx_v_cls, __pyx_v_left_other);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_10__ror__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__ror__", 0);

  /* "typped/pratt_parser.py":338
 *     def __ror__(cls, left_other):
 *         """The right version of `__or__` above."""
 *         return left_other | cls.prod_rule_funs["Tok"](cls)             # <<<<<<<<<<<<<<
 * 
 *     def __rmul__(cls, left_other):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_Tok); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_cls); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 338, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 338, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 338, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 338, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_cls);
      __Pyx_GIVEREF(__pyx_v_cls);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_cls);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 338, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyNumber_Or(__pyx_v_left_other, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":336
 *         return cls.prod_rule_funs["Tok"](cls) | other
 * 
 *     def __ror__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__or__` above."""
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__ror__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":340
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __rmul__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n*token` for an int `n` is "n occurrences of"
 *         `token`."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_13__rmul__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_12__rmul__[] = "The expression `n*token` for an int `n` is \"n occurrences of\"\n        `token`.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_13__rmul__ = {"__rmul__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_13__rmul__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_12__rmul__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_13__rmul__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_cls = 0;
  PyObject *__pyx_v_left_other = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__rmul__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_left_other,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left_other)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__rmul__", 1, 2, 2, 1); __PYX_ERR(0, 340, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__rmul__") < 0)) __PYX_ERR(0, 340, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_cls = values[0];
    __pyx_v_left_other = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__rmul__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 340, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__rmul__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_12__rmul__(__pyx_self, __pyx_v_cls, __pyx_v_left_other);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_12__rmul__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__rmul__", 0);

  /* "typped/pratt_parser.py":343
 *         """The expression `n*token` for an int `n` is "n occurrences of"
 *         `token`."""
 *         return cls.prod_rule_funs["Repeat"](left_other, cls)             # <<<<<<<<<<<<<<
 * 
 *     def __rpow__(cls, left_other):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 343, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_Repeat); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 343, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_left_other, __pyx_v_cls};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 343, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_left_other, __pyx_v_cls};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 343, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 343, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_left_other);
    __Pyx_GIVEREF(__pyx_v_left_other);
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_left_other);
    __Pyx_INCREF(__pyx_v_cls);
    __Pyx_GIVEREF(__pyx_v_cls);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_cls);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 343, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":340
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __rmul__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n*token` for an int `n` is "n occurrences of"
 *         `token`."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__rmul__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":345
 *         return cls.prod_rule_funs["Repeat"](left_other, cls)
 * 
 *     def __rpow__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n**token` for an int `n` is "n or more occurrences of"
 *         `token`."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_15__rpow__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_14__rpow__[] = "The expression `n**token` for an int `n` is \"n or more occurrences of\"\n        `token`.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_15__rpow__ = {"__rpow__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_15__rpow__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_14__rpow__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_15__rpow__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_cls = 0;
  PyObject *__pyx_v_left_other = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__rpow__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_left_other,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left_other)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__rpow__", 1, 2, 2, 1); __PYX_ERR(0, 345, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__rpow__") < 0)) __PYX_ERR(0, 345, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_cls = values[0];
    __pyx_v_left_other = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__rpow__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 345, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__rpow__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_14__rpow__(__pyx_self, __pyx_v_cls, __pyx_v_left_other);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_14__rpow__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_left_other) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__rpow__", 0);

  /* "typped/pratt_parser.py":348
 *         """The expression `n**token` for an int `n` is "n or more occurrences of"
 *         `token`."""
 *         return cls.prod_rule_funs["nOrMore"](left_other, cls)             # <<<<<<<<<<<<<<
 * 
 *     def __invert__(cls):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 348, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_nOrMore); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 348, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_left_other, __pyx_v_cls};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_left_other, __pyx_v_cls};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_left_other);
    __Pyx_GIVEREF(__pyx_v_left_other);
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_left_other);
    __Pyx_INCREF(__pyx_v_cls);
    __Pyx_GIVEREF(__pyx_v_cls);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_cls);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 348, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":345
 *         return cls.prod_rule_funs["Repeat"](left_other, cls)
 * 
 *     def __rpow__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n**token` for an int `n` is "n or more occurrences of"
 *         `token`."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__rpow__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":350
 *         return cls.prod_rule_funs["nOrMore"](left_other, cls)
 * 
 *     def __invert__(cls):             # <<<<<<<<<<<<<<
 *         """Define the `~` operator for production rule grammars."""
 *         return cls.prod_rule_funs["Not"](cls)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_17__invert__(PyObject *__pyx_self, PyObject *__pyx_v_cls); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_16__invert__[] = "Define the `~` operator for production rule grammars.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_17__invert__ = {"__invert__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_17__invert__, METH_O, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_16__invert__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_17__invert__(PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__invert__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_16__invert__(__pyx_self, ((PyObject *)__pyx_v_cls));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_16__invert__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__invert__", 0);

  /* "typped/pratt_parser.py":352
 *     def __invert__(cls):
 *         """Define the `~` operator for production rule grammars."""
 *         return cls.prod_rule_funs["Not"](cls)             # <<<<<<<<<<<<<<
 * 
 *     def __getitem__(cls, arg):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_Not); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_cls); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 352, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 352, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_cls};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 352, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 352, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_cls);
      __Pyx_GIVEREF(__pyx_v_cls);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_cls);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 352, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":350
 *         return cls.prod_rule_funs["nOrMore"](left_other, cls)
 * 
 *     def __invert__(cls):             # <<<<<<<<<<<<<<
 *         """Define the `~` operator for production rule grammars."""
 *         return cls.prod_rule_funs["Not"](cls)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__invert__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":354
 *         return cls.prod_rule_funs["Not"](cls)
 * 
 *     def __getitem__(cls, arg):             # <<<<<<<<<<<<<<
 *         """Define the bracket indexing operator for production rule grammars
 *         to set the precedence."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_19__getitem__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_18__getitem__[] = "Define the bracket indexing operator for production rule grammars\n        to set the precedence.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_19__getitem__ = {"__getitem__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_19__getitem__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_17TokenSubclassMeta_18__getitem__};
static PyObject *__pyx_pw_6typped_12pratt_parser_17TokenSubclassMeta_19__getitem__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_cls = 0;
  PyObject *__pyx_v_arg = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getitem__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_cls,&__pyx_n_s_arg,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_cls)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_arg)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__getitem__", 1, 2, 2, 1); __PYX_ERR(0, 354, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__getitem__") < 0)) __PYX_ERR(0, 354, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_cls = values[0];
    __pyx_v_arg = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__getitem__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 354, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_18__getitem__(__pyx_self, __pyx_v_cls, __pyx_v_arg);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_17TokenSubclassMeta_18__getitem__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls, PyObject *__pyx_v_arg) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__getitem__", 0);

  /* "typped/pratt_parser.py":357
 *         """Define the bracket indexing operator for production rule grammars
 *         to set the precedence."""
 *         return cls.prod_rule_funs["Prec"](cls, arg)             # <<<<<<<<<<<<<<
 * 
 * def token_subclass_factory():
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_prod_rule_funs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 357, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyObject_GetItem(__pyx_t_2, __pyx_n_s_Prec); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 357, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_cls, __pyx_v_arg};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_cls, __pyx_v_arg};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_cls);
    __Pyx_GIVEREF(__pyx_v_cls);
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_cls);
    __Pyx_INCREF(__pyx_v_arg);
    __Pyx_GIVEREF(__pyx_v_arg);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_arg);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":354
 *         return cls.prod_rule_funs["Not"](cls)
 * 
 *     def __getitem__(cls, arg):             # <<<<<<<<<<<<<<
 *         """Define the bracket indexing operator for production rule grammars
 *         to set the precedence."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.TokenSubclassMeta.__getitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":359
 *         return cls.prod_rule_funs["Prec"](cls, arg)
 * 
 * def token_subclass_factory():             # <<<<<<<<<<<<<<
 *     """This function is called from the `create_token_subclass` method of
 *     `TokenTable` when it needs to create a new subclass to begin
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_3token_subclass_factory(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_2token_subclass_factory[] = "This function is called from the `create_token_subclass` method of\n    `TokenTable` when it needs to create a new subclass to begin\n    with.  It should not be called directly.\n\n    Create and return a new token subclass which will be modified and used\n    to represent a particular kind of token.  Specifically, each scanned token\n    matching the regex defined for tokens with a given token label is\n    represented as an instance of the subclass created by calling this function\n    (with further attributes, such as the token label, added to it).\n\n    Using a separate subclass for each token label allows for attributes\n    specific to a kind of token (including head and tail handler methods) to\n    later be added to the class itself without conflicts.  This function\n    returns a bare-bones subclass without any head or tail functions, etc.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_3token_subclass_factory = {"token_subclass_factory", (PyCFunction)__pyx_pw_6typped_12pratt_parser_3token_subclass_factory, METH_NOARGS, __pyx_doc_6typped_12pratt_parser_2token_subclass_factory};
static PyObject *__pyx_pw_6typped_12pratt_parser_3token_subclass_factory(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("token_subclass_factory (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_2token_subclass_factory(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":384
 *         #parser_instance = None # Set during parsing by recursive_parse. AVOID if not needed.
 * 
 *         def __init__(self, value):             # <<<<<<<<<<<<<<
 *             """Initialize an instance of the subclass for a token of the kind
 *             labeled with `token_label`.  The `value` is the actual parsed
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass___init__[] = "Initialize an instance of the subclass for a token of the kind\n            labeled with `token_label`.  The `value` is the actual parsed\n            string from the text.  This instance represents the token.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_1__init__ = {"__init__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_1__init__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass___init__};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_value,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 384, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 384, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_value = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 384, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass___init__(__pyx_self, __pyx_v_self, __pyx_v_value);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass___init__(PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_value) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *__pyx_cur_scope;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *__pyx_outer_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__init__", 0);
  __pyx_outer_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;

  /* "typped/pratt_parser.py":388
 *             labeled with `token_label`.  The `value` is the actual parsed
 *             string from the text.  This instance represents the token."""
 *             super(TokenSubclass, self).__init__() # Call base class __init__.             # <<<<<<<<<<<<<<
 *             self.value = value # Set from lex.token_generator; static value=None.
 * 
 */
  if (unlikely(!__pyx_cur_scope->__pyx_v_TokenSubclass)) { __Pyx_RaiseClosureNameError("TokenSubclass"); __PYX_ERR(0, 388, __pyx_L1_error) }
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 388, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_TokenSubclass);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_TokenSubclass);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_cur_scope->__pyx_v_TokenSubclass);
  __Pyx_INCREF(__pyx_v_self);
  __Pyx_GIVEREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_self);
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 388, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_init); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 388, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 388, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 388, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":389
 *             string from the text.  This instance represents the token."""
 *             super(TokenSubclass, self).__init__() # Call base class __init__.
 *             self.value = value # Set from lex.token_generator; static value=None.             # <<<<<<<<<<<<<<
 * 
 *             # The `expanded_formal_sig` attr is set upon parsing.  It is the
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_value, __pyx_v_value) < 0) __PYX_ERR(0, 389, __pyx_L1_error)

  /* "typped/pratt_parser.py":405
 *             # return types is turned off then these dicts are keyed only on the
 *             # argument portion of the original typesig.)
 *             self.original_formal_sig = "Unresolved" # The matching orig sig.             # <<<<<<<<<<<<<<
 *             self.expanded_formal_sig = "Unresolved" # Expanded version of above.
 *             self.actual_sig = "Unresolved" # The actual signature.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_original_formal_sig, __pyx_n_s_Unresolved) < 0) __PYX_ERR(0, 405, __pyx_L1_error)

  /* "typped/pratt_parser.py":406
 *             # argument portion of the original typesig.)
 *             self.original_formal_sig = "Unresolved" # The matching orig sig.
 *             self.expanded_formal_sig = "Unresolved" # Expanded version of above.             # <<<<<<<<<<<<<<
 *             self.actual_sig = "Unresolved" # The actual signature.
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig, __pyx_n_s_Unresolved) < 0) __PYX_ERR(0, 406, __pyx_L1_error)

  /* "typped/pratt_parser.py":407
 *             self.original_formal_sig = "Unresolved" # The matching orig sig.
 *             self.expanded_formal_sig = "Unresolved" # Expanded version of above.
 *             self.actual_sig = "Unresolved" # The actual signature.             # <<<<<<<<<<<<<<
 * 
 *         @classmethod
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_actual_sig, __pyx_n_s_Unresolved) < 0) __PYX_ERR(0, 407, __pyx_L1_error)

  /* "typped/pratt_parser.py":384
 *         #parser_instance = None # Set during parsing by recursive_parse. AVOID if not needed.
 * 
 *         def __init__(self, value):             # <<<<<<<<<<<<<<
 *             """Initialize an instance of the subclass for a token of the kind
 *             labeled with `token_label`.  The `value` is the actual parsed
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":410
 * 
 *         @classmethod
 *         def prec(cls):             # <<<<<<<<<<<<<<
 *             """Return the precedence for the token.  This is currently a static
 *             value for each type of token.  Later it may be dynamic value
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_3prec(PyObject *__pyx_self, PyObject *__pyx_v_cls); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_2prec[] = "Return the precedence for the token.  This is currently a static\n            value for each type of token.  Later it may be dynamic value\n            associated with the particular tail function which is selected in a\n            given context.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_3prec = {"prec", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_3prec, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_2prec};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_3prec(PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("prec (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_2prec(__pyx_self, ((PyObject *)__pyx_v_cls));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_2prec(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("prec", 0);

  /* "typped/pratt_parser.py":415
 *             associated with the particular tail function which is selected in a
 *             given context."""
 *             return cls.static_prec             # <<<<<<<<<<<<<<
 * 
 *         def dispatch_handler(self, head_or_tail, lex, left=None, lookbehind=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_static_prec); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 415, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":410
 * 
 *         @classmethod
 *         def prec(cls):             # <<<<<<<<<<<<<<
 *             """Return the precedence for the token.  This is currently a static
 *             value for each type of token.  Later it may be dynamic value
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.prec", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":417
 *             return cls.static_prec
 * 
 *         def dispatch_handler(self, head_or_tail, lex, left=None, lookbehind=None):             # <<<<<<<<<<<<<<
 *             """Dispatch a callable function what will work as a handler.  The
 *             function also does type-checking after running the defined handler."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_5dispatch_handler(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_4dispatch_handler[] = "Dispatch a callable function what will work as a handler.  The\n            function also does type-checking after running the defined handler.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_5dispatch_handler = {"dispatch_handler", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_5dispatch_handler, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_4dispatch_handler};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_5dispatch_handler(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_head_or_tail = 0;
  PyObject *__pyx_v_lex = 0;
  PyObject *__pyx_v_left = 0;
  PyObject *__pyx_v_lookbehind = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("dispatch_handler (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_head_or_tail,&__pyx_n_s_lex,&__pyx_n_s_left,&__pyx_n_s_lookbehind,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)((PyObject *)Py_None));
    values[4] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_head_or_tail)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("dispatch_handler", 0, 3, 5, 1); __PYX_ERR(0, 417, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("dispatch_handler", 0, 3, 5, 2); __PYX_ERR(0, 417, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lookbehind);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "dispatch_handler") < 0)) __PYX_ERR(0, 417, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_head_or_tail = values[1];
    __pyx_v_lex = values[2];
    __pyx_v_left = values[3];
    __pyx_v_lookbehind = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("dispatch_handler", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 417, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.dispatch_handler", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_4dispatch_handler(__pyx_self, __pyx_v_self, __pyx_v_head_or_tail, __pyx_v_lex, __pyx_v_left, __pyx_v_lookbehind);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_4dispatch_handler(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_lex, PyObject *__pyx_v_left, PyObject *__pyx_v_lookbehind) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("dispatch_handler", 0);

  /* "typped/pratt_parser.py":420
 *             """Dispatch a callable function what will work as a handler.  The
 *             function also does type-checking after running the defined handler."""
 *             return self.parser_instance.construct_table.dispatch_handler(             # <<<<<<<<<<<<<<
 *                                         head_or_tail, self, lex, left, lookbehind)
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parser_instance); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 420, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_construct_table); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 420, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_dispatch_handler); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 420, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":421
 *             function also does type-checking after running the defined handler."""
 *             return self.parser_instance.construct_table.dispatch_handler(
 *                                         head_or_tail, self, lex, left, lookbehind)             # <<<<<<<<<<<<<<
 * 
 *         def process_not_in_tree(self):
 */
  __pyx_t_3 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[6] = {__pyx_t_3, __pyx_v_head_or_tail, __pyx_v_self, __pyx_v_lex, __pyx_v_left, __pyx_v_lookbehind};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 5+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 420, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[6] = {__pyx_t_3, __pyx_v_head_or_tail, __pyx_v_self, __pyx_v_lex, __pyx_v_left, __pyx_v_lookbehind};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 5+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 420, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(5+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 420, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(__pyx_v_head_or_tail);
    __Pyx_GIVEREF(__pyx_v_head_or_tail);
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_head_or_tail);
    __Pyx_INCREF(__pyx_v_self);
    __Pyx_GIVEREF(__pyx_v_self);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_self);
    __Pyx_INCREF(__pyx_v_lex);
    __Pyx_GIVEREF(__pyx_v_lex);
    PyTuple_SET_ITEM(__pyx_t_5, 2+__pyx_t_4, __pyx_v_lex);
    __Pyx_INCREF(__pyx_v_left);
    __Pyx_GIVEREF(__pyx_v_left);
    PyTuple_SET_ITEM(__pyx_t_5, 3+__pyx_t_4, __pyx_v_left);
    __Pyx_INCREF(__pyx_v_lookbehind);
    __Pyx_GIVEREF(__pyx_v_lookbehind);
    PyTuple_SET_ITEM(__pyx_t_5, 4+__pyx_t_4, __pyx_v_lookbehind);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 420, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":417
 *             return cls.static_prec
 * 
 *         def dispatch_handler(self, head_or_tail, lex, left=None, lookbehind=None):             # <<<<<<<<<<<<<<
 *             """Dispatch a callable function what will work as a handler.  The
 *             function also does type-checking after running the defined handler."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.dispatch_handler", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":423
 *                                         head_or_tail, self, lex, left, lookbehind)
 * 
 *         def process_not_in_tree(self):             # <<<<<<<<<<<<<<
 *             """Removes any immediate children which have `not_in_tree` set."""
 *             modified_children = []
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_7process_not_in_tree(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_6process_not_in_tree[] = "Removes any immediate children which have `not_in_tree` set.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_7process_not_in_tree = {"process_not_in_tree", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_7process_not_in_tree, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_6process_not_in_tree};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_7process_not_in_tree(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("process_not_in_tree (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_6process_not_in_tree(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_6process_not_in_tree(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_v_modified_children = NULL;
  PyObject *__pyx_v_child = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("process_not_in_tree", 0);

  /* "typped/pratt_parser.py":425
 *         def process_not_in_tree(self):
 *             """Removes any immediate children which have `not_in_tree` set."""
 *             modified_children = []             # <<<<<<<<<<<<<<
 *             for child in self.children:
 *                 if not hasattr(child, "not_in_tree"):
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 425, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_modified_children = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":426
 *             """Removes any immediate children which have `not_in_tree` set."""
 *             modified_children = []
 *             for child in self.children:             # <<<<<<<<<<<<<<
 *                 if not hasattr(child, "not_in_tree"):
 *                     modified_children.append(child)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 426, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 426, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 426, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 426, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 426, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 426, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 426, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 426, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XDECREF_SET(__pyx_v_child, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":427
 *             modified_children = []
 *             for child in self.children:
 *                 if not hasattr(child, "not_in_tree"):             # <<<<<<<<<<<<<<
 *                     modified_children.append(child)
 *                 else:
 */
    __pyx_t_5 = __Pyx_HasAttr(__pyx_v_child, __pyx_n_s_not_in_tree); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 427, __pyx_L1_error)
    __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
    if (__pyx_t_6) {

      /* "typped/pratt_parser.py":428
 *             for child in self.children:
 *                 if not hasattr(child, "not_in_tree"):
 *                     modified_children.append(child)             # <<<<<<<<<<<<<<
 *                 else:
 *                     modified_children += child.children
 */
      __pyx_t_7 = __Pyx_PyObject_Append(__pyx_v_modified_children, __pyx_v_child); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 428, __pyx_L1_error)

      /* "typped/pratt_parser.py":427
 *             modified_children = []
 *             for child in self.children:
 *                 if not hasattr(child, "not_in_tree"):             # <<<<<<<<<<<<<<
 *                     modified_children.append(child)
 *                 else:
 */
      goto __pyx_L5;
    }

    /* "typped/pratt_parser.py":430
 *                     modified_children.append(child)
 *                 else:
 *                     modified_children += child.children             # <<<<<<<<<<<<<<
 *             self.children = modified_children
 * 
 */
    /*else*/ {
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_child, __pyx_n_s_children); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 430, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_8 = PyNumber_InPlaceAdd(__pyx_v_modified_children, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 430, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF_SET(__pyx_v_modified_children, __pyx_t_8);
      __pyx_t_8 = 0;
    }
    __pyx_L5:;

    /* "typped/pratt_parser.py":426
 *             """Removes any immediate children which have `not_in_tree` set."""
 *             modified_children = []
 *             for child in self.children:             # <<<<<<<<<<<<<<
 *                 if not hasattr(child, "not_in_tree"):
 *                     modified_children.append(child)
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":431
 *                 else:
 *                     modified_children += child.children
 *             self.children = modified_children             # <<<<<<<<<<<<<<
 * 
 *         def process_and_check_node(self, construct,
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_children, __pyx_v_modified_children) < 0) __PYX_ERR(0, 431, __pyx_L1_error)

  /* "typped/pratt_parser.py":423
 *                                         head_or_tail, self, lex, left, lookbehind)
 * 
 *         def process_not_in_tree(self):             # <<<<<<<<<<<<<<
 *             """Removes any immediate children which have `not_in_tree` set."""
 *             modified_children = []
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.process_not_in_tree", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_modified_children);
  __Pyx_XDECREF(__pyx_v_child);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":433
 *             self.children = modified_children
 * 
 *         def process_and_check_node(self, construct,             # <<<<<<<<<<<<<<
 *                                    val_type_override=None, all_vals_override=None,
 *                                    typesig_override=None):
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_9process_and_check_node(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_8process_and_check_node[] = "This routine is automatically called just after a handler\n            function returns a subtree.  It is called for the root of the\n            returned subtree.  It sets some attributes and checks that the\n            actual types match some defined type signature for the function.\n\n            If `val_type_override` is set to a `TypeObject` instance then the\n            return type of both the `expanded_formal_sig` and the `actual_sig`\n            for the node is set to that type *after* the first pass of\n            processing and type-checking for the subtree is finished.  (This\n            option does not currently work for two-pass checking when\n            overloading on return types is used.)  This option is useful for\n            handling things like parentheses and brackets which inherit the\n            type of their child (assuming the parens and brackets are kept as\n            nodes in the parse tree and not eliminated).  The override value is\n            used for type-checking farther up the expression tree.\n\n            If `all_vals_override` is set to a `TypeObject` instance then all\n            the possible signatures have their `val_type` changed to that type\n            *before* any checking is done.  This should work for both one and\n            two-pass checking, but no check is made for producing duplicate\n            types due to the `val_type` changes.\n\n            The `typesig_override` argument must be a `TypeSig` instance.  If\n            set it will be *assigned* to the node as its only possible\n            `expanded_formal_sig` before type checking (instead of looking up\n            the registered ones).  Type checking then proceeds as usual.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_9process_and_check_node = {"process_and_check_node", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_9process_and_check_node, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_8process_and_check_node};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_9process_and_check_node(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_construct = 0;
  PyObject *__pyx_v_val_type_override = 0;
  PyObject *__pyx_v_all_vals_override = 0;
  PyObject *__pyx_v_typesig_override = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("process_and_check_node (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_construct,&__pyx_n_s_val_type_override,&__pyx_n_s_all_vals_override,&__pyx_n_s_typesig_override,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "typped/pratt_parser.py":434
 * 
 *         def process_and_check_node(self, construct,
 *                                    val_type_override=None, all_vals_override=None,             # <<<<<<<<<<<<<<
 *                                    typesig_override=None):
 *             """This routine is automatically called just after a handler
 */
    values[2] = ((PyObject *)((PyObject *)Py_None));
    values[3] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":435
 *         def process_and_check_node(self, construct,
 *                                    val_type_override=None, all_vals_override=None,
 *                                    typesig_override=None):             # <<<<<<<<<<<<<<
 *             """This routine is automatically called just after a handler
 *             function returns a subtree.  It is called for the root of the
 */
    values[4] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_construct)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("process_and_check_node", 0, 2, 5, 1); __PYX_ERR(0, 433, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_val_type_override);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_all_vals_override);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_typesig_override);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "process_and_check_node") < 0)) __PYX_ERR(0, 433, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_construct = values[1];
    __pyx_v_val_type_override = values[2];
    __pyx_v_all_vals_override = values[3];
    __pyx_v_typesig_override = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("process_and_check_node", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 433, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.process_and_check_node", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_8process_and_check_node(__pyx_self, __pyx_v_self, __pyx_v_construct, __pyx_v_val_type_override, __pyx_v_all_vals_override, __pyx_v_typesig_override);

  /* "typped/pratt_parser.py":433
 *             self.children = modified_children
 * 
 *         def process_and_check_node(self, construct,             # <<<<<<<<<<<<<<
 *                                    val_type_override=None, all_vals_override=None,
 *                                    typesig_override=None):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_8process_and_check_node(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_construct, PyObject *__pyx_v_val_type_override, PyObject *__pyx_v_all_vals_override, PyObject *__pyx_v_typesig_override) {
  PyObject *__pyx_v_all_possible_sigs = NULL;
  PyObject *__pyx_v_s = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  PyObject *(*__pyx_t_6)(PyObject *);
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  __Pyx_RefNannySetupContext("process_and_check_node", 0);

  /* "typped/pratt_parser.py":464
 * 
 *             # Get all the sigs registered for the node's construct.
 *             if typesig_override is not None:             # <<<<<<<<<<<<<<
 *                 all_possible_sigs = [typesig_override]
 *             else:
 */
  __pyx_t_1 = (__pyx_v_typesig_override != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":465
 *             # Get all the sigs registered for the node's construct.
 *             if typesig_override is not None:
 *                 all_possible_sigs = [typesig_override]             # <<<<<<<<<<<<<<
 *             else:
 *                 all_possible_sigs = construct.original_sigs
 */
    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 465, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_typesig_override);
    __Pyx_GIVEREF(__pyx_v_typesig_override);
    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_typesig_override);
    __pyx_v_all_possible_sigs = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":464
 * 
 *             # Get all the sigs registered for the node's construct.
 *             if typesig_override is not None:             # <<<<<<<<<<<<<<
 *                 all_possible_sigs = [typesig_override]
 *             else:
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":467
 *                 all_possible_sigs = [typesig_override]
 *             else:
 *                 all_possible_sigs = construct.original_sigs             # <<<<<<<<<<<<<<
 *             if all_vals_override:
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_construct, __pyx_n_s_original_sigs); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 467, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_all_possible_sigs = __pyx_t_3;
    __pyx_t_3 = 0;
  }
  __pyx_L3:;

  /* "typped/pratt_parser.py":468
 *             else:
 *                 all_possible_sigs = construct.original_sigs
 *             if all_vals_override:             # <<<<<<<<<<<<<<
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)
 *                                                       for s in all_possible_sigs]
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_all_vals_override); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 468, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":469
 *                 all_possible_sigs = construct.original_sigs
 *             if all_vals_override:
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)             # <<<<<<<<<<<<<<
 *                                                       for s in all_possible_sigs]
 *             self.all_possible_sigs = all_possible_sigs # Temporary attribute.
 */
    __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 469, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "typped/pratt_parser.py":470
 *             if all_vals_override:
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)
 *                                                       for s in all_possible_sigs]             # <<<<<<<<<<<<<<
 *             self.all_possible_sigs = all_possible_sigs # Temporary attribute.
 * 
 */
    if (likely(PyList_CheckExact(__pyx_v_all_possible_sigs)) || PyTuple_CheckExact(__pyx_v_all_possible_sigs)) {
      __pyx_t_4 = __pyx_v_all_possible_sigs; __Pyx_INCREF(__pyx_t_4); __pyx_t_5 = 0;
      __pyx_t_6 = NULL;
    } else {
      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_all_possible_sigs); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 470, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 470, __pyx_L1_error)
    }
    for (;;) {
      if (likely(!__pyx_t_6)) {
        if (likely(PyList_CheckExact(__pyx_t_4))) {
          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_7 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 470, __pyx_L1_error)
          #else
          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 470, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_7);
          #endif
        } else {
          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_7); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 470, __pyx_L1_error)
          #else
          __pyx_t_7 = PySequence_ITEM(__pyx_t_4, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 470, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_7);
          #endif
        }
      } else {
        __pyx_t_7 = __pyx_t_6(__pyx_t_4);
        if (unlikely(!__pyx_t_7)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 470, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_7);
      }
      __Pyx_XDECREF_SET(__pyx_v_s, __pyx_t_7);
      __pyx_t_7 = 0;

      /* "typped/pratt_parser.py":469
 *                 all_possible_sigs = construct.original_sigs
 *             if all_vals_override:
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)             # <<<<<<<<<<<<<<
 *                                                       for s in all_possible_sigs]
 *             self.all_possible_sigs = all_possible_sigs # Temporary attribute.
 */
      __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 469, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_arg_types); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 469, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_10 = NULL;
      __pyx_t_11 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
        __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_8);
        if (likely(__pyx_t_10)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
          __Pyx_INCREF(__pyx_t_10);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_8, function);
          __pyx_t_11 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_8)) {
        PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_v_all_vals_override, __pyx_t_9};
        __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 469, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_8)) {
        PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_v_all_vals_override, __pyx_t_9};
        __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 469, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      } else
      #endif
      {
        __pyx_t_12 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 469, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_12);
        if (__pyx_t_10) {
          __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_10); __pyx_t_10 = NULL;
        }
        __Pyx_INCREF(__pyx_v_all_vals_override);
        __Pyx_GIVEREF(__pyx_v_all_vals_override);
        PyTuple_SET_ITEM(__pyx_t_12, 0+__pyx_t_11, __pyx_v_all_vals_override);
        __Pyx_GIVEREF(__pyx_t_9);
        PyTuple_SET_ITEM(__pyx_t_12, 1+__pyx_t_11, __pyx_t_9);
        __pyx_t_9 = 0;
        __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_12, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 469, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      }
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_3, (PyObject*)__pyx_t_7))) __PYX_ERR(0, 469, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "typped/pratt_parser.py":470
 *             if all_vals_override:
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)
 *                                                       for s in all_possible_sigs]             # <<<<<<<<<<<<<<
 *             self.all_possible_sigs = all_possible_sigs # Temporary attribute.
 * 
 */
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_all_possible_sigs, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":468
 *             else:
 *                 all_possible_sigs = construct.original_sigs
 *             if all_vals_override:             # <<<<<<<<<<<<<<
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)
 *                                                       for s in all_possible_sigs]
 */
  }

  /* "typped/pratt_parser.py":471
 *                 all_possible_sigs = [TypeSig(all_vals_override, s.arg_types)
 *                                                       for s in all_possible_sigs]
 *             self.all_possible_sigs = all_possible_sigs # Temporary attribute.             # <<<<<<<<<<<<<<
 * 
 *             # Do the actual checking.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_all_possible_sigs, __pyx_v_all_possible_sigs) < 0) __PYX_ERR(0, 471, __pyx_L1_error)

  /* "typped/pratt_parser.py":474
 * 
 *             # Do the actual checking.
 *             if not self.parser_instance.overload_on_ret_types: # One-pass.             # <<<<<<<<<<<<<<
 *                 self._check_types_one_pass()
 *             else: # Two-pass.
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parser_instance); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 474, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_overload_on_ret_types); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 474, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 474, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = ((!__pyx_t_2) != 0);
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":475
 *             # Do the actual checking.
 *             if not self.parser_instance.overload_on_ret_types: # One-pass.
 *                 self._check_types_one_pass()             # <<<<<<<<<<<<<<
 *             else: # Two-pass.
 *                 self._check_types_first_of_two_passes()
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_types_one_pass); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 475, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (__pyx_t_7) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 475, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    } else {
      __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 475, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":474
 * 
 *             # Do the actual checking.
 *             if not self.parser_instance.overload_on_ret_types: # One-pass.             # <<<<<<<<<<<<<<
 *                 self._check_types_one_pass()
 *             else: # Two-pass.
 */
    goto __pyx_L7;
  }

  /* "typped/pratt_parser.py":477
 *                 self._check_types_one_pass()
 *             else: # Two-pass.
 *                 self._check_types_first_of_two_passes()             # <<<<<<<<<<<<<<
 *                 # If we have a *unique* matching sig, run pass two on the
 *                 # subtree.  In this case, since the signature is fixed by
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_types_first_of_two_passes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (__pyx_t_7) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 477, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    } else {
      __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 477, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":484
 *                 # subtree early.  Note `check_types_in_tree_second_pass` is
 *                 # also called on the root node from the `parse` method.
 *                 if len(self.matching_sigs) == 1: # matching_sigs set by _check_types             # <<<<<<<<<<<<<<
 *                     self.check_types_in_tree_second_pass()
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 484, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = PyObject_Length(__pyx_t_4); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 484, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = ((__pyx_t_5 == 1) != 0);
    if (__pyx_t_1) {

      /* "typped/pratt_parser.py":485
 *                 # also called on the root node from the `parse` method.
 *                 if len(self.matching_sigs) == 1: # matching_sigs set by _check_types
 *                     self.check_types_in_tree_second_pass()             # <<<<<<<<<<<<<<
 * 
 *             # Implement val_type override if set.
 */
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_types_in_tree_second_pass); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 485, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_7 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_7) {
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 485, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else {
        __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 485, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "typped/pratt_parser.py":484
 *                 # subtree early.  Note `check_types_in_tree_second_pass` is
 *                 # also called on the root node from the `parse` method.
 *                 if len(self.matching_sigs) == 1: # matching_sigs set by _check_types             # <<<<<<<<<<<<<<
 *                     self.check_types_in_tree_second_pass()
 * 
 */
    }
  }
  __pyx_L7:;

  /* "typped/pratt_parser.py":488
 * 
 *             # Implement val_type override if set.
 *             if val_type_override:             # <<<<<<<<<<<<<<
 *                 # Note that the original_formal_sig attribute was already set.
 *                 # The ast_data and eval_fun are keyed on that.
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_val_type_override); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 488, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":491
 *                 # Note that the original_formal_sig attribute was already set.
 *                 # The ast_data and eval_fun are keyed on that.
 *                 self.expanded_formal_sig = TypeSig(val_type_override,             # <<<<<<<<<<<<<<
 *                                                    self.expanded_formal_sig.arg_types)
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 491, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "typped/pratt_parser.py":492
 *                 # The ast_data and eval_fun are keyed on that.
 *                 self.expanded_formal_sig = TypeSig(val_type_override,
 *                                                    self.expanded_formal_sig.arg_types)             # <<<<<<<<<<<<<<
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)
 * 
 */
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 492, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_arg_types); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 492, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_val_type_override, __pyx_t_8};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 491, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_val_type_override, __pyx_t_8};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 491, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    } else
    #endif
    {
      __pyx_t_12 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 491, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_INCREF(__pyx_v_val_type_override);
      __Pyx_GIVEREF(__pyx_v_val_type_override);
      PyTuple_SET_ITEM(__pyx_t_12, 0+__pyx_t_11, __pyx_v_val_type_override);
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_12, 1+__pyx_t_11, __pyx_t_8);
      __pyx_t_8 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_12, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 491, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":491
 *                 # Note that the original_formal_sig attribute was already set.
 *                 # The ast_data and eval_fun are keyed on that.
 *                 self.expanded_formal_sig = TypeSig(val_type_override,             # <<<<<<<<<<<<<<
 *                                                    self.expanded_formal_sig.arg_types)
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig, __pyx_t_4) < 0) __PYX_ERR(0, 491, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":493
 *                 self.expanded_formal_sig = TypeSig(val_type_override,
 *                                                    self.expanded_formal_sig.arg_types)
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)             # <<<<<<<<<<<<<<
 * 
 *         def _check_types_one_pass(self):
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 493, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_actual_sig); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 493, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_12);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_arg_types); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 493, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    __pyx_t_12 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_12)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_12);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_v_val_type_override, __pyx_t_8};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 493, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_v_val_type_override, __pyx_t_8};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 493, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    } else
    #endif
    {
      __pyx_t_7 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 493, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (__pyx_t_12) {
        __Pyx_GIVEREF(__pyx_t_12); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_12); __pyx_t_12 = NULL;
      }
      __Pyx_INCREF(__pyx_v_val_type_override);
      __Pyx_GIVEREF(__pyx_v_val_type_override);
      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_11, __pyx_v_val_type_override);
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_11, __pyx_t_8);
      __pyx_t_8 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 493, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_actual_sig, __pyx_t_4) < 0) __PYX_ERR(0, 493, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":488
 * 
 *             # Implement val_type override if set.
 *             if val_type_override:             # <<<<<<<<<<<<<<
 *                 # Note that the original_formal_sig attribute was already set.
 *                 # The ast_data and eval_fun are keyed on that.
 */
  }

  /* "typped/pratt_parser.py":433
 *             self.children = modified_children
 * 
 *         def process_and_check_node(self, construct,             # <<<<<<<<<<<<<<
 *                                    val_type_override=None, all_vals_override=None,
 *                                    typesig_override=None):
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.process_and_check_node", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_all_possible_sigs);
  __Pyx_XDECREF(__pyx_v_s);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":495
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)
 * 
 *         def _check_types_one_pass(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to check
 *             the actual types against their signatures when overloading is only on
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_11_check_types_one_pass(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_10_check_types_one_pass[] = "Utility function called from `process_and_check_node` to check\n            the actual types against their signatures when overloading is only on\n            argument types.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_11_check_types_one_pass = {"_check_types_one_pass", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_11_check_types_one_pass, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_10_check_types_one_pass};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_11_check_types_one_pass(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_types_one_pass (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_10_check_types_one_pass(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_10_check_types_one_pass(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_v_all_possible_sigs = NULL;
  PyObject *__pyx_v_list_of_child_sig_lists = NULL;
  PyObject *__pyx_v_c = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  PyObject *(*__pyx_t_5)(PyObject *);
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  __Pyx_RefNannySetupContext("_check_types_one_pass", 0);

  /* "typped/pratt_parser.py":499
 *             the actual types against their signatures when overloading is only on
 *             argument types."""
 *             all_possible_sigs = self.all_possible_sigs             # <<<<<<<<<<<<<<
 * 
 *             # One-pass, each child c has a unique c.expanded_formal_sig already set.
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_all_possible_sigs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 499, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_all_possible_sigs = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":502
 * 
 *             # One-pass, each child c has a unique c.expanded_formal_sig already set.
 *             list_of_child_sig_lists = [[c.expanded_formal_sig] for c in self.children]             # <<<<<<<<<<<<<<
 * 
 *             # Reduce to only the signatures that the types of the children match.
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 502, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
    __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
  } else {
    __pyx_t_4 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 502, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 502, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  for (;;) {
    if (likely(!__pyx_t_5)) {
      if (likely(PyList_CheckExact(__pyx_t_3))) {
        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 502, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      } else {
        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 502, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      }
    } else {
      __pyx_t_2 = __pyx_t_5(__pyx_t_3);
      if (unlikely(!__pyx_t_2)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 502, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_2);
    }
    __Pyx_XDECREF_SET(__pyx_v_c, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_c, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 502, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = PyList_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 502, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_2);
    PyList_SET_ITEM(__pyx_t_6, 0, __pyx_t_2);
    __pyx_t_2 = 0;
    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 502, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_list_of_child_sig_lists = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":505
 * 
 *             # Reduce to only the signatures that the types of the children match.
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(             # <<<<<<<<<<<<<<
 *                                       all_possible_sigs, list_of_child_sig_lists,
 *                                       tnode=self)
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 505, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get_all_matching_expanded_sigs); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 505, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":506
 *             # Reduce to only the signatures that the types of the children match.
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(
 *                                       all_possible_sigs, list_of_child_sig_lists,             # <<<<<<<<<<<<<<
 *                                       tnode=self)
 *             # Below all_possible_sigs is saved ONLY for printing error messages.
 */
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 505, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_all_possible_sigs);
  __Pyx_GIVEREF(__pyx_v_all_possible_sigs);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_all_possible_sigs);
  __Pyx_INCREF(__pyx_v_list_of_child_sig_lists);
  __Pyx_GIVEREF(__pyx_v_list_of_child_sig_lists);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_list_of_child_sig_lists);

  /* "typped/pratt_parser.py":507
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(
 *                                       all_possible_sigs, list_of_child_sig_lists,
 *                                       tnode=self)             # <<<<<<<<<<<<<<
 *             # Below all_possible_sigs is saved ONLY for printing error messages.
 *             self.all_possible_sigs = all_possible_sigs
 */
  __pyx_t_6 = PyDict_New(); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 507, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_tnode, __pyx_v_self) < 0) __PYX_ERR(0, 507, __pyx_L1_error)

  /* "typped/pratt_parser.py":505
 * 
 *             # Reduce to only the signatures that the types of the children match.
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(             # <<<<<<<<<<<<<<
 *                                       all_possible_sigs, list_of_child_sig_lists,
 *                                       tnode=self)
 */
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, __pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 505, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs, __pyx_t_2) < 0) __PYX_ERR(0, 505, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":509
 *                                       tnode=self)
 *             # Below all_possible_sigs is saved ONLY for printing error messages.
 *             self.all_possible_sigs = all_possible_sigs             # <<<<<<<<<<<<<<
 * 
 *             # No overloading on return types so we can finalize the actual types.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_all_possible_sigs, __pyx_v_all_possible_sigs) < 0) __PYX_ERR(0, 509, __pyx_L1_error)

  /* "typped/pratt_parser.py":512
 * 
 *             # No overloading on return types so we can finalize the actual types.
 *             if len(self.matching_sigs) != 1:             # <<<<<<<<<<<<<<
 *                 self._raise_type_mismatch_error(self.matching_sigs,
 *                         "Ambiguous type resolution: The actual argument types match"
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 512, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = PyObject_Length(__pyx_t_2); if (unlikely(__pyx_t_4 == -1)) __PYX_ERR(0, 512, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_7 = ((__pyx_t_4 != 1) != 0);
  if (__pyx_t_7) {

    /* "typped/pratt_parser.py":513
 *             # No overloading on return types so we can finalize the actual types.
 *             if len(self.matching_sigs) != 1:
 *                 self._raise_type_mismatch_error(self.matching_sigs,             # <<<<<<<<<<<<<<
 *                         "Ambiguous type resolution: The actual argument types match"
 *                         " multiple signatures.")
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_raise_type_mismatch_error); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 513, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 513, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_6)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_t_1, __pyx_kp_s_Ambiguous_type_resolution_The_ac};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 513, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_t_1, __pyx_kp_s_Ambiguous_type_resolution_The_ac};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 513, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else
    #endif
    {
      __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 513, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      if (__pyx_t_3) {
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_3); __pyx_t_3 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_1);
      __Pyx_INCREF(__pyx_kp_s_Ambiguous_type_resolution_The_ac);
      __Pyx_GIVEREF(__pyx_kp_s_Ambiguous_type_resolution_The_ac);
      PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_kp_s_Ambiguous_type_resolution_The_ac);
      __pyx_t_1 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 513, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "typped/pratt_parser.py":512
 * 
 *             # No overloading on return types so we can finalize the actual types.
 *             if len(self.matching_sigs) != 1:             # <<<<<<<<<<<<<<
 *                 self._raise_type_mismatch_error(self.matching_sigs,
 *                         "Ambiguous type resolution: The actual argument types match"
 */
  }

  /* "typped/pratt_parser.py":519
 *             # Found a unique signature; set the node's expanded_formal_sig attribute.
 *             # Saved sig used for eval_fun resolution, ast_data, semantic action, etc.
 *             self.expanded_formal_sig = self.matching_sigs[0]             # <<<<<<<<<<<<<<
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig
 *             self.actual_sig = TypeSig(self.expanded_formal_sig.val_type,
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 519, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_6 = __Pyx_GetItemInt(__pyx_t_2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 519, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig, __pyx_t_6) < 0) __PYX_ERR(0, 519, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":520
 *             # Saved sig used for eval_fun resolution, ast_data, semantic action, etc.
 *             self.expanded_formal_sig = self.matching_sigs[0]
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig             # <<<<<<<<<<<<<<
 *             self.actual_sig = TypeSig(self.expanded_formal_sig.val_type,
 *                                       [c.actual_sig.val_type for c in self.children])
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_original_formal_sig); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_original_formal_sig, __pyx_t_2) < 0) __PYX_ERR(0, 520, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":521
 *             self.expanded_formal_sig = self.matching_sigs[0]
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig
 *             self.actual_sig = TypeSig(self.expanded_formal_sig.val_type,             # <<<<<<<<<<<<<<
 *                                       [c.actual_sig.val_type for c in self.children])
 * 
 */
  __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 521, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 521, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_val_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 521, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;

  /* "typped/pratt_parser.py":522
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig
 *             self.actual_sig = TypeSig(self.expanded_formal_sig.val_type,
 *                                       [c.actual_sig.val_type for c in self.children])             # <<<<<<<<<<<<<<
 * 
 *             # Delete some temporary attributes no longer needed.
 */
  __pyx_t_9 = PyList_New(0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 522, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 522, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
    __pyx_t_10 = __pyx_t_3; __Pyx_INCREF(__pyx_t_10); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
  } else {
    __pyx_t_4 = -1; __pyx_t_10 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 522, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_5 = Py_TYPE(__pyx_t_10)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 522, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  for (;;) {
    if (likely(!__pyx_t_5)) {
      if (likely(PyList_CheckExact(__pyx_t_10))) {
        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_10)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_10, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 522, __pyx_L1_error)
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_10, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 522, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        #endif
      } else {
        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_10)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_10, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 522, __pyx_L1_error)
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_10, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 522, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        #endif
      }
    } else {
      __pyx_t_3 = __pyx_t_5(__pyx_t_10);
      if (unlikely(!__pyx_t_3)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 522, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_3);
    }
    __Pyx_XDECREF_SET(__pyx_v_c, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_c, __pyx_n_s_actual_sig); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 522, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_val_type); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 522, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(__Pyx_ListComp_Append(__pyx_t_9, (PyObject*)__pyx_t_11))) __PYX_ERR(0, 522, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  }
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  __pyx_t_10 = NULL;
  __pyx_t_8 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_10)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_10);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
      __pyx_t_8 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_6)) {
    PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_t_1, __pyx_t_9};
    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 521, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
    PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_t_1, __pyx_t_9};
    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 521, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  } else
  #endif
  {
    __pyx_t_11 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 521, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    if (__pyx_t_10) {
      __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10); __pyx_t_10 = NULL;
    }
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_11, 0+__pyx_t_8, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_11, 1+__pyx_t_8, __pyx_t_9);
    __pyx_t_1 = 0;
    __pyx_t_9 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 521, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  }
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":521
 *             self.expanded_formal_sig = self.matching_sigs[0]
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig
 *             self.actual_sig = TypeSig(self.expanded_formal_sig.val_type,             # <<<<<<<<<<<<<<
 *                                       [c.actual_sig.val_type for c in self.children])
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_actual_sig, __pyx_t_2) < 0) __PYX_ERR(0, 521, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":525
 * 
 *             # Delete some temporary attributes no longer needed.
 *             delattr(self, "matching_sigs")             # <<<<<<<<<<<<<<
 *             delattr(self, "all_possible_sigs")
 * 
 */
  __pyx_t_12 = PyObject_DelAttr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 525, __pyx_L1_error)

  /* "typped/pratt_parser.py":526
 *             # Delete some temporary attributes no longer needed.
 *             delattr(self, "matching_sigs")
 *             delattr(self, "all_possible_sigs")             # <<<<<<<<<<<<<<
 * 
 *         def _check_types_first_of_two_passes(self):
 */
  __pyx_t_12 = PyObject_DelAttr(__pyx_v_self, __pyx_n_s_all_possible_sigs); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 526, __pyx_L1_error)

  /* "typped/pratt_parser.py":495
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)
 * 
 *         def _check_types_one_pass(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to check
 *             the actual types against their signatures when overloading is only on
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass._check_types_one_pass", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_all_possible_sigs);
  __Pyx_XDECREF(__pyx_v_list_of_child_sig_lists);
  __Pyx_XDECREF(__pyx_v_c);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":528
 *             delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_first_of_two_passes(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to do the
 *             first pass in checking the actual types against their signatures.
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_13_check_types_first_of_two_passes(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_12_check_types_first_of_two_passes[] = "Utility function called from `process_and_check_node` to do the\n            first pass in checking the actual types against their signatures.\n            Two-pass checking is needed for overloading on return types.  First\n            pass goes up the tree, second pass goes back down.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_13_check_types_first_of_two_passes = {"_check_types_first_of_two_passes", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_13_check_types_first_of_two_passes, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_12_check_types_first_of_two_passes};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_13_check_types_first_of_two_passes(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_types_first_of_two_passes (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_12_check_types_first_of_two_passes(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_12_check_types_first_of_two_passes(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_v_all_possible_sigs = NULL;
  PyObject *__pyx_v_list_of_child_sig_lists = NULL;
  PyObject *__pyx_v_c = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  PyObject *(*__pyx_t_5)(PyObject *);
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("_check_types_first_of_two_passes", 0);

  /* "typped/pratt_parser.py":533
 *             Two-pass checking is needed for overloading on return types.  First
 *             pass goes up the tree, second pass goes back down."""
 *             all_possible_sigs = self.all_possible_sigs             # <<<<<<<<<<<<<<
 * 
 *             # First pass case, multiple sigs in child's self.matching_sigs list.
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_all_possible_sigs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 533, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_all_possible_sigs = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":536
 * 
 *             # First pass case, multiple sigs in child's self.matching_sigs list.
 *             list_of_child_sig_lists = [c.matching_sigs for c in self.children]             # <<<<<<<<<<<<<<
 * 
 *             # Reduce to only the signatures that the types of the children match.
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 536, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 536, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
    __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
  } else {
    __pyx_t_4 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 536, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 536, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  for (;;) {
    if (likely(!__pyx_t_5)) {
      if (likely(PyList_CheckExact(__pyx_t_3))) {
        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 536, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 536, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      } else {
        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 536, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 536, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      }
    } else {
      __pyx_t_2 = __pyx_t_5(__pyx_t_3);
      if (unlikely(!__pyx_t_2)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 536, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_2);
    }
    __Pyx_XDECREF_SET(__pyx_v_c, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_c, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 536, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_2))) __PYX_ERR(0, 536, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_list_of_child_sig_lists = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":539
 * 
 *             # Reduce to only the signatures that the types of the children match.
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(             # <<<<<<<<<<<<<<
 *                                       all_possible_sigs, list_of_child_sig_lists,
 *                                       tnode=self)
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 539, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_get_all_matching_expanded_sigs); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 539, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":540
 *             # Reduce to only the signatures that the types of the children match.
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(
 *                                       all_possible_sigs, list_of_child_sig_lists,             # <<<<<<<<<<<<<<
 *                                       tnode=self)
 * 
 */
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 539, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_all_possible_sigs);
  __Pyx_GIVEREF(__pyx_v_all_possible_sigs);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_all_possible_sigs);
  __Pyx_INCREF(__pyx_v_list_of_child_sig_lists);
  __Pyx_GIVEREF(__pyx_v_list_of_child_sig_lists);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_list_of_child_sig_lists);

  /* "typped/pratt_parser.py":541
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(
 *                                       all_possible_sigs, list_of_child_sig_lists,
 *                                       tnode=self)             # <<<<<<<<<<<<<<
 * 
 *         def check_types_in_tree_second_pass(self, root=False):
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 541, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_tnode, __pyx_v_self) < 0) __PYX_ERR(0, 541, __pyx_L1_error)

  /* "typped/pratt_parser.py":539
 * 
 *             # Reduce to only the signatures that the types of the children match.
 *             self.matching_sigs = TypeSig.get_all_matching_expanded_sigs(             # <<<<<<<<<<<<<<
 *                                       all_possible_sigs, list_of_child_sig_lists,
 *                                       tnode=self)
 */
  __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 539, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs, __pyx_t_6) < 0) __PYX_ERR(0, 539, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":528
 *             delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_first_of_two_passes(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to do the
 *             first pass in checking the actual types against their signatures.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass._check_types_first_of_two_passes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_all_possible_sigs);
  __Pyx_XDECREF(__pyx_v_list_of_child_sig_lists);
  __Pyx_XDECREF(__pyx_v_c);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":543
 *                                       tnode=self)
 * 
 *         def check_types_in_tree_second_pass(self, root=False):             # <<<<<<<<<<<<<<
 *             """Recursively run the second pass on the token subtree with the
 *             `self` node as the root.
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_15check_types_in_tree_second_pass(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_14check_types_in_tree_second_pass[] = "Recursively run the second pass on the token subtree with the\n            `self` node as the root.\n\n            This method currently still needs to be explicitly called for the\n            root of the final parse tree, from the `PrattParser` method\n            `parse`, as well as from the checking routines here to do partial\n            checks on subtrees which are already resolvable.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_15check_types_in_tree_second_pass = {"check_types_in_tree_second_pass", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_15check_types_in_tree_second_pass, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_14check_types_in_tree_second_pass};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_15check_types_in_tree_second_pass(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_root = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_types_in_tree_second_pass (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_root,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)((PyObject *)Py_False));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_root);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_types_in_tree_second_pass") < 0)) __PYX_ERR(0, 543, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_root = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_types_in_tree_second_pass", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 543, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.check_types_in_tree_second_pass", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_14check_types_in_tree_second_pass(__pyx_self, __pyx_v_self, __pyx_v_root);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_14check_types_in_tree_second_pass(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_root) {
  PyObject *__pyx_v_unresolved_children = NULL;
  PyObject *__pyx_v_child = NULL;
  PyObject *__pyx_v_c = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  PyObject *(*__pyx_t_5)(PyObject *);
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  __Pyx_RefNannySetupContext("check_types_in_tree_second_pass", 0);

  /* "typped/pratt_parser.py":551
 *             `parse`, as well as from the checking routines here to do partial
 *             checks on subtrees which are already resolvable."""
 *             unresolved_children = [             # <<<<<<<<<<<<<<
 *                     c for c in self.children if hasattr(c, "matching_sigs")]
 *             self._check_types_pass_two() # Call first on self to do top-down.
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "typped/pratt_parser.py":552
 *             checks on subtrees which are already resolvable."""
 *             unresolved_children = [
 *                     c for c in self.children if hasattr(c, "matching_sigs")]             # <<<<<<<<<<<<<<
 *             self._check_types_pass_two() # Call first on self to do top-down.
 *             for child in unresolved_children: # Recurse on unprocessed children.
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 552, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
    __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
  } else {
    __pyx_t_4 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 552, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 552, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  for (;;) {
    if (likely(!__pyx_t_5)) {
      if (likely(PyList_CheckExact(__pyx_t_3))) {
        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 552, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 552, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      } else {
        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 552, __pyx_L1_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 552, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
      }
    } else {
      __pyx_t_2 = __pyx_t_5(__pyx_t_3);
      if (unlikely(!__pyx_t_2)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 552, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_2);
    }
    __Pyx_XDECREF_SET(__pyx_v_c, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_6 = __Pyx_HasAttr(__pyx_v_c, __pyx_n_s_matching_sigs); if (unlikely(__pyx_t_6 == -1)) __PYX_ERR(0, 552, __pyx_L1_error)
    __pyx_t_7 = (__pyx_t_6 != 0);
    if (__pyx_t_7) {
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_v_c))) __PYX_ERR(0, 551, __pyx_L1_error)
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_unresolved_children = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":553
 *             unresolved_children = [
 *                     c for c in self.children if hasattr(c, "matching_sigs")]
 *             self._check_types_pass_two() # Call first on self to do top-down.             # <<<<<<<<<<<<<<
 *             for child in unresolved_children: # Recurse on unprocessed children.
 *                 child.check_types_in_tree_second_pass()
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_check_types_pass_two); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 553, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 553, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 553, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":554
 *                     c for c in self.children if hasattr(c, "matching_sigs")]
 *             self._check_types_pass_two() # Call first on self to do top-down.
 *             for child in unresolved_children: # Recurse on unprocessed children.             # <<<<<<<<<<<<<<
 *                 child.check_types_in_tree_second_pass()
 *             # Delete childrens' matching_sigs lists after they are no longer needed.
 */
  __pyx_t_1 = __pyx_v_unresolved_children; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
  for (;;) {
    if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 554, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 554, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_child, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":555
 *             self._check_types_pass_two() # Call first on self to do top-down.
 *             for child in unresolved_children: # Recurse on unprocessed children.
 *                 child.check_types_in_tree_second_pass()             # <<<<<<<<<<<<<<
 *             # Delete childrens' matching_sigs lists after they are no longer needed.
 *             # This also acts as an indicator that the node has been resolved.
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_child, __pyx_n_s_check_types_in_tree_second_pass); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    if (__pyx_t_8) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 555, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    } else {
      __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 555, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":554
 *                     c for c in self.children if hasattr(c, "matching_sigs")]
 *             self._check_types_pass_two() # Call first on self to do top-down.
 *             for child in unresolved_children: # Recurse on unprocessed children.             # <<<<<<<<<<<<<<
 *                 child.check_types_in_tree_second_pass()
 *             # Delete childrens' matching_sigs lists after they are no longer needed.
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":558
 *             # Delete childrens' matching_sigs lists after they are no longer needed.
 *             # This also acts as an indicator that the node has been resolved.
 *             for child in unresolved_children:             # <<<<<<<<<<<<<<
 *                 delattr(child, "matching_sigs")
 *             if root:
 */
  __pyx_t_1 = __pyx_v_unresolved_children; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
  for (;;) {
    if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 558, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 558, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_child, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":559
 *             # This also acts as an indicator that the node has been resolved.
 *             for child in unresolved_children:
 *                 delattr(child, "matching_sigs")             # <<<<<<<<<<<<<<
 *             if root:
 *                 # The final pass in _check_types that deletes these attrs doesn't get
 */
    __pyx_t_9 = PyObject_DelAttr(__pyx_v_child, __pyx_n_s_matching_sigs); if (unlikely(__pyx_t_9 == -1)) __PYX_ERR(0, 559, __pyx_L1_error)

    /* "typped/pratt_parser.py":558
 *             # Delete childrens' matching_sigs lists after they are no longer needed.
 *             # This also acts as an indicator that the node has been resolved.
 *             for child in unresolved_children:             # <<<<<<<<<<<<<<
 *                 delattr(child, "matching_sigs")
 *             if root:
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":560
 *             for child in unresolved_children:
 *                 delattr(child, "matching_sigs")
 *             if root:             # <<<<<<<<<<<<<<
 *                 # The final pass in _check_types that deletes these attrs doesn't get
 *                 # run on root, so it is explicitly done here when `root` flag is true.
 */
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_root); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 560, __pyx_L1_error)
  if (__pyx_t_7) {

    /* "typped/pratt_parser.py":563
 *                 # The final pass in _check_types that deletes these attrs doesn't get
 *                 # run on root, so it is explicitly done here when `root` flag is true.
 *                 delattr(self, "matching_sigs")             # <<<<<<<<<<<<<<
 *                 delattr(self, "all_possible_sigs")
 * 
 */
    __pyx_t_9 = PyObject_DelAttr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(__pyx_t_9 == -1)) __PYX_ERR(0, 563, __pyx_L1_error)

    /* "typped/pratt_parser.py":564
 *                 # run on root, so it is explicitly done here when `root` flag is true.
 *                 delattr(self, "matching_sigs")
 *                 delattr(self, "all_possible_sigs")             # <<<<<<<<<<<<<<
 * 
 *         def _check_types_pass_two(self):
 */
    __pyx_t_9 = PyObject_DelAttr(__pyx_v_self, __pyx_n_s_all_possible_sigs); if (unlikely(__pyx_t_9 == -1)) __PYX_ERR(0, 564, __pyx_L1_error)

    /* "typped/pratt_parser.py":560
 *             for child in unresolved_children:
 *                 delattr(child, "matching_sigs")
 *             if root:             # <<<<<<<<<<<<<<
 *                 # The final pass in _check_types that deletes these attrs doesn't get
 *                 # run on root, so it is explicitly done here when `root` flag is true.
 */
  }

  /* "typped/pratt_parser.py":543
 *                                       tnode=self)
 * 
 *         def check_types_in_tree_second_pass(self, root=False):             # <<<<<<<<<<<<<<
 *             """Recursively run the second pass on the token subtree with the
 *             `self` node as the root.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.check_types_in_tree_second_pass", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_unresolved_children);
  __Pyx_XDECREF(__pyx_v_child);
  __Pyx_XDECREF(__pyx_v_c);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":566
 *                 delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_pass_two(self):             # <<<<<<<<<<<<<<
 *             """A second pass is only used when overloading on return types is
 *             allowed.  It is a top-down pass where each node chooses a unique
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_17_check_types_pass_two(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_16_check_types_pass_two[] = "A second pass is only used when overloading on return types is\n            allowed.  It is a top-down pass where each node chooses a unique\n            final signature for each of its children.  It depends on the\n            node attribute `self.matching_sigs` having been set in the first\n            pass.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_17_check_types_pass_two = {"_check_types_pass_two", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_17_check_types_pass_two, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_16_check_types_pass_two};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_17_check_types_pass_two(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_types_pass_two (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_16_check_types_pass_two(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_16_check_types_pass_two(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_v_parent_args_so_far = NULL;
  PyObject *__pyx_v_count = NULL;
  PyObject *__pyx_v_child = NULL;
  PyObject *__pyx_v_matched_sigs = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  int __pyx_t_14;
  PyObject *(*__pyx_t_15)(PyObject *);
  Py_ssize_t __pyx_t_16;
  PyObject *__pyx_t_17 = NULL;
  __Pyx_RefNannySetupContext("_check_types_pass_two", 0);

  /* "typped/pratt_parser.py":603
 *             # some error conditions sooner, and is what is implemented here.
 * 
 *             if len(self.matching_sigs) != 1: # The root case needs this.             # <<<<<<<<<<<<<<
 *                 self._raise_type_mismatch_error(self.matching_sigs,
 *                         "Ambiguous type resolution (second pass).  Possible type "
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 603, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 603, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((__pyx_t_2 != 1) != 0);
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":604
 * 
 *             if len(self.matching_sigs) != 1: # The root case needs this.
 *                 self._raise_type_mismatch_error(self.matching_sigs,             # <<<<<<<<<<<<<<
 *                         "Ambiguous type resolution (second pass).  Possible type "
 *                         "assignments for the children/arguments of the token node match"
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_raise_type_mismatch_error); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 604, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 604, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);

    /* "typped/pratt_parser.py":608
 *                         "assignments for the children/arguments of the token node match"
 *                         " {0} possible node signatures: {1}.  Uniqueness is required."
 *                         .format(len(self.matching_sigs), self.matching_sigs))             # <<<<<<<<<<<<<<
 * 
 *             # We have a unique signature; set the node's type attributes
 */
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Ambiguous_type_resolution_second, __pyx_n_s_format); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_2 = PyObject_Length(__pyx_t_8); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 608, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_10 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_10)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_10);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_t_8, __pyx_t_9};
      __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 608, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_t_8, __pyx_t_9};
      __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 608, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    } else
    #endif
    {
      __pyx_t_12 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 608, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);
      if (__pyx_t_10) {
        __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_10); __pyx_t_10 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_12, 0+__pyx_t_11, __pyx_t_8);
      __Pyx_GIVEREF(__pyx_t_9);
      PyTuple_SET_ITEM(__pyx_t_12, 1+__pyx_t_11, __pyx_t_9);
      __pyx_t_8 = 0;
      __pyx_t_9 = 0;
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_12, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 608, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_5, __pyx_t_6};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 604, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_5, __pyx_t_6};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 604, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    {
      __pyx_t_12 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 604, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_12, 0+__pyx_t_11, __pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_12, 1+__pyx_t_11, __pyx_t_6);
      __pyx_t_5 = 0;
      __pyx_t_6 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 604, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":603
 *             # some error conditions sooner, and is what is implemented here.
 * 
 *             if len(self.matching_sigs) != 1: # The root case needs this.             # <<<<<<<<<<<<<<
 *                 self._raise_type_mismatch_error(self.matching_sigs,
 *                         "Ambiguous type resolution (second pass).  Possible type "
 */
  }

  /* "typped/pratt_parser.py":611
 * 
 *             # We have a unique signature; set the node's type attributes
 *             self.expanded_formal_sig = self.matching_sigs[0] # Save sig for semantic actions.             # <<<<<<<<<<<<<<
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig
 *             # Start setting the actual signature; children will fill arg types when resolved.
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 611, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 611, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig, __pyx_t_4) < 0) __PYX_ERR(0, 611, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":612
 *             # We have a unique signature; set the node's type attributes
 *             self.expanded_formal_sig = self.matching_sigs[0] # Save sig for semantic actions.
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig             # <<<<<<<<<<<<<<
 *             # Start setting the actual signature; children will fill arg types when resolved.
 *             self.actual_sig = TypeSig(self.expanded_formal_sig.val_type, [])
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 612, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_original_formal_sig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 612, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_original_formal_sig, __pyx_t_1) < 0) __PYX_ERR(0, 612, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":614
 *             self.original_formal_sig = self.expanded_formal_sig.original_formal_sig
 *             # Start setting the actual signature; children will fill arg types when resolved.
 *             self.actual_sig = TypeSig(self.expanded_formal_sig.val_type, [])             # <<<<<<<<<<<<<<
 * 
 *             # Set the actual_sig arg_type for the parent (appending in sequence with others).
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 614, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 614, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_12);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_val_type); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 614, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
  __pyx_t_12 = PyList_New(0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 614, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_12);
  __pyx_t_5 = NULL;
  __pyx_t_11 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_11 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_6, __pyx_t_12};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 614, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_6, __pyx_t_12};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 614, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 614, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_11, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_12);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_11, __pyx_t_12);
    __pyx_t_6 = 0;
    __pyx_t_12 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 614, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_actual_sig, __pyx_t_1) < 0) __PYX_ERR(0, 614, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":617
 * 
 *             # Set the actual_sig arg_type for the parent (appending in sequence with others).
 *             if self.parent is not None:             # <<<<<<<<<<<<<<
 *                 parent_args_so_far = list(self.parent.actual_sig.arg_types)
 *                 parent_args_so_far.append(self.expanded_formal_sig.val_type)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parent); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 617, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = (__pyx_t_1 != Py_None);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_13 = (__pyx_t_3 != 0);
  if (__pyx_t_13) {

    /* "typped/pratt_parser.py":618
 *             # Set the actual_sig arg_type for the parent (appending in sequence with others).
 *             if self.parent is not None:
 *                 parent_args_so_far = list(self.parent.actual_sig.arg_types)             # <<<<<<<<<<<<<<
 *                 parent_args_so_far.append(self.expanded_formal_sig.val_type)
 *                 self.parent.actual_sig = TypeSig(self.parent.actual_sig.val_type,
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parent); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 618, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_actual_sig); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 618, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_arg_types); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 618, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 618, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_parent_args_so_far = ((PyObject*)__pyx_t_4);
    __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":619
 *             if self.parent is not None:
 *                 parent_args_so_far = list(self.parent.actual_sig.arg_types)
 *                 parent_args_so_far.append(self.expanded_formal_sig.val_type)             # <<<<<<<<<<<<<<
 *                 self.parent.actual_sig = TypeSig(self.parent.actual_sig.val_type,
 *                                                  parent_args_so_far)
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_val_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_14 = __Pyx_PyList_Append(__pyx_v_parent_args_so_far, __pyx_t_1); if (unlikely(__pyx_t_14 == -1)) __PYX_ERR(0, 619, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":620
 *                 parent_args_so_far = list(self.parent.actual_sig.arg_types)
 *                 parent_args_so_far.append(self.expanded_formal_sig.val_type)
 *                 self.parent.actual_sig = TypeSig(self.parent.actual_sig.val_type,             # <<<<<<<<<<<<<<
 *                                                  parent_args_so_far)
 * 
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parent); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_actual_sig); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_12);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_val_type); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;

    /* "typped/pratt_parser.py":621
 *                 parent_args_so_far.append(self.expanded_formal_sig.val_type)
 *                 self.parent.actual_sig = TypeSig(self.parent.actual_sig.val_type,
 *                                                  parent_args_so_far)             # <<<<<<<<<<<<<<
 * 
 *             # Update the matching_sigs attribute for each child (should be singleton).
 */
    __pyx_t_12 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_12)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_12);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_t_7, __pyx_v_parent_args_so_far};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 620, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_12, __pyx_t_7, __pyx_v_parent_args_so_far};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 620, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    } else
    #endif
    {
      __pyx_t_6 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 620, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (__pyx_t_12) {
        __Pyx_GIVEREF(__pyx_t_12); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_12); __pyx_t_12 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_11, __pyx_t_7);
      __Pyx_INCREF(__pyx_v_parent_args_so_far);
      __Pyx_GIVEREF(__pyx_v_parent_args_so_far);
      PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_11, __pyx_v_parent_args_so_far);
      __pyx_t_7 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 620, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":620
 *                 parent_args_so_far = list(self.parent.actual_sig.arg_types)
 *                 parent_args_so_far.append(self.expanded_formal_sig.val_type)
 *                 self.parent.actual_sig = TypeSig(self.parent.actual_sig.val_type,             # <<<<<<<<<<<<<<
 *                                                  parent_args_so_far)
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parent); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (__Pyx_PyObject_SetAttrStr(__pyx_t_4, __pyx_n_s_actual_sig, __pyx_t_1) < 0) __PYX_ERR(0, 620, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":617
 * 
 *             # Set the actual_sig arg_type for the parent (appending in sequence with others).
 *             if self.parent is not None:             # <<<<<<<<<<<<<<
 *                 parent_args_so_far = list(self.parent.actual_sig.arg_types)
 *                 parent_args_so_far.append(self.expanded_formal_sig.val_type)
 */
  }

  /* "typped/pratt_parser.py":624
 * 
 *             # Update the matching_sigs attribute for each child (should be singleton).
 *             for count, child in enumerate(self.children):             # <<<<<<<<<<<<<<
 *                 if not hasattr(child, "matching_sigs"):
 *                     continue # Already resolved.
 */
  __Pyx_INCREF(__pyx_int_0);
  __pyx_t_4 = __pyx_int_0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_6 = __pyx_t_1; __Pyx_INCREF(__pyx_t_6); __pyx_t_2 = 0;
    __pyx_t_15 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_6 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_15 = Py_TYPE(__pyx_t_6)->tp_iternext; if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 624, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_15)) {
      if (likely(PyList_CheckExact(__pyx_t_6))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_6)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_6, __pyx_t_2); __Pyx_INCREF(__pyx_t_1); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 624, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_6, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_6)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_6, __pyx_t_2); __Pyx_INCREF(__pyx_t_1); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 624, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_6, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_15(__pyx_t_6);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 624, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XDECREF_SET(__pyx_v_child, __pyx_t_1);
    __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_t_4);
    __Pyx_XDECREF_SET(__pyx_v_count, __pyx_t_4);
    __pyx_t_1 = __Pyx_PyInt_AddObjC(__pyx_t_4, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 624, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4);
    __pyx_t_4 = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":625
 *             # Update the matching_sigs attribute for each child (should be singleton).
 *             for count, child in enumerate(self.children):
 *                 if not hasattr(child, "matching_sigs"):             # <<<<<<<<<<<<<<
 *                     continue # Already resolved.
 *                 matched_sigs = TypeSig.get_child_sigs_matching_return_arg_type(
 */
    __pyx_t_13 = __Pyx_HasAttr(__pyx_v_child, __pyx_n_s_matching_sigs); if (unlikely(__pyx_t_13 == -1)) __PYX_ERR(0, 625, __pyx_L1_error)
    __pyx_t_3 = ((!(__pyx_t_13 != 0)) != 0);
    if (__pyx_t_3) {

      /* "typped/pratt_parser.py":626
 *             for count, child in enumerate(self.children):
 *                 if not hasattr(child, "matching_sigs"):
 *                     continue # Already resolved.             # <<<<<<<<<<<<<<
 *                 matched_sigs = TypeSig.get_child_sigs_matching_return_arg_type(
 *                                           child, self.expanded_formal_sig.arg_types[count],
 */
      goto __pyx_L5_continue;

      /* "typped/pratt_parser.py":625
 *             # Update the matching_sigs attribute for each child (should be singleton).
 *             for count, child in enumerate(self.children):
 *                 if not hasattr(child, "matching_sigs"):             # <<<<<<<<<<<<<<
 *                     continue # Already resolved.
 *                 matched_sigs = TypeSig.get_child_sigs_matching_return_arg_type(
 */
    }

    /* "typped/pratt_parser.py":627
 *                 if not hasattr(child, "matching_sigs"):
 *                     continue # Already resolved.
 *                 matched_sigs = TypeSig.get_child_sigs_matching_return_arg_type(             # <<<<<<<<<<<<<<
 *                                           child, self.expanded_formal_sig.arg_types[count],
 *                                           child.matching_sigs)
 */
    __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_get_child_sigs_matching_return_a); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_12);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

    /* "typped/pratt_parser.py":628
 *                     continue # Already resolved.
 *                 matched_sigs = TypeSig.get_child_sigs_matching_return_arg_type(
 *                                           child, self.expanded_formal_sig.arg_types[count],             # <<<<<<<<<<<<<<
 *                                           child.matching_sigs)
 *                 # From the first pass, we know at least one child sig matches.
 */
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 628, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_arg_types); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 628, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = PyObject_GetItem(__pyx_t_5, __pyx_v_count); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 628, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":629
 *                 matched_sigs = TypeSig.get_child_sigs_matching_return_arg_type(
 *                                           child, self.expanded_formal_sig.arg_types[count],
 *                                           child.matching_sigs)             # <<<<<<<<<<<<<<
 *                 # From the first pass, we know at least one child sig matches.
 *                 assert len(matched_sigs) != 0 # Debug.
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_child, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 629, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_9 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_12))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_12);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_12, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_12)) {
      PyObject *__pyx_temp[4] = {__pyx_t_9, __pyx_v_child, __pyx_t_7, __pyx_t_5};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_12, __pyx_temp+1-__pyx_t_11, 3+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_12)) {
      PyObject *__pyx_temp[4] = {__pyx_t_9, __pyx_v_child, __pyx_t_7, __pyx_t_5};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_12, __pyx_temp+1-__pyx_t_11, 3+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    {
      __pyx_t_8 = PyTuple_New(3+__pyx_t_11); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      if (__pyx_t_9) {
        __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_9); __pyx_t_9 = NULL;
      }
      __Pyx_INCREF(__pyx_v_child);
      __Pyx_GIVEREF(__pyx_v_child);
      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_11, __pyx_v_child);
      __Pyx_GIVEREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_11, __pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_8, 2+__pyx_t_11, __pyx_t_5);
      __pyx_t_7 = 0;
      __pyx_t_5 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_12, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 627, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    __Pyx_XDECREF_SET(__pyx_v_matched_sigs, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":631
 *                                           child.matching_sigs)
 *                 # From the first pass, we know at least one child sig matches.
 *                 assert len(matched_sigs) != 0 # Debug.             # <<<<<<<<<<<<<<
 *                 if len(matched_sigs) > 1:
 *                     # Recursion could catch this on the next step, but better err msg.
 */
    #ifndef CYTHON_WITHOUT_ASSERTIONS
    if (unlikely(!Py_OptimizeFlag)) {
      __pyx_t_16 = PyObject_Length(__pyx_v_matched_sigs); if (unlikely(__pyx_t_16 == -1)) __PYX_ERR(0, 631, __pyx_L1_error)
      if (unlikely(!((__pyx_t_16 != 0) != 0))) {
        PyErr_SetNone(PyExc_AssertionError);
        __PYX_ERR(0, 631, __pyx_L1_error)
      }
    }
    #endif

    /* "typped/pratt_parser.py":632
 *                 # From the first pass, we know at least one child sig matches.
 *                 assert len(matched_sigs) != 0 # Debug.
 *                 if len(matched_sigs) > 1:             # <<<<<<<<<<<<<<
 *                     # Recursion could catch this on the next step, but better err msg.
 *                     child._raise_type_mismatch_error(matched_sigs,
 */
    __pyx_t_16 = PyObject_Length(__pyx_v_matched_sigs); if (unlikely(__pyx_t_16 == -1)) __PYX_ERR(0, 632, __pyx_L1_error)
    __pyx_t_3 = ((__pyx_t_16 > 1) != 0);
    if (__pyx_t_3) {

      /* "typped/pratt_parser.py":634
 *                 if len(matched_sigs) > 1:
 *                     # Recursion could catch this on the next step, but better err msg.
 *                     child._raise_type_mismatch_error(matched_sigs,             # <<<<<<<<<<<<<<
 *                         "Token node has multiple signatures with return type matching "
 *                         "type of parent (pass two). Parent expects type '{0}'.  Defined"
 */
      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_v_child, __pyx_n_s_raise_type_mismatch_error); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 634, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);

      /* "typped/pratt_parser.py":638
 *                         "type of parent (pass two). Parent expects type '{0}'.  Defined"
 *                         " signatures are: {1}."
 *                         .format(self.expanded_formal_sig.val_type, child.matching_sigs))             # <<<<<<<<<<<<<<
 *                 child.matching_sigs = matched_sigs
 *             return
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Token_node_has_multiple_signatur, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_val_type); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_child, __pyx_n_s_matching_sigs); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 638, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_10 = NULL;
      __pyx_t_11 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_10)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_10);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
          __pyx_t_11 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_t_9, __pyx_t_7};
        __pyx_t_8 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_t_9, __pyx_t_7};
        __pyx_t_8 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      {
        __pyx_t_17 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_17);
        if (__pyx_t_10) {
          __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_t_10); __pyx_t_10 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_9);
        PyTuple_SET_ITEM(__pyx_t_17, 0+__pyx_t_11, __pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_7);
        PyTuple_SET_ITEM(__pyx_t_17, 1+__pyx_t_11, __pyx_t_7);
        __pyx_t_9 = 0;
        __pyx_t_7 = 0;
        __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_17, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 638, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
      }
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = NULL;
      __pyx_t_11 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_12))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_12);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_12, function);
          __pyx_t_11 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_12)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_matched_sigs, __pyx_t_8};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_12, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_12)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_matched_sigs, __pyx_t_8};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_12, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else
      #endif
      {
        __pyx_t_17 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_17);
        if (__pyx_t_5) {
          __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_t_5); __pyx_t_5 = NULL;
        }
        __Pyx_INCREF(__pyx_v_matched_sigs);
        __Pyx_GIVEREF(__pyx_v_matched_sigs);
        PyTuple_SET_ITEM(__pyx_t_17, 0+__pyx_t_11, __pyx_v_matched_sigs);
        __Pyx_GIVEREF(__pyx_t_8);
        PyTuple_SET_ITEM(__pyx_t_17, 1+__pyx_t_11, __pyx_t_8);
        __pyx_t_8 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_12, __pyx_t_17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 634, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
      }
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "typped/pratt_parser.py":632
 *                 # From the first pass, we know at least one child sig matches.
 *                 assert len(matched_sigs) != 0 # Debug.
 *                 if len(matched_sigs) > 1:             # <<<<<<<<<<<<<<
 *                     # Recursion could catch this on the next step, but better err msg.
 *                     child._raise_type_mismatch_error(matched_sigs,
 */
    }

    /* "typped/pratt_parser.py":639
 *                         " signatures are: {1}."
 *                         .format(self.expanded_formal_sig.val_type, child.matching_sigs))
 *                 child.matching_sigs = matched_sigs             # <<<<<<<<<<<<<<
 *             return
 * 
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_child, __pyx_n_s_matching_sigs, __pyx_v_matched_sigs) < 0) __PYX_ERR(0, 639, __pyx_L1_error)

    /* "typped/pratt_parser.py":624
 * 
 *             # Update the matching_sigs attribute for each child (should be singleton).
 *             for count, child in enumerate(self.children):             # <<<<<<<<<<<<<<
 *                 if not hasattr(child, "matching_sigs"):
 *                     continue # Already resolved.
 */
    __pyx_L5_continue:;
  }
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":640
 *                         .format(self.expanded_formal_sig.val_type, child.matching_sigs))
 *                 child.matching_sigs = matched_sigs
 *             return             # <<<<<<<<<<<<<<
 * 
 *         def _raise_type_mismatch_error(self, matching_sigs, basic_msg):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;

  /* "typped/pratt_parser.py":566
 *                 delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_pass_two(self):             # <<<<<<<<<<<<<<
 *             """A second pass is only used when overloading on return types is
 *             allowed.  It is a top-down pass where each node chooses a unique
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_XDECREF(__pyx_t_17);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass._check_types_pass_two", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_parent_args_so_far);
  __Pyx_XDECREF(__pyx_v_count);
  __Pyx_XDECREF(__pyx_v_child);
  __Pyx_XDECREF(__pyx_v_matched_sigs);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":642
 *             return
 * 
 *         def _raise_type_mismatch_error(self, matching_sigs, basic_msg):             # <<<<<<<<<<<<<<
 *             """Raise an error, printing a helpful diagnostic message.  Assumes
 *             that `_check_types` has been called (to set `self.all_possible_sigs`)."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_19_raise_type_mismatch_error(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_18_raise_type_mismatch_error[] = "Raise an error, printing a helpful diagnostic message.  Assumes\n            that `_check_types` has been called (to set `self.all_possible_sigs`).";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_19_raise_type_mismatch_error = {"_raise_type_mismatch_error", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_19_raise_type_mismatch_error, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_18_raise_type_mismatch_error};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_19_raise_type_mismatch_error(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_matching_sigs = 0;
  PyObject *__pyx_v_basic_msg = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_raise_type_mismatch_error (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_matching_sigs,&__pyx_n_s_basic_msg,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_matching_sigs)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_raise_type_mismatch_error", 1, 3, 3, 1); __PYX_ERR(0, 642, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_basic_msg)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_raise_type_mismatch_error", 1, 3, 3, 2); __PYX_ERR(0, 642, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_raise_type_mismatch_error") < 0)) __PYX_ERR(0, 642, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_self = values[0];
    __pyx_v_matching_sigs = values[1];
    __pyx_v_basic_msg = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_raise_type_mismatch_error", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 642, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass._raise_type_mismatch_error", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_18_raise_type_mismatch_error(__pyx_self, __pyx_v_self, __pyx_v_matching_sigs, __pyx_v_basic_msg);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_2generator(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "typped/pratt_parser.py":654
 *                          .format(self.value, self.token_label,
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),             # <<<<<<<<<<<<<<
 *                              list(c.expanded_formal_sig.val_type
 *                                  if not isinstance(c.expanded_formal_sig, str)
 */

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *)__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_2_genexpr(__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_2_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 654, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_2generator, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_token_subclass_factory_locals_To, __pyx_n_s_typped_pratt_parser); if (unlikely(!gen)) __PYX_ERR(0, 654, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass._raise_type_mismatch_error.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_2generator(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *__pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 654, __pyx_L1_error)
  __pyx_r = PyList_New(0); if (unlikely(!__pyx_r)) __PYX_ERR(0, 654, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self)) { __Pyx_RaiseClosureNameError("self"); __PYX_ERR(0, 654, __pyx_L1_error) }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 654, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 654, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 654, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 654, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_c);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_c, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_c, __pyx_n_s_summary_repr); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (__pyx_t_6) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else {
      __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(__Pyx_ListComp_Append(__pyx_r, (PyObject*)__pyx_t_1))) __PYX_ERR(0, 654, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_5generator1(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "typped/pratt_parser.py":655
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),
 *                              list(c.expanded_formal_sig.val_type             # <<<<<<<<<<<<<<
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig
 */

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_3genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *)__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_3_genexpr(__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_3_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 655, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_5generator1, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_token_subclass_factory_locals_To, __pyx_n_s_typped_pratt_parser); if (unlikely(!gen)) __PYX_ERR(0, 655, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass._raise_type_mismatch_error.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_5generator1(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *__pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 655, __pyx_L1_error)
  __pyx_r = PyList_New(0); if (unlikely(!__pyx_r)) __PYX_ERR(0, 655, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_r);

  /* "typped/pratt_parser.py":658
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig
 *                                    for c in self.children), # Note this can be "Unresolved", clean up...             # <<<<<<<<<<<<<<
 *                              matching_sigs, self.all_possible_sigs))
 *             raise TypeErrorInParsedLanguage(basic_msg + diagnostic)
 */
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self)) { __Pyx_RaiseClosureNameError("self"); __PYX_ERR(0, 658, __pyx_L1_error) }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 658, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 658, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 658, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 658, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 658, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 658, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 658, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 658, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_c);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_c, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":656
 *                              list(c.summary_repr() for c in self.children),
 *                              list(c.expanded_formal_sig.val_type
 *                                  if not isinstance(c.expanded_formal_sig, str)             # <<<<<<<<<<<<<<
 *                                  else c.expanded_formal_sig
 *                                    for c in self.children), # Note this can be "Unresolved", clean up...
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_c, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 656, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyString_Check(__pyx_t_5); 
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (((!(__pyx_t_6 != 0)) != 0)) {

      /* "typped/pratt_parser.py":655
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),
 *                              list(c.expanded_formal_sig.val_type             # <<<<<<<<<<<<<<
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_c, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 655, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_val_type); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 655, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_1 = __pyx_t_7;
      __pyx_t_7 = 0;
    } else {

      /* "typped/pratt_parser.py":657
 *                              list(c.expanded_formal_sig.val_type
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig             # <<<<<<<<<<<<<<
 *                                    for c in self.children), # Note this can be "Unresolved", clean up...
 *                              matching_sigs, self.all_possible_sigs))
 */
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_c, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 657, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_1 = __pyx_t_7;
      __pyx_t_7 = 0;
    }
    if (unlikely(__Pyx_ListComp_Append(__pyx_r, (PyObject*)__pyx_t_1))) __PYX_ERR(0, 655, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":658
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig
 *                                    for c in self.children), # Note this can be "Unresolved", clean up...             # <<<<<<<<<<<<<<
 *                              matching_sigs, self.all_possible_sigs))
 *             raise TypeErrorInParsedLanguage(basic_msg + diagnostic)
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* "typped/pratt_parser.py":655
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),
 *                              list(c.expanded_formal_sig.val_type             # <<<<<<<<<<<<<<
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":642
 *             return
 * 
 *         def _raise_type_mismatch_error(self, matching_sigs, basic_msg):             # <<<<<<<<<<<<<<
 *             """Raise an error, printing a helpful diagnostic message.  Assumes
 *             that `_check_types` has been called (to set `self.all_possible_sigs`)."""
 */

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_18_raise_type_mismatch_error(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_matching_sigs, PyObject *__pyx_v_basic_msg) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *__pyx_cur_scope;
  PyObject *__pyx_v_diagnostic = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  __Pyx_RefNannySetupContext("_raise_type_mismatch_error", 0);
  __pyx_cur_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error(__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 642, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_self = __pyx_v_self;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_self);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_self);

  /* "typped/pratt_parser.py":652
 *                          "value types {4}.  The list of matching signatures "
 *                          "is {5}.  The list of possible signatures was {6}"
 *                          .format(self.value, self.token_label,             # <<<<<<<<<<<<<<
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_The_current_token_has_value_0_a, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 652, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_self, __pyx_n_s_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 652, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_self, __pyx_n_s_token_label); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 652, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);

  /* "typped/pratt_parser.py":653
 *                          "is {5}.  The list of possible signatures was {6}"
 *                          .format(self.value, self.token_label,
 *                              self.expanded_formal_sig,             # <<<<<<<<<<<<<<
 *                              list(c.summary_repr() for c in self.children),
 *                              list(c.expanded_formal_sig.val_type
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 653, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);

  /* "typped/pratt_parser.py":654
 *                          .format(self.value, self.token_label,
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),             # <<<<<<<<<<<<<<
 *                              list(c.expanded_formal_sig.val_type
 *                                  if not isinstance(c.expanded_formal_sig, str)
 */
  __pyx_t_6 = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 654, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = __Pyx_Generator_Next(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 654, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":655
 *                              self.expanded_formal_sig,
 *                              list(c.summary_repr() for c in self.children),
 *                              list(c.expanded_formal_sig.val_type             # <<<<<<<<<<<<<<
 *                                  if not isinstance(c.expanded_formal_sig, str)
 *                                  else c.expanded_formal_sig
 */
  __pyx_t_6 = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26_raise_type_mismatch_error_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 655, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_8 = __Pyx_Generator_Next(__pyx_t_6); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 655, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":659
 *                                  else c.expanded_formal_sig
 *                                    for c in self.children), # Note this can be "Unresolved", clean up...
 *                              matching_sigs, self.all_possible_sigs))             # <<<<<<<<<<<<<<
 *             raise TypeErrorInParsedLanguage(basic_msg + diagnostic)
 * 
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_self, __pyx_n_s_all_possible_sigs); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 659, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_9 = NULL;
  __pyx_t_10 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_9)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_9);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_10 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[8] = {__pyx_t_9, __pyx_t_3, __pyx_t_4, __pyx_t_5, __pyx_t_7, __pyx_t_8, __pyx_v_matching_sigs, __pyx_t_6};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 7+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[8] = {__pyx_t_9, __pyx_t_3, __pyx_t_4, __pyx_t_5, __pyx_t_7, __pyx_t_8, __pyx_v_matching_sigs, __pyx_t_6};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 7+__pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  } else
  #endif
  {
    __pyx_t_11 = PyTuple_New(7+__pyx_t_10); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    if (__pyx_t_9) {
      __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_9); __pyx_t_9 = NULL;
    }
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_11, 0+__pyx_t_10, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_11, 1+__pyx_t_10, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_11, 2+__pyx_t_10, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_11, 3+__pyx_t_10, __pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_11, 4+__pyx_t_10, __pyx_t_8);
    __Pyx_INCREF(__pyx_v_matching_sigs);
    __Pyx_GIVEREF(__pyx_v_matching_sigs);
    PyTuple_SET_ITEM(__pyx_t_11, 5+__pyx_t_10, __pyx_v_matching_sigs);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_11, 6+__pyx_t_10, __pyx_t_6);
    __pyx_t_3 = 0;
    __pyx_t_4 = 0;
    __pyx_t_5 = 0;
    __pyx_t_7 = 0;
    __pyx_t_8 = 0;
    __pyx_t_6 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_diagnostic = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":660
 *                                    for c in self.children), # Note this can be "Unresolved", clean up...
 *                              matching_sigs, self.all_possible_sigs))
 *             raise TypeErrorInParsedLanguage(basic_msg + diagnostic)             # <<<<<<<<<<<<<<
 * 
 *         #
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeErrorInParsedLanguage); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 660, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_11 = PyNumber_Add(__pyx_v_basic_msg, __pyx_v_diagnostic); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 660, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_11);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_6) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_11};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_11};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    } else
    #endif
    {
      __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 660, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
      __Pyx_GIVEREF(__pyx_t_11);
      PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_11);
      __pyx_t_11 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(0, 660, __pyx_L1_error)

  /* "typped/pratt_parser.py":642
 *             return
 * 
 *         def _raise_type_mismatch_error(self, matching_sigs, basic_msg):             # <<<<<<<<<<<<<<
 *             """Raise an error, printing a helpful diagnostic message.  Assumes
 *             that `_check_types` has been called (to set `self.all_possible_sigs`)."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass._raise_type_mismatch_error", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XDECREF(__pyx_v_diagnostic);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":667
 * 
 *         @property
 *         def eval_fun(self):             # <<<<<<<<<<<<<<
 *             """Return the evaluation function saved by `_save_eval_fun_and_ast_data`.
 *             Must be called after parsing because the `original_formal_sig` attribute
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_21eval_fun(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_20eval_fun[] = "Return the evaluation function saved by `_save_eval_fun_and_ast_data`.\n            Must be called after parsing because the `original_formal_sig` attribute\n            must be set on the token instance.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_21eval_fun = {"eval_fun", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_21eval_fun, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_20eval_fun};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_21eval_fun(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("eval_fun (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_20eval_fun(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_20eval_fun(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_v_orig_sig = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("eval_fun", 0);

  /* "typped/pratt_parser.py":671
 *             Must be called after parsing because the `original_formal_sig` attribute
 *             must be set on the token instance."""
 *             orig_sig = self.original_formal_sig             # <<<<<<<<<<<<<<
 *             return self.parser_instance.construct_table.get_eval_fun(orig_sig, self)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_original_formal_sig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 671, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_orig_sig = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":672
 *             must be set on the token instance."""
 *             orig_sig = self.original_formal_sig
 *             return self.parser_instance.construct_table.get_eval_fun(orig_sig, self)             # <<<<<<<<<<<<<<
 * 
 *         @property
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parser_instance); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 672, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_construct_table); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 672, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get_eval_fun); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 672, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_orig_sig, __pyx_v_self};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 672, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_orig_sig, __pyx_v_self};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 672, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 672, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(__pyx_v_orig_sig);
    __Pyx_GIVEREF(__pyx_v_orig_sig);
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_orig_sig);
    __Pyx_INCREF(__pyx_v_self);
    __Pyx_GIVEREF(__pyx_v_self);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_self);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 672, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":667
 * 
 *         @property
 *         def eval_fun(self):             # <<<<<<<<<<<<<<
 *             """Return the evaluation function saved by `_save_eval_fun_and_ast_data`.
 *             Must be called after parsing because the `original_formal_sig` attribute
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.eval_fun", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_orig_sig);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":675
 * 
 *         @property
 *         def ast_data(self):             # <<<<<<<<<<<<<<
 *             """Return the ast data saved by `_save_ast_data_and_ast_data`.
 *             Must be called after parsing because the `precond_label` attribute must
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_23ast_data(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22ast_data[] = "Return the ast data saved by `_save_ast_data_and_ast_data`.\n            Must be called after parsing because the `precond_label` attribute must\n            be set on the token instance.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_23ast_data = {"ast_data", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_23ast_data, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22ast_data};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_23ast_data(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ast_data (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22ast_data(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22ast_data(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_v_orig_sig = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("ast_data", 0);

  /* "typped/pratt_parser.py":679
 *             Must be called after parsing because the `precond_label` attribute must
 *             be set on the token instance."""
 *             orig_sig = self.original_formal_sig             # <<<<<<<<<<<<<<
 *             return self.parser_instance.construct_table.get_ast_data(orig_sig, self)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_original_formal_sig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 679, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_orig_sig = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":680
 *             be set on the token instance."""
 *             orig_sig = self.original_formal_sig
 *             return self.parser_instance.construct_table.get_ast_data(orig_sig, self)             # <<<<<<<<<<<<<<
 * 
 *         def eval_subtree(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parser_instance); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 680, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_construct_table); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 680, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_get_ast_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 680, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_4 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_orig_sig, __pyx_v_self};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 680, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_orig_sig, __pyx_v_self};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 680, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 680, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(__pyx_v_orig_sig);
    __Pyx_GIVEREF(__pyx_v_orig_sig);
    PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_orig_sig);
    __Pyx_INCREF(__pyx_v_self);
    __Pyx_GIVEREF(__pyx_v_self);
    PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_self);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 680, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":675
 * 
 *         @property
 *         def ast_data(self):             # <<<<<<<<<<<<<<
 *             """Return the ast data saved by `_save_ast_data_and_ast_data`.
 *             Must be called after parsing because the `precond_label` attribute must
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.ast_data", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_orig_sig);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":682
 *             return self.parser_instance.construct_table.get_ast_data(orig_sig, self)
 * 
 *         def eval_subtree(self):             # <<<<<<<<<<<<<<
 *             """Run the saved evaluation function on the token, if one was
 *             registered with it.  Returns `None` if no evaluation function is found."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_25eval_subtree(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_24eval_subtree[] = "Run the saved evaluation function on the token, if one was\n            registered with it.  Returns `None` if no evaluation function is found.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_25eval_subtree = {"eval_subtree", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_25eval_subtree, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_24eval_subtree};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_25eval_subtree(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("eval_subtree (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_24eval_subtree(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_24eval_subtree(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  CYTHON_UNUSED PyObject *__pyx_v_orig_sig = NULL;
  PyObject *__pyx_v_eval_fun = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("eval_subtree", 0);

  /* "typped/pratt_parser.py":686
 *             registered with it.  Returns `None` if no evaluation function is found."""
 *             #sig = self.expanded_formal_sig
 *             orig_sig = self.original_formal_sig             # <<<<<<<<<<<<<<
 *             eval_fun = self.eval_fun
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_original_formal_sig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 686, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_orig_sig = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":687
 *             #sig = self.expanded_formal_sig
 *             orig_sig = self.original_formal_sig
 *             eval_fun = self.eval_fun             # <<<<<<<<<<<<<<
 * 
 *             # TODO: Consider if returning None is better than raising exception...
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_eval_fun); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 687, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_eval_fun = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":690
 * 
 *             # TODO: Consider if returning None is better than raising exception...
 *             if not eval_fun:             # <<<<<<<<<<<<<<
 *                 return None
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_eval_fun); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 690, __pyx_L1_error)
  __pyx_t_3 = ((!__pyx_t_2) != 0);
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":691
 *             # TODO: Consider if returning None is better than raising exception...
 *             if not eval_fun:
 *                 return None             # <<<<<<<<<<<<<<
 * 
 *             # TODO: Consider if special exception should be raised.
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "typped/pratt_parser.py":690
 * 
 *             # TODO: Consider if returning None is better than raising exception...
 *             if not eval_fun:             # <<<<<<<<<<<<<<
 *                 return None
 * 
 */
  }

  /* "typped/pratt_parser.py":704
 *             #                    self.precond_label, self.eval_fun_dict))
 * 
 *             return eval_fun(self)             # <<<<<<<<<<<<<<
 * 
 *         #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_eval_fun);
  __pyx_t_4 = __pyx_v_eval_fun; __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_self};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_self};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 704, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
      __Pyx_INCREF(__pyx_v_self);
      __Pyx_GIVEREF(__pyx_v_self);
      PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_self);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":682
 *             return self.parser_instance.construct_table.get_ast_data(orig_sig, self)
 * 
 *         def eval_subtree(self):             # <<<<<<<<<<<<<<
 *             """Run the saved evaluation function on the token, if one was
 *             registered with it.  Returns `None` if no evaluation function is found."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.eval_subtree", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_orig_sig);
  __Pyx_XDECREF(__pyx_v_eval_fun);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":710
 *         #
 * 
 *         def get_jop_token_instance(self, lex, processed_left, lookbehind, subexp_prec):             # <<<<<<<<<<<<<<
 *             """Returns an instance of the jop token iff one should be inferred in the
 *             current context; otherwise returns `None`."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_27get_jop_token_instance(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26get_jop_token_instance[] = "Returns an instance of the jop token iff one should be inferred in the\n            current context; otherwise returns `None`.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_27get_jop_token_instance = {"get_jop_token_instance", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_27get_jop_token_instance, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26get_jop_token_instance};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_27get_jop_token_instance(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_lex = 0;
  PyObject *__pyx_v_processed_left = 0;
  PyObject *__pyx_v_lookbehind = 0;
  PyObject *__pyx_v_subexp_prec = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_jop_token_instance (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_lex,&__pyx_n_s_processed_left,&__pyx_n_s_lookbehind,&__pyx_n_s_subexp_prec,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_jop_token_instance", 1, 5, 5, 1); __PYX_ERR(0, 710, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_processed_left)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_jop_token_instance", 1, 5, 5, 2); __PYX_ERR(0, 710, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lookbehind)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_jop_token_instance", 1, 5, 5, 3); __PYX_ERR(0, 710, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (likely((values[4] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_subexp_prec)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_jop_token_instance", 1, 5, 5, 4); __PYX_ERR(0, 710, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_jop_token_instance") < 0)) __PYX_ERR(0, 710, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
    }
    __pyx_v_self = values[0];
    __pyx_v_lex = values[1];
    __pyx_v_processed_left = values[2];
    __pyx_v_lookbehind = values[3];
    __pyx_v_subexp_prec = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_jop_token_instance", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 710, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.get_jop_token_instance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26get_jop_token_instance(__pyx_self, __pyx_v_self, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind, __pyx_v_subexp_prec);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_26get_jop_token_instance(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_lex, PyObject *__pyx_v_processed_left, PyObject *__pyx_v_lookbehind, PyObject *__pyx_v_subexp_prec) {
  PyObject *__pyx_v_parser_instance = NULL;
  PyObject *__pyx_v_jop_instance = NULL;
  PyObject *__pyx_v_curr_token = NULL;
  CYTHON_UNUSED PyObject *__pyx_v__peek_head_handler = NULL;
  CYTHON_UNUSED PyObject *__pyx_v__peek_tail_handler = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  int __pyx_t_16;
  char const *__pyx_t_17;
  __Pyx_RefNannySetupContext("get_jop_token_instance", 0);

  /* "typped/pratt_parser.py":713
 *             """Returns an instance of the jop token iff one should be inferred in the
 *             current context; otherwise returns `None`."""
 *             parser_instance = self.parser_instance             # <<<<<<<<<<<<<<
 * 
 *             # Not if jop token is undefined for the parser.
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parser_instance); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 713, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_parser_instance = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":716
 * 
 *             # Not if jop token is undefined for the parser.
 *             if not parser_instance.jop_token_subclass:             # <<<<<<<<<<<<<<
 *                 return None
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser_instance, __pyx_n_s_jop_token_subclass); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 716, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 716, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((!__pyx_t_2) != 0);
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":717
 *             # Not if jop token is undefined for the parser.
 *             if not parser_instance.jop_token_subclass:
 *                 return None             # <<<<<<<<<<<<<<
 * 
 *             # Not if at end of expression.
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "typped/pratt_parser.py":716
 * 
 *             # Not if jop token is undefined for the parser.
 *             if not parser_instance.jop_token_subclass:             # <<<<<<<<<<<<<<
 *                 return None
 * 
 */
  }

  /* "typped/pratt_parser.py":720
 * 
 *             # Not if at end of expression.
 *             if lex.peek().is_end_token():             # <<<<<<<<<<<<<<
 *                 return None
 * 
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_peek); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 720, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  if (__pyx_t_6) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 720, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  } else {
    __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 720, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_is_end_token); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 720, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  if (__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 720, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 720, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 720, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":721
 *             # Not if at end of expression.
 *             if lex.peek().is_end_token():
 *                 return None             # <<<<<<<<<<<<<<
 * 
 *             # Not if the ignored token for jop is set but not present.
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "typped/pratt_parser.py":720
 * 
 *             # Not if at end of expression.
 *             if lex.peek().is_end_token():             # <<<<<<<<<<<<<<
 *                 return None
 * 
 */
  }

  /* "typped/pratt_parser.py":724
 * 
 *             # Not if the ignored token for jop is set but not present.
 *             if parser_instance.jop_ignored_token_label and (             # <<<<<<<<<<<<<<
 *                           parser_instance.jop_ignored_token_label
 *                           not in lex.peek().ignored_before_labels()):
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser_instance, __pyx_n_s_jop_ignored_token_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 724, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 724, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {
  } else {
    __pyx_t_3 = __pyx_t_2;
    goto __pyx_L6_bool_binop_done;
  }

  /* "typped/pratt_parser.py":725
 *             # Not if the ignored token for jop is set but not present.
 *             if parser_instance.jop_ignored_token_label and (
 *                           parser_instance.jop_ignored_token_label             # <<<<<<<<<<<<<<
 *                           not in lex.peek().ignored_before_labels()):
 *                 return None
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser_instance, __pyx_n_s_jop_ignored_token_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 725, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "typped/pratt_parser.py":726
 *             if parser_instance.jop_ignored_token_label and (
 *                           parser_instance.jop_ignored_token_label
 *                           not in lex.peek().ignored_before_labels()):             # <<<<<<<<<<<<<<
 *                 return None
 * 
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_peek); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 726, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  if (__pyx_t_7) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 726, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  } else {
    __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 726, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_ignored_before_labels); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 726, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  if (__pyx_t_4) {
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 726, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 726, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_t_1, __pyx_t_5, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 726, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_8 = (__pyx_t_2 != 0);
  __pyx_t_3 = __pyx_t_8;
  __pyx_L6_bool_binop_done:;

  /* "typped/pratt_parser.py":724
 * 
 *             # Not if the ignored token for jop is set but not present.
 *             if parser_instance.jop_ignored_token_label and (             # <<<<<<<<<<<<<<
 *                           parser_instance.jop_ignored_token_label
 *                           not in lex.peek().ignored_before_labels()):
 */
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":727
 *                           parser_instance.jop_ignored_token_label
 *                           not in lex.peek().ignored_before_labels()):
 *                 return None             # <<<<<<<<<<<<<<
 * 
 *             # Now infer a jop, but only if 1) its prec would satisfy the while loop
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;

    /* "typped/pratt_parser.py":724
 * 
 *             # Not if the ignored token for jop is set but not present.
 *             if parser_instance.jop_ignored_token_label and (             # <<<<<<<<<<<<<<
 *                           parser_instance.jop_ignored_token_label
 *                           not in lex.peek().ignored_before_labels()):
 */
  }

  /* "typped/pratt_parser.py":734
 *             # to run its head handler, and 3) the next token similarly has no
 *             # tail handler in the context.
 *             if parser_instance.jop_token_subclass.prec() > subexp_prec:             # <<<<<<<<<<<<<<
 *                 # Provisionally infer a jop; create a subclass instance for its token.
 *                 #
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser_instance, __pyx_n_s_jop_token_subclass); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 734, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_prec); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 734, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  if (__pyx_t_1) {
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 734, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else {
    __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 734, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = PyObject_RichCompare(__pyx_t_5, __pyx_v_subexp_prec, Py_GT); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 734, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 734, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":741
 *                 # lexer to dress it up more like a "real" token, with ignored_before
 *                 # and line numbers, etc. (without putting it in the buffer, of course).
 *                 jop_instance = parser_instance.jop_token_subclass(None)             # <<<<<<<<<<<<<<
 * 
 *                 # This is a little inefficient (since it uses a `go_back` call)
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser_instance, __pyx_n_s_jop_token_subclass); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 741, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 741, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_v_jop_instance = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":752
 *                 # the loop above) infix or postfix operator, and no jop is
 *                 # inferred before another operator).
 *                 curr_token = lex.next()             # <<<<<<<<<<<<<<
 *                 try:
 *                     # Dispatch here WITHOUT CALLING, since calling will consume
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_next); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 752, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    if (__pyx_t_1) {
      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 752, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else {
      __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 752, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_v_curr_token = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":753
 *                 # inferred before another operator).
 *                 curr_token = lex.next()
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Dispatch here WITHOUT CALLING, since calling will consume
 *                     # another token; also, deeper-level recursions could cause false
 */
    /*try:*/ {
      {
        __Pyx_PyThreadState_declare
        __Pyx_PyThreadState_assign
        __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
        __Pyx_XGOTREF(__pyx_t_9);
        __Pyx_XGOTREF(__pyx_t_10);
        __Pyx_XGOTREF(__pyx_t_11);
        /*try:*/ {

          /* "typped/pratt_parser.py":758
 *                     # results to come up the recursion chain.  We are just testing
 *                     # what handlers are defined for the token.
 *                     _peek_head_handler = curr_token.dispatch_handler(HEAD, lex)             # <<<<<<<<<<<<<<
 *                     try: # Found head handler, now make sure it has no tail handler.
 *                         _peek_tail_handler = curr_token.dispatch_handler(
 */
          __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_curr_token, __pyx_n_s_dispatch_handler); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 758, __pyx_L12_error)
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_HEAD); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 758, __pyx_L12_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_4 = NULL;
          __pyx_t_12 = 0;
          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
            __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
            if (likely(__pyx_t_4)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
              __Pyx_INCREF(__pyx_t_4);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_6, function);
              __pyx_t_12 = 1;
            }
          }
          #if CYTHON_FAST_PYCALL
          if (PyFunction_Check(__pyx_t_6)) {
            PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_1, __pyx_v_lex};
            __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 758, __pyx_L12_error)
            __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          } else
          #endif
          #if CYTHON_FAST_PYCCALL
          if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
            PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_1, __pyx_v_lex};
            __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 758, __pyx_L12_error)
            __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          } else
          #endif
          {
            __pyx_t_7 = PyTuple_New(2+__pyx_t_12); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 758, __pyx_L12_error)
            __Pyx_GOTREF(__pyx_t_7);
            if (__pyx_t_4) {
              __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
            }
            __Pyx_GIVEREF(__pyx_t_1);
            PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_12, __pyx_t_1);
            __Pyx_INCREF(__pyx_v_lex);
            __Pyx_GIVEREF(__pyx_v_lex);
            PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_12, __pyx_v_lex);
            __pyx_t_1 = 0;
            __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 758, __pyx_L12_error)
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
          }
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __pyx_v__peek_head_handler = __pyx_t_5;
          __pyx_t_5 = 0;

          /* "typped/pratt_parser.py":759
 *                     # what handlers are defined for the token.
 *                     _peek_head_handler = curr_token.dispatch_handler(HEAD, lex)
 *                     try: # Found head handler, now make sure it has no tail handler.             # <<<<<<<<<<<<<<
 *                         _peek_tail_handler = curr_token.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)
 */
          {
            __Pyx_PyThreadState_declare
            __Pyx_PyThreadState_assign
            __Pyx_ExceptionSave(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
            __Pyx_XGOTREF(__pyx_t_13);
            __Pyx_XGOTREF(__pyx_t_14);
            __Pyx_XGOTREF(__pyx_t_15);
            /*try:*/ {

              /* "typped/pratt_parser.py":760
 *                     _peek_head_handler = curr_token.dispatch_handler(HEAD, lex)
 *                     try: # Found head handler, now make sure it has no tail handler.
 *                         _peek_tail_handler = curr_token.dispatch_handler(             # <<<<<<<<<<<<<<
 *                                            TAIL, lex, processed_left, lookbehind)
 *                     except NoHandlerFunctionDefined:
 */
              __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_curr_token, __pyx_n_s_dispatch_handler); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 760, __pyx_L18_error)
              __Pyx_GOTREF(__pyx_t_6);

              /* "typped/pratt_parser.py":761
 *                     try: # Found head handler, now make sure it has no tail handler.
 *                         _peek_tail_handler = curr_token.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)             # <<<<<<<<<<<<<<
 *                     except NoHandlerFunctionDefined:
 *                         # This is the only case where an actual token is returned.
 */
              __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 761, __pyx_L18_error)
              __Pyx_GOTREF(__pyx_t_7);
              __pyx_t_1 = NULL;
              __pyx_t_12 = 0;
              if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
                __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_6);
                if (likely(__pyx_t_1)) {
                  PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
                  __Pyx_INCREF(__pyx_t_1);
                  __Pyx_INCREF(function);
                  __Pyx_DECREF_SET(__pyx_t_6, function);
                  __pyx_t_12 = 1;
                }
              }
              #if CYTHON_FAST_PYCALL
              if (PyFunction_Check(__pyx_t_6)) {
                PyObject *__pyx_temp[5] = {__pyx_t_1, __pyx_t_7, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
                __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_12, 4+__pyx_t_12); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 760, __pyx_L18_error)
                __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
                __Pyx_GOTREF(__pyx_t_5);
                __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
              } else
              #endif
              #if CYTHON_FAST_PYCCALL
              if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
                PyObject *__pyx_temp[5] = {__pyx_t_1, __pyx_t_7, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
                __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_12, 4+__pyx_t_12); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 760, __pyx_L18_error)
                __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
                __Pyx_GOTREF(__pyx_t_5);
                __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
              } else
              #endif
              {
                __pyx_t_4 = PyTuple_New(4+__pyx_t_12); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 760, __pyx_L18_error)
                __Pyx_GOTREF(__pyx_t_4);
                if (__pyx_t_1) {
                  __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1); __pyx_t_1 = NULL;
                }
                __Pyx_GIVEREF(__pyx_t_7);
                PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_12, __pyx_t_7);
                __Pyx_INCREF(__pyx_v_lex);
                __Pyx_GIVEREF(__pyx_v_lex);
                PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_12, __pyx_v_lex);
                __Pyx_INCREF(__pyx_v_processed_left);
                __Pyx_GIVEREF(__pyx_v_processed_left);
                PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_12, __pyx_v_processed_left);
                __Pyx_INCREF(__pyx_v_lookbehind);
                __Pyx_GIVEREF(__pyx_v_lookbehind);
                PyTuple_SET_ITEM(__pyx_t_4, 3+__pyx_t_12, __pyx_v_lookbehind);
                __pyx_t_7 = 0;
                __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 760, __pyx_L18_error)
                __Pyx_GOTREF(__pyx_t_5);
                __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
              }
              __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
              __pyx_v__peek_tail_handler = __pyx_t_5;
              __pyx_t_5 = 0;

              /* "typped/pratt_parser.py":759
 *                     # what handlers are defined for the token.
 *                     _peek_head_handler = curr_token.dispatch_handler(HEAD, lex)
 *                     try: # Found head handler, now make sure it has no tail handler.             # <<<<<<<<<<<<<<
 *                         _peek_tail_handler = curr_token.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)
 */
            }

            /* "typped/pratt_parser.py":766
 *                         return jop_instance
 *                     else:
 *                         return None             # <<<<<<<<<<<<<<
 *                 except NoHandlerFunctionDefined:
 *                     return None # No precondition matches, assume no jop.
 */
            /*else:*/ {
              __Pyx_XDECREF(__pyx_r);
              __Pyx_INCREF(Py_None);
              __pyx_r = Py_None;
              goto __pyx_L21_except_return;
            }
            __pyx_L18_error:;
            __Pyx_PyThreadState_assign
            __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
            __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
            __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
            __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
            __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;

            /* "typped/pratt_parser.py":762
 *                         _peek_tail_handler = curr_token.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)
 *                     except NoHandlerFunctionDefined:             # <<<<<<<<<<<<<<
 *                         # This is the only case where an actual token is returned.
 *                         return jop_instance
 */
            __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_NoHandlerFunctionDefined); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 762, __pyx_L20_except_error)
            __Pyx_GOTREF(__pyx_t_5);
            __pyx_t_12 = __Pyx_PyErr_ExceptionMatches(__pyx_t_5);
            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
            if (__pyx_t_12) {
              __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.get_jop_token_instance", __pyx_clineno, __pyx_lineno, __pyx_filename);
              if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_4) < 0) __PYX_ERR(0, 762, __pyx_L20_except_error)
              __Pyx_GOTREF(__pyx_t_5);
              __Pyx_GOTREF(__pyx_t_6);
              __Pyx_GOTREF(__pyx_t_4);

              /* "typped/pratt_parser.py":764
 *                     except NoHandlerFunctionDefined:
 *                         # This is the only case where an actual token is returned.
 *                         return jop_instance             # <<<<<<<<<<<<<<
 *                     else:
 *                         return None
 */
              __Pyx_XDECREF(__pyx_r);
              __Pyx_INCREF(__pyx_v_jop_instance);
              __pyx_r = __pyx_v_jop_instance;
              __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
              __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
              __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
              goto __pyx_L21_except_return;
            }
            goto __pyx_L20_except_error;
            __pyx_L20_except_error:;

            /* "typped/pratt_parser.py":759
 *                     # what handlers are defined for the token.
 *                     _peek_head_handler = curr_token.dispatch_handler(HEAD, lex)
 *                     try: # Found head handler, now make sure it has no tail handler.             # <<<<<<<<<<<<<<
 *                         _peek_tail_handler = curr_token.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)
 */
            __Pyx_PyThreadState_assign
            __Pyx_XGIVEREF(__pyx_t_13);
            __Pyx_XGIVEREF(__pyx_t_14);
            __Pyx_XGIVEREF(__pyx_t_15);
            __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
            goto __pyx_L12_error;
            __pyx_L21_except_return:;
            __Pyx_PyThreadState_assign
            __Pyx_XGIVEREF(__pyx_t_13);
            __Pyx_XGIVEREF(__pyx_t_14);
            __Pyx_XGIVEREF(__pyx_t_15);
            __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
            goto __pyx_L16_try_return;
          }

          /* "typped/pratt_parser.py":753
 *                 # inferred before another operator).
 *                 curr_token = lex.next()
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Dispatch here WITHOUT CALLING, since calling will consume
 *                     # another token; also, deeper-level recursions could cause false
 */
        }
        __pyx_L12_error:;
        __Pyx_PyThreadState_assign
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;

        /* "typped/pratt_parser.py":767
 *                     else:
 *                         return None
 *                 except NoHandlerFunctionDefined:             # <<<<<<<<<<<<<<
 *                     return None # No precondition matches, assume no jop.
 *                 finally:
 */
        __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_NoHandlerFunctionDefined); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 767, __pyx_L14_except_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_12 = __Pyx_PyErr_ExceptionMatches(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (__pyx_t_12) {
          __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.get_jop_token_instance", __pyx_clineno, __pyx_lineno, __pyx_filename);
          if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_6, &__pyx_t_5) < 0) __PYX_ERR(0, 767, __pyx_L14_except_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_GOTREF(__pyx_t_5);

          /* "typped/pratt_parser.py":768
 *                         return None
 *                 except NoHandlerFunctionDefined:
 *                     return None # No precondition matches, assume no jop.             # <<<<<<<<<<<<<<
 *                 finally:
 *                     lex.go_back(1)
 */
          __Pyx_XDECREF(__pyx_r);
          __Pyx_INCREF(Py_None);
          __pyx_r = Py_None;
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          goto __pyx_L15_except_return;
        }
        goto __pyx_L14_except_error;
        __pyx_L14_except_error:;

        /* "typped/pratt_parser.py":753
 *                 # inferred before another operator).
 *                 curr_token = lex.next()
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Dispatch here WITHOUT CALLING, since calling will consume
 *                     # another token; also, deeper-level recursions could cause false
 */
        __Pyx_PyThreadState_assign
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
        goto __pyx_L10_error;
        __pyx_L16_try_return:;
        __Pyx_PyThreadState_assign
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
        goto __pyx_L9_return;
        __pyx_L15_except_return:;
        __Pyx_PyThreadState_assign
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
        goto __pyx_L9_return;
      }
    }

    /* "typped/pratt_parser.py":770
 *                     return None # No precondition matches, assume no jop.
 *                 finally:
 *                     lex.go_back(1)             # <<<<<<<<<<<<<<
 *             else:
 *                 return None
 */
    /*finally:*/ {
      /*exception exit:*/{
        __Pyx_PyThreadState_declare
        __pyx_L10_error:;
        __pyx_t_11 = 0; __pyx_t_10 = 0; __pyx_t_9 = 0; __pyx_t_15 = 0; __pyx_t_14 = 0; __pyx_t_13 = 0;
        __Pyx_PyThreadState_assign
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_15, &__pyx_t_14, &__pyx_t_13);
        if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_11, &__pyx_t_10, &__pyx_t_9) < 0)) __Pyx_ErrFetch(&__pyx_t_11, &__pyx_t_10, &__pyx_t_9);
        __Pyx_XGOTREF(__pyx_t_11);
        __Pyx_XGOTREF(__pyx_t_10);
        __Pyx_XGOTREF(__pyx_t_9);
        __Pyx_XGOTREF(__pyx_t_15);
        __Pyx_XGOTREF(__pyx_t_14);
        __Pyx_XGOTREF(__pyx_t_13);
        __pyx_t_12 = __pyx_lineno; __pyx_t_16 = __pyx_clineno; __pyx_t_17 = __pyx_filename;
        {
          __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_go_back); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 770, __pyx_L29_error)
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 770, __pyx_L29_error)
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        }
        __Pyx_PyThreadState_assign
        if (PY_MAJOR_VERSION >= 3) {
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_XGIVEREF(__pyx_t_14);
          __Pyx_XGIVEREF(__pyx_t_13);
          __Pyx_ExceptionReset(__pyx_t_15, __pyx_t_14, __pyx_t_13);
        }
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_9);
        __Pyx_ErrRestore(__pyx_t_11, __pyx_t_10, __pyx_t_9);
        __pyx_t_11 = 0; __pyx_t_10 = 0; __pyx_t_9 = 0; __pyx_t_15 = 0; __pyx_t_14 = 0; __pyx_t_13 = 0;
        __pyx_lineno = __pyx_t_12; __pyx_clineno = __pyx_t_16; __pyx_filename = __pyx_t_17;
        goto __pyx_L1_error;
        __pyx_L29_error:;
        __Pyx_PyThreadState_assign
        if (PY_MAJOR_VERSION >= 3) {
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_XGIVEREF(__pyx_t_14);
          __Pyx_XGIVEREF(__pyx_t_13);
          __Pyx_ExceptionReset(__pyx_t_15, __pyx_t_14, __pyx_t_13);
        }
        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_t_15 = 0; __pyx_t_14 = 0; __pyx_t_13 = 0;
        goto __pyx_L1_error;
      }
      __pyx_L9_return: {
        __pyx_t_13 = __pyx_r;
        __pyx_r = 0;
        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_go_back); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 770, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 770, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_r = __pyx_t_13;
        __pyx_t_13 = 0;
        goto __pyx_L0;
      }
    }

    /* "typped/pratt_parser.py":734
 *             # to run its head handler, and 3) the next token similarly has no
 *             # tail handler in the context.
 *             if parser_instance.jop_token_subclass.prec() > subexp_prec:             # <<<<<<<<<<<<<<
 *                 # Provisionally infer a jop; create a subclass instance for its token.
 *                 #
 */
  }

  /* "typped/pratt_parser.py":772
 *                     lex.go_back(1)
 *             else:
 *                 return None             # <<<<<<<<<<<<<<
 * 
 *         def get_null_string_token_and_handler(self, head_or_tail, lex, subexp_prec,
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_None);
    __pyx_r = Py_None;
    goto __pyx_L0;
  }

  /* "typped/pratt_parser.py":710
 *         #
 * 
 *         def get_jop_token_instance(self, lex, processed_left, lookbehind, subexp_prec):             # <<<<<<<<<<<<<<
 *             """Returns an instance of the jop token iff one should be inferred in the
 *             current context; otherwise returns `None`."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.get_jop_token_instance", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_parser_instance);
  __Pyx_XDECREF(__pyx_v_jop_instance);
  __Pyx_XDECREF(__pyx_v_curr_token);
  __Pyx_XDECREF(__pyx_v__peek_head_handler);
  __Pyx_XDECREF(__pyx_v__peek_tail_handler);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":774
 *                 return None
 * 
 *         def get_null_string_token_and_handler(self, head_or_tail, lex, subexp_prec,             # <<<<<<<<<<<<<<
 *                                          processed_left=None, lookbehind=None):
 *             """Check for any possible matching null-string token handlers;
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_29get_null_string_token_and_handler(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_28get_null_string_token_and_handler[] = "Check for any possible matching null-string token handlers;\n            return the token and the matching handler if one is found.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_29get_null_string_token_and_handler = {"get_null_string_token_and_handler", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_29get_null_string_token_and_handler, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_28get_null_string_token_and_handler};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_29get_null_string_token_and_handler(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_head_or_tail = 0;
  PyObject *__pyx_v_lex = 0;
  PyObject *__pyx_v_subexp_prec = 0;
  PyObject *__pyx_v_processed_left = 0;
  PyObject *__pyx_v_lookbehind = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_null_string_token_and_handler (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_head_or_tail,&__pyx_n_s_lex,&__pyx_n_s_subexp_prec,&__pyx_n_s_processed_left,&__pyx_n_s_lookbehind,0};
    PyObject* values[6] = {0,0,0,0,0,0};

    /* "typped/pratt_parser.py":775
 * 
 *         def get_null_string_token_and_handler(self, head_or_tail, lex, subexp_prec,
 *                                          processed_left=None, lookbehind=None):             # <<<<<<<<<<<<<<
 *             """Check for any possible matching null-string token handlers;
 *             return the token and the matching handler if one is found."""
 */
    values[4] = ((PyObject *)((PyObject *)Py_None));
    values[5] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_head_or_tail)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_null_string_token_and_handler", 0, 4, 6, 1); __PYX_ERR(0, 774, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_null_string_token_and_handler", 0, 4, 6, 2); __PYX_ERR(0, 774, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_subexp_prec)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_null_string_token_and_handler", 0, 4, 6, 3); __PYX_ERR(0, 774, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_processed_left);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lookbehind);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_null_string_token_and_handler") < 0)) __PYX_ERR(0, 774, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_head_or_tail = values[1];
    __pyx_v_lex = values[2];
    __pyx_v_subexp_prec = values[3];
    __pyx_v_processed_left = values[4];
    __pyx_v_lookbehind = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_null_string_token_and_handler", 0, 4, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 774, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.get_null_string_token_and_handler", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_28get_null_string_token_and_handler(__pyx_self, __pyx_v_self, __pyx_v_head_or_tail, __pyx_v_lex, __pyx_v_subexp_prec, __pyx_v_processed_left, __pyx_v_lookbehind);

  /* "typped/pratt_parser.py":774
 *                 return None
 * 
 *         def get_null_string_token_and_handler(self, head_or_tail, lex, subexp_prec,             # <<<<<<<<<<<<<<
 *                                          processed_left=None, lookbehind=None):
 *             """Check for any possible matching null-string token handlers;
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_28get_null_string_token_and_handler(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_lex, PyObject *__pyx_v_subexp_prec, PyObject *__pyx_v_processed_left, PyObject *__pyx_v_lookbehind) {
  PyObject *__pyx_v_parser_instance = NULL;
  PyObject *__pyx_v_curr_token = NULL;
  PyObject *__pyx_v_handler_fun = NULL;
  PyObject *__pyx_v_null_string_token = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  __Pyx_RefNannySetupContext("get_null_string_token_and_handler", 0);

  /* "typped/pratt_parser.py":794
 *             # descent like way...
 * 
 *             parser_instance = self.parser_instance             # <<<<<<<<<<<<<<
 *             curr_token = None
 *             handler_fun = None
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parser_instance); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 794, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_parser_instance = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":795
 * 
 *             parser_instance = self.parser_instance
 *             curr_token = None             # <<<<<<<<<<<<<<
 *             handler_fun = None
 *             # See if a null-string token is set and a handler matches preconds.
 */
  __Pyx_INCREF(Py_None);
  __pyx_v_curr_token = Py_None;

  /* "typped/pratt_parser.py":796
 *             parser_instance = self.parser_instance
 *             curr_token = None
 *             handler_fun = None             # <<<<<<<<<<<<<<
 *             # See if a null-string token is set and a handler matches preconds.
 *             if parser_instance.null_string_token_label:
 */
  __Pyx_INCREF(Py_None);
  __pyx_v_handler_fun = Py_None;

  /* "typped/pratt_parser.py":798
 *             handler_fun = None
 *             # See if a null-string token is set and a handler matches preconds.
 *             if parser_instance.null_string_token_label:             # <<<<<<<<<<<<<<
 *                 null_string_token = parser_instance.null_string_token_subclass(None)
 *                 try:
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser_instance, __pyx_n_s_null_string_token_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":799
 *             # See if a null-string token is set and a handler matches preconds.
 *             if parser_instance.null_string_token_label:
 *                 null_string_token = parser_instance.null_string_token_subclass(None)             # <<<<<<<<<<<<<<
 *                 try:
 *                     handler_fun = null_string_token.dispatch_handler(
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_parser_instance, __pyx_n_s_null_string_token_subclass); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 799, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 799, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_null_string_token = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":800
 *             if parser_instance.null_string_token_label:
 *                 null_string_token = parser_instance.null_string_token_subclass(None)
 *                 try:             # <<<<<<<<<<<<<<
 *                     handler_fun = null_string_token.dispatch_handler(
 *                                       head_or_tail, lex, processed_left, lookbehind)
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_4, &__pyx_t_5, &__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_4);
      __Pyx_XGOTREF(__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_6);
      /*try:*/ {

        /* "typped/pratt_parser.py":801
 *                 null_string_token = parser_instance.null_string_token_subclass(None)
 *                 try:
 *                     handler_fun = null_string_token.dispatch_handler(             # <<<<<<<<<<<<<<
 *                                       head_or_tail, lex, processed_left, lookbehind)
 *                     curr_token = null_string_token
 */
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_null_string_token, __pyx_n_s_dispatch_handler); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 801, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_1);

        /* "typped/pratt_parser.py":802
 *                 try:
 *                     handler_fun = null_string_token.dispatch_handler(
 *                                       head_or_tail, lex, processed_left, lookbehind)             # <<<<<<<<<<<<<<
 *                     curr_token = null_string_token
 *                     # Save subexp_prec and lookbehind as attributes so null-string
 */
        __pyx_t_7 = NULL;
        __pyx_t_8 = 0;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
          __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_1);
          if (likely(__pyx_t_7)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
            __Pyx_INCREF(__pyx_t_7);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_1, function);
            __pyx_t_8 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_1)) {
          PyObject *__pyx_temp[5] = {__pyx_t_7, __pyx_v_head_or_tail, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
          __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_8, 4+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 801, __pyx_L4_error)
          __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_GOTREF(__pyx_t_3);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
          PyObject *__pyx_temp[5] = {__pyx_t_7, __pyx_v_head_or_tail, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
          __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_8, 4+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 801, __pyx_L4_error)
          __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_GOTREF(__pyx_t_3);
        } else
        #endif
        {
          __pyx_t_9 = PyTuple_New(4+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 801, __pyx_L4_error)
          __Pyx_GOTREF(__pyx_t_9);
          if (__pyx_t_7) {
            __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
          }
          __Pyx_INCREF(__pyx_v_head_or_tail);
          __Pyx_GIVEREF(__pyx_v_head_or_tail);
          PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_v_head_or_tail);
          __Pyx_INCREF(__pyx_v_lex);
          __Pyx_GIVEREF(__pyx_v_lex);
          PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_lex);
          __Pyx_INCREF(__pyx_v_processed_left);
          __Pyx_GIVEREF(__pyx_v_processed_left);
          PyTuple_SET_ITEM(__pyx_t_9, 2+__pyx_t_8, __pyx_v_processed_left);
          __Pyx_INCREF(__pyx_v_lookbehind);
          __Pyx_GIVEREF(__pyx_v_lookbehind);
          PyTuple_SET_ITEM(__pyx_t_9, 3+__pyx_t_8, __pyx_v_lookbehind);
          __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 801, __pyx_L4_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        }
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF_SET(__pyx_v_handler_fun, __pyx_t_3);
        __pyx_t_3 = 0;

        /* "typped/pratt_parser.py":803
 *                     handler_fun = null_string_token.dispatch_handler(
 *                                       head_or_tail, lex, processed_left, lookbehind)
 *                     curr_token = null_string_token             # <<<<<<<<<<<<<<
 *                     # Save subexp_prec and lookbehind as attributes so null-string
 *                     # token's handler funs can access them when relaying calls.
 */
        __Pyx_INCREF(__pyx_v_null_string_token);
        __Pyx_DECREF_SET(__pyx_v_curr_token, __pyx_v_null_string_token);

        /* "typped/pratt_parser.py":806
 *                     # Save subexp_prec and lookbehind as attributes so null-string
 *                     # token's handler funs can access them when relaying calls.
 *                     curr_token.saved_subexp_prec = subexp_prec             # <<<<<<<<<<<<<<
 *                     curr_token.lookbehind = lookbehind
 *                 except NoHandlerFunctionDefined:
 */
        if (__Pyx_PyObject_SetAttrStr(__pyx_v_curr_token, __pyx_n_s_saved_subexp_prec, __pyx_v_subexp_prec) < 0) __PYX_ERR(0, 806, __pyx_L4_error)

        /* "typped/pratt_parser.py":807
 *                     # token's handler funs can access them when relaying calls.
 *                     curr_token.saved_subexp_prec = subexp_prec
 *                     curr_token.lookbehind = lookbehind             # <<<<<<<<<<<<<<
 *                 except NoHandlerFunctionDefined:
 *                     pass
 */
        if (__Pyx_PyObject_SetAttrStr(__pyx_v_curr_token, __pyx_n_s_lookbehind, __pyx_v_lookbehind) < 0) __PYX_ERR(0, 807, __pyx_L4_error)

        /* "typped/pratt_parser.py":800
 *             if parser_instance.null_string_token_label:
 *                 null_string_token = parser_instance.null_string_token_subclass(None)
 *                 try:             # <<<<<<<<<<<<<<
 *                     handler_fun = null_string_token.dispatch_handler(
 *                                       head_or_tail, lex, processed_left, lookbehind)
 */
      }
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      goto __pyx_L9_try_end;
      __pyx_L4_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "typped/pratt_parser.py":808
 *                     curr_token.saved_subexp_prec = subexp_prec
 *                     curr_token.lookbehind = lookbehind
 *                 except NoHandlerFunctionDefined:             # <<<<<<<<<<<<<<
 *                     pass
 *             return curr_token, handler_fun
 */
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_NoHandlerFunctionDefined); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 808, __pyx_L6_except_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_8 = __Pyx_PyErr_ExceptionMatches(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (__pyx_t_8) {
        __Pyx_ErrRestore(0,0,0);
        goto __pyx_L5_exception_handled;
      }
      goto __pyx_L6_except_error;
      __pyx_L6_except_error:;

      /* "typped/pratt_parser.py":800
 *             if parser_instance.null_string_token_label:
 *                 null_string_token = parser_instance.null_string_token_subclass(None)
 *                 try:             # <<<<<<<<<<<<<<
 *                     handler_fun = null_string_token.dispatch_handler(
 *                                       head_or_tail, lex, processed_left, lookbehind)
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_ExceptionReset(__pyx_t_4, __pyx_t_5, __pyx_t_6);
      goto __pyx_L1_error;
      __pyx_L5_exception_handled:;
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_ExceptionReset(__pyx_t_4, __pyx_t_5, __pyx_t_6);
      __pyx_L9_try_end:;
    }

    /* "typped/pratt_parser.py":798
 *             handler_fun = None
 *             # See if a null-string token is set and a handler matches preconds.
 *             if parser_instance.null_string_token_label:             # <<<<<<<<<<<<<<
 *                 null_string_token = parser_instance.null_string_token_subclass(None)
 *                 try:
 */
  }

  /* "typped/pratt_parser.py":810
 *                 except NoHandlerFunctionDefined:
 *                     pass
 *             return curr_token, handler_fun             # <<<<<<<<<<<<<<
 * 
 *         def recursive_parse(self, subexp_prec,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_curr_token);
  __Pyx_GIVEREF(__pyx_v_curr_token);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_curr_token);
  __Pyx_INCREF(__pyx_v_handler_fun);
  __Pyx_GIVEREF(__pyx_v_handler_fun);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_handler_fun);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":774
 *                 return None
 * 
 *         def get_null_string_token_and_handler(self, head_or_tail, lex, subexp_prec,             # <<<<<<<<<<<<<<
 *                                          processed_left=None, lookbehind=None):
 *             """Check for any possible matching null-string token handlers;
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.get_null_string_token_and_handler", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_parser_instance);
  __Pyx_XDECREF(__pyx_v_curr_token);
  __Pyx_XDECREF(__pyx_v_handler_fun);
  __Pyx_XDECREF(__pyx_v_null_string_token);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":812
 *             return curr_token, handler_fun
 * 
 *         def recursive_parse(self, subexp_prec,             # <<<<<<<<<<<<<<
 *                             # Below parameters ONLY used in null-string handler funs.
 *                             processed_left=None, lookbehind=None):
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_31recursive_parse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_30recursive_parse[] = "Parse a subexpression as defined by token precedences. Return\n            the result of the evaluation.  Recursively builds up the final\n            result in `processed_left`, which is the tree for the part of the\n            full expression to the left of the current token.  This is a static\n            method so that it can be called from head and tail functions.  Note\n            that the function `dispatch_and_call_handler` which is called in\n            the code often recursively call `recursive_parse` again.  Each\n            recursive call inside the function processes a subexpression,\n            sub-subexpression, etc.  (as implicitly defined by the token\n            precedences).  The list `lookbehind` saves all the previously\n            evaluated subexpressions at this level of recursion (i.e., at the\n            top level in the same subexpression) and passes it to the\n            `tail_dispatcher` method of the tokens, in case that routine wants\n            to make use of it.  For example, the ordinal position of the token\n            in the top level of the subexpression can be calculated from the\n            length of `lookbehind`.\n\n            This function is made a method of `TokenSubclass` so that handler\n            functions can easily call it by using `tok.recursive_parse`, and\n            also so that it can access the lexer without it needing to be\n            passed as an argument.  It is basically a static function, though.\n\n            If `processed_left` is set (evaluates to true) then the first part\n            of `recursive_parse` is skipped and it jumps right to the\n            tail-handling loop part using the passed-in values of\n            `processed_left` and `lookbehind`.  These parameters should\n            generally not be set.  They are only used by certain null-string\n            tokens' tail-handlers so they can relay their call as a tail-handler\n            to the actual token (which does the re""al work).";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_31recursive_parse = {"recursive_parse", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_31recursive_parse, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_30recursive_parse};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_31recursive_parse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_subexp_prec = 0;
  PyObject *__pyx_v_processed_left = 0;
  PyObject *__pyx_v_lookbehind = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recursive_parse (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_subexp_prec,&__pyx_n_s_processed_left,&__pyx_n_s_lookbehind,0};
    PyObject* values[4] = {0,0,0,0};

    /* "typped/pratt_parser.py":814
 *         def recursive_parse(self, subexp_prec,
 *                             # Below parameters ONLY used in null-string handler funs.
 *                             processed_left=None, lookbehind=None):             # <<<<<<<<<<<<<<
 *             """Parse a subexpression as defined by token precedences. Return
 *             the result of the evaluation.  Recursively builds up the final
 */
    values[2] = ((PyObject *)((PyObject *)Py_None));
    values[3] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_subexp_prec)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("recursive_parse", 0, 2, 4, 1); __PYX_ERR(0, 812, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_processed_left);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lookbehind);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "recursive_parse") < 0)) __PYX_ERR(0, 812, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_subexp_prec = values[1];
    __pyx_v_processed_left = values[2];
    __pyx_v_lookbehind = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("recursive_parse", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 812, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.recursive_parse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_30recursive_parse(__pyx_self, __pyx_v_self, __pyx_v_subexp_prec, __pyx_v_processed_left, __pyx_v_lookbehind);

  /* "typped/pratt_parser.py":812
 *             return curr_token, handler_fun
 * 
 *         def recursive_parse(self, subexp_prec,             # <<<<<<<<<<<<<<
 *                             # Below parameters ONLY used in null-string handler funs.
 *                             processed_left=None, lookbehind=None):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_30recursive_parse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_subexp_prec, PyObject *__pyx_v_processed_left, PyObject *__pyx_v_lookbehind) {
  PyObject *__pyx_v_lex = NULL;
  PyObject *__pyx_v_curr_token = NULL;
  PyObject *__pyx_v_head_handler = NULL;
  PyObject *__pyx_v_tail_handler = NULL;
  PyObject *__pyx_v_jop_instance = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *(*__pyx_t_9)(PyObject *);
  int __pyx_t_10;
  __Pyx_RefNannySetupContext("recursive_parse", 0);
  __Pyx_INCREF(__pyx_v_processed_left);
  __Pyx_INCREF(__pyx_v_lookbehind);

  /* "typped/pratt_parser.py":857
 * 
 *             # Set some convenience variables (the lexer and parser instances).
 *             lex = self.token_table.lex             # <<<<<<<<<<<<<<
 *             if not hasattr(self, "parser_instance"):
 *                 # This catches some cases of tokens defined via Lexer, not all.
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 857, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_lex); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 857, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_lex = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":858
 *             # Set some convenience variables (the lexer and parser instances).
 *             lex = self.token_table.lex
 *             if not hasattr(self, "parser_instance"):             # <<<<<<<<<<<<<<
 *                 # This catches some cases of tokens defined via Lexer, not all.
 *                 raise ParserException("All tokens used in the parser must be"
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_self, __pyx_n_s_parser_instance); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 858, __pyx_L1_error)
  __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
  if (__pyx_t_4) {

    /* "typped/pratt_parser.py":860
 *             if not hasattr(self, "parser_instance"):
 *                 # This catches some cases of tokens defined via Lexer, not all.
 *                 raise ParserException("All tokens used in the parser must be"             # <<<<<<<<<<<<<<
 *                         " defined in via parser's methods, not the lexer's.")
 *             #parser_instance = self.parser_instance # If needed, avoid otherwise.
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 860, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 860, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 860, __pyx_L1_error)

    /* "typped/pratt_parser.py":858
 *             # Set some convenience variables (the lexer and parser instances).
 *             lex = self.token_table.lex
 *             if not hasattr(self, "parser_instance"):             # <<<<<<<<<<<<<<
 *                 # This catches some cases of tokens defined via Lexer, not all.
 *                 raise ParserException("All tokens used in the parser must be"
 */
  }

  /* "typped/pratt_parser.py":866
 *             # Skip head-handling if `processed_left` passed in.  ONLY skipped
 *             # when called from relaying null-string tail handlers.
 *             if not processed_left:             # <<<<<<<<<<<<<<
 *                 curr_token, head_handler = self.get_null_string_token_and_handler(
 *                                                            HEAD, lex, subexp_prec)
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_processed_left); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 866, __pyx_L1_error)
  __pyx_t_3 = ((!__pyx_t_4) != 0);
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":867
 *             # when called from relaying null-string tail handlers.
 *             if not processed_left:
 *                 curr_token, head_handler = self.get_null_string_token_and_handler(             # <<<<<<<<<<<<<<
 *                                                            HEAD, lex, subexp_prec)
 *                 if not curr_token:
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_get_null_string_token_and_handle); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 867, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);

    /* "typped/pratt_parser.py":868
 *             if not processed_left:
 *                 curr_token, head_handler = self.get_null_string_token_and_handler(
 *                                                            HEAD, lex, subexp_prec)             # <<<<<<<<<<<<<<
 *                 if not curr_token:
 *                     curr_token = lex.next()
 */
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_HEAD); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 868, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    __pyx_t_7 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
        __pyx_t_7 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[4] = {__pyx_t_6, __pyx_t_5, __pyx_v_lex, __pyx_v_subexp_prec};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 3+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[4] = {__pyx_t_6, __pyx_t_5, __pyx_v_lex, __pyx_v_subexp_prec};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 3+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    {
      __pyx_t_8 = PyTuple_New(3+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      if (__pyx_t_6) {
        __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_5);
      __Pyx_INCREF(__pyx_v_lex);
      __Pyx_GIVEREF(__pyx_v_lex);
      PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_lex);
      __Pyx_INCREF(__pyx_v_subexp_prec);
      __Pyx_GIVEREF(__pyx_v_subexp_prec);
      PyTuple_SET_ITEM(__pyx_t_8, 2+__pyx_t_7, __pyx_v_subexp_prec);
      __pyx_t_5 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
      PyObject* sequence = __pyx_t_1;
      #if !CYTHON_COMPILING_IN_PYPY
      Py_ssize_t size = Py_SIZE(sequence);
      #else
      Py_ssize_t size = PySequence_Size(sequence);
      #endif
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        __PYX_ERR(0, 867, __pyx_L1_error)
      }
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      if (likely(PyTuple_CheckExact(sequence))) {
        __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
        __pyx_t_8 = PyTuple_GET_ITEM(sequence, 1); 
      } else {
        __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
        __pyx_t_8 = PyList_GET_ITEM(sequence, 1); 
      }
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_8);
      #else
      __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_8 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      #endif
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else {
      Py_ssize_t index = -1;
      __pyx_t_5 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 867, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_9 = Py_TYPE(__pyx_t_5)->tp_iternext;
      index = 0; __pyx_t_2 = __pyx_t_9(__pyx_t_5); if (unlikely(!__pyx_t_2)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_2);
      index = 1; __pyx_t_8 = __pyx_t_9(__pyx_t_5); if (unlikely(!__pyx_t_8)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_8);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_5), 2) < 0) __PYX_ERR(0, 867, __pyx_L1_error)
      __pyx_t_9 = NULL;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      goto __pyx_L6_unpacking_done;
      __pyx_L5_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_9 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      __PYX_ERR(0, 867, __pyx_L1_error)
      __pyx_L6_unpacking_done:;
    }

    /* "typped/pratt_parser.py":867
 *             # when called from relaying null-string tail handlers.
 *             if not processed_left:
 *                 curr_token, head_handler = self.get_null_string_token_and_handler(             # <<<<<<<<<<<<<<
 *                                                            HEAD, lex, subexp_prec)
 *                 if not curr_token:
 */
    __pyx_v_curr_token = __pyx_t_2;
    __pyx_t_2 = 0;
    __pyx_v_head_handler = __pyx_t_8;
    __pyx_t_8 = 0;

    /* "typped/pratt_parser.py":869
 *                 curr_token, head_handler = self.get_null_string_token_and_handler(
 *                                                            HEAD, lex, subexp_prec)
 *                 if not curr_token:             # <<<<<<<<<<<<<<
 *                     curr_token = lex.next()
 *                     head_handler = curr_token.dispatch_handler(HEAD, lex)
 */
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_curr_token); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 869, __pyx_L1_error)
    __pyx_t_4 = ((!__pyx_t_3) != 0);
    if (__pyx_t_4) {

      /* "typped/pratt_parser.py":870
 *                                                            HEAD, lex, subexp_prec)
 *                 if not curr_token:
 *                     curr_token = lex.next()             # <<<<<<<<<<<<<<
 *                     head_handler = curr_token.dispatch_handler(HEAD, lex)
 *                 curr_token.is_head = True # To look up eval_fun and ast_data later.
 */
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_next); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 870, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_2 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_8);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_8, function);
        }
      }
      if (__pyx_t_2) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else {
        __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 870, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF_SET(__pyx_v_curr_token, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "typped/pratt_parser.py":871
 *                 if not curr_token:
 *                     curr_token = lex.next()
 *                     head_handler = curr_token.dispatch_handler(HEAD, lex)             # <<<<<<<<<<<<<<
 *                 curr_token.is_head = True # To look up eval_fun and ast_data later.
 *                 # Call the head-handler looked up above.
 */
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_curr_token, __pyx_n_s_dispatch_handler); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 871, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_HEAD); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 871, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_5 = NULL;
      __pyx_t_7 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_8);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_8, function);
          __pyx_t_7 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_8)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_2, __pyx_v_lex};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 871, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_8)) {
        PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_2, __pyx_v_lex};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 871, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 871, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        if (__pyx_t_5) {
          __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_7, __pyx_t_2);
        __Pyx_INCREF(__pyx_v_lex);
        __Pyx_GIVEREF(__pyx_v_lex);
        PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_7, __pyx_v_lex);
        __pyx_t_2 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 871, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF_SET(__pyx_v_head_handler, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "typped/pratt_parser.py":869
 *                 curr_token, head_handler = self.get_null_string_token_and_handler(
 *                                                            HEAD, lex, subexp_prec)
 *                 if not curr_token:             # <<<<<<<<<<<<<<
 *                     curr_token = lex.next()
 *                     head_handler = curr_token.dispatch_handler(HEAD, lex)
 */
    }

    /* "typped/pratt_parser.py":872
 *                     curr_token = lex.next()
 *                     head_handler = curr_token.dispatch_handler(HEAD, lex)
 *                 curr_token.is_head = True # To look up eval_fun and ast_data later.             # <<<<<<<<<<<<<<
 *                 # Call the head-handler looked up above.
 *                 processed_left = head_handler()
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_curr_token, __pyx_n_s_is_head, Py_True) < 0) __PYX_ERR(0, 872, __pyx_L1_error)

    /* "typped/pratt_parser.py":874
 *                 curr_token.is_head = True # To look up eval_fun and ast_data later.
 *                 # Call the head-handler looked up above.
 *                 processed_left = head_handler()             # <<<<<<<<<<<<<<
 *                 lookbehind = [processed_left]
 * 
 */
    __Pyx_INCREF(__pyx_v_head_handler);
    __pyx_t_8 = __pyx_v_head_handler; __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_8);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_8, function);
      }
    }
    if (__pyx_t_6) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 874, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else {
      __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 874, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF_SET(__pyx_v_processed_left, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":875
 *                 # Call the head-handler looked up above.
 *                 processed_left = head_handler()
 *                 lookbehind = [processed_left]             # <<<<<<<<<<<<<<
 * 
 *             while True:
 */
    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 875, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v_processed_left);
    __Pyx_GIVEREF(__pyx_v_processed_left);
    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_v_processed_left);
    __Pyx_DECREF_SET(__pyx_v_lookbehind, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":866
 *             # Skip head-handling if `processed_left` passed in.  ONLY skipped
 *             # when called from relaying null-string tail handlers.
 *             if not processed_left:             # <<<<<<<<<<<<<<
 *                 curr_token, head_handler = self.get_null_string_token_and_handler(
 *                                                            HEAD, lex, subexp_prec)
 */
  }

  /* "typped/pratt_parser.py":877
 *                 lookbehind = [processed_left]
 * 
 *             while True:             # <<<<<<<<<<<<<<
 * 
 *                 #
 */
  while (1) {

    /* "typped/pratt_parser.py":884
 *                 #
 * 
 *                 while lex.peek().prec() > subexp_prec:             # <<<<<<<<<<<<<<
 *                     curr_token, tail_handler = self.get_null_string_token_and_handler(
 *                                     TAIL, lex, subexp_prec, processed_left, lookbehind)
 */
    while (1) {
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_peek); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 884, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_2 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      if (__pyx_t_2) {
        __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 884, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else {
        __pyx_t_8 = __Pyx_PyObject_CallNoArg(__pyx_t_6); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 884, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_prec); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 884, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      if (__pyx_t_8) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 884, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else {
        __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 884, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = PyObject_RichCompare(__pyx_t_1, __pyx_v_subexp_prec, Py_GT); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 884, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 884, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (!__pyx_t_4) break;

      /* "typped/pratt_parser.py":885
 * 
 *                 while lex.peek().prec() > subexp_prec:
 *                     curr_token, tail_handler = self.get_null_string_token_and_handler(             # <<<<<<<<<<<<<<
 *                                     TAIL, lex, subexp_prec, processed_left, lookbehind)
 *                     if not curr_token:
 */
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_get_null_string_token_and_handle); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 885, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);

      /* "typped/pratt_parser.py":886
 *                 while lex.peek().prec() > subexp_prec:
 *                     curr_token, tail_handler = self.get_null_string_token_and_handler(
 *                                     TAIL, lex, subexp_prec, processed_left, lookbehind)             # <<<<<<<<<<<<<<
 *                     if not curr_token:
 *                         curr_token = lex.next()
 */
      __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 886, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_2 = NULL;
      __pyx_t_7 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_1, function);
          __pyx_t_7 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[6] = {__pyx_t_2, __pyx_t_8, __pyx_v_lex, __pyx_v_subexp_prec, __pyx_v_processed_left, __pyx_v_lookbehind};
        __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_7, 5+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 885, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[6] = {__pyx_t_2, __pyx_t_8, __pyx_v_lex, __pyx_v_subexp_prec, __pyx_v_processed_left, __pyx_v_lookbehind};
        __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_7, 5+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 885, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(5+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 885, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        if (__pyx_t_2) {
          __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __pyx_t_2 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_8);
        PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_7, __pyx_t_8);
        __Pyx_INCREF(__pyx_v_lex);
        __Pyx_GIVEREF(__pyx_v_lex);
        PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_7, __pyx_v_lex);
        __Pyx_INCREF(__pyx_v_subexp_prec);
        __Pyx_GIVEREF(__pyx_v_subexp_prec);
        PyTuple_SET_ITEM(__pyx_t_5, 2+__pyx_t_7, __pyx_v_subexp_prec);
        __Pyx_INCREF(__pyx_v_processed_left);
        __Pyx_GIVEREF(__pyx_v_processed_left);
        PyTuple_SET_ITEM(__pyx_t_5, 3+__pyx_t_7, __pyx_v_processed_left);
        __Pyx_INCREF(__pyx_v_lookbehind);
        __Pyx_GIVEREF(__pyx_v_lookbehind);
        PyTuple_SET_ITEM(__pyx_t_5, 4+__pyx_t_7, __pyx_v_lookbehind);
        __pyx_t_8 = 0;
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 885, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if ((likely(PyTuple_CheckExact(__pyx_t_6))) || (PyList_CheckExact(__pyx_t_6))) {
        PyObject* sequence = __pyx_t_6;
        #if !CYTHON_COMPILING_IN_PYPY
        Py_ssize_t size = Py_SIZE(sequence);
        #else
        Py_ssize_t size = PySequence_Size(sequence);
        #endif
        if (unlikely(size != 2)) {
          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
          __PYX_ERR(0, 885, __pyx_L1_error)
        }
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        if (likely(PyTuple_CheckExact(sequence))) {
          __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
          __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
        } else {
          __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
          __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
        }
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_5);
        #else
        __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 885, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 885, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        #endif
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else {
        Py_ssize_t index = -1;
        __pyx_t_8 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 885, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext;
        index = 0; __pyx_t_1 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_1)) goto __pyx_L12_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_1);
        index = 1; __pyx_t_5 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_5)) goto __pyx_L12_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_5);
        if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_8), 2) < 0) __PYX_ERR(0, 885, __pyx_L1_error)
        __pyx_t_9 = NULL;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        goto __pyx_L13_unpacking_done;
        __pyx_L12_unpacking_failed:;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __pyx_t_9 = NULL;
        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
        __PYX_ERR(0, 885, __pyx_L1_error)
        __pyx_L13_unpacking_done:;
      }

      /* "typped/pratt_parser.py":885
 * 
 *                 while lex.peek().prec() > subexp_prec:
 *                     curr_token, tail_handler = self.get_null_string_token_and_handler(             # <<<<<<<<<<<<<<
 *                                     TAIL, lex, subexp_prec, processed_left, lookbehind)
 *                     if not curr_token:
 */
      __Pyx_XDECREF_SET(__pyx_v_curr_token, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_XDECREF_SET(__pyx_v_tail_handler, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "typped/pratt_parser.py":887
 *                     curr_token, tail_handler = self.get_null_string_token_and_handler(
 *                                     TAIL, lex, subexp_prec, processed_left, lookbehind)
 *                     if not curr_token:             # <<<<<<<<<<<<<<
 *                         curr_token = lex.next()
 *                         tail_handler = curr_token.dispatch_handler(
 */
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_curr_token); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 887, __pyx_L1_error)
      __pyx_t_3 = ((!__pyx_t_4) != 0);
      if (__pyx_t_3) {

        /* "typped/pratt_parser.py":888
 *                                     TAIL, lex, subexp_prec, processed_left, lookbehind)
 *                     if not curr_token:
 *                         curr_token = lex.next()             # <<<<<<<<<<<<<<
 *                         tail_handler = curr_token.dispatch_handler(
 *                                              TAIL, lex, processed_left, lookbehind)
 */
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_lex, __pyx_n_s_next); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 888, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_1 = NULL;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
          __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
          if (likely(__pyx_t_1)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
            __Pyx_INCREF(__pyx_t_1);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_5, function);
          }
        }
        if (__pyx_t_1) {
          __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 888, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        } else {
          __pyx_t_6 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 888, __pyx_L1_error)
        }
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF_SET(__pyx_v_curr_token, __pyx_t_6);
        __pyx_t_6 = 0;

        /* "typped/pratt_parser.py":889
 *                     if not curr_token:
 *                         curr_token = lex.next()
 *                         tail_handler = curr_token.dispatch_handler(             # <<<<<<<<<<<<<<
 *                                              TAIL, lex, processed_left, lookbehind)
 * 
 */
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_curr_token, __pyx_n_s_dispatch_handler); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 889, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);

        /* "typped/pratt_parser.py":890
 *                         curr_token = lex.next()
 *                         tail_handler = curr_token.dispatch_handler(
 *                                              TAIL, lex, processed_left, lookbehind)             # <<<<<<<<<<<<<<
 * 
 *                     processed_left = tail_handler()
 */
        __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 890, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_8 = NULL;
        __pyx_t_7 = 0;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
          __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_5);
          if (likely(__pyx_t_8)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
            __Pyx_INCREF(__pyx_t_8);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_5, function);
            __pyx_t_7 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_5)) {
          PyObject *__pyx_temp[5] = {__pyx_t_8, __pyx_t_1, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
          __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 4+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 889, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
          PyObject *__pyx_temp[5] = {__pyx_t_8, __pyx_t_1, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
          __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 4+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 889, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        } else
        #endif
        {
          __pyx_t_2 = PyTuple_New(4+__pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 889, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          if (__pyx_t_8) {
            __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_8); __pyx_t_8 = NULL;
          }
          __Pyx_GIVEREF(__pyx_t_1);
          PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_7, __pyx_t_1);
          __Pyx_INCREF(__pyx_v_lex);
          __Pyx_GIVEREF(__pyx_v_lex);
          PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_7, __pyx_v_lex);
          __Pyx_INCREF(__pyx_v_processed_left);
          __Pyx_GIVEREF(__pyx_v_processed_left);
          PyTuple_SET_ITEM(__pyx_t_2, 2+__pyx_t_7, __pyx_v_processed_left);
          __Pyx_INCREF(__pyx_v_lookbehind);
          __Pyx_GIVEREF(__pyx_v_lookbehind);
          PyTuple_SET_ITEM(__pyx_t_2, 3+__pyx_t_7, __pyx_v_lookbehind);
          __pyx_t_1 = 0;
          __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_2, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 889, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        }
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF_SET(__pyx_v_tail_handler, __pyx_t_6);
        __pyx_t_6 = 0;

        /* "typped/pratt_parser.py":887
 *                     curr_token, tail_handler = self.get_null_string_token_and_handler(
 *                                     TAIL, lex, subexp_prec, processed_left, lookbehind)
 *                     if not curr_token:             # <<<<<<<<<<<<<<
 *                         curr_token = lex.next()
 *                         tail_handler = curr_token.dispatch_handler(
 */
      }

      /* "typped/pratt_parser.py":892
 *                                              TAIL, lex, processed_left, lookbehind)
 * 
 *                     processed_left = tail_handler()             # <<<<<<<<<<<<<<
 *                     lookbehind.append(processed_left)
 * 
 */
      __Pyx_INCREF(__pyx_v_tail_handler);
      __pyx_t_5 = __pyx_v_tail_handler; __pyx_t_2 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      if (__pyx_t_2) {
        __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 892, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      } else {
        __pyx_t_6 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 892, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF_SET(__pyx_v_processed_left, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "typped/pratt_parser.py":893
 * 
 *                     processed_left = tail_handler()
 *                     lookbehind.append(processed_left)             # <<<<<<<<<<<<<<
 * 
 *                 #
 */
      __pyx_t_10 = __Pyx_PyObject_Append(__pyx_v_lookbehind, __pyx_v_processed_left); if (unlikely(__pyx_t_10 == -1)) __PYX_ERR(0, 893, __pyx_L1_error)
    }

    /* "typped/pratt_parser.py":899
 *                 #
 * 
 *                 jop_instance = self.get_jop_token_instance(             # <<<<<<<<<<<<<<
 *                                          lex, processed_left, lookbehind, subexp_prec)
 *                 if jop_instance:
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_get_jop_token_instance); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 899, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);

    /* "typped/pratt_parser.py":900
 * 
 *                 jop_instance = self.get_jop_token_instance(
 *                                          lex, processed_left, lookbehind, subexp_prec)             # <<<<<<<<<<<<<<
 *                 if jop_instance:
 *                     tail_handler = jop_instance.dispatch_handler(
 */
    __pyx_t_2 = NULL;
    __pyx_t_7 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_7 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind, __pyx_v_subexp_prec};
      __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 4+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 899, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind, __pyx_v_subexp_prec};
      __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 4+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 899, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    {
      __pyx_t_1 = PyTuple_New(4+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 899, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (__pyx_t_2) {
        __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2); __pyx_t_2 = NULL;
      }
      __Pyx_INCREF(__pyx_v_lex);
      __Pyx_GIVEREF(__pyx_v_lex);
      PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_7, __pyx_v_lex);
      __Pyx_INCREF(__pyx_v_processed_left);
      __Pyx_GIVEREF(__pyx_v_processed_left);
      PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_7, __pyx_v_processed_left);
      __Pyx_INCREF(__pyx_v_lookbehind);
      __Pyx_GIVEREF(__pyx_v_lookbehind);
      PyTuple_SET_ITEM(__pyx_t_1, 2+__pyx_t_7, __pyx_v_lookbehind);
      __Pyx_INCREF(__pyx_v_subexp_prec);
      __Pyx_GIVEREF(__pyx_v_subexp_prec);
      PyTuple_SET_ITEM(__pyx_t_1, 3+__pyx_t_7, __pyx_v_subexp_prec);
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_1, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 899, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF_SET(__pyx_v_jop_instance, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "typped/pratt_parser.py":901
 *                 jop_instance = self.get_jop_token_instance(
 *                                          lex, processed_left, lookbehind, subexp_prec)
 *                 if jop_instance:             # <<<<<<<<<<<<<<
 *                     tail_handler = jop_instance.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)
 */
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_jop_instance); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 901, __pyx_L1_error)
    if (__pyx_t_3) {

      /* "typped/pratt_parser.py":902
 *                                          lex, processed_left, lookbehind, subexp_prec)
 *                 if jop_instance:
 *                     tail_handler = jop_instance.dispatch_handler(             # <<<<<<<<<<<<<<
 *                                            TAIL, lex, processed_left, lookbehind)
 *                     processed_left = tail_handler()
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_jop_instance, __pyx_n_s_dispatch_handler); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 902, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);

      /* "typped/pratt_parser.py":903
 *                 if jop_instance:
 *                     tail_handler = jop_instance.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)             # <<<<<<<<<<<<<<
 *                     processed_left = tail_handler()
 *                     lookbehind.append(processed_left)
 */
      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 903, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = NULL;
      __pyx_t_7 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
          __pyx_t_7 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_t_1, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
        __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 4+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 902, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_t_1, __pyx_v_lex, __pyx_v_processed_left, __pyx_v_lookbehind};
        __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 4+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 902, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(4+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 902, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        if (__pyx_t_2) {
          __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_2); __pyx_t_2 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_1);
        PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
        __Pyx_INCREF(__pyx_v_lex);
        __Pyx_GIVEREF(__pyx_v_lex);
        PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_lex);
        __Pyx_INCREF(__pyx_v_processed_left);
        __Pyx_GIVEREF(__pyx_v_processed_left);
        PyTuple_SET_ITEM(__pyx_t_8, 2+__pyx_t_7, __pyx_v_processed_left);
        __Pyx_INCREF(__pyx_v_lookbehind);
        __Pyx_GIVEREF(__pyx_v_lookbehind);
        PyTuple_SET_ITEM(__pyx_t_8, 3+__pyx_t_7, __pyx_v_lookbehind);
        __pyx_t_1 = 0;
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 902, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF_SET(__pyx_v_tail_handler, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "typped/pratt_parser.py":904
 *                     tail_handler = jop_instance.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)
 *                     processed_left = tail_handler()             # <<<<<<<<<<<<<<
 *                     lookbehind.append(processed_left)
 *                 else:
 */
      __Pyx_INCREF(__pyx_v_tail_handler);
      __pyx_t_5 = __pyx_v_tail_handler; __pyx_t_8 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      if (__pyx_t_8) {
        __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 904, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else {
        __pyx_t_6 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 904, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF_SET(__pyx_v_processed_left, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "typped/pratt_parser.py":905
 *                                            TAIL, lex, processed_left, lookbehind)
 *                     processed_left = tail_handler()
 *                     lookbehind.append(processed_left)             # <<<<<<<<<<<<<<
 *                 else:
 *                     break
 */
      __pyx_t_10 = __Pyx_PyObject_Append(__pyx_v_lookbehind, __pyx_v_processed_left); if (unlikely(__pyx_t_10 == -1)) __PYX_ERR(0, 905, __pyx_L1_error)

      /* "typped/pratt_parser.py":901
 *                 jop_instance = self.get_jop_token_instance(
 *                                          lex, processed_left, lookbehind, subexp_prec)
 *                 if jop_instance:             # <<<<<<<<<<<<<<
 *                     tail_handler = jop_instance.dispatch_handler(
 *                                            TAIL, lex, processed_left, lookbehind)
 */
      goto __pyx_L15;
    }

    /* "typped/pratt_parser.py":907
 *                     lookbehind.append(processed_left)
 *                 else:
 *                     break             # <<<<<<<<<<<<<<
 * 
 *             return processed_left
 */
    /*else*/ {
      goto __pyx_L9_break;
    }
    __pyx_L15:;
  }
  __pyx_L9_break:;

  /* "typped/pratt_parser.py":909
 *                     break
 * 
 *             return processed_left             # <<<<<<<<<<<<<<
 * 
 *         #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_processed_left);
  __pyx_r = __pyx_v_processed_left;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":812
 *             return curr_token, handler_fun
 * 
 *         def recursive_parse(self, subexp_prec,             # <<<<<<<<<<<<<<
 *                             # Below parameters ONLY used in null-string handler funs.
 *                             processed_left=None, lookbehind=None):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.recursive_parse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_lex);
  __Pyx_XDECREF(__pyx_v_curr_token);
  __Pyx_XDECREF(__pyx_v_head_handler);
  __Pyx_XDECREF(__pyx_v_tail_handler);
  __Pyx_XDECREF(__pyx_v_jop_instance);
  __Pyx_XDECREF(__pyx_v_processed_left);
  __Pyx_XDECREF(__pyx_v_lookbehind);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":915
 *         #
 * 
 *         def __copy__(self):             # <<<<<<<<<<<<<<
 *             """Return a shallow copy of the token."""
 *             return copy.copy(self)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_33__copy__(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_32__copy__[] = "Return a shallow copy of the token.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_33__copy__ = {"__copy__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_33__copy__, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_32__copy__};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_33__copy__(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__copy__ (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_32__copy__(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_32__copy__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__copy__", 0);

  /* "typped/pratt_parser.py":917
 *         def __copy__(self):
 *             """Return a shallow copy of the token."""
 *             return copy.copy(self)             # <<<<<<<<<<<<<<
 * 
 *         #
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_copy); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 917, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_copy); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 917, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 917, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_self};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 917, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_self};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 917, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 917, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_self);
      __Pyx_GIVEREF(__pyx_v_self);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_self);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 917, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":915
 *         #
 * 
 *         def __copy__(self):             # <<<<<<<<<<<<<<
 *             """Return a shallow copy of the token."""
 *             return copy.copy(self)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.__copy__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":923
 *         #
 * 
 *         def summary_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A short summary repr of the node, without its children."""
 *             return ("<" + str(self.token_label) +
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_35summary_repr_with_types(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_34summary_repr_with_types[] = "A short summary repr of the node, without its children.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_35summary_repr_with_types = {"summary_repr_with_types", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_35summary_repr_with_types, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_34summary_repr_with_types};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_35summary_repr_with_types(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("summary_repr_with_types (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_34summary_repr_with_types(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_34summary_repr_with_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("summary_repr_with_types", 0);

  /* "typped/pratt_parser.py":925
 *         def summary_repr_with_types(self):
 *             """A short summary repr of the node, without its children."""
 *             return ("<" + str(self.token_label) +             # <<<<<<<<<<<<<<
 *                     ",'" + str(self.value) +
 *                     "'," + str(self.expanded_formal_sig.val_type) + ">")
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyNumber_Add(__pyx_kp_s__6, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyNumber_Add(__pyx_t_2, __pyx_kp_s__7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":926
 *             """A short summary repr of the node, without its children."""
 *             return ("<" + str(self.token_label) +
 *                     ",'" + str(self.value) +             # <<<<<<<<<<<<<<
 *                     "'," + str(self.expanded_formal_sig.val_type) + ">")
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 926, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 926, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 926, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 926, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyNumber_Add(__pyx_t_3, __pyx_kp_s__8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 926, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":927
 *             return ("<" + str(self.token_label) +
 *                     ",'" + str(self.value) +
 *                     "'," + str(self.expanded_formal_sig.val_type) + ">")             # <<<<<<<<<<<<<<
 * 
 *         def tree_repr_with_types(self, indent=""):
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_expanded_formal_sig); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_val_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyNumber_Add(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyNumber_Add(__pyx_t_3, __pyx_kp_s__9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":923
 *         #
 * 
 *         def summary_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A short summary repr of the node, without its children."""
 *             return ("<" + str(self.token_label) +
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.summary_repr_with_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":929
 *                     "'," + str(self.expanded_formal_sig.val_type) + ">")
 * 
 *         def tree_repr_with_types(self, indent=""):             # <<<<<<<<<<<<<<
 *             """Token representation as the root of a parse subtree, with formatting.
 *             The optional `indent` parameter can be either an indent string or else
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_37tree_repr_with_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_36tree_repr_with_types[] = "Token representation as the root of a parse subtree, with formatting.\n            The optional `indent` parameter can be either an indent string or else\n            an integer for the number of spaces to indent.  Note that the ordinary\n            `tree_repr` method without types is also available, inherited from\n            the base node object.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_37tree_repr_with_types = {"tree_repr_with_types", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_37tree_repr_with_types, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_36tree_repr_with_types};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_37tree_repr_with_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_indent = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tree_repr_with_types (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_indent,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)((PyObject*)__pyx_kp_s__10));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_indent);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "tree_repr_with_types") < 0)) __PYX_ERR(0, 929, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_indent = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("tree_repr_with_types", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 929, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.tree_repr_with_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_36tree_repr_with_types(__pyx_self, __pyx_v_self, __pyx_v_indent);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_36tree_repr_with_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indent) {
  PyObject *__pyx_v_num_indent = NULL;
  PyObject *__pyx_v_string = NULL;
  PyObject *__pyx_v_c = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  PyObject *(*__pyx_t_9)(PyObject *);
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  __Pyx_RefNannySetupContext("tree_repr_with_types", 0);
  __Pyx_INCREF(__pyx_v_indent);

  /* "typped/pratt_parser.py":935
 *             `tree_repr` method without types is also available, inherited from
 *             the base node object."""
 *             try:             # <<<<<<<<<<<<<<
 *                 num_indent = int(indent)
 *             except ValueError:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_1);
    __Pyx_XGOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "typped/pratt_parser.py":936
 *             the base node object."""
 *             try:
 *                 num_indent = int(indent)             # <<<<<<<<<<<<<<
 *             except ValueError:
 *                 pass
 */
      __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_indent); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 936, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_v_num_indent = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "typped/pratt_parser.py":935
 *             `tree_repr` method without types is also available, inherited from
 *             the base node object."""
 *             try:             # <<<<<<<<<<<<<<
 *                 num_indent = int(indent)
 *             except ValueError:
 */
    }

    /* "typped/pratt_parser.py":940
 *                 pass
 *             else:
 *                 indent = " " * num_indent             # <<<<<<<<<<<<<<
 *             string = indent + self.summary_repr_with_types() + "\n"
 *             for c in self.children:
 */
    /*else:*/ {
      __pyx_t_4 = PyNumber_Multiply(__pyx_kp_s__11, __pyx_v_num_indent); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 940, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF_SET(__pyx_v_indent, __pyx_t_4);
      __pyx_t_4 = 0;
    }
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8_try_end;
    __pyx_L3_error:;
    __Pyx_PyThreadState_assign
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":937
 *             try:
 *                 num_indent = int(indent)
 *             except ValueError:             # <<<<<<<<<<<<<<
 *                 pass
 *             else:
 */
    __pyx_t_5 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
    if (__pyx_t_5) {
      __Pyx_ErrRestore(0,0,0);
      goto __pyx_L4_exception_handled;
    }
    goto __pyx_L5_except_error;
    __pyx_L5_except_error:;

    /* "typped/pratt_parser.py":935
 *             `tree_repr` method without types is also available, inherited from
 *             the base node object."""
 *             try:             # <<<<<<<<<<<<<<
 *                 num_indent = int(indent)
 *             except ValueError:
 */
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L4_exception_handled:;
    __Pyx_PyThreadState_assign
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    __pyx_L8_try_end:;
  }

  /* "typped/pratt_parser.py":941
 *             else:
 *                 indent = " " * num_indent
 *             string = indent + self.summary_repr_with_types() + "\n"             # <<<<<<<<<<<<<<
 *             for c in self.children:
 *                 string += c.tree_repr_with_types(indent=indent+" "*4)
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_summary_repr_with_types); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 941, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  if (__pyx_t_7) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 941, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  } else {
    __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 941, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = PyNumber_Add(__pyx_v_indent, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 941, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = PyNumber_Add(__pyx_t_6, __pyx_kp_s__12); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 941, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_v_string = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":942
 *                 indent = " " * num_indent
 *             string = indent + self.summary_repr_with_types() + "\n"
 *             for c in self.children:             # <<<<<<<<<<<<<<
 *                 string += c.tree_repr_with_types(indent=indent+" "*4)
 *             return string
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 942, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (likely(PyList_CheckExact(__pyx_t_4)) || PyTuple_CheckExact(__pyx_t_4)) {
    __pyx_t_6 = __pyx_t_4; __Pyx_INCREF(__pyx_t_6); __pyx_t_8 = 0;
    __pyx_t_9 = NULL;
  } else {
    __pyx_t_8 = -1; __pyx_t_6 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 942, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_9 = Py_TYPE(__pyx_t_6)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 942, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  for (;;) {
    if (likely(!__pyx_t_9)) {
      if (likely(PyList_CheckExact(__pyx_t_6))) {
        if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_6)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_6, __pyx_t_8); __Pyx_INCREF(__pyx_t_4); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 942, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_6, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 942, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_6)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_6, __pyx_t_8); __Pyx_INCREF(__pyx_t_4); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 942, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_6, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 942, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_9(__pyx_t_6);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 942, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_c, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":943
 *             string = indent + self.summary_repr_with_types() + "\n"
 *             for c in self.children:
 *                 string += c.tree_repr_with_types(indent=indent+" "*4)             # <<<<<<<<<<<<<<
 *             return string
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_c, __pyx_n_s_tree_repr_with_types); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = PyDict_New(); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_10 = PyNumber_Multiply(__pyx_kp_s__11, __pyx_int_4); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_11 = PyNumber_Add(__pyx_v_indent, __pyx_t_10); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_indent, __pyx_t_11) < 0) __PYX_ERR(0, 943, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_empty_tuple, __pyx_t_7); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_v_string, __pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    __Pyx_DECREF_SET(__pyx_v_string, __pyx_t_7);
    __pyx_t_7 = 0;

    /* "typped/pratt_parser.py":942
 *                 indent = " " * num_indent
 *             string = indent + self.summary_repr_with_types() + "\n"
 *             for c in self.children:             # <<<<<<<<<<<<<<
 *                 string += c.tree_repr_with_types(indent=indent+" "*4)
 *             return string
 */
  }
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":944
 *             for c in self.children:
 *                 string += c.tree_repr_with_types(indent=indent+" "*4)
 *             return string             # <<<<<<<<<<<<<<
 * 
 *         def string_repr_with_types(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_string);
  __pyx_r = __pyx_v_string;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":929
 *                     "'," + str(self.expanded_formal_sig.val_type) + ">")
 * 
 *         def tree_repr_with_types(self, indent=""):             # <<<<<<<<<<<<<<
 *             """Token representation as the root of a parse subtree, with formatting.
 *             The optional `indent` parameter can be either an indent string or else
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.tree_repr_with_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_num_indent);
  __Pyx_XDECREF(__pyx_v_string);
  __Pyx_XDECREF(__pyx_v_c);
  __Pyx_XDECREF(__pyx_v_indent);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":946
 *             return string
 * 
 *         def string_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_39string_repr_with_types(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_38string_repr_with_types[] = "A string repr for the tree that includes type information.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_39string_repr_with_types = {"string_repr_with_types", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_39string_repr_with_types, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_38string_repr_with_types};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_39string_repr_with_types(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("string_repr_with_types (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_38string_repr_with_types(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22string_repr_with_types_2generator2(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "typped/pratt_parser.py":951
 *             if self.children:
 *                 string += "("
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)             # <<<<<<<<<<<<<<
 *                 string += ")"
 *             return string
 */

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22string_repr_with_types_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *)__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_5_genexpr(__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_5_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 951, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22string_repr_with_types_2generator2, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_token_subclass_factory_locals_To_2, __pyx_n_s_typped_pratt_parser); if (unlikely(!gen)) __PYX_ERR(0, 951, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.string_repr_with_types.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22string_repr_with_types_2generator2(__pyx_CoroutineObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *__pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L6_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 951, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self)) { __Pyx_RaiseClosureNameError("self"); __PYX_ERR(0, 951, __pyx_L1_error) }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 951, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 951, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 951, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 951, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_c);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_c, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_c, __pyx_n_s_string_repr_with_types); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (__pyx_t_6) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else {
      __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    __Pyx_XGIVEREF(__pyx_t_2);
    __pyx_cur_scope->__pyx_t_0 = __pyx_t_2;
    __pyx_cur_scope->__pyx_t_1 = __pyx_t_3;
    __pyx_cur_scope->__pyx_t_2 = __pyx_t_4;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 1;
    return __pyx_r;
    __pyx_L6_resume_from_yield:;
    __pyx_t_2 = __pyx_cur_scope->__pyx_t_0;
    __pyx_cur_scope->__pyx_t_0 = 0;
    __Pyx_XGOTREF(__pyx_t_2);
    __pyx_t_3 = __pyx_cur_scope->__pyx_t_1;
    __pyx_t_4 = __pyx_cur_scope->__pyx_t_2;
    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 951, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":946
 *             return string
 * 
 *         def string_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 */

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_38string_repr_with_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *__pyx_cur_scope;
  PyObject *__pyx_v_string = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("string_repr_with_types", 0);
  __pyx_cur_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *)__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types(__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 946, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_self = __pyx_v_self;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_self);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_self);

  /* "typped/pratt_parser.py":948
 *         def string_repr_with_types(self):
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()             # <<<<<<<<<<<<<<
 *             if self.children:
 *                 string += "("
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_self, __pyx_n_s_summary_repr_with_types); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 948, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 948, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 948, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_string = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":949
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 *             if self.children:             # <<<<<<<<<<<<<<
 *                 string += "("
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_self, __pyx_n_s_children); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 949, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 949, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_4) {

    /* "typped/pratt_parser.py":950
 *             string = self.summary_repr_with_types()
 *             if self.children:
 *                 string += "("             # <<<<<<<<<<<<<<
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)
 *                 string += ")"
 */
    __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_v_string, __pyx_kp_s__13); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 950, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF_SET(__pyx_v_string, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":951
 *             if self.children:
 *                 string += "("
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)             # <<<<<<<<<<<<<<
 *                 string += ")"
 *             return string
 */
    __pyx_t_1 = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_22string_repr_with_types_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyString_Join(__pyx_kp_s__14, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_v_string, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF_SET(__pyx_v_string, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":952
 *                 string += "("
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)
 *                 string += ")"             # <<<<<<<<<<<<<<
 *             return string
 * 
 */
    __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_v_string, __pyx_kp_s__15); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 952, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF_SET(__pyx_v_string, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":949
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 *             if self.children:             # <<<<<<<<<<<<<<
 *                 string += "("
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)
 */
  }

  /* "typped/pratt_parser.py":953
 *                 string += ",".join(c.string_repr_with_types() for c in self.children)
 *                 string += ")"
 *             return string             # <<<<<<<<<<<<<<
 * 
 *         @classmethod
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_string);
  __pyx_r = __pyx_v_string;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":946
 *             return string
 * 
 *         def string_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.string_repr_with_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_string);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":956
 * 
 *         @classmethod
 *         def class_repr(cls):             # <<<<<<<<<<<<<<
 *             """Print out the `TokenSubclass` classes (representing tokens) in a
 *             nice way.  The default is hard to read."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_41class_repr(PyObject *__pyx_self, PyObject *__pyx_v_cls); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_40class_repr[] = "Print out the `TokenSubclass` classes (representing tokens) in a\n            nice way.  The default is hard to read.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_41class_repr = {"class_repr", (PyCFunction)__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_41class_repr, METH_O, __pyx_doc_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_40class_repr};
static PyObject *__pyx_pw_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_41class_repr(PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("class_repr (wrapper)", 0);
  __pyx_r = __pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_40class_repr(__pyx_self, ((PyObject *)__pyx_v_cls));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_40class_repr(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_cls) {
  PyObject *__pyx_v_string = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("class_repr", 0);

  /* "typped/pratt_parser.py":959
 *             """Print out the `TokenSubclass` classes (representing tokens) in a
 *             nice way.  The default is hard to read."""
 *             string = "Token({0})".format(cls.token_label)             # <<<<<<<<<<<<<<
 *             return string
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Token_0, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 959, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cls, __pyx_n_s_token_label); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 959, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 959, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 959, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 959, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 959, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 959, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_string = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":960
 *             nice way.  The default is hard to read."""
 *             string = "Token({0})".format(cls.token_label)
 *             return string             # <<<<<<<<<<<<<<
 * 
 *     return TokenSubclass # Return from token_subclass_factory function.
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_string);
  __pyx_r = __pyx_v_string;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":956
 * 
 *         @classmethod
 *         def class_repr(cls):             # <<<<<<<<<<<<<<
 *             """Print out the `TokenSubclass` classes (representing tokens) in a
 *             nice way.  The default is hard to read."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory.TokenSubclass.class_repr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_string);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":359
 *         return cls.prod_rule_funs["Prec"](cls, arg)
 * 
 * def token_subclass_factory():             # <<<<<<<<<<<<<<
 *     """This function is called from the `create_token_subclass` method of
 *     `TokenTable` when it needs to create a new subclass to begin
 */

static PyObject *__pyx_pf_6typped_12pratt_parser_2token_subclass_factory(CYTHON_UNUSED PyObject *__pyx_self) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannySetupContext("token_subclass_factory", 0);
  __pyx_cur_scope = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *)__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory(__pyx_ptype_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 359, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }

  /* "typped/pratt_parser.py":375
 *     returns a bare-bones subclass without any head or tail functions, etc."""
 * 
 *     class TokenSubclass(TokenSubclassMeta("TokenSubclass", (object,), {}), TokenNode):             # <<<<<<<<<<<<<<
 *     #class TokenSubclass(TokenNode, metaclass=TokenSubclassMeta):  # Python 3
 *     #class TokenSubclass(TokenNode):                               # No metaclass.
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_TokenSubclassMeta); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_builtin_object);
  __Pyx_GIVEREF(__pyx_builtin_object);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_builtin_object);
  __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[4] = {__pyx_t_5, __pyx_n_s_TokenSubclass, __pyx_t_3, __pyx_t_4};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 375, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[4] = {__pyx_t_5, __pyx_n_s_TokenSubclass, __pyx_t_3, __pyx_t_4};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 375, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 375, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_INCREF(__pyx_n_s_TokenSubclass);
    __Pyx_GIVEREF(__pyx_n_s_TokenSubclass);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_n_s_TokenSubclass);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_t_4);
    __pyx_t_3 = 0;
    __pyx_t_4 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 375, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_TokenNode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_7, __pyx_n_s_TokenSubclass, __pyx_n_s_token_subclass_factory_locals_To_3, (PyObject *) NULL, __pyx_n_s_typped_pratt_parser, __pyx_kp_s_The_factory_function_returns_thi); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "typped/pratt_parser.py":380
 *         """The factory function returns this class to represent tokens.  It is a
 *         subclass of the `TokenNode` class, defined in the lexer module."""
 *         static_prec = 0 # The prec value for this kind of token, with default zero.             # <<<<<<<<<<<<<<
 *         token_label = None # Set to the actual value later, by create_token_subclass.
 *         #parser_instance = None # Set during parsing by recursive_parse. AVOID if not needed.
 */
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_static_prec, __pyx_int_0) < 0) __PYX_ERR(0, 380, __pyx_L1_error)

  /* "typped/pratt_parser.py":381
 *         subclass of the `TokenNode` class, defined in the lexer module."""
 *         static_prec = 0 # The prec value for this kind of token, with default zero.
 *         token_label = None # Set to the actual value later, by create_token_subclass.             # <<<<<<<<<<<<<<
 *         #parser_instance = None # Set during parsing by recursive_parse. AVOID if not needed.
 * 
 */
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_token_label, Py_None) < 0) __PYX_ERR(0, 381, __pyx_L1_error)

  /* "typped/pratt_parser.py":384
 *         #parser_instance = None # Set during parsing by recursive_parse. AVOID if not needed.
 * 
 *         def __init__(self, value):             # <<<<<<<<<<<<<<
 *             """Initialize an instance of the subclass for a token of the kind
 *             labeled with `token_label`.  The `value` is the actual parsed
 */
  __pyx_t_4 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_1__init__, 0, __pyx_n_s_token_subclass_factory_locals_To_4, ((PyObject*)__pyx_cur_scope), __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__17)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 384, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 384, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":410
 * 
 *         @classmethod
 *         def prec(cls):             # <<<<<<<<<<<<<<
 *             """Return the precedence for the token.  This is currently a static
 *             value for each type of token.  Later it may be dynamic value
 */
  __pyx_t_4 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_3prec, __Pyx_CYFUNCTION_CLASSMETHOD, __pyx_n_s_token_subclass_factory_locals_To_5, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__19)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 410, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);

  /* "typped/pratt_parser.py":409
 *             self.actual_sig = "Unresolved" # The actual signature.
 * 
 *         @classmethod             # <<<<<<<<<<<<<<
 *         def prec(cls):
 *             """Return the precedence for the token.  This is currently a static
 */
  __pyx_t_3 = __Pyx_Method_ClassMethod(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 409, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_prec, __pyx_t_3) < 0) __PYX_ERR(0, 410, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":417
 *             return cls.static_prec
 * 
 *         def dispatch_handler(self, head_or_tail, lex, left=None, lookbehind=None):             # <<<<<<<<<<<<<<
 *             """Dispatch a callable function what will work as a handler.  The
 *             function also does type-checking after running the defined handler."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_5dispatch_handler, 0, __pyx_n_s_token_subclass_factory_locals_To_6, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__21)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__22);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_dispatch_handler, __pyx_t_3) < 0) __PYX_ERR(0, 417, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":423
 *                                         head_or_tail, self, lex, left, lookbehind)
 * 
 *         def process_not_in_tree(self):             # <<<<<<<<<<<<<<
 *             """Removes any immediate children which have `not_in_tree` set."""
 *             modified_children = []
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_7process_not_in_tree, 0, __pyx_n_s_token_subclass_factory_locals_To_7, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__24)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 423, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_process_not_in_tree, __pyx_t_3) < 0) __PYX_ERR(0, 423, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":433
 *             self.children = modified_children
 * 
 *         def process_and_check_node(self, construct,             # <<<<<<<<<<<<<<
 *                                    val_type_override=None, all_vals_override=None,
 *                                    typesig_override=None):
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_9process_and_check_node, 0, __pyx_n_s_token_subclass_factory_locals_To_8, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__26)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__27);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_process_and_check_node, __pyx_t_3) < 0) __PYX_ERR(0, 433, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":495
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)
 * 
 *         def _check_types_one_pass(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to check
 *             the actual types against their signatures when overloading is only on
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_11_check_types_one_pass, 0, __pyx_n_s_token_subclass_factory_locals_To_9, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__29)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 495, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_check_types_one_pass, __pyx_t_3) < 0) __PYX_ERR(0, 495, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":528
 *             delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_first_of_two_passes(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to do the
 *             first pass in checking the actual types against their signatures.
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_13_check_types_first_of_two_passes, 0, __pyx_n_s_token_subclass_factory_locals_To_10, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__31)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 528, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_check_types_first_of_two_passes, __pyx_t_3) < 0) __PYX_ERR(0, 528, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":543
 *                                       tnode=self)
 * 
 *         def check_types_in_tree_second_pass(self, root=False):             # <<<<<<<<<<<<<<
 *             """Recursively run the second pass on the token subtree with the
 *             `self` node as the root.
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_15check_types_in_tree_second_pass, 0, __pyx_n_s_token_subclass_factory_locals_To_11, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 543, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__34);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_check_types_in_tree_second_pass, __pyx_t_3) < 0) __PYX_ERR(0, 543, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":566
 *                 delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_pass_two(self):             # <<<<<<<<<<<<<<
 *             """A second pass is only used when overloading on return types is
 *             allowed.  It is a top-down pass where each node chooses a unique
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_17_check_types_pass_two, 0, __pyx_n_s_token_subclass_factory_locals_To_12, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 566, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_check_types_pass_two, __pyx_t_3) < 0) __PYX_ERR(0, 566, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":642
 *             return
 * 
 *         def _raise_type_mismatch_error(self, matching_sigs, basic_msg):             # <<<<<<<<<<<<<<
 *             """Raise an error, printing a helpful diagnostic message.  Assumes
 *             that `_check_types` has been called (to set `self.all_possible_sigs`)."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_19_raise_type_mismatch_error, 0, __pyx_n_s_token_subclass_factory_locals_To_13, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_raise_type_mismatch_error, __pyx_t_3) < 0) __PYX_ERR(0, 642, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":667
 * 
 *         @property
 *         def eval_fun(self):             # <<<<<<<<<<<<<<
 *             """Return the evaluation function saved by `_save_eval_fun_and_ast_data`.
 *             Must be called after parsing because the `original_formal_sig` attribute
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_21eval_fun, 0, __pyx_n_s_token_subclass_factory_locals_To_14, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__40)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 667, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "typped/pratt_parser.py":666
 *         #
 * 
 *         @property             # <<<<<<<<<<<<<<
 *         def eval_fun(self):
 *             """Return the evaluation function saved by `_save_eval_fun_and_ast_data`.
 */
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 666, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 666, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_eval_fun, __pyx_t_3) < 0) __PYX_ERR(0, 667, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":675
 * 
 *         @property
 *         def ast_data(self):             # <<<<<<<<<<<<<<
 *             """Return the ast data saved by `_save_ast_data_and_ast_data`.
 *             Must be called after parsing because the `precond_label` attribute must
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_23ast_data, 0, __pyx_n_s_token_subclass_factory_locals_To_15, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__42)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 675, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "typped/pratt_parser.py":674
 *             return self.parser_instance.construct_table.get_eval_fun(orig_sig, self)
 * 
 *         @property             # <<<<<<<<<<<<<<
 *         def ast_data(self):
 *             """Return the ast data saved by `_save_ast_data_and_ast_data`.
 */
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 674, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 674, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_ast_data, __pyx_t_3) < 0) __PYX_ERR(0, 675, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":682
 *             return self.parser_instance.construct_table.get_ast_data(orig_sig, self)
 * 
 *         def eval_subtree(self):             # <<<<<<<<<<<<<<
 *             """Run the saved evaluation function on the token, if one was
 *             registered with it.  Returns `None` if no evaluation function is found."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_25eval_subtree, 0, __pyx_n_s_token_subclass_factory_locals_To_16, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__44)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 682, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_eval_subtree, __pyx_t_3) < 0) __PYX_ERR(0, 682, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":710
 *         #
 * 
 *         def get_jop_token_instance(self, lex, processed_left, lookbehind, subexp_prec):             # <<<<<<<<<<<<<<
 *             """Returns an instance of the jop token iff one should be inferred in the
 *             current context; otherwise returns `None`."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_27get_jop_token_instance, 0, __pyx_n_s_token_subclass_factory_locals_To_17, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__46)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 710, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_get_jop_token_instance, __pyx_t_3) < 0) __PYX_ERR(0, 710, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":774
 *                 return None
 * 
 *         def get_null_string_token_and_handler(self, head_or_tail, lex, subexp_prec,             # <<<<<<<<<<<<<<
 *                                          processed_left=None, lookbehind=None):
 *             """Check for any possible matching null-string token handlers;
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_29get_null_string_token_and_handler, 0, __pyx_n_s_token_subclass_factory_locals_To_18, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__48)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 774, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__49);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_get_null_string_token_and_handle, __pyx_t_3) < 0) __PYX_ERR(0, 774, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":812
 *             return curr_token, handler_fun
 * 
 *         def recursive_parse(self, subexp_prec,             # <<<<<<<<<<<<<<
 *                             # Below parameters ONLY used in null-string handler funs.
 *                             processed_left=None, lookbehind=None):
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_31recursive_parse, 0, __pyx_n_s_token_subclass_factory_locals_To_19, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__51)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__52);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_recursive_parse, __pyx_t_3) < 0) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":915
 *         #
 * 
 *         def __copy__(self):             # <<<<<<<<<<<<<<
 *             """Return a shallow copy of the token."""
 *             return copy.copy(self)
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_33__copy__, 0, __pyx_n_s_token_subclass_factory_locals_To_20, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__54)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 915, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_copy_2, __pyx_t_3) < 0) __PYX_ERR(0, 915, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":923
 *         #
 * 
 *         def summary_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A short summary repr of the node, without its children."""
 *             return ("<" + str(self.token_label) +
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_35summary_repr_with_types, 0, __pyx_n_s_token_subclass_factory_locals_To_21, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__56)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 923, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_summary_repr_with_types, __pyx_t_3) < 0) __PYX_ERR(0, 923, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":929
 *                     "'," + str(self.expanded_formal_sig.val_type) + ">")
 * 
 *         def tree_repr_with_types(self, indent=""):             # <<<<<<<<<<<<<<
 *             """Token representation as the root of a parse subtree, with formatting.
 *             The optional `indent` parameter can be either an indent string or else
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_37tree_repr_with_types, 0, __pyx_n_s_token_subclass_factory_locals_To_22, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__58)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 929, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__59);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_tree_repr_with_types, __pyx_t_3) < 0) __PYX_ERR(0, 929, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":946
 *             return string
 * 
 *         def string_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_39string_repr_with_types, 0, __pyx_n_s_token_subclass_factory_locals_To_23, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__61)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 946, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_string_repr_with_types, __pyx_t_3) < 0) __PYX_ERR(0, 946, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":956
 * 
 *         @classmethod
 *         def class_repr(cls):             # <<<<<<<<<<<<<<
 *             """Print out the `TokenSubclass` classes (representing tokens) in a
 *             nice way.  The default is hard to read."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_22token_subclass_factory_13TokenSubclass_41class_repr, __Pyx_CYFUNCTION_CLASSMETHOD, __pyx_n_s_token_subclass_factory_locals_To_24, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__63)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 956, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "typped/pratt_parser.py":955
 *             return string
 * 
 *         @classmethod             # <<<<<<<<<<<<<<
 *         def class_repr(cls):
 *             """Print out the `TokenSubclass` classes (representing tokens) in a
 */
  __pyx_t_4 = __Pyx_Method_ClassMethod(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 955, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (PyObject_SetItem(__pyx_t_1, __pyx_n_s_class_repr, __pyx_t_4) < 0) __PYX_ERR(0, 956, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":375
 *     returns a bare-bones subclass without any head or tail functions, etc."""
 * 
 *     class TokenSubclass(TokenSubclassMeta("TokenSubclass", (object,), {}), TokenNode):             # <<<<<<<<<<<<<<
 *     #class TokenSubclass(TokenNode, metaclass=TokenSubclassMeta):  # Python 3
 *     #class TokenSubclass(TokenNode):                               # No metaclass.
 */
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_TokenSubclass, __pyx_t_7, __pyx_t_1, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_cur_scope->__pyx_v_TokenSubclass = __pyx_t_4;
  __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "typped/pratt_parser.py":962
 *             return string
 * 
 *     return TokenSubclass # Return from token_subclass_factory function.             # <<<<<<<<<<<<<<
 * 
 * #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_TokenSubclass);
  __pyx_r = __pyx_cur_scope->__pyx_v_TokenSubclass;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":359
 *         return cls.prod_rule_funs["Prec"](cls, arg)
 * 
 * def token_subclass_factory():             # <<<<<<<<<<<<<<
 *     """This function is called from the `create_token_subclass` method of
 *     `TokenTable` when it needs to create a new subclass to begin
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("typped.pratt_parser.token_subclass_factory", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":968
 * #
 * 
 * def lexer_add_parser_instance_attribute(lexer, token):             # <<<<<<<<<<<<<<
 *     """Passed to lexer to add a `parser_instance` attribute to each token it
 *     returns.  This attribute is added to instances at the lexer, from its
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_5lexer_add_parser_instance_attribute(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_4lexer_add_parser_instance_attribute[] = "Passed to lexer to add a `parser_instance` attribute to each token it\n    returns.  This attribute is added to instances at the lexer, from its\n    current token table, because of the case where parsers call other parsers.\n    (It is not added to general token subclasses in `def_token_master` because\n    parsers could potentially share token subclasses.)";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_5lexer_add_parser_instance_attribute = {"lexer_add_parser_instance_attribute", (PyCFunction)__pyx_pw_6typped_12pratt_parser_5lexer_add_parser_instance_attribute, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_4lexer_add_parser_instance_attribute};
static PyObject *__pyx_pw_6typped_12pratt_parser_5lexer_add_parser_instance_attribute(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_lexer = 0;
  PyObject *__pyx_v_token = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lexer_add_parser_instance_attribute (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_lexer,&__pyx_n_s_token,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lexer)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_token)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("lexer_add_parser_instance_attribute", 1, 2, 2, 1); __PYX_ERR(0, 968, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "lexer_add_parser_instance_attribute") < 0)) __PYX_ERR(0, 968, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_lexer = values[0];
    __pyx_v_token = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("lexer_add_parser_instance_attribute", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 968, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.lexer_add_parser_instance_attribute", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_4lexer_add_parser_instance_attribute(__pyx_self, __pyx_v_lexer, __pyx_v_token);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_4lexer_add_parser_instance_attribute(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_lexer, PyObject *__pyx_v_token) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("lexer_add_parser_instance_attribute", 0);

  /* "typped/pratt_parser.py":974
 *     (It is not added to general token subclasses in `def_token_master` because
 *     parsers could potentially share token subclasses.)"""
 *     token.parser_instance = lexer.token_table.parser_instance             # <<<<<<<<<<<<<<
 *     return token
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_lexer, __pyx_n_s_token_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 974, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_parser_instance); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 974, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_token, __pyx_n_s_parser_instance, __pyx_t_2) < 0) __PYX_ERR(0, 974, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":975
 *     parsers could potentially share token subclasses.)"""
 *     token.parser_instance = lexer.token_table.parser_instance
 *     return token             # <<<<<<<<<<<<<<
 * 
 * class PrattParser(object):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_token);
  __pyx_r = __pyx_v_token;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":968
 * #
 * 
 * def lexer_add_parser_instance_attribute(lexer, token):             # <<<<<<<<<<<<<<
 *     """Passed to lexer to add a `parser_instance` attribute to each token it
 *     returns.  This attribute is added to instances at the lexer, from its
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("typped.pratt_parser.lexer_add_parser_instance_attribute", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":980
 *     """A parser object.  Each parser object contains its own token table for tokens
 *     and its own lexer."""
 *     def __init__(self, max_peek_tokens=None,             # <<<<<<<<<<<<<<
 *                        max_deque_size=None,
 *                        lexer = None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser___init__[] = "Initialize the parser.\n\n        The `max_peek_tokens` parameter is an optional arbitrary limit on the\n        level of peeks allowed in the lexer.  Setting to 1 limits it to a\n        single token lookahead.  The default setting `None` gives\n        peek-on-demand as far ahead as requested.\n\n        The `max_deque_size` parameter is an optional limit on the size of the\n        deque that the lexer keeps for previous tokens, the current token, and\n        requested peek tokens.  The default is for it to grow arbitrarily\n        (though it is reset on each parse).  Needs to be large enough for the\n        max level of peeks required plus the max `go_back` level required.\n\n        If a `Lexer` instance is passed in the parser will use that lexer and\n        its token table, otherwise a new lexer is created.  The any other lexer\n        options are ignored.\n\n        No default begin and end functions will be set if a lexer is passed in,\n        regardless of the value of `default_begin_end_tokens`.  Otherwise,\n        default begin and end tokens will be defined unless\n        `default_begin_end_tokens` is set false (note that creating them by\n        default is the opposite of the default behavior for the lower-level\n        Lexer class).\n\n        Setting `skip_type_checking=True` is slightly faster if typing is not\n        being used at all.  Overloading depends on type-checking to resolve the\n        actual types, so this flag implies that the overload flags are all\n        false.  The default is false.\n\n        The `overload_on_arg_types` flag specifies whether or not to overload\n        on argument types.  The default is true.\n\n        Setting `overload_on_ret_types` also overloads on argument types.  It\n        requires an extra walk of the token tree, and implies overloading on\n        argument types.  The default is false.\n\n        If `partial_expressions` is set true then no check will be made in the\n        `parse` method t""o see if the parsing consumed up to the end-token in\n        the lexer.  Multiple expression text can be parsed by repeatedly\n        calling `parse` when this option is true and checking whether the\n        lexer's current token is the end-token.\n\n        If `raise_on_equal_priority_preconds` is true then an exception will be\n        raised if two precondition functions are registered with the same\n        trigger token in the same head or tail position which have the same\n        precondition priority.  The default is false, and the last-defined\n        matching precondition function of the same priority will win any\n        competition.  This option can be used to ensure at language define-time\n        that there is no definition-order dependence in dispatching.  If two\n        such preconditions functions are mutually exclusive there is no problem\n        with them having the same priority, but this condition cannot be\n        checked by a program.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_1__init__ = {"__init__", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_1__init__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser___init__};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_max_peek_tokens = 0;
  PyObject *__pyx_v_max_deque_size = 0;
  PyObject *__pyx_v_lexer = 0;
  PyObject *__pyx_v_default_begin_end_tokens = 0;
  PyObject *__pyx_v_type_table = 0;
  PyObject *__pyx_v_skip_type_checking = 0;
  PyObject *__pyx_v_overload_on_arg_types = 0;
  PyObject *__pyx_v_overload_on_ret_types = 0;
  PyObject *__pyx_v_partial_expressions = 0;
  PyObject *__pyx_v_raise_on_equal_priority_preconds = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_max_peek_tokens,&__pyx_n_s_max_deque_size,&__pyx_n_s_lexer,&__pyx_n_s_default_begin_end_tokens,&__pyx_n_s_type_table,&__pyx_n_s_skip_type_checking,&__pyx_n_s_overload_on_arg_types,&__pyx_n_s_overload_on_ret_types,&__pyx_n_s_partial_expressions,&__pyx_n_s_raise_on_equal_priority_preconds,0};
    PyObject* values[11] = {0,0,0,0,0,0,0,0,0,0,0};
    values[1] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":981
 *     and its own lexer."""
 *     def __init__(self, max_peek_tokens=None,
 *                        max_deque_size=None,             # <<<<<<<<<<<<<<
 *                        lexer = None,
 *                        default_begin_end_tokens=True,
 */
    values[2] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":982
 *     def __init__(self, max_peek_tokens=None,
 *                        max_deque_size=None,
 *                        lexer = None,             # <<<<<<<<<<<<<<
 *                        default_begin_end_tokens=True,
 *                        type_table = None,
 */
    values[3] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":983
 *                        max_deque_size=None,
 *                        lexer = None,
 *                        default_begin_end_tokens=True,             # <<<<<<<<<<<<<<
 *                        type_table = None,
 *                        skip_type_checking=False,
 */
    values[4] = ((PyObject *)((PyObject *)Py_True));

    /* "typped/pratt_parser.py":984
 *                        lexer = None,
 *                        default_begin_end_tokens=True,
 *                        type_table = None,             # <<<<<<<<<<<<<<
 *                        skip_type_checking=False,
 *                        overload_on_arg_types=True,
 */
    values[5] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":985
 *                        default_begin_end_tokens=True,
 *                        type_table = None,
 *                        skip_type_checking=False,             # <<<<<<<<<<<<<<
 *                        overload_on_arg_types=True,
 *                        overload_on_ret_types=False,
 */
    values[6] = ((PyObject *)((PyObject *)Py_False));

    /* "typped/pratt_parser.py":986
 *                        type_table = None,
 *                        skip_type_checking=False,
 *                        overload_on_arg_types=True,             # <<<<<<<<<<<<<<
 *                        overload_on_ret_types=False,
 *                        partial_expressions=False,
 */
    values[7] = ((PyObject *)((PyObject *)Py_True));

    /* "typped/pratt_parser.py":987
 *                        skip_type_checking=False,
 *                        overload_on_arg_types=True,
 *                        overload_on_ret_types=False,             # <<<<<<<<<<<<<<
 *                        partial_expressions=False,
 *                        raise_on_equal_priority_preconds=False):
 */
    values[8] = ((PyObject *)((PyObject *)Py_False));

    /* "typped/pratt_parser.py":988
 *                        overload_on_arg_types=True,
 *                        overload_on_ret_types=False,
 *                        partial_expressions=False,             # <<<<<<<<<<<<<<
 *                        raise_on_equal_priority_preconds=False):
 *         """Initialize the parser.
 */
    values[9] = ((PyObject *)((PyObject *)Py_False));

    /* "typped/pratt_parser.py":989
 *                        overload_on_ret_types=False,
 *                        partial_expressions=False,
 *                        raise_on_equal_priority_preconds=False):             # <<<<<<<<<<<<<<
 *         """Initialize the parser.
 * 
 */
    values[10] = ((PyObject *)((PyObject *)Py_False));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        CYTHON_FALLTHROUGH;
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_max_peek_tokens);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_max_deque_size);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lexer);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_default_begin_end_tokens);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_type_table);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_skip_type_checking);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_overload_on_arg_types);
          if (value) { values[7] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  8:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_overload_on_ret_types);
          if (value) { values[8] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  9:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_partial_expressions);
          if (value) { values[9] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 10:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_raise_on_equal_priority_preconds);
          if (value) { values[10] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 980, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        CYTHON_FALLTHROUGH;
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_max_peek_tokens = values[1];
    __pyx_v_max_deque_size = values[2];
    __pyx_v_lexer = values[3];
    __pyx_v_default_begin_end_tokens = values[4];
    __pyx_v_type_table = values[5];
    __pyx_v_skip_type_checking = values[6];
    __pyx_v_overload_on_arg_types = values[7];
    __pyx_v_overload_on_ret_types = values[8];
    __pyx_v_partial_expressions = values[9];
    __pyx_v_raise_on_equal_priority_preconds = values[10];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 11, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 980, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser___init__(__pyx_self, __pyx_v_self, __pyx_v_max_peek_tokens, __pyx_v_max_deque_size, __pyx_v_lexer, __pyx_v_default_begin_end_tokens, __pyx_v_type_table, __pyx_v_skip_type_checking, __pyx_v_overload_on_arg_types, __pyx_v_overload_on_ret_types, __pyx_v_partial_expressions, __pyx_v_raise_on_equal_priority_preconds);

  /* "typped/pratt_parser.py":980
 *     """A parser object.  Each parser object contains its own token table for tokens
 *     and its own lexer."""
 *     def __init__(self, max_peek_tokens=None,             # <<<<<<<<<<<<<<
 *                        max_deque_size=None,
 *                        lexer = None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_max_peek_tokens, PyObject *__pyx_v_max_deque_size, PyObject *__pyx_v_lexer, PyObject *__pyx_v_default_begin_end_tokens, PyObject *__pyx_v_type_table, PyObject *__pyx_v_skip_type_checking, PyObject *__pyx_v_overload_on_arg_types, PyObject *__pyx_v_overload_on_ret_types, PyObject *__pyx_v_partial_expressions, PyObject *__pyx_v_raise_on_equal_priority_preconds) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_INCREF(__pyx_v_overload_on_arg_types);

  /* "typped/pratt_parser.py":1043
 *         checked by a program."""
 *         ## Type-checking options below; these can be changed between calls to `parse`.
 *         if overload_on_ret_types:             # <<<<<<<<<<<<<<
 *             overload_on_arg_types = True # Overload on ret implies overload on args.
 *         self.skip_type_checking = skip_type_checking # Skip all type checks, faster.
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_overload_on_ret_types); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1043, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1044
 *         ## Type-checking options below; these can be changed between calls to `parse`.
 *         if overload_on_ret_types:
 *             overload_on_arg_types = True # Overload on ret implies overload on args.             # <<<<<<<<<<<<<<
 *         self.skip_type_checking = skip_type_checking # Skip all type checks, faster.
 *         if not skip_type_checking:
 */
    __Pyx_INCREF(Py_True);
    __Pyx_DECREF_SET(__pyx_v_overload_on_arg_types, Py_True);

    /* "typped/pratt_parser.py":1043
 *         checked by a program."""
 *         ## Type-checking options below; these can be changed between calls to `parse`.
 *         if overload_on_ret_types:             # <<<<<<<<<<<<<<
 *             overload_on_arg_types = True # Overload on ret implies overload on args.
 *         self.skip_type_checking = skip_type_checking # Skip all type checks, faster.
 */
  }

  /* "typped/pratt_parser.py":1045
 *         if overload_on_ret_types:
 *             overload_on_arg_types = True # Overload on ret implies overload on args.
 *         self.skip_type_checking = skip_type_checking # Skip all type checks, faster.             # <<<<<<<<<<<<<<
 *         if not skip_type_checking:
 *             self.overload_on_arg_types = overload_on_arg_types
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_skip_type_checking, __pyx_v_skip_type_checking) < 0) __PYX_ERR(0, 1045, __pyx_L1_error)

  /* "typped/pratt_parser.py":1046
 *             overload_on_arg_types = True # Overload on ret implies overload on args.
 *         self.skip_type_checking = skip_type_checking # Skip all type checks, faster.
 *         if not skip_type_checking:             # <<<<<<<<<<<<<<
 *             self.overload_on_arg_types = overload_on_arg_types
 *             self.overload_on_ret_types = overload_on_ret_types
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_skip_type_checking); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1046, __pyx_L1_error)
  __pyx_t_2 = ((!__pyx_t_1) != 0);
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1047
 *         self.skip_type_checking = skip_type_checking # Skip all type checks, faster.
 *         if not skip_type_checking:
 *             self.overload_on_arg_types = overload_on_arg_types             # <<<<<<<<<<<<<<
 *             self.overload_on_ret_types = overload_on_ret_types
 *         else: # Overloading requires type checking.
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_overload_on_arg_types, __pyx_v_overload_on_arg_types) < 0) __PYX_ERR(0, 1047, __pyx_L1_error)

    /* "typped/pratt_parser.py":1048
 *         if not skip_type_checking:
 *             self.overload_on_arg_types = overload_on_arg_types
 *             self.overload_on_ret_types = overload_on_ret_types             # <<<<<<<<<<<<<<
 *         else: # Overloading requires type checking.
 *             self.overload_on_arg_types = False
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_overload_on_ret_types, __pyx_v_overload_on_ret_types) < 0) __PYX_ERR(0, 1048, __pyx_L1_error)

    /* "typped/pratt_parser.py":1046
 *             overload_on_arg_types = True # Overload on ret implies overload on args.
 *         self.skip_type_checking = skip_type_checking # Skip all type checks, faster.
 *         if not skip_type_checking:             # <<<<<<<<<<<<<<
 *             self.overload_on_arg_types = overload_on_arg_types
 *             self.overload_on_ret_types = overload_on_ret_types
 */
    goto __pyx_L4;
  }

  /* "typped/pratt_parser.py":1050
 *             self.overload_on_ret_types = overload_on_ret_types
 *         else: # Overloading requires type checking.
 *             self.overload_on_arg_types = False             # <<<<<<<<<<<<<<
 *             self.overload_on_ret_types = False
 * 
 */
  /*else*/ {
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_overload_on_arg_types, Py_False) < 0) __PYX_ERR(0, 1050, __pyx_L1_error)

    /* "typped/pratt_parser.py":1051
 *         else: # Overloading requires type checking.
 *             self.overload_on_arg_types = False
 *             self.overload_on_ret_types = False             # <<<<<<<<<<<<<<
 * 
 *         # If exceptions are not raised on ties below, the last-set one has
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_overload_on_ret_types, Py_False) < 0) __PYX_ERR(0, 1051, __pyx_L1_error)
  }
  __pyx_L4:;

  /* "typped/pratt_parser.py":1056
 *         # precedence.  Define this before registering any handlers (done
 *         # below in `def_begin_end_tokens`).
 *         self.raise_on_equal_priority_preconds = True             # <<<<<<<<<<<<<<
 * 
 *         self.construct_table = ConstructTable(parser_instance=self) # Dict of constructs.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_raise_on_equal_priority_preconds, Py_True) < 0) __PYX_ERR(0, 1056, __pyx_L1_error)

  /* "typped/pratt_parser.py":1058
 *         self.raise_on_equal_priority_preconds = True
 * 
 *         self.construct_table = ConstructTable(parser_instance=self) # Dict of constructs.             # <<<<<<<<<<<<<<
 *         self.default_precond_label_number = 0 # For unique precondition labels.
 * 
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ConstructTable); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1058, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1058, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_parser_instance, __pyx_v_self) < 0) __PYX_ERR(0, 1058, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_empty_tuple, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1058, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_construct_table, __pyx_t_5) < 0) __PYX_ERR(0, 1058, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "typped/pratt_parser.py":1059
 * 
 *         self.construct_table = ConstructTable(parser_instance=self) # Dict of constructs.
 *         self.default_precond_label_number = 0 # For unique precondition labels.             # <<<<<<<<<<<<<<
 * 
 *         if lexer: # Lexer passed in.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_default_precond_label_number, __pyx_int_0) < 0) __PYX_ERR(0, 1059, __pyx_L1_error)

  /* "typped/pratt_parser.py":1061
 *         self.default_precond_label_number = 0 # For unique precondition labels.
 * 
 *         if lexer: # Lexer passed in.             # <<<<<<<<<<<<<<
 *             self.lex = lexer
 *             self.token_table = lexer.token_table
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_lexer); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1061, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1062
 * 
 *         if lexer: # Lexer passed in.
 *             self.lex = lexer             # <<<<<<<<<<<<<<
 *             self.token_table = lexer.token_table
 *         else: # No Lexer passed in.
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_lex, __pyx_v_lexer) < 0) __PYX_ERR(0, 1062, __pyx_L1_error)

    /* "typped/pratt_parser.py":1063
 *         if lexer: # Lexer passed in.
 *             self.lex = lexer
 *             self.token_table = lexer.token_table             # <<<<<<<<<<<<<<
 *         else: # No Lexer passed in.
 *             self.token_table = TokenTable(
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_lexer, __pyx_n_s_token_table); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1063, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_token_table, __pyx_t_5) < 0) __PYX_ERR(0, 1063, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1061
 *         self.default_precond_label_number = 0 # For unique precondition labels.
 * 
 *         if lexer: # Lexer passed in.             # <<<<<<<<<<<<<<
 *             self.lex = lexer
 *             self.token_table = lexer.token_table
 */
    goto __pyx_L5;
  }

  /* "typped/pratt_parser.py":1065
 *             self.token_table = lexer.token_table
 *         else: # No Lexer passed in.
 *             self.token_table = TokenTable(             # <<<<<<<<<<<<<<
 *                                 token_subclass_factory_fun=token_subclass_factory)
 *             self.lex = Lexer(self.token_table,
 */
  /*else*/ {
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_TokenTable); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1065, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);

    /* "typped/pratt_parser.py":1066
 *         else: # No Lexer passed in.
 *             self.token_table = TokenTable(
 *                                 token_subclass_factory_fun=token_subclass_factory)             # <<<<<<<<<<<<<<
 *             self.lex = Lexer(self.token_table,
 *                              max_peek_tokens=max_peek_tokens,
 */
    __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1066, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_token_subclass_factory); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1066, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_token_subclass_factory_fun, __pyx_t_3) < 0) __PYX_ERR(0, 1066, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":1065
 *             self.token_table = lexer.token_table
 *         else: # No Lexer passed in.
 *             self.token_table = TokenTable(             # <<<<<<<<<<<<<<
 *                                 token_subclass_factory_fun=token_subclass_factory)
 *             self.lex = Lexer(self.token_table,
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_empty_tuple, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1065, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_token_table, __pyx_t_3) < 0) __PYX_ERR(0, 1065, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":1067
 *             self.token_table = TokenTable(
 *                                 token_subclass_factory_fun=token_subclass_factory)
 *             self.lex = Lexer(self.token_table,             # <<<<<<<<<<<<<<
 *                              max_peek_tokens=max_peek_tokens,
 *                              max_deque_size=max_deque_size,
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_Lexer); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1067, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1067, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1067, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":1068
 *                                 token_subclass_factory_fun=token_subclass_factory)
 *             self.lex = Lexer(self.token_table,
 *                              max_peek_tokens=max_peek_tokens,             # <<<<<<<<<<<<<<
 *                              max_deque_size=max_deque_size,
 *                              default_begin_end_tokens=False)
 */
    __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1068, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_max_peek_tokens, __pyx_v_max_peek_tokens) < 0) __PYX_ERR(0, 1068, __pyx_L1_error)

    /* "typped/pratt_parser.py":1069
 *             self.lex = Lexer(self.token_table,
 *                              max_peek_tokens=max_peek_tokens,
 *                              max_deque_size=max_deque_size,             # <<<<<<<<<<<<<<
 *                              default_begin_end_tokens=False)
 *             # Set the begin and end tokens unless the user specified not to.
 */
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_max_deque_size, __pyx_v_max_deque_size) < 0) __PYX_ERR(0, 1068, __pyx_L1_error)

    /* "typped/pratt_parser.py":1070
 *                              max_peek_tokens=max_peek_tokens,
 *                              max_deque_size=max_deque_size,
 *                              default_begin_end_tokens=False)             # <<<<<<<<<<<<<<
 *             # Set the begin and end tokens unless the user specified not to.
 *             if default_begin_end_tokens:
 */
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_default_begin_end_tokens, Py_False) < 0) __PYX_ERR(0, 1068, __pyx_L1_error)

    /* "typped/pratt_parser.py":1067
 *             self.token_table = TokenTable(
 *                                 token_subclass_factory_fun=token_subclass_factory)
 *             self.lex = Lexer(self.token_table,             # <<<<<<<<<<<<<<
 *                              max_peek_tokens=max_peek_tokens,
 *                              max_deque_size=max_deque_size,
 */
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1067, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_lex, __pyx_t_6) < 0) __PYX_ERR(0, 1067, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "typped/pratt_parser.py":1072
 *                              default_begin_end_tokens=False)
 *             # Set the begin and end tokens unless the user specified not to.
 *             if default_begin_end_tokens:             # <<<<<<<<<<<<<<
 *                 self.def_begin_end_tokens() # Use function's defaults.
 *         self.lex.default_helper_exception = ParserException # Default for match_next, etc.
 */
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_default_begin_end_tokens); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1072, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "typped/pratt_parser.py":1073
 *             # Set the begin and end tokens unless the user specified not to.
 *             if default_begin_end_tokens:
 *                 self.def_begin_end_tokens() # Use function's defaults.             # <<<<<<<<<<<<<<
 *         self.lex.default_helper_exception = ParserException # Default for match_next, etc.
 *         # Add mod function to lexer here, works even if they passed in a lexer.
 */
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_begin_end_tokens); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1073, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      if (__pyx_t_5) {
        __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1073, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else {
        __pyx_t_6 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1073, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

      /* "typped/pratt_parser.py":1072
 *                              default_begin_end_tokens=False)
 *             # Set the begin and end tokens unless the user specified not to.
 *             if default_begin_end_tokens:             # <<<<<<<<<<<<<<
 *                 self.def_begin_end_tokens() # Use function's defaults.
 *         self.lex.default_helper_exception = ParserException # Default for match_next, etc.
 */
    }
  }
  __pyx_L5:;

  /* "typped/pratt_parser.py":1074
 *             if default_begin_end_tokens:
 *                 self.def_begin_end_tokens() # Use function's defaults.
 *         self.lex.default_helper_exception = ParserException # Default for match_next, etc.             # <<<<<<<<<<<<<<
 *         # Add mod function to lexer here, works even if they passed in a lexer.
 *         self.lex.final_mod_function = lexer_add_parser_instance_attribute
 */
  __pyx_t_6 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1074, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1074, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (__Pyx_PyObject_SetAttrStr(__pyx_t_4, __pyx_n_s_default_helper_exception, __pyx_t_6) < 0) __PYX_ERR(0, 1074, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":1076
 *         self.lex.default_helper_exception = ParserException # Default for match_next, etc.
 *         # Add mod function to lexer here, works even if they passed in a lexer.
 *         self.lex.final_mod_function = lexer_add_parser_instance_attribute             # <<<<<<<<<<<<<<
 * 
 *         self.token_table.parser_instance = self # Give token table ref to parser.
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_lexer_add_parser_instance_attrib); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1076, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1076, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  if (__Pyx_PyObject_SetAttrStr(__pyx_t_6, __pyx_n_s_final_mod_function, __pyx_t_4) < 0) __PYX_ERR(0, 1076, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":1078
 *         self.lex.final_mod_function = lexer_add_parser_instance_attribute
 * 
 *         self.token_table.parser_instance = self # Give token table ref to parser.             # <<<<<<<<<<<<<<
 * 
 *         if type_table:
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1078, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  if (__Pyx_PyObject_SetAttrStr(__pyx_t_6, __pyx_n_s_parser_instance, __pyx_v_self) < 0) __PYX_ERR(0, 1078, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":1080
 *         self.token_table.parser_instance = self # Give token table ref to parser.
 * 
 *         if type_table:             # <<<<<<<<<<<<<<
 *             self.type_table = type_table
 *         else:
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_type_table); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1080, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1081
 * 
 *         if type_table:
 *             self.type_table = type_table             # <<<<<<<<<<<<<<
 *         else:
 *             self.type_table = TypeTable(self)
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_type_table, __pyx_v_type_table) < 0) __PYX_ERR(0, 1081, __pyx_L1_error)

    /* "typped/pratt_parser.py":1080
 *         self.token_table.parser_instance = self # Give token table ref to parser.
 * 
 *         if type_table:             # <<<<<<<<<<<<<<
 *             self.type_table = type_table
 *         else:
 */
    goto __pyx_L7;
  }

  /* "typped/pratt_parser.py":1083
 *             self.type_table = type_table
 *         else:
 *             self.type_table = TypeTable(self)             # <<<<<<<<<<<<<<
 * 
 *         self.num_lookahead_tokens = max_peek_tokens
 */
  /*else*/ {
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeTable); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1083, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_self); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1083, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_self};
        __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1083, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_self};
        __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1083, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      {
        __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1083, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_INCREF(__pyx_v_self);
        __Pyx_GIVEREF(__pyx_v_self);
        PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_v_self);
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1083, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_type_table, __pyx_t_6) < 0) __PYX_ERR(0, 1083, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __pyx_L7:;

  /* "typped/pratt_parser.py":1085
 *             self.type_table = TypeTable(self)
 * 
 *         self.num_lookahead_tokens = max_peek_tokens             # <<<<<<<<<<<<<<
 *         self.jop_token_label = None # Label of the jop token, if any.
 *         self.jop_token_subclass = None # The actual jop token, if defined.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_num_lookahead_tokens, __pyx_v_max_peek_tokens) < 0) __PYX_ERR(0, 1085, __pyx_L1_error)

  /* "typped/pratt_parser.py":1086
 * 
 *         self.num_lookahead_tokens = max_peek_tokens
 *         self.jop_token_label = None # Label of the jop token, if any.             # <<<<<<<<<<<<<<
 *         self.jop_token_subclass = None # The actual jop token, if defined.
 *         self.null_string_token_label = None # Label of the null-string token, if any.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_label, Py_None) < 0) __PYX_ERR(0, 1086, __pyx_L1_error)

  /* "typped/pratt_parser.py":1087
 *         self.num_lookahead_tokens = max_peek_tokens
 *         self.jop_token_label = None # Label of the jop token, if any.
 *         self.jop_token_subclass = None # The actual jop token, if defined.             # <<<<<<<<<<<<<<
 *         self.null_string_token_label = None # Label of the null-string token, if any.
 *         self.null_string_token_subclass = None # The actual null-string token, if any.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_subclass, Py_None) < 0) __PYX_ERR(0, 1087, __pyx_L1_error)

  /* "typped/pratt_parser.py":1088
 *         self.jop_token_label = None # Label of the jop token, if any.
 *         self.jop_token_subclass = None # The actual jop token, if defined.
 *         self.null_string_token_label = None # Label of the null-string token, if any.             # <<<<<<<<<<<<<<
 *         self.null_string_token_subclass = None # The actual null-string token, if any.
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_label, Py_None) < 0) __PYX_ERR(0, 1088, __pyx_L1_error)

  /* "typped/pratt_parser.py":1089
 *         self.jop_token_subclass = None # The actual jop token, if defined.
 *         self.null_string_token_label = None # Label of the null-string token, if any.
 *         self.null_string_token_subclass = None # The actual null-string token, if any.             # <<<<<<<<<<<<<<
 * 
 *         self.partial_expressions = partial_expressions # Whether to parse multiple expressions.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_subclass, Py_None) < 0) __PYX_ERR(0, 1089, __pyx_L1_error)

  /* "typped/pratt_parser.py":1091
 *         self.null_string_token_subclass = None # The actual null-string token, if any.
 * 
 *         self.partial_expressions = partial_expressions # Whether to parse multiple expressions.             # <<<<<<<<<<<<<<
 *         self.raise_on_equal_priority_preconds = raise_on_equal_priority_preconds
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_partial_expressions, __pyx_v_partial_expressions) < 0) __PYX_ERR(0, 1091, __pyx_L1_error)

  /* "typped/pratt_parser.py":1092
 * 
 *         self.partial_expressions = partial_expressions # Whether to parse multiple expressions.
 *         self.raise_on_equal_priority_preconds = raise_on_equal_priority_preconds             # <<<<<<<<<<<<<<
 * 
 *         self.pstate_stack = [] # Stack of production rules used in grammar parsing.
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_raise_on_equal_priority_preconds, __pyx_v_raise_on_equal_priority_preconds) < 0) __PYX_ERR(0, 1092, __pyx_L1_error)

  /* "typped/pratt_parser.py":1094
 *         self.raise_on_equal_priority_preconds = raise_on_equal_priority_preconds
 * 
 *         self.pstate_stack = [] # Stack of production rules used in grammar parsing.             # <<<<<<<<<<<<<<
 *         self.top_level_production = False # If true, force prod. rule to consume all.
 * 
 */
  __pyx_t_6 = PyList_New(0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_pstate_stack, __pyx_t_6) < 0) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "typped/pratt_parser.py":1095
 * 
 *         self.pstate_stack = [] # Stack of production rules used in grammar parsing.
 *         self.top_level_production = False # If true, force prod. rule to consume all.             # <<<<<<<<<<<<<<
 * 
 *     def _next_unique_precond_label(self, autolabel_prefix=None):
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_top_level_production, Py_False) < 0) __PYX_ERR(0, 1095, __pyx_L1_error)

  /* "typped/pratt_parser.py":980
 *     """A parser object.  Each parser object contains its own token table for tokens
 *     and its own lexer."""
 *     def __init__(self, max_peek_tokens=None,             # <<<<<<<<<<<<<<
 *                        max_deque_size=None,
 *                        lexer = None,
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_overload_on_arg_types);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1097
 *         self.top_level_production = False # If true, force prod. rule to consume all.
 * 
 *     def _next_unique_precond_label(self, autolabel_prefix=None):             # <<<<<<<<<<<<<<
 *         """Return the next unique default label for constructs.  It is a tuple so it
 *         never matches an actual string label."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_3_next_unique_precond_label(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_2_next_unique_precond_label[] = "Return the next unique default label for constructs.  It is a tuple so it\n        never matches an actual string label.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_3_next_unique_precond_label = {"_next_unique_precond_label", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_3_next_unique_precond_label, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_2_next_unique_precond_label};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_3_next_unique_precond_label(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_autolabel_prefix = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_next_unique_precond_label (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_autolabel_prefix,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_autolabel_prefix);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_next_unique_precond_label") < 0)) __PYX_ERR(0, 1097, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_autolabel_prefix = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_next_unique_precond_label", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1097, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser._next_unique_precond_label", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_2_next_unique_precond_label(__pyx_self, __pyx_v_self, __pyx_v_autolabel_prefix);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_2_next_unique_precond_label(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_autolabel_prefix) {
  PyObject *__pyx_v_string_prefix = NULL;
  PyObject *__pyx_v_label = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  __Pyx_RefNannySetupContext("_next_unique_precond_label", 0);

  /* "typped/pratt_parser.py":1100
 *         """Return the next unique default label for constructs.  It is a tuple so it
 *         never matches an actual string label."""
 *         self.default_precond_label_number += 1             # <<<<<<<<<<<<<<
 *         if isinstance(autolabel_prefix, str):
 *             string_prefix = autolabel_prefix
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_default_precond_label_number); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1100, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_AddObjC(__pyx_t_1, __pyx_int_1, 1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1100, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_default_precond_label_number, __pyx_t_2) < 0) __PYX_ERR(0, 1100, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":1101
 *         never matches an actual string label."""
 *         self.default_precond_label_number += 1
 *         if isinstance(autolabel_prefix, str):             # <<<<<<<<<<<<<<
 *             string_prefix = autolabel_prefix
 *         elif autolabel_prefix is None:
 */
  __pyx_t_3 = PyString_Check(__pyx_v_autolabel_prefix); 
  __pyx_t_4 = (__pyx_t_3 != 0);
  if (__pyx_t_4) {

    /* "typped/pratt_parser.py":1102
 *         self.default_precond_label_number += 1
 *         if isinstance(autolabel_prefix, str):
 *             string_prefix = autolabel_prefix             # <<<<<<<<<<<<<<
 *         elif autolabel_prefix is None:
 *             string_prefix = DEFAULT_PRECOND_AUTOLABEL_PREFIX
 */
    __Pyx_INCREF(__pyx_v_autolabel_prefix);
    __pyx_v_string_prefix = __pyx_v_autolabel_prefix;

    /* "typped/pratt_parser.py":1101
 *         never matches an actual string label."""
 *         self.default_precond_label_number += 1
 *         if isinstance(autolabel_prefix, str):             # <<<<<<<<<<<<<<
 *             string_prefix = autolabel_prefix
 *         elif autolabel_prefix is None:
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1103
 *         if isinstance(autolabel_prefix, str):
 *             string_prefix = autolabel_prefix
 *         elif autolabel_prefix is None:             # <<<<<<<<<<<<<<
 *             string_prefix = DEFAULT_PRECOND_AUTOLABEL_PREFIX
 *         else:
 */
  __pyx_t_4 = (__pyx_v_autolabel_prefix == Py_None);
  __pyx_t_3 = (__pyx_t_4 != 0);
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":1104
 *             string_prefix = autolabel_prefix
 *         elif autolabel_prefix is None:
 *             string_prefix = DEFAULT_PRECOND_AUTOLABEL_PREFIX             # <<<<<<<<<<<<<<
 *         else:
 *             raise ParserException("Value of autolabel_prefix value must be None or a"
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_DEFAULT_PRECOND_AUTOLABEL_PREFIX); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1104, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_v_string_prefix = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "typped/pratt_parser.py":1103
 *         if isinstance(autolabel_prefix, str):
 *             string_prefix = autolabel_prefix
 *         elif autolabel_prefix is None:             # <<<<<<<<<<<<<<
 *             string_prefix = DEFAULT_PRECOND_AUTOLABEL_PREFIX
 *         else:
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1106
 *             string_prefix = DEFAULT_PRECOND_AUTOLABEL_PREFIX
 *         else:
 *             raise ParserException("Value of autolabel_prefix value must be None or a"             # <<<<<<<<<<<<<<
 *                                   " string.  Instead got: {0}".format(autolabel_prefix))
 *         label = "{0}__uniquelabel__{1}".format(string_prefix,
 */
  /*else*/ {
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1106, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);

    /* "typped/pratt_parser.py":1107
 *         else:
 *             raise ParserException("Value of autolabel_prefix value must be None or a"
 *                                   " string.  Instead got: {0}".format(autolabel_prefix))             # <<<<<<<<<<<<<<
 *         label = "{0}__uniquelabel__{1}".format(string_prefix,
 *                                                self.default_precond_label_number)
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Value_of_autolabel_prefix_value, __pyx_n_s_format); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1107, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_autolabel_prefix); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1107, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_6)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_autolabel_prefix};
        __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1107, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_autolabel_prefix};
        __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1107, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1107, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
        __Pyx_INCREF(__pyx_v_autolabel_prefix);
        __Pyx_GIVEREF(__pyx_v_autolabel_prefix);
        PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_v_autolabel_prefix);
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1107, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1106, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_5};
        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1106, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
        PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_5};
        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1106, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1106, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_5);
        __pyx_t_5 = 0;
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1106, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 1106, __pyx_L1_error)
  }
  __pyx_L3:;

  /* "typped/pratt_parser.py":1108
 *             raise ParserException("Value of autolabel_prefix value must be None or a"
 *                                   " string.  Instead got: {0}".format(autolabel_prefix))
 *         label = "{0}__uniquelabel__{1}".format(string_prefix,             # <<<<<<<<<<<<<<
 *                                                self.default_precond_label_number)
 *         return label
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_0___uniquelabel___1, __pyx_n_s_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1108, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "typped/pratt_parser.py":1109
 *                                   " string.  Instead got: {0}".format(autolabel_prefix))
 *         label = "{0}__uniquelabel__{1}".format(string_prefix,
 *                                                self.default_precond_label_number)             # <<<<<<<<<<<<<<
 *         return label
 * 
 */
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_default_precond_label_number); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1109, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_5 = NULL;
  __pyx_t_9 = 0;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
      __pyx_t_9 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_string_prefix, __pyx_t_8};
    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1108, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_string_prefix, __pyx_t_8};
    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1108, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  } else
  #endif
  {
    __pyx_t_6 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1108, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_INCREF(__pyx_v_string_prefix);
    __Pyx_GIVEREF(__pyx_v_string_prefix);
    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_9, __pyx_v_string_prefix);
    __Pyx_GIVEREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_9, __pyx_t_8);
    __pyx_t_8 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1108, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_label = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":1110
 *         label = "{0}__uniquelabel__{1}".format(string_prefix,
 *                                                self.default_precond_label_number)
 *         return label             # <<<<<<<<<<<<<<
 * 
 *     #
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_label);
  __pyx_r = __pyx_v_label;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1097
 *         self.top_level_production = False # If true, force prod. rule to consume all.
 * 
 *     def _next_unique_precond_label(self, autolabel_prefix=None):             # <<<<<<<<<<<<<<
 *         """Return the next unique default label for constructs.  It is a tuple so it
 *         never matches an actual string label."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser._next_unique_precond_label", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_string_prefix);
  __Pyx_XDECREF(__pyx_v_label);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1116
 *     #
 * 
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                          token_kind="regular", ignored_token_label=None,
 *                          matcher_options=None):
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_5def_token_master(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_4def_token_master[] = "The master method for defining tokens; all the convenience methods\n        actually call it.  Allows for factoring out some common code and\n        keeping the attributes of all the different kinds of tokens up-to-date.\n        This routine calls the underlying lexer's `def_token` to get tokens and\n        then adds extra attributes needed by the `PrattParser` class.\n\n        The `token_kind` argument must be one of the following strings:\n        `\"regular\"`, `\"ignored\"`, `\"begin\"`, `\"end\"`, `\"jop\"`, or\n        `\"null-string\"`.  The `ignored_token_label` is used only when defining\n        a jop.\n\n        Tokens can be shared between parsers if all their properties are the\n        same.  Note that for now this includes the precedence value for any\n        tail handlers (since that is made a token attribute).  Null-string and\n        jop tokens are the exception, but they are special in that they are\n        never returned by the lexer, only by a particular parser.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_5def_token_master = {"def_token_master", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_5def_token_master, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_4def_token_master};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_5def_token_master(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_token_label = 0;
  PyObject *__pyx_v_regex_string = 0;
  PyObject *__pyx_v_on_ties = 0;
  PyObject *__pyx_v_ignore = 0;
  PyObject *__pyx_v_token_kind = 0;
  PyObject *__pyx_v_ignored_token_label = 0;
  PyObject *__pyx_v_matcher_options = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_token_master (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_token_label,&__pyx_n_s_regex_string,&__pyx_n_s_on_ties,&__pyx_n_s_ignore,&__pyx_n_s_token_kind,&__pyx_n_s_ignored_token_label,&__pyx_n_s_matcher_options,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};
    values[2] = ((PyObject *)((PyObject *)Py_None));
    values[3] = ((PyObject *)((PyObject *)__pyx_int_0));
    values[4] = ((PyObject *)((PyObject *)Py_False));
    values[5] = ((PyObject *)((PyObject*)__pyx_n_s_regular));

    /* "typped/pratt_parser.py":1117
 * 
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,
 *                          token_kind="regular", ignored_token_label=None,             # <<<<<<<<<<<<<<
 *                          matcher_options=None):
 *         """The master method for defining tokens; all the convenience methods
 */
    values[6] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":1118
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,
 *                          token_kind="regular", ignored_token_label=None,
 *                          matcher_options=None):             # <<<<<<<<<<<<<<
 *         """The master method for defining tokens; all the convenience methods
 *         actually call it.  Allows for factoring out some common code and
 */
    values[7] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_token_master", 0, 2, 8, 1); __PYX_ERR(0, 1116, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_regex_string);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_on_ties);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ignore);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_token_kind);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ignored_token_label);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_matcher_options);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_token_master") < 0)) __PYX_ERR(0, 1116, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_token_label = values[1];
    __pyx_v_regex_string = values[2];
    __pyx_v_on_ties = values[3];
    __pyx_v_ignore = values[4];
    __pyx_v_token_kind = values[5];
    __pyx_v_ignored_token_label = values[6];
    __pyx_v_matcher_options = values[7];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_token_master", 0, 2, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1116, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_4def_token_master(__pyx_self, __pyx_v_self, __pyx_v_token_label, __pyx_v_regex_string, __pyx_v_on_ties, __pyx_v_ignore, __pyx_v_token_kind, __pyx_v_ignored_token_label, __pyx_v_matcher_options);

  /* "typped/pratt_parser.py":1116
 *     #
 * 
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                          token_kind="regular", ignored_token_label=None,
 *                          matcher_options=None):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1149
 *             self.begin_token_label = token_label
 *             # Define dummy handlers for the begin-token, just to catch errors.
 *             def begin_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_1begin_head(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_begin_head[] = "Dummy head handler for begin-tokens.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_1begin_head = {"begin_head", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_1begin_head, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_begin_head};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_1begin_head(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
  CYTHON_UNUSED PyObject *__pyx_v_lex = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("begin_head (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_lex,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("begin_head", 1, 2, 2, 1); __PYX_ERR(0, 1149, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "begin_head") < 0)) __PYX_ERR(0, 1149, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_lex = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("begin_head", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1149, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.begin_head", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_begin_head(__pyx_self, __pyx_v_self, __pyx_v_lex);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_begin_head(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("begin_head", 0);

  /* "typped/pratt_parser.py":1151
 *             def begin_head(self, lex):
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")             # <<<<<<<<<<<<<<
 *             def begin_tail(self, lex, left):
 *                 """Dummy tail-handler for begin-tokens."""
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_CalledBeginTokenHandler); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__64, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __PYX_ERR(0, 1151, __pyx_L1_error)

  /* "typped/pratt_parser.py":1149
 *             self.begin_token_label = token_label
 *             # Define dummy handlers for the begin-token, just to catch errors.
 *             def begin_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.begin_head", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1152
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 *             def begin_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_3begin_tail(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_2begin_tail[] = "Dummy tail-handler for begin-tokens.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_3begin_tail = {"begin_tail", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_3begin_tail, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_2begin_tail};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_3begin_tail(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
  CYTHON_UNUSED PyObject *__pyx_v_lex = 0;
  CYTHON_UNUSED PyObject *__pyx_v_left = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("begin_tail (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_lex,&__pyx_n_s_left,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("begin_tail", 1, 3, 3, 1); __PYX_ERR(0, 1152, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("begin_tail", 1, 3, 3, 2); __PYX_ERR(0, 1152, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "begin_tail") < 0)) __PYX_ERR(0, 1152, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_self = values[0];
    __pyx_v_lex = values[1];
    __pyx_v_left = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("begin_tail", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1152, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.begin_tail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_2begin_tail(__pyx_self, __pyx_v_self, __pyx_v_lex, __pyx_v_left);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_2begin_tail(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex, CYTHON_UNUSED PyObject *__pyx_v_left) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("begin_tail", 0);

  /* "typped/pratt_parser.py":1154
 *             def begin_tail(self, lex, left):
 *                 """Dummy tail-handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")             # <<<<<<<<<<<<<<
 *             self.def_construct(HEAD, begin_head, token_label)
 *             self.def_construct(TAIL, begin_tail, token_label, dummy_handler=True)
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_CalledBeginTokenHandler); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1154, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__65, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1154, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __PYX_ERR(0, 1154, __pyx_L1_error)

  /* "typped/pratt_parser.py":1152
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 *             def begin_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.begin_tail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1163
 *             self.end_token_label = token_label
 *             # Define dummy handlers for the end-token, just to catch errors.
 *             def end_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_5end_head(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_4end_head[] = "Dummy head handler for end-tokens.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_5end_head = {"end_head", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_5end_head, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_4end_head};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_5end_head(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
  CYTHON_UNUSED PyObject *__pyx_v_lex = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("end_head (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_lex,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("end_head", 1, 2, 2, 1); __PYX_ERR(0, 1163, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "end_head") < 0)) __PYX_ERR(0, 1163, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_lex = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("end_head", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1163, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.end_head", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_4end_head(__pyx_self, __pyx_v_self, __pyx_v_lex);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_4end_head(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("end_head", 0);

  /* "typped/pratt_parser.py":1165
 *             def end_head(self, lex):
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")             # <<<<<<<<<<<<<<
 *             def end_tail(self, lex, left):
 *                 """Dummy tail-handler for end-tokens."""
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_CalledEndTokenHandler); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1165, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__66, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1165, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __PYX_ERR(0, 1165, __pyx_L1_error)

  /* "typped/pratt_parser.py":1163
 *             self.end_token_label = token_label
 *             # Define dummy handlers for the end-token, just to catch errors.
 *             def end_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.end_head", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1166
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 *             def end_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_7end_tail(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_6end_tail[] = "Dummy tail-handler for end-tokens.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_7end_tail = {"end_tail", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_7end_tail, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_16def_token_master_6end_tail};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_16def_token_master_7end_tail(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
  CYTHON_UNUSED PyObject *__pyx_v_lex = 0;
  CYTHON_UNUSED PyObject *__pyx_v_left = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("end_tail (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_lex,&__pyx_n_s_left,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lex)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("end_tail", 1, 3, 3, 1); __PYX_ERR(0, 1166, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_left)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("end_tail", 1, 3, 3, 2); __PYX_ERR(0, 1166, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "end_tail") < 0)) __PYX_ERR(0, 1166, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_self = values[0];
    __pyx_v_lex = values[1];
    __pyx_v_left = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("end_tail", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1166, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.end_tail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_6end_tail(__pyx_self, __pyx_v_self, __pyx_v_lex, __pyx_v_left);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16def_token_master_6end_tail(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_lex, CYTHON_UNUSED PyObject *__pyx_v_left) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("end_tail", 0);

  /* "typped/pratt_parser.py":1168
 *             def end_tail(self, lex, left):
 *                 """Dummy tail-handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")             # <<<<<<<<<<<<<<
 *             self.def_construct(HEAD, end_head, token_label)
 *             self.def_construct(TAIL, end_tail, token_label, dummy_handler=True)
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_CalledEndTokenHandler); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1168, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__67, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1168, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __PYX_ERR(0, 1168, __pyx_L1_error)

  /* "typped/pratt_parser.py":1166
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 *             def end_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master.end_tail", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1116
 *     #
 * 
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                          token_kind="regular", ignored_token_label=None,
 *                          matcher_options=None):
 */

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_4def_token_master(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label, PyObject *__pyx_v_regex_string, PyObject *__pyx_v_on_ties, PyObject *__pyx_v_ignore, PyObject *__pyx_v_token_kind, PyObject *__pyx_v_ignored_token_label, PyObject *__pyx_v_matcher_options) {
  PyObject *__pyx_v_token_table = NULL;
  PyObject *__pyx_v_tok = NULL;
  PyObject *__pyx_v_begin_head = 0;
  PyObject *__pyx_v_begin_tail = 0;
  PyObject *__pyx_v_end_head = 0;
  PyObject *__pyx_v_end_tail = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("def_token_master", 0);

  /* "typped/pratt_parser.py":1135
 *         jop tokens are the exception, but they are special in that they are
 *         never returned by the lexer, only by a particular parser."""
 *         token_table = self.token_table             # <<<<<<<<<<<<<<
 * 
 *         if token_kind == "regular":
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_token_table = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1137
 *         token_table = self.token_table
 * 
 *         if token_kind == "regular":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_token(token_label, regex_string,
 *                        on_ties=on_ties, ignore=ignore, matcher_options=matcher_options)
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_token_kind, __pyx_n_s_regular, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1137, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1138
 * 
 *         if token_kind == "regular":
 *             tok = token_table.def_token(token_label, regex_string,             # <<<<<<<<<<<<<<
 *                        on_ties=on_ties, ignore=ignore, matcher_options=matcher_options)
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_def_token); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1138, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1138, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_token_label);
    __Pyx_GIVEREF(__pyx_v_token_label);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_token_label);
    __Pyx_INCREF(__pyx_v_regex_string);
    __Pyx_GIVEREF(__pyx_v_regex_string);
    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_regex_string);

    /* "typped/pratt_parser.py":1139
 *         if token_kind == "regular":
 *             tok = token_table.def_token(token_label, regex_string,
 *                        on_ties=on_ties, ignore=ignore, matcher_options=matcher_options)             # <<<<<<<<<<<<<<
 * 
 *         elif token_kind == "ignored":
 */
    __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1139, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_on_ties, __pyx_v_on_ties) < 0) __PYX_ERR(0, 1139, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_ignore, __pyx_v_ignore) < 0) __PYX_ERR(0, 1139, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_matcher_options, __pyx_v_matcher_options) < 0) __PYX_ERR(0, 1139, __pyx_L1_error)

    /* "typped/pratt_parser.py":1138
 * 
 *         if token_kind == "regular":
 *             tok = token_table.def_token(token_label, regex_string,             # <<<<<<<<<<<<<<
 *                        on_ties=on_ties, ignore=ignore, matcher_options=matcher_options)
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1138, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_v_tok = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1137
 *         token_table = self.token_table
 * 
 *         if token_kind == "regular":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_token(token_label, regex_string,
 *                        on_ties=on_ties, ignore=ignore, matcher_options=matcher_options)
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1141
 *                        on_ties=on_ties, ignore=ignore, matcher_options=matcher_options)
 * 
 *         elif token_kind == "ignored":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_token(token_label, regex_string,
 *                        on_ties=on_ties, ignore=True, matcher_options=matcher_options)
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_token_kind, __pyx_n_s_ignored, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1141, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1142
 * 
 *         elif token_kind == "ignored":
 *             tok = token_table.def_token(token_label, regex_string,             # <<<<<<<<<<<<<<
 *                        on_ties=on_ties, ignore=True, matcher_options=matcher_options)
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_def_token); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1142, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1142, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(__pyx_v_token_label);
    __Pyx_GIVEREF(__pyx_v_token_label);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_token_label);
    __Pyx_INCREF(__pyx_v_regex_string);
    __Pyx_GIVEREF(__pyx_v_regex_string);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_regex_string);

    /* "typped/pratt_parser.py":1143
 *         elif token_kind == "ignored":
 *             tok = token_table.def_token(token_label, regex_string,
 *                        on_ties=on_ties, ignore=True, matcher_options=matcher_options)             # <<<<<<<<<<<<<<
 * 
 *         elif token_kind == "begin":
 */
    __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1143, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_on_ties, __pyx_v_on_ties) < 0) __PYX_ERR(0, 1143, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ignore, Py_True) < 0) __PYX_ERR(0, 1143, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_matcher_options, __pyx_v_matcher_options) < 0) __PYX_ERR(0, 1143, __pyx_L1_error)

    /* "typped/pratt_parser.py":1142
 * 
 *         elif token_kind == "ignored":
 *             tok = token_table.def_token(token_label, regex_string,             # <<<<<<<<<<<<<<
 *                        on_ties=on_ties, ignore=True, matcher_options=matcher_options)
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1142, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_tok = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1141
 *                        on_ties=on_ties, ignore=ignore, matcher_options=matcher_options)
 * 
 *         elif token_kind == "ignored":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_token(token_label, regex_string,
 *                        on_ties=on_ties, ignore=True, matcher_options=matcher_options)
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1145
 *                        on_ties=on_ties, ignore=True, matcher_options=matcher_options)
 * 
 *         elif token_kind == "begin":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_begin_token(token_label)
 *             self.begin_token_label = token_label
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_token_kind, __pyx_n_s_begin, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1145, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1146
 * 
 *         elif token_kind == "begin":
 *             tok = token_table.def_begin_token(token_label)             # <<<<<<<<<<<<<<
 *             self.begin_token_label = token_label
 *             # Define dummy handlers for the begin-token, just to catch errors.
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_def_begin_token); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1146, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_4) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_token_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1146, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_v_token_label};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1146, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_v_token_label};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1146, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1146, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
        __Pyx_INCREF(__pyx_v_token_label);
        __Pyx_GIVEREF(__pyx_v_token_label);
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_token_label);
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1146, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_tok = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1147
 *         elif token_kind == "begin":
 *             tok = token_table.def_begin_token(token_label)
 *             self.begin_token_label = token_label             # <<<<<<<<<<<<<<
 *             # Define dummy handlers for the begin-token, just to catch errors.
 *             def begin_head(self, lex):
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_begin_token_label, __pyx_v_token_label) < 0) __PYX_ERR(0, 1147, __pyx_L1_error)

    /* "typped/pratt_parser.py":1149
 *             self.begin_token_label = token_label
 *             # Define dummy handlers for the begin-token, just to catch errors.
 *             def begin_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 */
    __pyx_t_1 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_1begin_head, 0, __pyx_n_s_PrattParser_def_token_master_loc, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__69)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1149, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_begin_head = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1152
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 *             def begin_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")
 */
    __pyx_t_1 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_3begin_tail, 0, __pyx_n_s_PrattParser_def_token_master_loc_2, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__71)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1152, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_begin_tail = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1155
 *                 """Dummy tail-handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")
 *             self.def_construct(HEAD, begin_head, token_label)             # <<<<<<<<<<<<<<
 *             self.def_construct(TAIL, begin_tail, token_label, dummy_handler=True)
 *             self.begin_token_subclass = tok
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_construct); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1155, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_HEAD); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1155, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_v_begin_head, __pyx_v_token_label};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1155, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_v_begin_head, __pyx_v_token_label};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1155, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    {
      __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1155, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (__pyx_t_4) {
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
      __Pyx_INCREF(__pyx_v_begin_head);
      __Pyx_GIVEREF(__pyx_v_begin_head);
      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_begin_head);
      __Pyx_INCREF(__pyx_v_token_label);
      __Pyx_GIVEREF(__pyx_v_token_label);
      PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_v_token_label);
      __pyx_t_5 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1155, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1156
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")
 *             self.def_construct(HEAD, begin_head, token_label)
 *             self.def_construct(TAIL, begin_tail, token_label, dummy_handler=True)             # <<<<<<<<<<<<<<
 *             self.begin_token_subclass = tok
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_construct); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1156, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1156, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1156, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3);
    __Pyx_INCREF(__pyx_v_begin_tail);
    __Pyx_GIVEREF(__pyx_v_begin_tail);
    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_v_begin_tail);
    __Pyx_INCREF(__pyx_v_token_label);
    __Pyx_GIVEREF(__pyx_v_token_label);
    PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_v_token_label);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1156, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dummy_handler, Py_True) < 0) __PYX_ERR(0, 1156, __pyx_L1_error)
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_7, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1156, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1157
 *             self.def_construct(HEAD, begin_head, token_label)
 *             self.def_construct(TAIL, begin_tail, token_label, dummy_handler=True)
 *             self.begin_token_subclass = tok             # <<<<<<<<<<<<<<
 * 
 *         elif token_kind == "end":
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_begin_token_subclass, __pyx_v_tok) < 0) __PYX_ERR(0, 1157, __pyx_L1_error)

    /* "typped/pratt_parser.py":1145
 *                        on_ties=on_ties, ignore=True, matcher_options=matcher_options)
 * 
 *         elif token_kind == "begin":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_begin_token(token_label)
 *             self.begin_token_label = token_label
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1159
 *             self.begin_token_subclass = tok
 * 
 *         elif token_kind == "end":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_end_token(token_label)
 *             self.end_token_label = token_label
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_token_kind, __pyx_n_s_end, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1159, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1160
 * 
 *         elif token_kind == "end":
 *             tok = token_table.def_end_token(token_label)             # <<<<<<<<<<<<<<
 *             self.end_token_label = token_label
 *             # Define dummy handlers for the end-token, just to catch errors.
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_def_end_token); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1160, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_token_label); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1160, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_token_label};
        __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1160, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_token_label};
        __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1160, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_5);
      } else
      #endif
      {
        __pyx_t_1 = PyTuple_New(1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1160, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_7); __pyx_t_7 = NULL;
        __Pyx_INCREF(__pyx_v_token_label);
        __Pyx_GIVEREF(__pyx_v_token_label);
        PyTuple_SET_ITEM(__pyx_t_1, 0+1, __pyx_v_token_label);
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1160, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_tok = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1161
 *         elif token_kind == "end":
 *             tok = token_table.def_end_token(token_label)
 *             self.end_token_label = token_label             # <<<<<<<<<<<<<<
 *             # Define dummy handlers for the end-token, just to catch errors.
 *             def end_head(self, lex):
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_end_token_label, __pyx_v_token_label) < 0) __PYX_ERR(0, 1161, __pyx_L1_error)

    /* "typped/pratt_parser.py":1163
 *             self.end_token_label = token_label
 *             # Define dummy handlers for the end-token, just to catch errors.
 *             def end_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 */
    __pyx_t_5 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_5end_head, 0, __pyx_n_s_PrattParser_def_token_master_loc_3, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__73)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1163, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_v_end_head = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1166
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 *             def end_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")
 */
    __pyx_t_5 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_16def_token_master_7end_tail, 0, __pyx_n_s_PrattParser_def_token_master_loc_4, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__75)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1166, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_v_end_tail = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1169
 *                 """Dummy tail-handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")
 *             self.def_construct(HEAD, end_head, token_label)             # <<<<<<<<<<<<<<
 *             self.def_construct(TAIL, end_tail, token_label, dummy_handler=True)
 *             self.end_token_subclass = tok
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_construct); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1169, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_HEAD); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1169, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_1, __pyx_v_end_head, __pyx_v_token_label};
      __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1169, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_1, __pyx_v_end_head, __pyx_v_token_label};
      __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1169, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1169, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_t_1);
      __Pyx_INCREF(__pyx_v_end_head);
      __Pyx_GIVEREF(__pyx_v_end_head);
      PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_v_end_head);
      __Pyx_INCREF(__pyx_v_token_label);
      __Pyx_GIVEREF(__pyx_v_token_label);
      PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_v_token_label);
      __pyx_t_1 = 0;
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1169, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1170
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")
 *             self.def_construct(HEAD, end_head, token_label)
 *             self.def_construct(TAIL, end_tail, token_label, dummy_handler=True)             # <<<<<<<<<<<<<<
 *             self.end_token_subclass = tok
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_construct); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1170, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1170, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1170, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_INCREF(__pyx_v_end_tail);
    __Pyx_GIVEREF(__pyx_v_end_tail);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_end_tail);
    __Pyx_INCREF(__pyx_v_token_label);
    __Pyx_GIVEREF(__pyx_v_token_label);
    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_v_token_label);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1170, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dummy_handler, Py_True) < 0) __PYX_ERR(0, 1170, __pyx_L1_error)
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1170, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1171
 *             self.def_construct(HEAD, end_head, token_label)
 *             self.def_construct(TAIL, end_tail, token_label, dummy_handler=True)
 *             self.end_token_subclass = tok             # <<<<<<<<<<<<<<
 * 
 *         elif token_kind == "jop":
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_end_token_subclass, __pyx_v_tok) < 0) __PYX_ERR(0, 1171, __pyx_L1_error)

    /* "typped/pratt_parser.py":1159
 *             self.begin_token_subclass = tok
 * 
 *         elif token_kind == "end":             # <<<<<<<<<<<<<<
 *             tok = token_table.def_end_token(token_label)
 *             self.end_token_label = token_label
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1173
 *             self.end_token_subclass = tok
 * 
 *         elif token_kind == "jop":             # <<<<<<<<<<<<<<
 *             if self.jop_token_subclass:
 *                 raise ParserException("A jop token is already defined.  It must be "
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_token_kind, __pyx_n_s_jop, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1173, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1174
 * 
 *         elif token_kind == "jop":
 *             if self.jop_token_subclass:             # <<<<<<<<<<<<<<
 *                 raise ParserException("A jop token is already defined.  It must be "
 *                                       "undefined before defining a new one.")
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_subclass); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1174, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1174, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_2) {

      /* "typped/pratt_parser.py":1175
 *         elif token_kind == "jop":
 *             if self.jop_token_subclass:
 *                 raise ParserException("A jop token is already defined.  It must be "             # <<<<<<<<<<<<<<
 *                                       "undefined before defining a new one.")
 *             self.jop_token_label = token_label
 */
      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1175, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__76, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1175, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 1175, __pyx_L1_error)

      /* "typped/pratt_parser.py":1174
 * 
 *         elif token_kind == "jop":
 *             if self.jop_token_subclass:             # <<<<<<<<<<<<<<
 *                 raise ParserException("A jop token is already defined.  It must be "
 *                                       "undefined before defining a new one.")
 */
    }

    /* "typped/pratt_parser.py":1177
 *                 raise ParserException("A jop token is already defined.  It must be "
 *                                       "undefined before defining a new one.")
 *             self.jop_token_label = token_label             # <<<<<<<<<<<<<<
 *             self.jop_ignored_token_label = ignored_token_label
 *             tok = token_table.def_token(token_label, None)
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_label, __pyx_v_token_label) < 0) __PYX_ERR(0, 1177, __pyx_L1_error)

    /* "typped/pratt_parser.py":1178
 *                                       "undefined before defining a new one.")
 *             self.jop_token_label = token_label
 *             self.jop_ignored_token_label = ignored_token_label             # <<<<<<<<<<<<<<
 *             tok = token_table.def_token(token_label, None)
 *             self.jop_token_subclass = tok
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_ignored_token_label, __pyx_v_ignored_token_label) < 0) __PYX_ERR(0, 1178, __pyx_L1_error)

    /* "typped/pratt_parser.py":1179
 *             self.jop_token_label = token_label
 *             self.jop_ignored_token_label = ignored_token_label
 *             tok = token_table.def_token(token_label, None)             # <<<<<<<<<<<<<<
 *             self.jop_token_subclass = tok
 *             tok.parser_instance = self # Special token, never returned by lexer.
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_def_token); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1179, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_token_label, Py_None};
      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1179, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_token_label, Py_None};
      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1179, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1179, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      if (__pyx_t_4) {
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
      }
      __Pyx_INCREF(__pyx_v_token_label);
      __Pyx_GIVEREF(__pyx_v_token_label);
      PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_6, __pyx_v_token_label);
      __Pyx_INCREF(Py_None);
      __Pyx_GIVEREF(Py_None);
      PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_6, Py_None);
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1179, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_tok = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":1180
 *             self.jop_ignored_token_label = ignored_token_label
 *             tok = token_table.def_token(token_label, None)
 *             self.jop_token_subclass = tok             # <<<<<<<<<<<<<<
 *             tok.parser_instance = self # Special token, never returned by lexer.
 * 
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_subclass, __pyx_v_tok) < 0) __PYX_ERR(0, 1180, __pyx_L1_error)

    /* "typped/pratt_parser.py":1181
 *             tok = token_table.def_token(token_label, None)
 *             self.jop_token_subclass = tok
 *             tok.parser_instance = self # Special token, never returned by lexer.             # <<<<<<<<<<<<<<
 * 
 *         elif token_kind == "null-string":
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_tok, __pyx_n_s_parser_instance, __pyx_v_self) < 0) __PYX_ERR(0, 1181, __pyx_L1_error)

    /* "typped/pratt_parser.py":1173
 *             self.end_token_subclass = tok
 * 
 *         elif token_kind == "jop":             # <<<<<<<<<<<<<<
 *             if self.jop_token_subclass:
 *                 raise ParserException("A jop token is already defined.  It must be "
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1183
 *             tok.parser_instance = self # Special token, never returned by lexer.
 * 
 *         elif token_kind == "null-string":             # <<<<<<<<<<<<<<
 *             if self.null_string_token_subclass:
 *                 raise ParserException("A null-string token is already defined.  It"
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_token_kind, __pyx_kp_s_null_string, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1183, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1184
 * 
 *         elif token_kind == "null-string":
 *             if self.null_string_token_subclass:             # <<<<<<<<<<<<<<
 *                 raise ParserException("A null-string token is already defined.  It"
 *                          " must be undefined before defining an new one.")
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_subclass); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1184, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1184, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_2) {

      /* "typped/pratt_parser.py":1185
 *         elif token_kind == "null-string":
 *             if self.null_string_token_subclass:
 *                 raise ParserException("A null-string token is already defined.  It"             # <<<<<<<<<<<<<<
 *                          " must be undefined before defining an new one.")
 *             self.null_string_token_label = token_label
 */
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1185, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__77, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1185, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 1185, __pyx_L1_error)

      /* "typped/pratt_parser.py":1184
 * 
 *         elif token_kind == "null-string":
 *             if self.null_string_token_subclass:             # <<<<<<<<<<<<<<
 *                 raise ParserException("A null-string token is already defined.  It"
 *                          " must be undefined before defining an new one.")
 */
    }

    /* "typped/pratt_parser.py":1187
 *                 raise ParserException("A null-string token is already defined.  It"
 *                          " must be undefined before defining an new one.")
 *             self.null_string_token_label = token_label             # <<<<<<<<<<<<<<
 *             tok = token_table.def_token(token_label, None)
 *             self.null_string_token_subclass = tok
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_label, __pyx_v_token_label) < 0) __PYX_ERR(0, 1187, __pyx_L1_error)

    /* "typped/pratt_parser.py":1188
 *                          " must be undefined before defining an new one.")
 *             self.null_string_token_label = token_label
 *             tok = token_table.def_token(token_label, None)             # <<<<<<<<<<<<<<
 *             self.null_string_token_subclass = tok
 *             tok.parser_instance = self # Special token, never returned by lexer.
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_def_token); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1188, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_6 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_token_label, Py_None};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1188, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_token_label, Py_None};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1188, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1188, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (__pyx_t_5) {
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5); __pyx_t_5 = NULL;
      }
      __Pyx_INCREF(__pyx_v_token_label);
      __Pyx_GIVEREF(__pyx_v_token_label);
      PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_v_token_label);
      __Pyx_INCREF(Py_None);
      __Pyx_GIVEREF(Py_None);
      PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, Py_None);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1188, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_tok = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1189
 *             self.null_string_token_label = token_label
 *             tok = token_table.def_token(token_label, None)
 *             self.null_string_token_subclass = tok             # <<<<<<<<<<<<<<
 *             tok.parser_instance = self # Special token, never returned by lexer.
 * 
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_subclass, __pyx_v_tok) < 0) __PYX_ERR(0, 1189, __pyx_L1_error)

    /* "typped/pratt_parser.py":1190
 *             tok = token_table.def_token(token_label, None)
 *             self.null_string_token_subclass = tok
 *             tok.parser_instance = self # Special token, never returned by lexer.             # <<<<<<<<<<<<<<
 * 
 *         else:
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_tok, __pyx_n_s_parser_instance, __pyx_v_self) < 0) __PYX_ERR(0, 1190, __pyx_L1_error)

    /* "typped/pratt_parser.py":1183
 *             tok.parser_instance = self # Special token, never returned by lexer.
 * 
 *         elif token_kind == "null-string":             # <<<<<<<<<<<<<<
 *             if self.null_string_token_subclass:
 *                 raise ParserException("A null-string token is already defined.  It"
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1193
 * 
 *         else:
 *             raise ParserException("Bad call to def_token_master, with unrecognized"             # <<<<<<<<<<<<<<
 *                     ' string "{0}" for the keyword argument token_kind.'
 *                     .format(token_kind))
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1193, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "typped/pratt_parser.py":1195
 *             raise ParserException("Bad call to def_token_master, with unrecognized"
 *                     ' string "{0}" for the keyword argument token_kind.'
 *                     .format(token_kind))             # <<<<<<<<<<<<<<
 * 
 *         tok.token_kind = token_kind
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Bad_call_to_def_token_master_wit, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1195, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_token_kind); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1195, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_token_kind};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1195, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_token_kind};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1195, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1195, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
        __Pyx_INCREF(__pyx_v_token_kind);
        __Pyx_GIVEREF(__pyx_v_token_kind);
        PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_v_token_kind);
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1195, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1193, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1193, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1193, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1193, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_GIVEREF(__pyx_t_4);
        PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_4);
        __pyx_t_4 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1193, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1193, __pyx_L1_error)
  }
  __pyx_L3:;

  /* "typped/pratt_parser.py":1197
 *                     .format(token_kind))
 * 
 *         tok.token_kind = token_kind             # <<<<<<<<<<<<<<
 *         tok.is_head = False # Set true in recursive_parse if instance parses as a head.
 *         return tok
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_tok, __pyx_n_s_token_kind, __pyx_v_token_kind) < 0) __PYX_ERR(0, 1197, __pyx_L1_error)

  /* "typped/pratt_parser.py":1198
 * 
 *         tok.token_kind = token_kind
 *         tok.is_head = False # Set true in recursive_parse if instance parses as a head.             # <<<<<<<<<<<<<<
 *         return tok
 * 
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_tok, __pyx_n_s_is_head, Py_False) < 0) __PYX_ERR(0, 1198, __pyx_L1_error)

  /* "typped/pratt_parser.py":1199
 *         tok.token_kind = token_kind
 *         tok.is_head = False # Set true in recursive_parse if instance parses as a head.
 *         return tok             # <<<<<<<<<<<<<<
 * 
 *     def def_token(self, token_label, regex_string, on_ties=0, ignore=False,
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_tok);
  __pyx_r = __pyx_v_tok;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1116
 *     #
 * 
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                          token_kind="regular", ignored_token_label=None,
 *                          matcher_options=None):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token_master", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_token_table);
  __Pyx_XDECREF(__pyx_v_tok);
  __Pyx_XDECREF(__pyx_v_begin_head);
  __Pyx_XDECREF(__pyx_v_begin_tail);
  __Pyx_XDECREF(__pyx_v_end_head);
  __Pyx_XDECREF(__pyx_v_end_tail);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1201
 *         return tok
 * 
 *     def def_token(self, token_label, regex_string, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                   matcher_options=None):
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_7def_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_6def_token[] = "Define a token.  Use this instead of the Lexer `def_token` method,\n        since it adds extra attributes to the tokens.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_7def_token = {"def_token", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_7def_token, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_6def_token};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_7def_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_token_label = 0;
  PyObject *__pyx_v_regex_string = 0;
  PyObject *__pyx_v_on_ties = 0;
  PyObject *__pyx_v_ignore = 0;
  PyObject *__pyx_v_matcher_options = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_token (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_token_label,&__pyx_n_s_regex_string,&__pyx_n_s_on_ties,&__pyx_n_s_ignore,&__pyx_n_s_matcher_options,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[3] = ((PyObject *)((PyObject *)__pyx_int_0));
    values[4] = ((PyObject *)((PyObject *)Py_False));

    /* "typped/pratt_parser.py":1202
 * 
 *     def def_token(self, token_label, regex_string, on_ties=0, ignore=False,
 *                   matcher_options=None):             # <<<<<<<<<<<<<<
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 *         since it adds extra attributes to the tokens."""
 */
    values[5] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_token", 0, 3, 6, 1); __PYX_ERR(0, 1201, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_regex_string)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_token", 0, 3, 6, 2); __PYX_ERR(0, 1201, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_on_ties);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ignore);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_matcher_options);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_token") < 0)) __PYX_ERR(0, 1201, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_token_label = values[1];
    __pyx_v_regex_string = values[2];
    __pyx_v_on_ties = values[3];
    __pyx_v_ignore = values[4];
    __pyx_v_matcher_options = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_token", 0, 3, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1201, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_6def_token(__pyx_self, __pyx_v_self, __pyx_v_token_label, __pyx_v_regex_string, __pyx_v_on_ties, __pyx_v_ignore, __pyx_v_matcher_options);

  /* "typped/pratt_parser.py":1201
 *         return tok
 * 
 *     def def_token(self, token_label, regex_string, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                   matcher_options=None):
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_6def_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label, PyObject *__pyx_v_regex_string, PyObject *__pyx_v_on_ties, PyObject *__pyx_v_ignore, PyObject *__pyx_v_matcher_options) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("def_token", 0);

  /* "typped/pratt_parser.py":1205
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 *         since it adds extra attributes to the tokens."""
 *         return self.def_token_master(token_label, regex_string, on_ties, ignore,             # <<<<<<<<<<<<<<
 *                               token_kind="regular", matcher_options=matcher_options)
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_token_master); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_token_label);
  __Pyx_GIVEREF(__pyx_v_token_label);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_token_label);
  __Pyx_INCREF(__pyx_v_regex_string);
  __Pyx_GIVEREF(__pyx_v_regex_string);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_regex_string);
  __Pyx_INCREF(__pyx_v_on_ties);
  __Pyx_GIVEREF(__pyx_v_on_ties);
  PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_on_ties);
  __Pyx_INCREF(__pyx_v_ignore);
  __Pyx_GIVEREF(__pyx_v_ignore);
  PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_v_ignore);

  /* "typped/pratt_parser.py":1206
 *         since it adds extra attributes to the tokens."""
 *         return self.def_token_master(token_label, regex_string, on_ties, ignore,
 *                               token_kind="regular", matcher_options=matcher_options)             # <<<<<<<<<<<<<<
 * 
 *     def def_ignored_token(self, token_label, regex_string, on_ties=0,
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_token_kind, __pyx_n_s_regular) < 0) __PYX_ERR(0, 1206, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_matcher_options, __pyx_v_matcher_options) < 0) __PYX_ERR(0, 1206, __pyx_L1_error)

  /* "typped/pratt_parser.py":1205
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 *         since it adds extra attributes to the tokens."""
 *         return self.def_token_master(token_label, regex_string, on_ties, ignore,             # <<<<<<<<<<<<<<
 *                               token_kind="regular", matcher_options=matcher_options)
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1201
 *         return tok
 * 
 *     def def_token(self, token_label, regex_string, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                   matcher_options=None):
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1208
 *                               token_kind="regular", matcher_options=matcher_options)
 * 
 *     def def_ignored_token(self, token_label, regex_string, on_ties=0,             # <<<<<<<<<<<<<<
 *                           matcher_options=None):
 *         """A convenience function to define a token with `ignored=True`."""
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_9def_ignored_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_8def_ignored_token[] = "A convenience function to define a token with `ignored=True`.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_9def_ignored_token = {"def_ignored_token", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_9def_ignored_token, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_8def_ignored_token};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_9def_ignored_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_token_label = 0;
  PyObject *__pyx_v_regex_string = 0;
  PyObject *__pyx_v_on_ties = 0;
  PyObject *__pyx_v_matcher_options = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_ignored_token (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_token_label,&__pyx_n_s_regex_string,&__pyx_n_s_on_ties,&__pyx_n_s_matcher_options,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[3] = ((PyObject *)((PyObject *)__pyx_int_0));

    /* "typped/pratt_parser.py":1209
 * 
 *     def def_ignored_token(self, token_label, regex_string, on_ties=0,
 *                           matcher_options=None):             # <<<<<<<<<<<<<<
 *         """A convenience function to define a token with `ignored=True`."""
 *         return self.def_token_master(token_label, regex_string, on_ties, ignore=True,
 */
    values[4] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_ignored_token", 0, 3, 5, 1); __PYX_ERR(0, 1208, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_regex_string)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_ignored_token", 0, 3, 5, 2); __PYX_ERR(0, 1208, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_on_ties);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_matcher_options);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_ignored_token") < 0)) __PYX_ERR(0, 1208, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_token_label = values[1];
    __pyx_v_regex_string = values[2];
    __pyx_v_on_ties = values[3];
    __pyx_v_matcher_options = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_ignored_token", 0, 3, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1208, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_ignored_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_8def_ignored_token(__pyx_self, __pyx_v_self, __pyx_v_token_label, __pyx_v_regex_string, __pyx_v_on_ties, __pyx_v_matcher_options);

  /* "typped/pratt_parser.py":1208
 *                               token_kind="regular", matcher_options=matcher_options)
 * 
 *     def def_ignored_token(self, token_label, regex_string, on_ties=0,             # <<<<<<<<<<<<<<
 *                           matcher_options=None):
 *         """A convenience function to define a token with `ignored=True`."""
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_8def_ignored_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label, PyObject *__pyx_v_regex_string, PyObject *__pyx_v_on_ties, PyObject *__pyx_v_matcher_options) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("def_ignored_token", 0);

  /* "typped/pratt_parser.py":1211
 *                           matcher_options=None):
 *         """A convenience function to define a token with `ignored=True`."""
 *         return self.def_token_master(token_label, regex_string, on_ties, ignore=True,             # <<<<<<<<<<<<<<
 *                               token_kind="ignored", matcher_options=matcher_options)
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_token_master); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_token_label);
  __Pyx_GIVEREF(__pyx_v_token_label);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_token_label);
  __Pyx_INCREF(__pyx_v_regex_string);
  __Pyx_GIVEREF(__pyx_v_regex_string);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_regex_string);
  __Pyx_INCREF(__pyx_v_on_ties);
  __Pyx_GIVEREF(__pyx_v_on_ties);
  PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_on_ties);
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ignore, Py_True) < 0) __PYX_ERR(0, 1211, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_token_kind, __pyx_n_s_ignored) < 0) __PYX_ERR(0, 1211, __pyx_L1_error)

  /* "typped/pratt_parser.py":1212
 *         """A convenience function to define a token with `ignored=True`."""
 *         return self.def_token_master(token_label, regex_string, on_ties, ignore=True,
 *                               token_kind="ignored", matcher_options=matcher_options)             # <<<<<<<<<<<<<<
 * 
 *     def def_begin_end_tokens(self, begin_token_label="k_begin",
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_matcher_options, __pyx_v_matcher_options) < 0) __PYX_ERR(0, 1211, __pyx_L1_error)

  /* "typped/pratt_parser.py":1211
 *                           matcher_options=None):
 *         """A convenience function to define a token with `ignored=True`."""
 *         return self.def_token_master(token_label, regex_string, on_ties, ignore=True,             # <<<<<<<<<<<<<<
 *                               token_kind="ignored", matcher_options=matcher_options)
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1208
 *                               token_kind="regular", matcher_options=matcher_options)
 * 
 *     def def_ignored_token(self, token_label, regex_string, on_ties=0,             # <<<<<<<<<<<<<<
 *                           matcher_options=None):
 *         """A convenience function to define a token with `ignored=True`."""
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_ignored_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1214
 *                               token_kind="ignored", matcher_options=matcher_options)
 * 
 *     def def_begin_end_tokens(self, begin_token_label="k_begin",             # <<<<<<<<<<<<<<
 *                                    end_token_label="k_end"):
 *         """Calls the `Lexer` method to define begin- and end-tokens.  The
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_11def_begin_end_tokens(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_10def_begin_end_tokens[] = "Calls the `Lexer` method to define begin- and end-tokens.  The\n        subclasses are then given initial head and tail functions for use in\n        the Pratt parser.  To use the `PrattParser` this method must be called,\n        not the method of `Lexer` with the same name (since it also creates\n        head and tail handler functions that raise exceptions for better error\n        messages).  The default is to call this method automatically on\n        initialization, with the default token labels for the begin and end\n        tokens.  If the flag `default_begin_end_tokens` is set false on\n        `PrattParser` initalization then the user must call this function\n        (setting whatever token labels are desired).  Returns a tuple\n        containing the new begin and end `TokenNode` subclasses.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_11def_begin_end_tokens = {"def_begin_end_tokens", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_11def_begin_end_tokens, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_10def_begin_end_tokens};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_11def_begin_end_tokens(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_begin_token_label = 0;
  PyObject *__pyx_v_end_token_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_begin_end_tokens (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_begin_token_label,&__pyx_n_s_end_token_label,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)((PyObject*)__pyx_n_s_k_begin));
    values[2] = ((PyObject *)((PyObject*)__pyx_n_s_k_end));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_begin_token_label);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end_token_label);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_begin_end_tokens") < 0)) __PYX_ERR(0, 1214, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_begin_token_label = values[1];
    __pyx_v_end_token_label = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_begin_end_tokens", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1214, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_begin_end_tokens", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_10def_begin_end_tokens(__pyx_self, __pyx_v_self, __pyx_v_begin_token_label, __pyx_v_end_token_label);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_10def_begin_end_tokens(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_begin_token_label, PyObject *__pyx_v_end_token_label) {
  PyObject *__pyx_v_begin_tok = NULL;
  PyObject *__pyx_v_end_tok = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("def_begin_end_tokens", 0);

  /* "typped/pratt_parser.py":1227
 *         (setting whatever token labels are desired).  Returns a tuple
 *         containing the new begin and end `TokenNode` subclasses."""
 *         begin_tok = self.def_token_master(begin_token_label, token_kind="begin")             # <<<<<<<<<<<<<<
 *         end_tok = self.def_token_master(end_token_label, token_kind="end")
 *         return begin_tok, end_tok
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_token_master); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_begin_token_label);
  __Pyx_GIVEREF(__pyx_v_begin_token_label);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_begin_token_label);
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_token_kind, __pyx_n_s_begin) < 0) __PYX_ERR(0, 1227, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1227, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_begin_tok = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":1228
 *         containing the new begin and end `TokenNode` subclasses."""
 *         begin_tok = self.def_token_master(begin_token_label, token_kind="begin")
 *         end_tok = self.def_token_master(end_token_label, token_kind="end")             # <<<<<<<<<<<<<<
 *         return begin_tok, end_tok
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_token_master); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_end_token_label);
  __Pyx_GIVEREF(__pyx_v_end_token_label);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_end_token_label);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_token_kind, __pyx_n_s_end) < 0) __PYX_ERR(0, 1228, __pyx_L1_error)
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1228, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_end_tok = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1229
 *         begin_tok = self.def_token_master(begin_token_label, token_kind="begin")
 *         end_tok = self.def_token_master(end_token_label, token_kind="end")
 *         return begin_tok, end_tok             # <<<<<<<<<<<<<<
 * 
 *     def def_jop_token(self, jop_token_label, ignored_token_label):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1229, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_begin_tok);
  __Pyx_GIVEREF(__pyx_v_begin_tok);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_begin_tok);
  __Pyx_INCREF(__pyx_v_end_tok);
  __Pyx_GIVEREF(__pyx_v_end_tok);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_end_tok);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1214
 *                               token_kind="ignored", matcher_options=matcher_options)
 * 
 *     def def_begin_end_tokens(self, begin_token_label="k_begin",             # <<<<<<<<<<<<<<
 *                                    end_token_label="k_end"):
 *         """Calls the `Lexer` method to define begin- and end-tokens.  The
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_begin_end_tokens", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_begin_tok);
  __Pyx_XDECREF(__pyx_v_end_tok);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1231
 *         return begin_tok, end_tok
 * 
 *     def def_jop_token(self, jop_token_label, ignored_token_label):             # <<<<<<<<<<<<<<
 *         """Define a token for the juxtaposition operator.  This token has no
 *         regex pattern.  An instance is inserted in `recursive_parse` when it is
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_13def_jop_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_12def_jop_token[] = "Define a token for the juxtaposition operator.  This token has no\n        regex pattern.  An instance is inserted in `recursive_parse` when it is\n        inferred to be present.  This method must be explicitly called before a\n        juxtaposition operator can be used (i.e., before `def_jop`).  The\n        parameter `jop_token_label` is the label for the newly-created token\n        representing the juxtaposition operator.  The `ignored_token_label`\n        parameter is the label of an ignored token which must be present for a\n        jop to be inferred.  Some already-defined token is required; usually it\n        will be a token for spaces and tabs.  If set to `None` then no ignored\n        space at all is required (i.e., the operands can be right next to each\n        other).";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_13def_jop_token = {"def_jop_token", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_13def_jop_token, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_12def_jop_token};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_13def_jop_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_jop_token_label = 0;
  PyObject *__pyx_v_ignored_token_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_jop_token (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_jop_token_label,&__pyx_n_s_ignored_token_label,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_jop_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_jop_token", 1, 3, 3, 1); __PYX_ERR(0, 1231, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ignored_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_jop_token", 1, 3, 3, 2); __PYX_ERR(0, 1231, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_jop_token") < 0)) __PYX_ERR(0, 1231, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_self = values[0];
    __pyx_v_jop_token_label = values[1];
    __pyx_v_ignored_token_label = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_jop_token", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1231, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_jop_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_12def_jop_token(__pyx_self, __pyx_v_self, __pyx_v_jop_token_label, __pyx_v_ignored_token_label);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_12def_jop_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_jop_token_label, PyObject *__pyx_v_ignored_token_label) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("def_jop_token", 0);

  /* "typped/pratt_parser.py":1243
 *         space at all is required (i.e., the operands can be right next to each
 *         other)."""
 *         return self.def_token_master(jop_token_label,             # <<<<<<<<<<<<<<
 *                                      ignored_token_label=ignored_token_label,
 *                                      token_kind="jop")
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_token_master); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_jop_token_label);
  __Pyx_GIVEREF(__pyx_v_jop_token_label);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_jop_token_label);

  /* "typped/pratt_parser.py":1244
 *         other)."""
 *         return self.def_token_master(jop_token_label,
 *                                      ignored_token_label=ignored_token_label,             # <<<<<<<<<<<<<<
 *                                      token_kind="jop")
 * 
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ignored_token_label, __pyx_v_ignored_token_label) < 0) __PYX_ERR(0, 1244, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_token_kind, __pyx_n_s_jop) < 0) __PYX_ERR(0, 1244, __pyx_L1_error)

  /* "typped/pratt_parser.py":1243
 *         space at all is required (i.e., the operands can be right next to each
 *         other)."""
 *         return self.def_token_master(jop_token_label,             # <<<<<<<<<<<<<<
 *                                      ignored_token_label=ignored_token_label,
 *                                      token_kind="jop")
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1231
 *         return begin_tok, end_tok
 * 
 *     def def_jop_token(self, jop_token_label, ignored_token_label):             # <<<<<<<<<<<<<<
 *         """Define a token for the juxtaposition operator.  This token has no
 *         regex pattern.  An instance is inserted in `recursive_parse` when it is
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_jop_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1247
 *                                      token_kind="jop")
 * 
 *     def def_null_string_token(self, null_string_token_label="k_null-string"):             # <<<<<<<<<<<<<<
 *         """Define the null-string token.  This token has no regex pattern.  An
 *         instance is inserted in `recursive_parse` when it is inferred to be
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_15def_null_string_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_14def_null_string_token[] = "Define the null-string token.  This token has no regex pattern.  An\n        instance is inserted in `recursive_parse` when it is inferred to be\n        present based.  It can only ever have head handlers, and is not even\n        tested for tail handlers.  This method must be called before a\n        null-string can be used.  The parameter `null_string_token_label` is\n        the label for the newly-created tok representing it.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_15def_null_string_token = {"def_null_string_token", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_15def_null_string_token, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_14def_null_string_token};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_15def_null_string_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_null_string_token_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_null_string_token (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_null_string_token_label,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)((PyObject*)__pyx_kp_s_k_null_string));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_null_string_token_label);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_null_string_token") < 0)) __PYX_ERR(0, 1247, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_null_string_token_label = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_null_string_token", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1247, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_null_string_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_14def_null_string_token(__pyx_self, __pyx_v_self, __pyx_v_null_string_token_label);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_14def_null_string_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_null_string_token_label) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("def_null_string_token", 0);

  /* "typped/pratt_parser.py":1254
 *         null-string can be used.  The parameter `null_string_token_label` is
 *         the label for the newly-created tok representing it."""
 *         return self.def_token_master(null_string_token_label,             # <<<<<<<<<<<<<<
 *                                      token_kind="null-string")
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_def_token_master); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_null_string_token_label);
  __Pyx_GIVEREF(__pyx_v_null_string_token_label);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_null_string_token_label);

  /* "typped/pratt_parser.py":1255
 *         the label for the newly-created tok representing it."""
 *         return self.def_token_master(null_string_token_label,
 *                                      token_kind="null-string")             # <<<<<<<<<<<<<<
 * 
 *     def get_token(self, token_label):
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1255, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_token_kind, __pyx_kp_s_null_string) < 0) __PYX_ERR(0, 1255, __pyx_L1_error)

  /* "typped/pratt_parser.py":1254
 *         null-string can be used.  The parameter `null_string_token_label` is
 *         the label for the newly-created tok representing it."""
 *         return self.def_token_master(null_string_token_label,             # <<<<<<<<<<<<<<
 *                                      token_kind="null-string")
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1247
 *                                      token_kind="jop")
 * 
 *     def def_null_string_token(self, null_string_token_label="k_null-string"):             # <<<<<<<<<<<<<<
 *         """Define the null-string token.  This token has no regex pattern.  An
 *         instance is inserted in `recursive_parse` when it is inferred to be
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_null_string_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1257
 *                                      token_kind="null-string")
 * 
 *     def get_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """Return the token with the label `token_label`.  The reverse
 *         operation, getting a label from a token instance, can be done by
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_17get_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_16get_token[] = "Return the token with the label `token_label`.  The reverse\n        operation, getting a label from a token instance, can be done by\n        looking at the `token_label` attribute of the token.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_17get_token = {"get_token", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_17get_token, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_16get_token};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_17get_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_token_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_token (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_token_label,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("get_token", 1, 2, 2, 1); __PYX_ERR(0, 1257, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "get_token") < 0)) __PYX_ERR(0, 1257, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_token_label = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("get_token", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1257, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.get_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_16get_token(__pyx_self, __pyx_v_self, __pyx_v_token_label);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_16get_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("get_token", 0);

  /* "typped/pratt_parser.py":1261
 *         operation, getting a label from a token instance, can be done by
 *         looking at the `token_label` attribute of the token."""
 *         return self.token_table[token_label]             # <<<<<<<<<<<<<<
 * 
 *     #
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_GetItem(__pyx_t_1, __pyx_v_token_label); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1257
 *                                      token_kind="null-string")
 * 
 *     def get_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """Return the token with the label `token_label`.  The reverse
 *         operation, getting a label from a token instance, can be done by
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.get_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1267
 *     #
 * 
 *     def undef_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """A method for undefining any token defined by the `PrattParser` methods.
 *         Since the `token_kind` was set for all tokens when they were defined
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_19undef_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_18undef_token[] = "A method for undefining any token defined by the `PrattParser` methods.\n        Since the `token_kind` was set for all tokens when they were defined\n        it knows how to undelete any kind of token.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_19undef_token = {"undef_token", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_19undef_token, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_18undef_token};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_19undef_token(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_token_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("undef_token (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_token_label,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("undef_token", 1, 2, 2, 1); __PYX_ERR(0, 1267, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "undef_token") < 0)) __PYX_ERR(0, 1267, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_token_label = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("undef_token", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1267, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.undef_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_18undef_token(__pyx_self, __pyx_v_self, __pyx_v_token_label);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_18undef_token(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_token_label) {
  PyObject *__pyx_v_token_table = NULL;
  PyObject *__pyx_v_tok = NULL;
  PyObject *__pyx_v_kind = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("undef_token", 0);

  /* "typped/pratt_parser.py":1272
 *         it knows how to undelete any kind of token."""
 *         # TODO: Make sure this is up-to-date with the what the token_master class does.
 *         token_table = self.token_table             # <<<<<<<<<<<<<<
 *         tok = token_table[token_label]
 *         kind = tok.token_kind
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1272, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_token_table = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1273
 *         # TODO: Make sure this is up-to-date with the what the token_master class does.
 *         token_table = self.token_table
 *         tok = token_table[token_label]             # <<<<<<<<<<<<<<
 *         kind = tok.token_kind
 *         if kind == "jop":
 */
  __pyx_t_1 = PyObject_GetItem(__pyx_v_token_table, __pyx_v_token_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1273, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_tok = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1274
 *         token_table = self.token_table
 *         tok = token_table[token_label]
 *         kind = tok.token_kind             # <<<<<<<<<<<<<<
 *         if kind == "jop":
 *             token_table.undef_token(self.jop_token_label)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_tok, __pyx_n_s_token_kind); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_kind = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1275
 *         tok = token_table[token_label]
 *         kind = tok.token_kind
 *         if kind == "jop":             # <<<<<<<<<<<<<<
 *             token_table.undef_token(self.jop_token_label)
 *             self.jop_token_subclass = None
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_kind, __pyx_n_s_jop, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1275, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1276
 *         kind = tok.token_kind
 *         if kind == "jop":
 *             token_table.undef_token(self.jop_token_label)             # <<<<<<<<<<<<<<
 *             self.jop_token_subclass = None
 *             self.jop_token_label = None
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_undef_token); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1276, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_label); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1276, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1276, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1276, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_t_4};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1276, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1276, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_GIVEREF(__pyx_t_4);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_4);
        __pyx_t_4 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1276, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1277
 *         if kind == "jop":
 *             token_table.undef_token(self.jop_token_label)
 *             self.jop_token_subclass = None             # <<<<<<<<<<<<<<
 *             self.jop_token_label = None
 *             self.jop_ignored_token_label = None
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_subclass, Py_None) < 0) __PYX_ERR(0, 1277, __pyx_L1_error)

    /* "typped/pratt_parser.py":1278
 *             token_table.undef_token(self.jop_token_label)
 *             self.jop_token_subclass = None
 *             self.jop_token_label = None             # <<<<<<<<<<<<<<
 *             self.jop_ignored_token_label = None
 *         elif kind == "null-string":
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_token_label, Py_None) < 0) __PYX_ERR(0, 1278, __pyx_L1_error)

    /* "typped/pratt_parser.py":1279
 *             self.jop_token_subclass = None
 *             self.jop_token_label = None
 *             self.jop_ignored_token_label = None             # <<<<<<<<<<<<<<
 *         elif kind == "null-string":
 *             token_table.undef_token(self.null_string_token_label)
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_jop_ignored_token_label, Py_None) < 0) __PYX_ERR(0, 1279, __pyx_L1_error)

    /* "typped/pratt_parser.py":1275
 *         tok = token_table[token_label]
 *         kind = tok.token_kind
 *         if kind == "jop":             # <<<<<<<<<<<<<<
 *             token_table.undef_token(self.jop_token_label)
 *             self.jop_token_subclass = None
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1280
 *             self.jop_token_label = None
 *             self.jop_ignored_token_label = None
 *         elif kind == "null-string":             # <<<<<<<<<<<<<<
 *             token_table.undef_token(self.null_string_token_label)
 *             self.null_string_token_subclass = None
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_kind, __pyx_kp_s_null_string, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1280, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1281
 *             self.jop_ignored_token_label = None
 *         elif kind == "null-string":
 *             token_table.undef_token(self.null_string_token_label)             # <<<<<<<<<<<<<<
 *             self.null_string_token_subclass = None
 *             self.null_string_token_label = None
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_undef_token); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1281, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_label); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1281, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_4) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1281, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_6};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1281, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_6};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1281, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1281, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
        __Pyx_GIVEREF(__pyx_t_6);
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_6);
        __pyx_t_6 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1281, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":1282
 *         elif kind == "null-string":
 *             token_table.undef_token(self.null_string_token_label)
 *             self.null_string_token_subclass = None             # <<<<<<<<<<<<<<
 *             self.null_string_token_label = None
 *             self.null_string_ignored_token_label = None
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_subclass, Py_None) < 0) __PYX_ERR(0, 1282, __pyx_L1_error)

    /* "typped/pratt_parser.py":1283
 *             token_table.undef_token(self.null_string_token_label)
 *             self.null_string_token_subclass = None
 *             self.null_string_token_label = None             # <<<<<<<<<<<<<<
 *             self.null_string_ignored_token_label = None
 *         else:
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_null_string_token_label, Py_None) < 0) __PYX_ERR(0, 1283, __pyx_L1_error)

    /* "typped/pratt_parser.py":1284
 *             self.null_string_token_subclass = None
 *             self.null_string_token_label = None
 *             self.null_string_ignored_token_label = None             # <<<<<<<<<<<<<<
 *         else:
 *             token_table.undef_token(token_label)
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_null_string_ignored_token_label, Py_None) < 0) __PYX_ERR(0, 1284, __pyx_L1_error)

    /* "typped/pratt_parser.py":1280
 *             self.jop_token_label = None
 *             self.jop_ignored_token_label = None
 *         elif kind == "null-string":             # <<<<<<<<<<<<<<
 *             token_table.undef_token(self.null_string_token_label)
 *             self.null_string_token_subclass = None
 */
    goto __pyx_L3;
  }

  /* "typped/pratt_parser.py":1286
 *             self.null_string_ignored_token_label = None
 *         else:
 *             token_table.undef_token(token_label)             # <<<<<<<<<<<<<<
 * 
 *     #
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_token_table, __pyx_n_s_undef_token); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1286, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_token_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1286, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_token_label};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1286, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_token_label};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1286, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1286, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
        __Pyx_INCREF(__pyx_v_token_label);
        __Pyx_GIVEREF(__pyx_v_token_label);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_token_label);
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1286, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }
  __pyx_L3:;

  /* "typped/pratt_parser.py":1267
 *     #
 * 
 *     def undef_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """A method for undefining any token defined by the `PrattParser` methods.
 *         Since the `token_kind` was set for all tokens when they were defined
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.undef_token", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_token_table);
  __Pyx_XDECREF(__pyx_v_tok);
  __Pyx_XDECREF(__pyx_v_kind);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1292
 *     #
 * 
 *     def def_construct(self, head_or_tail, handler_fun, trigger_token_label,             # <<<<<<<<<<<<<<
 *                       prec=0, precond_label=None, precond_fun=None,
 *                       precond_priority=0, val_type=None, arg_types=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_21def_construct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_20def_construct[] = "Define a construct and register it with the token with label\n        `trigger_token_label`.  A token with that label must already be in the\n        token table or an exception will be raised.\n\n        Stores the construct instance in the parser's construct table and also\n        return the construct instance.\n\n        The `head_or_tail` argument should be set to either `HEAD` or `TAIL`.\n        If `head_or_tail==TAIL` then the operator precedence will be set to\n        `prec`.  For a head handler the `prec` value is ignored and effectively\n        set to zero.  For a tail handler a `prec` value greater than zero is\n        required or else an exception will be raised (unless `dummy_handler` is\n        set true).  Similarly, an exception is raised for a non-zero `prec`\n        value for a head-handler (the default value).\n\n        If `precond_label` is `None` then a unique string label will be\n        generated.  If the parameter `autolabel_prefix` is passed a string then\n        that value will be made the prefix of any automatically-generated\n        precondition labels (i.e., when `precond_label` is `None`).  This can be\n        used to create more-informative labels, which can help in debugging.\n\n        Uniqueness of constructs is essentially determined by triples of the\n        form::\n\n           (head_or_tail, trigger_token_label, precond_label)\n\n        Note that preconditions functions are *not* part of the tuple.\n        Defining distinct constructs which match in `head_or_tail` and also in\n        their `trigger_token_label` requires distinct precondition labels.\n        Otherwise overloading is assumed and the last-defined properties (such\n        as the preconditions function) are used for all but the overloaded\n        parts (AST data and evaluation functions keyed by type signatures).  A\n        unique, default precondition label is provided if one is not supplied, so\n        labels are really only required in order to ""specify overloading.\n\n        The `eval_fun` and the `ast_data` arguments are saved in the dicts\n        `eval_fun_dict` and `ast_data_dict` respectively, keyed by the\n        `TypeSig` (defined by `val_type` and `arg_types`), as well as by\n        `arg_types` alone for when overloading on return values is not used.\n        This allows for different overloads to have different evaluation\n        functions and AST-associated data.\n\n        If `value_key` is set to a string value then that value will be part of\n        the key tuple for saving AST data and evaluation functions.  This can\n        be used, for example, when overloading a generic identifier with\n        different evaluation functions for when the identifier value is `sin`,\n        `cos`, etc.  In looking up the AST data and evaluation function the\n        parsed token's actual string value (from the program text) is used as\n        the key.  If any overload of a particular construct provides a\n        `value_key` string then all the other overloads for that construct must\n        also (for the time being, at least).";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_21def_construct = {"def_construct", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_21def_construct, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_20def_construct};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_21def_construct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_head_or_tail = 0;
  PyObject *__pyx_v_handler_fun = 0;
  PyObject *__pyx_v_trigger_token_label = 0;
  PyObject *__pyx_v_prec = 0;
  PyObject *__pyx_v_precond_label = 0;
  PyObject *__pyx_v_precond_fun = 0;
  PyObject *__pyx_v_precond_priority = 0;
  PyObject *__pyx_v_val_type = 0;
  PyObject *__pyx_v_arg_types = 0;
  PyObject *__pyx_v_eval_fun = 0;
  PyObject *__pyx_v_ast_data = 0;
  PyObject *__pyx_v_value_key = 0;
  PyObject *__pyx_v_autolabel_prefix = 0;
  PyObject *__pyx_v_dummy_handler = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_construct (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_head_or_tail,&__pyx_n_s_handler_fun,&__pyx_n_s_trigger_token_label,&__pyx_n_s_prec,&__pyx_n_s_precond_label,&__pyx_n_s_precond_fun,&__pyx_n_s_precond_priority,&__pyx_n_s_val_type,&__pyx_n_s_arg_types,&__pyx_n_s_eval_fun,&__pyx_n_s_ast_data,&__pyx_n_s_value_key,&__pyx_n_s_autolabel_prefix,&__pyx_n_s_dummy_handler,0};
    PyObject* values[15] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    values[4] = ((PyObject *)((PyObject *)__pyx_int_0));

    /* "typped/pratt_parser.py":1293
 * 
 *     def def_construct(self, head_or_tail, handler_fun, trigger_token_label,
 *                       prec=0, precond_label=None, precond_fun=None,             # <<<<<<<<<<<<<<
 *                       precond_priority=0, val_type=None, arg_types=None,
 *                       eval_fun=None, ast_data=None, value_key=None,
 */
    values[5] = ((PyObject *)((PyObject *)Py_None));
    values[6] = ((PyObject *)((PyObject *)Py_None));
    values[7] = ((PyObject *)((PyObject *)__pyx_int_0));

    /* "typped/pratt_parser.py":1294
 *     def def_construct(self, head_or_tail, handler_fun, trigger_token_label,
 *                       prec=0, precond_label=None, precond_fun=None,
 *                       precond_priority=0, val_type=None, arg_types=None,             # <<<<<<<<<<<<<<
 *                       eval_fun=None, ast_data=None, value_key=None,
 *                       autolabel_prefix=None, dummy_handler=False):
 */
    values[8] = ((PyObject *)((PyObject *)Py_None));
    values[9] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":1295
 *                       prec=0, precond_label=None, precond_fun=None,
 *                       precond_priority=0, val_type=None, arg_types=None,
 *                       eval_fun=None, ast_data=None, value_key=None,             # <<<<<<<<<<<<<<
 *                       autolabel_prefix=None, dummy_handler=False):
 *         """Define a construct and register it with the token with label
 */
    values[10] = ((PyObject *)((PyObject *)Py_None));
    values[11] = ((PyObject *)((PyObject *)Py_None));
    values[12] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":1296
 *                       precond_priority=0, val_type=None, arg_types=None,
 *                       eval_fun=None, ast_data=None, value_key=None,
 *                       autolabel_prefix=None, dummy_handler=False):             # <<<<<<<<<<<<<<
 *         """Define a construct and register it with the token with label
 *         `trigger_token_label`.  A token with that label must already be in the
 */
    values[13] = ((PyObject *)((PyObject *)Py_None));
    values[14] = ((PyObject *)((PyObject *)Py_False));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        CYTHON_FALLTHROUGH;
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        CYTHON_FALLTHROUGH;
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        CYTHON_FALLTHROUGH;
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        CYTHON_FALLTHROUGH;
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        CYTHON_FALLTHROUGH;
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_head_or_tail)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_construct", 0, 4, 15, 1); __PYX_ERR(0, 1292, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_handler_fun)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_construct", 0, 4, 15, 2); __PYX_ERR(0, 1292, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_trigger_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_construct", 0, 4, 15, 3); __PYX_ERR(0, 1292, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_prec);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_precond_label);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_precond_fun);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_precond_priority);
          if (value) { values[7] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  8:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_val_type);
          if (value) { values[8] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  9:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_arg_types);
          if (value) { values[9] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 10:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_eval_fun);
          if (value) { values[10] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 11:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ast_data);
          if (value) { values[11] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 12:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_value_key);
          if (value) { values[12] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 13:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_autolabel_prefix);
          if (value) { values[13] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case 14:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_dummy_handler);
          if (value) { values[14] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_construct") < 0)) __PYX_ERR(0, 1292, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        CYTHON_FALLTHROUGH;
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        CYTHON_FALLTHROUGH;
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        CYTHON_FALLTHROUGH;
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        CYTHON_FALLTHROUGH;
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        CYTHON_FALLTHROUGH;
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        CYTHON_FALLTHROUGH;
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        CYTHON_FALLTHROUGH;
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_head_or_tail = values[1];
    __pyx_v_handler_fun = values[2];
    __pyx_v_trigger_token_label = values[3];
    __pyx_v_prec = values[4];
    __pyx_v_precond_label = values[5];
    __pyx_v_precond_fun = values[6];
    __pyx_v_precond_priority = values[7];
    __pyx_v_val_type = values[8];
    __pyx_v_arg_types = values[9];
    __pyx_v_eval_fun = values[10];
    __pyx_v_ast_data = values[11];
    __pyx_v_value_key = values[12];
    __pyx_v_autolabel_prefix = values[13];
    __pyx_v_dummy_handler = values[14];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_construct", 0, 4, 15, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1292, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_construct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_20def_construct(__pyx_self, __pyx_v_self, __pyx_v_head_or_tail, __pyx_v_handler_fun, __pyx_v_trigger_token_label, __pyx_v_prec, __pyx_v_precond_label, __pyx_v_precond_fun, __pyx_v_precond_priority, __pyx_v_val_type, __pyx_v_arg_types, __pyx_v_eval_fun, __pyx_v_ast_data, __pyx_v_value_key, __pyx_v_autolabel_prefix, __pyx_v_dummy_handler);

  /* "typped/pratt_parser.py":1292
 *     #
 * 
 *     def def_construct(self, head_or_tail, handler_fun, trigger_token_label,             # <<<<<<<<<<<<<<
 *                       prec=0, precond_label=None, precond_fun=None,
 *                       precond_priority=0, val_type=None, arg_types=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_20def_construct(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_handler_fun, PyObject *__pyx_v_trigger_token_label, PyObject *__pyx_v_prec, PyObject *__pyx_v_precond_label, PyObject *__pyx_v_precond_fun, PyObject *__pyx_v_precond_priority, PyObject *__pyx_v_val_type, PyObject *__pyx_v_arg_types, PyObject *__pyx_v_eval_fun, PyObject *__pyx_v_ast_data, PyObject *__pyx_v_value_key, PyObject *__pyx_v_autolabel_prefix, PyObject *__pyx_v_dummy_handler) {
  PyObject *__pyx_v_token_subclass = NULL;
  PyObject *__pyx_v_type_sig = NULL;
  PyObject *__pyx_v_construct = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  __Pyx_RefNannySetupContext("def_construct", 0);
  __Pyx_INCREF(__pyx_v_precond_label);
  __Pyx_INCREF(__pyx_v_precond_fun);

  /* "typped/pratt_parser.py":1351
 *         # set yet when this method is called.
 * 
 *         if isinstance(arg_types, str):             # <<<<<<<<<<<<<<
 *             raise ParserException("The arg_types argument to token_subclass must"
 *                     " be None or an iterable returning type labels (e.g., a list"
 */
  __pyx_t_1 = PyString_Check(__pyx_v_arg_types); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1352
 * 
 *         if isinstance(arg_types, str):
 *             raise ParserException("The arg_types argument to token_subclass must"             # <<<<<<<<<<<<<<
 *                     " be None or an iterable returning type labels (e.g., a list"
 *                     " or tuple).")
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1352, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__78, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1352, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 1352, __pyx_L1_error)

    /* "typped/pratt_parser.py":1351
 *         # set yet when this method is called.
 * 
 *         if isinstance(arg_types, str):             # <<<<<<<<<<<<<<
 *             raise ParserException("The arg_types argument to token_subclass must"
 *                     " be None or an iterable returning type labels (e.g., a list"
 */
  }

  /* "typped/pratt_parser.py":1356
 *                     " or tuple).")
 * 
 *         if head_or_tail == TAIL and prec <= 0 and not dummy_handler:             # <<<<<<<<<<<<<<
 *             raise ParserException("Attempt to define a construct for trigger token"
 *                     " '{0}' with a tail hander and a precedence of zero or less."
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1356, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyObject_RichCompare(__pyx_v_head_or_tail, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1356, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1356, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_1) {
  } else {
    __pyx_t_2 = __pyx_t_1;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_3 = PyObject_RichCompare(__pyx_v_prec, __pyx_int_0, Py_LE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1356, __pyx_L1_error)
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1356, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_1) {
  } else {
    __pyx_t_2 = __pyx_t_1;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_dummy_handler); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1356, __pyx_L1_error)
  __pyx_t_5 = ((!__pyx_t_1) != 0);
  __pyx_t_2 = __pyx_t_5;
  __pyx_L5_bool_binop_done:;
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1357
 * 
 *         if head_or_tail == TAIL and prec <= 0 and not dummy_handler:
 *             raise ParserException("Attempt to define a construct for trigger token"             # <<<<<<<<<<<<<<
 *                     " '{0}' with a tail hander and a precedence of zero or less."
 *                     .format(trigger_token_label))
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1357, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "typped/pratt_parser.py":1359
 *             raise ParserException("Attempt to define a construct for trigger token"
 *                     " '{0}' with a tail hander and a precedence of zero or less."
 *                     .format(trigger_token_label))             # <<<<<<<<<<<<<<
 *         if head_or_tail == HEAD and prec != 0 and not dummy_handler:
 *             raise ParserException("Attempt to define a construct for trigger token"
 */
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Attempt_to_define_a_construct_fo, __pyx_n_s_format); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1359, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    if (!__pyx_t_8) {
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_trigger_token_label); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1359, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_7)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_v_trigger_token_label};
        __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1359, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_v_trigger_token_label};
        __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1359, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1359, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __pyx_t_8 = NULL;
        __Pyx_INCREF(__pyx_v_trigger_token_label);
        __Pyx_GIVEREF(__pyx_v_trigger_token_label);
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_v_trigger_token_label);
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_9, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1359, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1357, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_t_6};
        __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1357, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_t_6};
        __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1357, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1357, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
        __Pyx_GIVEREF(__pyx_t_6);
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_6);
        __pyx_t_6 = 0;
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1357, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 1357, __pyx_L1_error)

    /* "typped/pratt_parser.py":1356
 *                     " or tuple).")
 * 
 *         if head_or_tail == TAIL and prec <= 0 and not dummy_handler:             # <<<<<<<<<<<<<<
 *             raise ParserException("Attempt to define a construct for trigger token"
 *                     " '{0}' with a tail hander and a precedence of zero or less."
 */
  }

  /* "typped/pratt_parser.py":1360
 *                     " '{0}' with a tail hander and a precedence of zero or less."
 *                     .format(trigger_token_label))
 *         if head_or_tail == HEAD and prec != 0 and not dummy_handler:             # <<<<<<<<<<<<<<
 *             raise ParserException("Attempt to define a construct for trigger token"
 *                     " '{0}' with a head hander and a precedence not equal to zero."
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_HEAD); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyObject_RichCompare(__pyx_v_head_or_tail, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_5) {
  } else {
    __pyx_t_2 = __pyx_t_5;
    goto __pyx_L9_bool_binop_done;
  }
  __pyx_t_4 = PyObject_RichCompare(__pyx_v_prec, __pyx_int_0, Py_NE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_5) {
  } else {
    __pyx_t_2 = __pyx_t_5;
    goto __pyx_L9_bool_binop_done;
  }
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_dummy_handler); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __pyx_t_1 = ((!__pyx_t_5) != 0);
  __pyx_t_2 = __pyx_t_1;
  __pyx_L9_bool_binop_done:;
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1361
 *                     .format(trigger_token_label))
 *         if head_or_tail == HEAD and prec != 0 and not dummy_handler:
 *             raise ParserException("Attempt to define a construct for trigger token"             # <<<<<<<<<<<<<<
 *                     " '{0}' with a head hander and a precedence not equal to zero."
 *                     .format(trigger_token_label))
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1361, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "typped/pratt_parser.py":1363
 *             raise ParserException("Attempt to define a construct for trigger token"
 *                     " '{0}' with a head hander and a precedence not equal to zero."
 *                     .format(trigger_token_label))             # <<<<<<<<<<<<<<
 * 
 *         if precond_fun is None:
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Attempt_to_define_a_construct_fo_2, __pyx_n_s_format); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1363, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_9 = __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_trigger_token_label); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1363, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_6)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_trigger_token_label};
        __pyx_t_9 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1363, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_9);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_trigger_token_label};
        __pyx_t_9 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1363, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_9);
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1363, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
        __Pyx_INCREF(__pyx_v_trigger_token_label);
        __Pyx_GIVEREF(__pyx_v_trigger_token_label);
        PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_v_trigger_token_label);
        __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_8, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1363, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_6) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1361, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_9};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1361, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_t_9};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1361, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1361, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
        __Pyx_GIVEREF(__pyx_t_9);
        PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_t_9);
        __pyx_t_9 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1361, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 1361, __pyx_L1_error)

    /* "typped/pratt_parser.py":1360
 *                     " '{0}' with a tail hander and a precedence of zero or less."
 *                     .format(trigger_token_label))
 *         if head_or_tail == HEAD and prec != 0 and not dummy_handler:             # <<<<<<<<<<<<<<
 *             raise ParserException("Attempt to define a construct for trigger token"
 *                     " '{0}' with a head hander and a precedence not equal to zero."
 */
  }

  /* "typped/pratt_parser.py":1365
 *                     .format(trigger_token_label))
 * 
 *         if precond_fun is None:             # <<<<<<<<<<<<<<
 *             if precond_label:
 *                 raise ParserException("Call to def_construct with precond_label set"
 */
  __pyx_t_2 = (__pyx_v_precond_fun == Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1366
 * 
 *         if precond_fun is None:
 *             if precond_label:             # <<<<<<<<<<<<<<
 *                 raise ParserException("Call to def_construct with precond_label set"
 *                         " to '{0}', but no precond_fun was provided.".format(precond_label))
 */
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_precond_label); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1366, __pyx_L1_error)
    if (__pyx_t_1) {

      /* "typped/pratt_parser.py":1367
 *         if precond_fun is None:
 *             if precond_label:
 *                 raise ParserException("Call to def_construct with precond_label set"             # <<<<<<<<<<<<<<
 *                         " to '{0}', but no precond_fun was provided.".format(precond_label))
 *             precond_fun = DEFAULT_ALWAYS_TRUE_PRECOND_FUN
 */
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1367, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);

      /* "typped/pratt_parser.py":1368
 *             if precond_label:
 *                 raise ParserException("Call to def_construct with precond_label set"
 *                         " to '{0}', but no precond_fun was provided.".format(precond_label))             # <<<<<<<<<<<<<<
 *             precond_fun = DEFAULT_ALWAYS_TRUE_PRECOND_FUN
 *             precond_label = DEFAULT_ALWAYS_TRUE_PRECOND_LABEL
 */
      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Call_to_def_construct_with_preco, __pyx_n_s_format); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1368, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_6 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_9))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_9);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_9, function);
        }
      }
      if (!__pyx_t_6) {
        __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_precond_label); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1368, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_9)) {
          PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v_precond_label};
          __pyx_t_8 = __Pyx_PyFunction_FastCall(__pyx_t_9, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1368, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_GOTREF(__pyx_t_8);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_9)) {
          PyObject *__pyx_temp[2] = {__pyx_t_6, __pyx_v_precond_label};
          __pyx_t_8 = __Pyx_PyCFunction_FastCall(__pyx_t_9, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1368, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_GOTREF(__pyx_t_8);
        } else
        #endif
        {
          __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1368, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_7);
          __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __pyx_t_6 = NULL;
          __Pyx_INCREF(__pyx_v_precond_label);
          __Pyx_GIVEREF(__pyx_v_precond_label);
          PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_v_precond_label);
          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1368, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_t_9 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_9)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_9);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (!__pyx_t_9) {
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1367, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[2] = {__pyx_t_9, __pyx_t_8};
          __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1367, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[2] = {__pyx_t_9, __pyx_t_8};
          __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1367, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        } else
        #endif
        {
          __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1367, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_7);
          __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_9); __pyx_t_9 = NULL;
          __Pyx_GIVEREF(__pyx_t_8);
          PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_8);
          __pyx_t_8 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1367, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 1367, __pyx_L1_error)

      /* "typped/pratt_parser.py":1366
 * 
 *         if precond_fun is None:
 *             if precond_label:             # <<<<<<<<<<<<<<
 *                 raise ParserException("Call to def_construct with precond_label set"
 *                         " to '{0}', but no precond_fun was provided.".format(precond_label))
 */
    }

    /* "typped/pratt_parser.py":1369
 *                 raise ParserException("Call to def_construct with precond_label set"
 *                         " to '{0}', but no precond_fun was provided.".format(precond_label))
 *             precond_fun = DEFAULT_ALWAYS_TRUE_PRECOND_FUN             # <<<<<<<<<<<<<<
 *             precond_label = DEFAULT_ALWAYS_TRUE_PRECOND_LABEL
 *         elif precond_label is None:
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_FUN); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1369, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF_SET(__pyx_v_precond_fun, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":1370
 *                         " to '{0}', but no precond_fun was provided.".format(precond_label))
 *             precond_fun = DEFAULT_ALWAYS_TRUE_PRECOND_FUN
 *             precond_label = DEFAULT_ALWAYS_TRUE_PRECOND_LABEL             # <<<<<<<<<<<<<<
 *         elif precond_label is None:
 *             precond_label = self._next_unique_precond_label(autolabel_prefix)
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_LABE); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1370, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF_SET(__pyx_v_precond_label, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":1365
 *                     .format(trigger_token_label))
 * 
 *         if precond_fun is None:             # <<<<<<<<<<<<<<
 *             if precond_label:
 *                 raise ParserException("Call to def_construct with precond_label set"
 */
    goto __pyx_L12;
  }

  /* "typped/pratt_parser.py":1371
 *             precond_fun = DEFAULT_ALWAYS_TRUE_PRECOND_FUN
 *             precond_label = DEFAULT_ALWAYS_TRUE_PRECOND_LABEL
 *         elif precond_label is None:             # <<<<<<<<<<<<<<
 *             precond_label = self._next_unique_precond_label(autolabel_prefix)
 * 
 */
  __pyx_t_1 = (__pyx_v_precond_label == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":1372
 *             precond_label = DEFAULT_ALWAYS_TRUE_PRECOND_LABEL
 *         elif precond_label is None:
 *             precond_label = self._next_unique_precond_label(autolabel_prefix)             # <<<<<<<<<<<<<<
 * 
 *         if trigger_token_label in self.token_table:
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_next_unique_precond_label); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1372, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_autolabel_prefix); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1372, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_autolabel_prefix};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1372, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_v_autolabel_prefix};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1372, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else
      #endif
      {
        __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1372, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
        __Pyx_INCREF(__pyx_v_autolabel_prefix);
        __Pyx_GIVEREF(__pyx_v_autolabel_prefix);
        PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_v_autolabel_prefix);
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1372, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_precond_label, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":1371
 *             precond_fun = DEFAULT_ALWAYS_TRUE_PRECOND_FUN
 *             precond_label = DEFAULT_ALWAYS_TRUE_PRECOND_LABEL
 *         elif precond_label is None:             # <<<<<<<<<<<<<<
 *             precond_label = self._next_unique_precond_label(autolabel_prefix)
 * 
 */
  }
  __pyx_L12:;

  /* "typped/pratt_parser.py":1374
 *             precond_label = self._next_unique_precond_label(autolabel_prefix)
 * 
 *         if trigger_token_label in self.token_table:             # <<<<<<<<<<<<<<
 *             token_subclass = self.get_token(trigger_token_label)
 *         else:
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1374, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_trigger_token_label, __pyx_t_4, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1374, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1375
 * 
 *         if trigger_token_label in self.token_table:
 *             token_subclass = self.get_token(trigger_token_label)             # <<<<<<<<<<<<<<
 *         else:
 *             raise ParserException("In call to def_construct: subclass for"
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_get_token); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1375, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_8) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_trigger_token_label); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1375, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_v_trigger_token_label};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1375, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_v_trigger_token_label};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1375, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_4);
      } else
      #endif
      {
        __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1375, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_8); __pyx_t_8 = NULL;
        __Pyx_INCREF(__pyx_v_trigger_token_label);
        __Pyx_GIVEREF(__pyx_v_trigger_token_label);
        PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_v_trigger_token_label);
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1375, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_token_subclass = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":1374
 *             precond_label = self._next_unique_precond_label(autolabel_prefix)
 * 
 *         if trigger_token_label in self.token_table:             # <<<<<<<<<<<<<<
 *             token_subclass = self.get_token(trigger_token_label)
 *         else:
 */
    goto __pyx_L14;
  }

  /* "typped/pratt_parser.py":1377
 *             token_subclass = self.get_token(trigger_token_label)
 *         else:
 *             raise ParserException("In call to def_construct: subclass for"             # <<<<<<<<<<<<<<
 *                     " token labeled '{0}' has not been defined.  Maybe try"
 *                     " calling def_token first.".format(trigger_token_label))
 */
  /*else*/ {
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1377, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "typped/pratt_parser.py":1379
 *             raise ParserException("In call to def_construct: subclass for"
 *                     " token labeled '{0}' has not been defined.  Maybe try"
 *                     " calling def_token first.".format(trigger_token_label))             # <<<<<<<<<<<<<<
 *             # Below line formerly just created a subclass, but that can mask errors!
 *             #TokenSubclass = self.token_table.create_token_subclass(token_label)
 */
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_In_call_to_def_construct_subclas, __pyx_n_s_format); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1379, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_8, function);
      }
    }
    if (!__pyx_t_9) {
      __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_trigger_token_label); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1379, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_8)) {
        PyObject *__pyx_temp[2] = {__pyx_t_9, __pyx_v_trigger_token_label};
        __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1379, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_GOTREF(__pyx_t_7);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_8)) {
        PyObject *__pyx_temp[2] = {__pyx_t_9, __pyx_v_trigger_token_label};
        __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1379, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
        __Pyx_GOTREF(__pyx_t_7);
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1379, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_9); __pyx_t_9 = NULL;
        __Pyx_INCREF(__pyx_v_trigger_token_label);
        __Pyx_GIVEREF(__pyx_v_trigger_token_label);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_trigger_token_label);
        __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_6, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1379, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_8) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1377, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_t_7};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1377, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_t_7};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1377, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1377, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_8); __pyx_t_8 = NULL;
        __Pyx_GIVEREF(__pyx_t_7);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_7);
        __pyx_t_7 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1377, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 1377, __pyx_L1_error)
  }
  __pyx_L14:;

  /* "typped/pratt_parser.py":1385
 *         # TODO: Precedence is currently saved as a token attribute.  Consider
 *         # saving it in the construct instead.
 *         if head_or_tail == TAIL:             # <<<<<<<<<<<<<<
 *             token_subclass.static_prec = prec # Ignore prec for heads; it will stay 0.
 * 
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_TAIL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1385, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyObject_RichCompare(__pyx_v_head_or_tail, __pyx_t_4, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1385, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1385, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1386
 *         # saving it in the construct instead.
 *         if head_or_tail == TAIL:
 *             token_subclass.static_prec = prec # Ignore prec for heads; it will stay 0.             # <<<<<<<<<<<<<<
 * 
 *         # Create the type sig object.
 */
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_token_subclass, __pyx_n_s_static_prec, __pyx_v_prec) < 0) __PYX_ERR(0, 1386, __pyx_L1_error)

    /* "typped/pratt_parser.py":1385
 *         # TODO: Precedence is currently saved as a token attribute.  Consider
 *         # saving it in the construct instead.
 *         if head_or_tail == TAIL:             # <<<<<<<<<<<<<<
 *             token_subclass.static_prec = prec # Ignore prec for heads; it will stay 0.
 * 
 */
  }

  /* "typped/pratt_parser.py":1389
 * 
 *         # Create the type sig object.
 *         type_sig = TypeSig(val_type, arg_types)             # <<<<<<<<<<<<<<
 * 
 *         # Register the handler funs.
 */
  __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_6 = NULL;
  __pyx_t_10 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_10 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_val_type, __pyx_v_arg_types};
    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1389, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_val_type, __pyx_v_arg_types};
    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1389, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1389, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_6) {
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __pyx_t_6 = NULL;
    }
    __Pyx_INCREF(__pyx_v_val_type);
    __Pyx_GIVEREF(__pyx_v_val_type);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_10, __pyx_v_val_type);
    __Pyx_INCREF(__pyx_v_arg_types);
    __Pyx_GIVEREF(__pyx_v_arg_types);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_10, __pyx_v_arg_types);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1389, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_type_sig = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1392
 * 
 *         # Register the handler funs.
 *         construct = self.construct_table.register_construct(             # <<<<<<<<<<<<<<
 *                                               head_or_tail=head_or_tail,
 *                                               trigger_token_label=trigger_token_label,
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_construct_table); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_register_construct); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1393
 *         # Register the handler funs.
 *         construct = self.construct_table.register_construct(
 *                                               head_or_tail=head_or_tail,             # <<<<<<<<<<<<<<
 *                                               trigger_token_label=trigger_token_label,
 *                                               handler_fun=handler_fun,
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1393, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_head_or_tail, __pyx_v_head_or_tail) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1394
 *         construct = self.construct_table.register_construct(
 *                                               head_or_tail=head_or_tail,
 *                                               trigger_token_label=trigger_token_label,             # <<<<<<<<<<<<<<
 *                                               handler_fun=handler_fun,
 *                                               precond_fun=precond_fun,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_trigger_token_label, __pyx_v_trigger_token_label) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1395
 *                                               head_or_tail=head_or_tail,
 *                                               trigger_token_label=trigger_token_label,
 *                                               handler_fun=handler_fun,             # <<<<<<<<<<<<<<
 *                                               precond_fun=precond_fun,
 *                                               precond_priority=precond_priority,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_handler_fun, __pyx_v_handler_fun) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1396
 *                                               trigger_token_label=trigger_token_label,
 *                                               handler_fun=handler_fun,
 *                                               precond_fun=precond_fun,             # <<<<<<<<<<<<<<
 *                                               precond_priority=precond_priority,
 *                                               precond_label=precond_label,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_precond_fun, __pyx_v_precond_fun) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1397
 *                                               handler_fun=handler_fun,
 *                                               precond_fun=precond_fun,
 *                                               precond_priority=precond_priority,             # <<<<<<<<<<<<<<
 *                                               precond_label=precond_label,
 *                                               type_sig=type_sig,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_precond_priority, __pyx_v_precond_priority) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1398
 *                                               precond_fun=precond_fun,
 *                                               precond_priority=precond_priority,
 *                                               precond_label=precond_label,             # <<<<<<<<<<<<<<
 *                                               type_sig=type_sig,
 *                                               eval_fun=eval_fun, ast_data=ast_data,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_precond_label, __pyx_v_precond_label) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1399
 *                                               precond_priority=precond_priority,
 *                                               precond_label=precond_label,
 *                                               type_sig=type_sig,             # <<<<<<<<<<<<<<
 *                                               eval_fun=eval_fun, ast_data=ast_data,
 *                                               value_key=value_key)
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type_sig, __pyx_v_type_sig) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1400
 *                                               precond_label=precond_label,
 *                                               type_sig=type_sig,
 *                                               eval_fun=eval_fun, ast_data=ast_data,             # <<<<<<<<<<<<<<
 *                                               value_key=value_key)
 *                                               #parser_instance=self)
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_eval_fun, __pyx_v_eval_fun) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ast_data, __pyx_v_ast_data) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1401
 *                                               type_sig=type_sig,
 *                                               eval_fun=eval_fun, ast_data=ast_data,
 *                                               value_key=value_key)             # <<<<<<<<<<<<<<
 *                                               #parser_instance=self)
 *         return construct
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_value_key, __pyx_v_value_key) < 0) __PYX_ERR(0, 1393, __pyx_L1_error)

  /* "typped/pratt_parser.py":1392
 * 
 *         # Register the handler funs.
 *         construct = self.construct_table.register_construct(             # <<<<<<<<<<<<<<
 *                                               head_or_tail=head_or_tail,
 *                                               trigger_token_label=trigger_token_label,
 */
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_construct = __pyx_t_7;
  __pyx_t_7 = 0;

  /* "typped/pratt_parser.py":1403
 *                                               value_key=value_key)
 *                                               #parser_instance=self)
 *         return construct             # <<<<<<<<<<<<<<
 * 
 *     def undef_construct(self, head_or_tail, trigger_token_label, precond_label=None,
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_construct);
  __pyx_r = __pyx_v_construct;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1292
 *     #
 * 
 *     def def_construct(self, head_or_tail, handler_fun, trigger_token_label,             # <<<<<<<<<<<<<<
 *                       prec=0, precond_label=None, precond_fun=None,
 *                       precond_priority=0, val_type=None, arg_types=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_construct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_token_subclass);
  __Pyx_XDECREF(__pyx_v_type_sig);
  __Pyx_XDECREF(__pyx_v_construct);
  __Pyx_XDECREF(__pyx_v_precond_label);
  __Pyx_XDECREF(__pyx_v_precond_fun);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1405
 *         return construct
 * 
 *     def undef_construct(self, head_or_tail, trigger_token_label, precond_label=None,             # <<<<<<<<<<<<<<
 *                          val_type=None, arg_types=None, all_handlers=False):
 *         """Undefine a head or tail function with the given `token_label`,
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_23undef_construct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_22undef_construct[] = "Undefine a head or tail function with the given `token_label`,\n        `precond_label` and type signature.\n\n        The `head_or_tail` value should be `HEAD` or `TAIL`.\n\n        If `all_precond` is set then all heads and tails for all preconditions\n        will be undefined.\n\n        If `all_overloads` then all overloaded type signatures will be\n        undefined.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_23undef_construct = {"undef_construct", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_23undef_construct, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_22undef_construct};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_23undef_construct(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_head_or_tail = 0;
  PyObject *__pyx_v_trigger_token_label = 0;
  PyObject *__pyx_v_precond_label = 0;
  PyObject *__pyx_v_val_type = 0;
  PyObject *__pyx_v_arg_types = 0;
  PyObject *__pyx_v_all_handlers = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("undef_construct (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_head_or_tail,&__pyx_n_s_trigger_token_label,&__pyx_n_s_precond_label,&__pyx_n_s_val_type,&__pyx_n_s_arg_types,&__pyx_n_s_all_handlers,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};
    values[3] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":1406
 * 
 *     def undef_construct(self, head_or_tail, trigger_token_label, precond_label=None,
 *                          val_type=None, arg_types=None, all_handlers=False):             # <<<<<<<<<<<<<<
 *         """Undefine a head or tail function with the given `token_label`,
 *         `precond_label` and type signature.
 */
    values[4] = ((PyObject *)((PyObject *)Py_None));
    values[5] = ((PyObject *)((PyObject *)Py_None));
    values[6] = ((PyObject *)((PyObject *)Py_False));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_head_or_tail)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("undef_construct", 0, 3, 7, 1); __PYX_ERR(0, 1405, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_trigger_token_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("undef_construct", 0, 3, 7, 2); __PYX_ERR(0, 1405, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_precond_label);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_val_type);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_arg_types);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_all_handlers);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "undef_construct") < 0)) __PYX_ERR(0, 1405, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_head_or_tail = values[1];
    __pyx_v_trigger_token_label = values[2];
    __pyx_v_precond_label = values[3];
    __pyx_v_val_type = values[4];
    __pyx_v_arg_types = values[5];
    __pyx_v_all_handlers = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("undef_construct", 0, 3, 7, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1405, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.undef_construct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_22undef_construct(__pyx_self, __pyx_v_self, __pyx_v_head_or_tail, __pyx_v_trigger_token_label, __pyx_v_precond_label, __pyx_v_val_type, __pyx_v_arg_types, __pyx_v_all_handlers);

  /* "typped/pratt_parser.py":1405
 *         return construct
 * 
 *     def undef_construct(self, head_or_tail, trigger_token_label, precond_label=None,             # <<<<<<<<<<<<<<
 *                          val_type=None, arg_types=None, all_handlers=False):
 *         """Undefine a head or tail function with the given `token_label`,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_22undef_construct(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_head_or_tail, PyObject *__pyx_v_trigger_token_label, PyObject *__pyx_v_precond_label, PyObject *__pyx_v_val_type, PyObject *__pyx_v_arg_types, PyObject *__pyx_v_all_handlers) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_RefNannySetupContext("undef_construct", 0);

  /* "typped/pratt_parser.py":1417
 *         If `all_overloads` then all overloaded type signatures will be
 *         undefined."""
 *         self.construct_table.unregister_construct(head_or_tail, trigger_token_label,             # <<<<<<<<<<<<<<
 *                                                   precond_label,
 *                                                   type_sig=TypeSig(val_type, arg_types),
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_construct_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_unregister_construct); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1418
 *         undefined."""
 *         self.construct_table.unregister_construct(head_or_tail, trigger_token_label,
 *                                                   precond_label,             # <<<<<<<<<<<<<<
 *                                                   type_sig=TypeSig(val_type, arg_types),
 *                                                   all_handlers=all_handlers)
 */
  __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_head_or_tail);
  __Pyx_GIVEREF(__pyx_v_head_or_tail);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_head_or_tail);
  __Pyx_INCREF(__pyx_v_trigger_token_label);
  __Pyx_GIVEREF(__pyx_v_trigger_token_label);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_trigger_token_label);
  __Pyx_INCREF(__pyx_v_precond_label);
  __Pyx_GIVEREF(__pyx_v_precond_label);
  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_precond_label);

  /* "typped/pratt_parser.py":1419
 *         self.construct_table.unregister_construct(head_or_tail, trigger_token_label,
 *                                                   precond_label,
 *                                                   type_sig=TypeSig(val_type, arg_types),             # <<<<<<<<<<<<<<
 *                                                   all_handlers=all_handlers)
 * 
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1419, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_TypeSig); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1419, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  __pyx_t_7 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
      __pyx_t_7 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_val_type, __pyx_v_arg_types};
    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1419, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_4);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_val_type, __pyx_v_arg_types};
    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1419, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_4);
  } else
  #endif
  {
    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1419, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    if (__pyx_t_6) {
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
    }
    __Pyx_INCREF(__pyx_v_val_type);
    __Pyx_GIVEREF(__pyx_v_val_type);
    PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_v_val_type);
    __Pyx_INCREF(__pyx_v_arg_types);
    __Pyx_GIVEREF(__pyx_v_arg_types);
    PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_v_arg_types);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1419, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_type_sig, __pyx_t_4) < 0) __PYX_ERR(0, 1419, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":1420
 *                                                   precond_label,
 *                                                   type_sig=TypeSig(val_type, arg_types),
 *                                                   all_handlers=all_handlers)             # <<<<<<<<<<<<<<
 * 
 *     #
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_all_handlers, __pyx_v_all_handlers) < 0) __PYX_ERR(0, 1419, __pyx_L1_error)

  /* "typped/pratt_parser.py":1417
 *         If `all_overloads` then all overloaded type signatures will be
 *         undefined."""
 *         self.construct_table.unregister_construct(head_or_tail, trigger_token_label,             # <<<<<<<<<<<<<<
 *                                                   precond_label,
 *                                                   type_sig=TypeSig(val_type, arg_types),
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "typped/pratt_parser.py":1405
 *         return construct
 * 
 *     def undef_construct(self, head_or_tail, trigger_token_label, precond_label=None,             # <<<<<<<<<<<<<<
 *                          val_type=None, arg_types=None, all_handlers=False):
 *         """Undefine a head or tail function with the given `token_label`,
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.undef_construct", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1426
 *     #
 * 
 *     def def_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Define a type associated with the name `type_label`."""
 *         return self.type_table.create_typeobject(type_label)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_25def_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_24def_type[] = "Define a type associated with the name `type_label`.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_25def_type = {"def_type", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_25def_type, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_24def_type};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_25def_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_type_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("def_type (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_type_label,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_type_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("def_type", 1, 2, 2, 1); __PYX_ERR(0, 1426, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "def_type") < 0)) __PYX_ERR(0, 1426, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_type_label = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("def_type", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1426, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_24def_type(__pyx_self, __pyx_v_self, __pyx_v_type_label);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_24def_type(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_type_label) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("def_type", 0);

  /* "typped/pratt_parser.py":1428
 *     def def_type(self, type_label):
 *         """Define a type associated with the name `type_label`."""
 *         return self.type_table.create_typeobject(type_label)             # <<<<<<<<<<<<<<
 * 
 *     def undef_type(self, type_label):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_type_table); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1428, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_create_typeobject); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1428, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_type_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1428, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_type_label};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1428, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_type_label};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1428, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1428, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_type_label);
      __Pyx_GIVEREF(__pyx_v_type_label);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_type_label);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1428, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1426
 *     #
 * 
 *     def def_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Define a type associated with the name `type_label`."""
 *         return self.type_table.create_typeobject(type_label)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.def_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1430
 *         return self.type_table.create_typeobject(type_label)
 * 
 *     def undef_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Undefine the type associated with the name `type_label`."""
 *         self.type_table.undef_typeobject(type_label)
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_27undef_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_26undef_type[] = "Undefine the type associated with the name `type_label`.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_27undef_type = {"undef_type", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_27undef_type, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_26undef_type};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_27undef_type(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_type_label = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("undef_type (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_type_label,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_type_label)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("undef_type", 1, 2, 2, 1); __PYX_ERR(0, 1430, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "undef_type") < 0)) __PYX_ERR(0, 1430, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_type_label = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("undef_type", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1430, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.undef_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_26undef_type(__pyx_self, __pyx_v_self, __pyx_v_type_label);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_26undef_type(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_type_label) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("undef_type", 0);

  /* "typped/pratt_parser.py":1432
 *     def undef_type(self, type_label):
 *         """Undefine the type associated with the name `type_label`."""
 *         self.type_table.undef_typeobject(type_label)             # <<<<<<<<<<<<<<
 * 
 *     #
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_type_table); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1432, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_undef_typeobject); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1432, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_type_label); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1432, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_type_label};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1432, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_v_type_label};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1432, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_1);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1432, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
      __Pyx_INCREF(__pyx_v_type_label);
      __Pyx_GIVEREF(__pyx_v_type_label);
      PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_type_label);
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1432, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1430
 *         return self.type_table.create_typeobject(type_label)
 * 
 *     def undef_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Undefine the type associated with the name `type_label`."""
 *         self.type_table.undef_typeobject(type_label)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.undef_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1438
 *     #
 * 
 *     def parse_from_lexer(self, lexer_to_use, pstate=None):             # <<<<<<<<<<<<<<
 *         """The same as the `parse` method, but a lexer_to_use is already assumed to be
 *         initialized.  This is ONLY used when one parser instance calls another
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_29parse_from_lexer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_28parse_from_lexer[] = "The same as the `parse` method, but a lexer_to_use is already assumed to be\n        initialized.  This is ONLY used when one parser instance calls another\n        parser instance (implicitly, via the handler functions of its tokens).\n        The outer parser calls this routine of the inner, subexpression parser.\n        Such a call to another parser would look something like::\n\n            alternate_parser.parse_from_lexer(lexer_to_use)\n\n        where `lexer_to_use` is the lexer_to_use of the outer parser.  This routine\n        temporarily swaps the token table for the passed-in lexer_to_use to be the\n        token table for this parser (remember that this parser is the inner\n        parser when this routine is called).";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_29parse_from_lexer = {"parse_from_lexer", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_29parse_from_lexer, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_28parse_from_lexer};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_29parse_from_lexer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_lexer_to_use = 0;
  PyObject *__pyx_v_pstate = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("parse_from_lexer (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_lexer_to_use,&__pyx_n_s_pstate,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)((PyObject *)Py_None));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_lexer_to_use)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("parse_from_lexer", 0, 2, 3, 1); __PYX_ERR(0, 1438, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pstate);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "parse_from_lexer") < 0)) __PYX_ERR(0, 1438, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_lexer_to_use = values[1];
    __pyx_v_pstate = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("parse_from_lexer", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1438, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.parse_from_lexer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_28parse_from_lexer(__pyx_self, __pyx_v_self, __pyx_v_lexer_to_use, __pyx_v_pstate);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_28parse_from_lexer(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_lexer_to_use, PyObject *__pyx_v_pstate) {
  PyObject *__pyx_v_lexer_to_use_usual_table = NULL;
  PyObject *__pyx_v_usual_lexer = NULL;
  PyObject *__pyx_v_parsed_subexpression = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  char const *__pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  __Pyx_RefNannySetupContext("parse_from_lexer", 0);

  /* "typped/pratt_parser.py":1458
 * 
 *         # Temporarily change new lexer's token table.
 *         lexer_to_use_usual_table = lexer_to_use.token_table             # <<<<<<<<<<<<<<
 *         lexer_to_use.set_token_table(self.token_table)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_lexer_to_use, __pyx_n_s_token_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1458, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_lexer_to_use_usual_table = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1459
 *         # Temporarily change new lexer's token table.
 *         lexer_to_use_usual_table = lexer_to_use.token_table
 *         lexer_to_use.set_token_table(self.token_table)             # <<<<<<<<<<<<<<
 * 
 *         # Swap the lexer in.
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_lexer_to_use, __pyx_n_s_set_token_table); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1459, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_token_table); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1459, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1459, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1459, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_3};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1459, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1459, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
      __pyx_t_3 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1459, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1462
 * 
 *         # Swap the lexer in.
 *         usual_lexer = self.lex             # <<<<<<<<<<<<<<
 *         self.lex = lexer_to_use # Swap the lexer.
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1462, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_usual_lexer = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1463
 *         # Swap the lexer in.
 *         usual_lexer = self.lex
 *         self.lex = lexer_to_use # Swap the lexer.             # <<<<<<<<<<<<<<
 * 
 *         try:
 */
  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_lex, __pyx_v_lexer_to_use) < 0) __PYX_ERR(0, 1463, __pyx_L1_error)

  /* "typped/pratt_parser.py":1465
 *         self.lex = lexer_to_use # Swap the lexer.
 * 
 *         try:             # <<<<<<<<<<<<<<
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,
 *                                     partial_expressions=True,
 */
  /*try:*/ {
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      /*try:*/ {

        /* "typped/pratt_parser.py":1466
 * 
 *         try:
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,             # <<<<<<<<<<<<<<
 *                                     partial_expressions=True,
 *                                     skip_lex_setup=True)
 */
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_parse); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1466, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1466, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_2);
        if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_pstate, __pyx_v_pstate) < 0) __PYX_ERR(0, 1466, __pyx_L6_error)

        /* "typped/pratt_parser.py":1467
 *         try:
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,
 *                                     partial_expressions=True,             # <<<<<<<<<<<<<<
 *                                     skip_lex_setup=True)
 *         except ParserException:
 */
        if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_partial_expressions, Py_True) < 0) __PYX_ERR(0, 1466, __pyx_L6_error)

        /* "typped/pratt_parser.py":1468
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,
 *                                     partial_expressions=True,
 *                                     skip_lex_setup=True)             # <<<<<<<<<<<<<<
 *         except ParserException:
 *             print("Error in `parse_from_lexer` method, in call to `parse` method"
 */
        if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_skip_lex_setup, Py_True) < 0) __PYX_ERR(0, 1466, __pyx_L6_error)

        /* "typped/pratt_parser.py":1466
 * 
 *         try:
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,             # <<<<<<<<<<<<<<
 *                                     partial_expressions=True,
 *                                     skip_lex_setup=True)
 */
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__79, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1466, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_v_parsed_subexpression = __pyx_t_5;
        __pyx_t_5 = 0;

        /* "typped/pratt_parser.py":1465
 *         self.lex = lexer_to_use # Swap the lexer.
 * 
 *         try:             # <<<<<<<<<<<<<<
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,
 *                                     partial_expressions=True,
 */
      }
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L11_try_end;
      __pyx_L6_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "typped/pratt_parser.py":1469
 *                                     partial_expressions=True,
 *                                     skip_lex_setup=True)
 *         except ParserException:             # <<<<<<<<<<<<<<
 *             print("Error in `parse_from_lexer` method, in call to `parse` method"
 *                     " using a different parser's lexer for a subexpression.",
 */
      __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1469, __pyx_L8_except_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (__pyx_t_9) {
        __Pyx_AddTraceback("typped.pratt_parser.PrattParser.parse_from_lexer", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_2, &__pyx_t_1) < 0) __PYX_ERR(0, 1469, __pyx_L8_except_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_GOTREF(__pyx_t_1);

        /* "typped/pratt_parser.py":1472
 *             print("Error in `parse_from_lexer` method, in call to `parse` method"
 *                     " using a different parser's lexer for a subexpression.",
 *                     file=sys.stderr)             # <<<<<<<<<<<<<<
 *             raise
 *         finally:
 */
        __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1472, __pyx_L8_except_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_sys); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1472, __pyx_L8_except_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_stderr); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1472, __pyx_L8_except_error)
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_file, __pyx_t_10) < 0) __PYX_ERR(0, 1472, __pyx_L8_except_error)
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;

        /* "typped/pratt_parser.py":1470
 *                                     skip_lex_setup=True)
 *         except ParserException:
 *             print("Error in `parse_from_lexer` method, in call to `parse` method"             # <<<<<<<<<<<<<<
 *                     " using a different parser's lexer for a subexpression.",
 *                     file=sys.stderr)
 */
        __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple__80, __pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1470, __pyx_L8_except_error)
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;

        /* "typped/pratt_parser.py":1473
 *                     " using a different parser's lexer for a subexpression.",
 *                     file=sys.stderr)
 *             raise             # <<<<<<<<<<<<<<
 *         finally:
 *             # Restore the lexer.
 */
        __Pyx_GIVEREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_2);
        __Pyx_XGIVEREF(__pyx_t_1);
        __Pyx_ErrRestoreWithState(__pyx_t_5, __pyx_t_2, __pyx_t_1);
        __pyx_t_5 = 0; __pyx_t_2 = 0; __pyx_t_1 = 0; 
        __PYX_ERR(0, 1473, __pyx_L8_except_error)
      }
      goto __pyx_L8_except_error;
      __pyx_L8_except_error:;

      /* "typped/pratt_parser.py":1465
 *         self.lex = lexer_to_use # Swap the lexer.
 * 
 *         try:             # <<<<<<<<<<<<<<
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,
 *                                     partial_expressions=True,
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
      goto __pyx_L4_error;
      __pyx_L11_try_end:;
    }
  }

  /* "typped/pratt_parser.py":1476
 *         finally:
 *             # Restore the lexer.
 *             lexer_to_use.set_token_table(lexer_to_use_usual_table) # Restore token table.             # <<<<<<<<<<<<<<
 *             self.lex = usual_lexer
 *         return parsed_subexpression
 */
  /*finally:*/ {
    /*normal exit:*/{
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_lexer_to_use, __pyx_n_s_set_token_table); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1476, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      if (!__pyx_t_5) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_lexer_to_use_usual_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
      } else {
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_2)) {
          PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_lexer_to_use_usual_table};
          __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_1);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
          PyObject *__pyx_temp[2] = {__pyx_t_5, __pyx_v_lexer_to_use_usual_table};
          __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_1);
        } else
        #endif
        {
          __pyx_t_10 = PyTuple_New(1+1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1476, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_10);
          __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5); __pyx_t_5 = NULL;
          __Pyx_INCREF(__pyx_v_lexer_to_use_usual_table);
          __Pyx_GIVEREF(__pyx_v_lexer_to_use_usual_table);
          PyTuple_SET_ITEM(__pyx_t_10, 0+1, __pyx_v_lexer_to_use_usual_table);
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        }
      }
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "typped/pratt_parser.py":1477
 *             # Restore the lexer.
 *             lexer_to_use.set_token_table(lexer_to_use_usual_table) # Restore token table.
 *             self.lex = usual_lexer             # <<<<<<<<<<<<<<
 *         return parsed_subexpression
 * 
 */
      if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_lex, __pyx_v_usual_lexer) < 0) __PYX_ERR(0, 1477, __pyx_L1_error)
      goto __pyx_L5;
    }
    /*exception exit:*/{
      __Pyx_PyThreadState_declare
      __pyx_L4_error:;
      __pyx_t_8 = 0; __pyx_t_7 = 0; __pyx_t_6 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_8, &__pyx_t_7, &__pyx_t_6) < 0)) __Pyx_ErrFetch(&__pyx_t_8, &__pyx_t_7, &__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_6);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_15);
      __pyx_t_9 = __pyx_lineno; __pyx_t_11 = __pyx_clineno; __pyx_t_12 = __pyx_filename;
      {

        /* "typped/pratt_parser.py":1476
 *         finally:
 *             # Restore the lexer.
 *             lexer_to_use.set_token_table(lexer_to_use_usual_table) # Restore token table.             # <<<<<<<<<<<<<<
 *             self.lex = usual_lexer
 *         return parsed_subexpression
 */
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_lexer_to_use, __pyx_n_s_set_token_table); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1476, __pyx_L15_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_10 = NULL;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
          __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_2);
          if (likely(__pyx_t_10)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
            __Pyx_INCREF(__pyx_t_10);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_2, function);
          }
        }
        if (!__pyx_t_10) {
          __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_lexer_to_use_usual_table); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L15_error)
          __Pyx_GOTREF(__pyx_t_1);
        } else {
          #if CYTHON_FAST_PYCALL
          if (PyFunction_Check(__pyx_t_2)) {
            PyObject *__pyx_temp[2] = {__pyx_t_10, __pyx_v_lexer_to_use_usual_table};
            __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L15_error)
            __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
            __Pyx_GOTREF(__pyx_t_1);
          } else
          #endif
          #if CYTHON_FAST_PYCCALL
          if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
            PyObject *__pyx_temp[2] = {__pyx_t_10, __pyx_v_lexer_to_use_usual_table};
            __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L15_error)
            __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
            __Pyx_GOTREF(__pyx_t_1);
          } else
          #endif
          {
            __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1476, __pyx_L15_error)
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_10); __pyx_t_10 = NULL;
            __Pyx_INCREF(__pyx_v_lexer_to_use_usual_table);
            __Pyx_GIVEREF(__pyx_v_lexer_to_use_usual_table);
            PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_lexer_to_use_usual_table);
            __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L15_error)
            __Pyx_GOTREF(__pyx_t_1);
            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          }
        }
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "typped/pratt_parser.py":1477
 *             # Restore the lexer.
 *             lexer_to_use.set_token_table(lexer_to_use_usual_table) # Restore token table.
 *             self.lex = usual_lexer             # <<<<<<<<<<<<<<
 *         return parsed_subexpression
 * 
 */
        if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_lex, __pyx_v_usual_lexer) < 0) __PYX_ERR(0, 1477, __pyx_L15_error)
      }
      __Pyx_PyThreadState_assign
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
      }
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_6);
      __Pyx_ErrRestore(__pyx_t_8, __pyx_t_7, __pyx_t_6);
      __pyx_t_8 = 0; __pyx_t_7 = 0; __pyx_t_6 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __pyx_lineno = __pyx_t_9; __pyx_clineno = __pyx_t_11; __pyx_filename = __pyx_t_12;
      goto __pyx_L1_error;
      __pyx_L15_error:;
      __Pyx_PyThreadState_assign
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
      }
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      goto __pyx_L1_error;
    }
    __pyx_L5:;
  }

  /* "typped/pratt_parser.py":1478
 *             lexer_to_use.set_token_table(lexer_to_use_usual_table) # Restore token table.
 *             self.lex = usual_lexer
 *         return parsed_subexpression             # <<<<<<<<<<<<<<
 * 
 *     def parse(self, program, pstate=None, partial_expressions=None,
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_parsed_subexpression);
  __pyx_r = __pyx_v_parsed_subexpression;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1438
 *     #
 * 
 *     def parse_from_lexer(self, lexer_to_use, pstate=None):             # <<<<<<<<<<<<<<
 *         """The same as the `parse` method, but a lexer_to_use is already assumed to be
 *         initialized.  This is ONLY used when one parser instance calls another
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.parse_from_lexer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_lexer_to_use_usual_table);
  __Pyx_XDECREF(__pyx_v_usual_lexer);
  __Pyx_XDECREF(__pyx_v_parsed_subexpression);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "typped/pratt_parser.py":1480
 *         return parsed_subexpression
 * 
 *     def parse(self, program, pstate=None, partial_expressions=None,             # <<<<<<<<<<<<<<
 *                                                       skip_lex_setup=False):
 *         """The main routine for parsing a full program or expression.  Users of
 */

/* Python wrapper */
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_31parse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_6typped_12pratt_parser_11PrattParser_30parse[] = "The main routine for parsing a full program or expression.  Users of\n        the class should call this method to perform the parsing operations\n        (after defining a grammar, of course).\n\n        Unless there was a parsing failure or `partial_expressions` is true\n        then the lexer is left with the end-token as the current token.\n\n        If the `pstate` variable is set then the value will be pushed as the\n        initial state on the production rule stack `pstate_stack`.  The stack\n        is then cleared after a successful call.  (Set the parser attribute\n        directly for more control.)\n\n        The parser's `partial_expressions` attribute will be used unless it is\n        overridden by the parameter `partial_expressions` here.  When it is\n        true no check is made for the end-token after `recursive_parse` returns\n        a value.    The lexer will be left at the last token consumed, so a\n        check for the end-token will tell when all the text was consumed.\n        Users are responsible for making sure their grammars are suitable for\n        this kind of parsing if the option is set.\n\n        If the `skip_lex_setup` parameter is true then the text `program` is\n        ignored and lexer setup is skipped.  This is generally ONLY used when\n        multiple parsers are parsing from a common text stream, and `parse` is\n        called from the method `parse_from_lexer`.";
static PyMethodDef __pyx_mdef_6typped_12pratt_parser_11PrattParser_31parse = {"parse", (PyCFunction)__pyx_pw_6typped_12pratt_parser_11PrattParser_31parse, METH_VARARGS|METH_KEYWORDS, __pyx_doc_6typped_12pratt_parser_11PrattParser_30parse};
static PyObject *__pyx_pw_6typped_12pratt_parser_11PrattParser_31parse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_program = 0;
  PyObject *__pyx_v_pstate = 0;
  PyObject *__pyx_v_partial_expressions = 0;
  PyObject *__pyx_v_skip_lex_setup = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("parse (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_program,&__pyx_n_s_pstate,&__pyx_n_s_partial_expressions,&__pyx_n_s_skip_lex_setup,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[2] = ((PyObject *)((PyObject *)Py_None));
    values[3] = ((PyObject *)((PyObject *)Py_None));

    /* "typped/pratt_parser.py":1481
 * 
 *     def parse(self, program, pstate=None, partial_expressions=None,
 *                                                       skip_lex_setup=False):             # <<<<<<<<<<<<<<
 *         """The main routine for parsing a full program or expression.  Users of
 *         the class should call this method to perform the parsing operations
 */
    values[4] = ((PyObject *)((PyObject *)Py_False));
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_program)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("parse", 0, 2, 5, 1); __PYX_ERR(0, 1480, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pstate);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_partial_expressions);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_skip_lex_setup);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "parse") < 0)) __PYX_ERR(0, 1480, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_self = values[0];
    __pyx_v_program = values[1];
    __pyx_v_pstate = values[2];
    __pyx_v_partial_expressions = values[3];
    __pyx_v_skip_lex_setup = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("parse", 0, 2, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1480, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.parse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_6typped_12pratt_parser_11PrattParser_30parse(__pyx_self, __pyx_v_self, __pyx_v_program, __pyx_v_pstate, __pyx_v_partial_expressions, __pyx_v_skip_lex_setup);

  /* "typped/pratt_parser.py":1480
 *         return parsed_subexpression
 * 
 *     def parse(self, program, pstate=None, partial_expressions=None,             # <<<<<<<<<<<<<<
 *                                                       skip_lex_setup=False):
 *         """The main routine for parsing a full program or expression.  Users of
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_6typped_12pratt_parser_11PrattParser_30parse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_program, PyObject *__pyx_v_pstate, PyObject *__pyx_v_partial_expressions, PyObject *__pyx_v_skip_lex_setup) {
  PyObject *__pyx_v_begin_tok = NULL;
  PyObject *__pyx_v_parse_tree = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  int __pyx_t_15;
  __Pyx_RefNannySetupContext("parse", 0);
  __Pyx_INCREF(__pyx_v_partial_expressions);

  /* "typped/pratt_parser.py":1506
 *         multiple parsers are parsing from a common text stream, and `parse` is
 *         called from the method `parse_from_lexer`."""
 *         if pstate:             # <<<<<<<<<<<<<<
 *             self.pstate_stack = [pstate] # For parsing production rule grammars.
 *         if partial_expressions is None:
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_pstate); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1506, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1507
 *         called from the method `parse_from_lexer`."""
 *         if pstate:
 *             self.pstate_stack = [pstate] # For parsing production rule grammars.             # <<<<<<<<<<<<<<
 *         if partial_expressions is None:
 *             partial_expressions = self.partial_expressions
 */
    __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1507, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_pstate);
    __Pyx_GIVEREF(__pyx_v_pstate);
    PyList_SET_ITEM(__pyx_t_2, 0, __pyx_v_pstate);
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_pstate_stack, __pyx_t_2) < 0) __PYX_ERR(0, 1507, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "typped/pratt_parser.py":1506
 *         multiple parsers are parsing from a common text stream, and `parse` is
 *         called from the method `parse_from_lexer`."""
 *         if pstate:             # <<<<<<<<<<<<<<
 *             self.pstate_stack = [pstate] # For parsing production rule grammars.
 *         if partial_expressions is None:
 */
  }

  /* "typped/pratt_parser.py":1508
 *         if pstate:
 *             self.pstate_stack = [pstate] # For parsing production rule grammars.
 *         if partial_expressions is None:             # <<<<<<<<<<<<<<
 *             partial_expressions = self.partial_expressions
 * 
 */
  __pyx_t_1 = (__pyx_v_partial_expressions == Py_None);
  __pyx_t_3 = (__pyx_t_1 != 0);
  if (__pyx_t_3) {

    /* "typped/pratt_parser.py":1509
 *             self.pstate_stack = [pstate] # For parsing production rule grammars.
 *         if partial_expressions is None:
 *             partial_expressions = self.partial_expressions             # <<<<<<<<<<<<<<
 * 
 *         if not skip_lex_setup:
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_partial_expressions); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1509, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF_SET(__pyx_v_partial_expressions, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "typped/pratt_parser.py":1508
 *         if pstate:
 *             self.pstate_stack = [pstate] # For parsing production rule grammars.
 *         if partial_expressions is None:             # <<<<<<<<<<<<<<
 *             partial_expressions = self.partial_expressions
 * 
 */
  }

  /* "typped/pratt_parser.py":1511
 *             partial_expressions = self.partial_expressions
 * 
 *         if not skip_lex_setup:             # <<<<<<<<<<<<<<
 *             self.lex.set_text(program)
 *         begin_tok = self.lex.token # Get the first token to access recursive_parse.
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_skip_lex_setup); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 1511, __pyx_L1_error)
  __pyx_t_1 = ((!__pyx_t_3) != 0);
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1512
 * 
 *         if not skip_lex_setup:
 *             self.lex.set_text(program)             # <<<<<<<<<<<<<<
 *         begin_tok = self.lex.token # Get the first token to access recursive_parse.
 *         parse_tree = begin_tok.recursive_parse(0)
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1512, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_set_text); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1512, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (!__pyx_t_4) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_program); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1512, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_v_program};
        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1512, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_2);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_v_program};
        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1512, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_2);
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1512, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
        __Pyx_INCREF(__pyx_v_program);
        __Pyx_GIVEREF(__pyx_v_program);
        PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_program);
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1512, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "typped/pratt_parser.py":1511
 *             partial_expressions = self.partial_expressions
 * 
 *         if not skip_lex_setup:             # <<<<<<<<<<<<<<
 *             self.lex.set_text(program)
 *         begin_tok = self.lex.token # Get the first token to access recursive_parse.
 */
  }

  /* "typped/pratt_parser.py":1513
 *         if not skip_lex_setup:
 *             self.lex.set_text(program)
 *         begin_tok = self.lex.token # Get the first token to access recursive_parse.             # <<<<<<<<<<<<<<
 *         parse_tree = begin_tok.recursive_parse(0)
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1513, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_token); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1513, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_begin_tok = __pyx_t_5;
  __pyx_t_5 = 0;

  /* "typped/pratt_parser.py":1514
 *             self.lex.set_text(program)
 *         begin_tok = self.lex.token # Get the first token to access recursive_parse.
 *         parse_tree = begin_tok.recursive_parse(0)             # <<<<<<<<<<<<<<
 * 
 *         # Finalize type-checking for root when overloading on return types.
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_begin_tok, __pyx_n_s_recursive_parse); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1514, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_tuple__81, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1514, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_v_parse_tree = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "typped/pratt_parser.py":1517
 * 
 *         # Finalize type-checking for root when overloading on return types.
 *         if self.overload_on_ret_types:             # <<<<<<<<<<<<<<
 *             parse_tree.check_types_in_tree_second_pass(root=True)
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_overload_on_ret_types); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1517, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1517, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1518
 *         # Finalize type-checking for root when overloading on return types.
 *         if self.overload_on_ret_types:
 *             parse_tree.check_types_in_tree_second_pass(root=True)             # <<<<<<<<<<<<<<
 * 
 *         # See if we reached the end of the token stream.
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_parse_tree, __pyx_n_s_check_types_in_tree_second_pass); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1518, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1518, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_root, Py_True) < 0) __PYX_ERR(0, 1518, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1518, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "typped/pratt_parser.py":1517
 * 
 *         # Finalize type-checking for root when overloading on return types.
 *         if self.overload_on_ret_types:             # <<<<<<<<<<<<<<
 *             parse_tree.check_types_in_tree_second_pass(root=True)
 * 
 */
  }

  /* "typped/pratt_parser.py":1521
 * 
 *         # See if we reached the end of the token stream.
 *         if not self.lex.peek().is_end_token() and not partial_expressions:             # <<<<<<<<<<<<<<
 *             raise IncompleteParseException("Parsing never reached the end of"
 *                 " the text.  Parsing stopped with tokens still in the lexer."
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1521, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_peek); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1521, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (__pyx_t_2) {
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1521, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1521, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_is_end_token); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1521, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (__pyx_t_5) {
    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1521, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  } else {
    __pyx_t_6 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1521, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 1521, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_7 = ((!__pyx_t_3) != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_1 = __pyx_t_7;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_partial_expressions); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1521, __pyx_L1_error)
  __pyx_t_3 = ((!__pyx_t_7) != 0);
  __pyx_t_1 = __pyx_t_3;
  __pyx_L8_bool_binop_done:;
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1522
 *         # See if we reached the end of the token stream.
 *         if not self.lex.peek().is_end_token() and not partial_expressions:
 *             raise IncompleteParseException("Parsing never reached the end of"             # <<<<<<<<<<<<<<
 *                 " the text.  Parsing stopped with tokens still in the lexer."
 *                 "  No syntax element was recognized. The last-parsed token had"
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_IncompleteParseException); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1522, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "typped/pratt_parser.py":1528
 *                 " in the lexer with value '{2}' and label '{3}'.  The partial"
 *                 " result returned is:\n{4}"
 *                 .format(self.lex.token.value, self.lex.token.token_label,             # <<<<<<<<<<<<<<
 *                         self.lex.peek().value, self.lex.peek().token_label,
 *                         parse_tree.tree_repr()))
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Parsing_never_reached_the_end_of, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1528, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1528, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_token); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1528, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_value); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1528, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1528, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_token); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1528, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_token_label); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1528, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;

    /* "typped/pratt_parser.py":1529
 *                 " result returned is:\n{4}"
 *                 .format(self.lex.token.value, self.lex.token.token_label,
 *                         self.lex.peek().value, self.lex.peek().token_label,             # <<<<<<<<<<<<<<
 *                         parse_tree.tree_repr()))
 * 
 */
    __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 1529, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_11, __pyx_n_s_peek); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1529, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_12);
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    __pyx_t_11 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_12))) {
      __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_12);
      if (likely(__pyx_t_11)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
        __Pyx_INCREF(__pyx_t_11);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_12, function);
      }
    }
    if (__pyx_t_11) {
      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_t_12, __pyx_t_11); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1529, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    } else {
      __pyx_t_10 = __Pyx_PyObject_CallNoArg(__pyx_t_12); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1529, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_value); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1529, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_12);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_lex); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 1529, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_11, __pyx_n_s_peek); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1529, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    __pyx_t_11 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
      __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_13);
      if (likely(__pyx_t_11)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
        __Pyx_INCREF(__pyx_t_11);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_13, function);
      }
    }
    if (__pyx_t_11) {
      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_11); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1529, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    } else {
      __pyx_t_10 = __Pyx_PyObject_CallNoArg(__pyx_t_13); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1529, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_token_label); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1529, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;

    /* "typped/pratt_parser.py":1530
 *                 .format(self.lex.token.value, self.lex.token.token_label,
 *                         self.lex.peek().value, self.lex.peek().token_label,
 *                         parse_tree.tree_repr()))             # <<<<<<<<<<<<<<
 * 
 *         if pstate:
 */
    __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_parse_tree, __pyx_n_s_tree_repr); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 1530, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __pyx_t_14 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_11))) {
      __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_11);
      if (likely(__pyx_t_14)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
        __Pyx_INCREF(__pyx_t_14);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_11, function);
      }
    }
    if (__pyx_t_14) {
      __pyx_t_10 = __Pyx_PyObject_CallOneArg(__pyx_t_11, __pyx_t_14); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1530, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    } else {
      __pyx_t_10 = __Pyx_PyObject_CallNoArg(__pyx_t_11); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1530, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    __pyx_t_11 = NULL;
    __pyx_t_15 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_11)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_11);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
        __pyx_t_15 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[6] = {__pyx_t_11, __pyx_t_8, __pyx_t_9, __pyx_t_12, __pyx_t_13, __pyx_t_10};
      __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_15, 5+__pyx_t_15); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1528, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[6] = {__pyx_t_11, __pyx_t_8, __pyx_t_9, __pyx_t_12, __pyx_t_13, __pyx_t_10};
      __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_15, 5+__pyx_t_15); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1528, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    } else
    #endif
    {
      __pyx_t_14 = PyTuple_New(5+__pyx_t_15); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 1528, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      if (__pyx_t_11) {
        __Pyx_GIVEREF(__pyx_t_11); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_11); __pyx_t_11 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_15, __pyx_t_8);
      __Pyx_GIVEREF(__pyx_t_9);
      PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_15, __pyx_t_9);
      __Pyx_GIVEREF(__pyx_t_12);
      PyTuple_SET_ITEM(__pyx_t_14, 2+__pyx_t_15, __pyx_t_12);
      __Pyx_GIVEREF(__pyx_t_13);
      PyTuple_SET_ITEM(__pyx_t_14, 3+__pyx_t_15, __pyx_t_13);
      __Pyx_GIVEREF(__pyx_t_10);
      PyTuple_SET_ITEM(__pyx_t_14, 4+__pyx_t_15, __pyx_t_10);
      __pyx_t_8 = 0;
      __pyx_t_9 = 0;
      __pyx_t_12 = 0;
      __pyx_t_13 = 0;
      __pyx_t_10 = 0;
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_14, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1528, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_2) {
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1522, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_t_5};
        __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1522, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
        PyObject *__pyx_temp[2] = {__pyx_t_2, __pyx_t_5};
        __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1522, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else
      #endif
      {
        __pyx_t_14 = PyTuple_New(1+1); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 1522, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_2); __pyx_t_2 = NULL;
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_14, 0+1, __pyx_t_5);
        __pyx_t_5 = 0;
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_14, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1522, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __PYX_ERR(0, 1522, __pyx_L1_error)

    /* "typped/pratt_parser.py":1521
 * 
 *         # See if we reached the end of the token stream.
 *         if not self.lex.peek().is_end_token() and not partial_expressions:             # <<<<<<<<<<<<<<
 *             raise IncompleteParseException("Parsing never reached the end of"
 *                 " the text.  Parsing stopped with tokens still in the lexer."
 */
  }

  /* "typped/pratt_parser.py":1532
 *                         parse_tree.tree_repr()))
 * 
 *         if pstate:             # <<<<<<<<<<<<<<
 *             self.pstate_stack = []
 *         return parse_tree
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_pstate); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1532, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "typped/pratt_parser.py":1533
 * 
 *         if pstate:
 *             self.pstate_stack = []             # <<<<<<<<<<<<<<
 *         return parse_tree
 * 
 */
    __pyx_t_6 = PyList_New(0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1533, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_pstate_stack, __pyx_t_6) < 0) __PYX_ERR(0, 1533, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "typped/pratt_parser.py":1532
 *                         parse_tree.tree_repr()))
 * 
 *         if pstate:             # <<<<<<<<<<<<<<
 *             self.pstate_stack = []
 *         return parse_tree
 */
  }

  /* "typped/pratt_parser.py":1534
 *         if pstate:
 *             self.pstate_stack = []
 *         return parse_tree             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_parse_tree);
  __pyx_r = __pyx_v_parse_tree;
  goto __pyx_L0;

  /* "typped/pratt_parser.py":1480
 *         return parsed_subexpression
 * 
 *     def parse(self, program, pstate=None, partial_expressions=None,             # <<<<<<<<<<<<<<
 *                                                       skip_lex_setup=False):
 *         """The main routine for parsing a full program or expression.  Users of
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_AddTraceback("typped.pratt_parser.PrattParser.parse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_begin_tok);
  __Pyx_XDECREF(__pyx_v_parse_tree);
  __Pyx_XDECREF(__pyx_v_partial_expressions);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory[8];
static int __pyx_freecount_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory = 0;

static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory)))) {
    o = (PyObject*)__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory[--__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory];
    memset(o, 0, sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory(PyObject *o) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_TokenSubclass);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory)))) {
    __pyx_freelist_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory[__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory++] = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *)o;
  if (p->__pyx_v_TokenSubclass) {
    e = (*v)(p->__pyx_v_TokenSubclass, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory *)o;
  tmp = ((PyObject*)p->__pyx_v_TokenSubclass);
  p->__pyx_v_TokenSubclass = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory = {
  PyVarObject_HEAD_INIT(0, 0)
  "typped.pratt_parser.__pyx_scope_struct__token_subclass_factory", /*tp_name*/
  sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory, /*tp_traverse*/
  __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error[8];
static int __pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error = 0;

static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error)))) {
    o = (PyObject*)__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error[--__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error];
    memset(o, 0, sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error(PyObject *o) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_self);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error)))) {
    __pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error[__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error++] = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)o;
  if (p->__pyx_v_self) {
    e = (*v)(p->__pyx_v_self, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)o;
  tmp = ((PyObject*)p->__pyx_v_self);
  p->__pyx_v_self = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error = {
  PyVarObject_HEAD_INIT(0, 0)
  "typped.pratt_parser.__pyx_scope_struct_1__raise_type_mismatch_error", /*tp_name*/
  sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error, /*tp_traverse*/
  __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_2_genexpr[8];
static int __pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_2_genexpr = 0;

static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_2_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_2_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr)))) {
    o = (PyObject*)__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_2_genexpr[--__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_2_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_2_genexpr(PyObject *o) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_c);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_2_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr)))) {
    __pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_2_genexpr[__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_2_genexpr++] = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_2_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_c) {
    e = (*v)(p->__pyx_v_c, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_2_genexpr(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr *)o;
  tmp = ((PyObject*)p->__pyx_outer_scope);
  p->__pyx_outer_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_c);
  p->__pyx_v_c = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_6typped_12pratt_parser___pyx_scope_struct_2_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "typped.pratt_parser.__pyx_scope_struct_2_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_2_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_2_genexpr, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_2_genexpr, /*tp_traverse*/
  __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_2_genexpr, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_2_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_3_genexpr[8];
static int __pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_3_genexpr = 0;

static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_3_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_3_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr)))) {
    o = (PyObject*)__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_3_genexpr[--__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_3_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_3_genexpr(PyObject *o) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_c);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_3_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr)))) {
    __pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_3_genexpr[__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_3_genexpr++] = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_3_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_c) {
    e = (*v)(p->__pyx_v_c, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_3_genexpr(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr *)o;
  tmp = ((PyObject*)p->__pyx_outer_scope);
  p->__pyx_outer_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_c);
  p->__pyx_v_c = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_6typped_12pratt_parser___pyx_scope_struct_3_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "typped.pratt_parser.__pyx_scope_struct_3_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_3_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_3_genexpr, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_3_genexpr, /*tp_traverse*/
  __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_3_genexpr, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_3_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types[8];
static int __pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types = 0;

static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types)))) {
    o = (PyObject*)__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types[--__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types];
    memset(o, 0, sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types(PyObject *o) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_self);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types)))) {
    __pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types[__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types++] = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *)o;
  if (p->__pyx_v_self) {
    e = (*v)(p->__pyx_v_self, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *)o;
  tmp = ((PyObject*)p->__pyx_v_self);
  p->__pyx_v_self = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types = {
  PyVarObject_HEAD_INIT(0, 0)
  "typped.pratt_parser.__pyx_scope_struct_4_string_repr_with_types", /*tp_name*/
  sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types, /*tp_traverse*/
  __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_5_genexpr[8];
static int __pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_5_genexpr = 0;

static PyObject *__pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_5_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_5_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr)))) {
    o = (PyObject*)__pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_5_genexpr[--__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_5_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_5_genexpr(PyObject *o) {
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_c);
  Py_CLEAR(p->__pyx_t_0);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_5_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr)))) {
    __pyx_freelist_6typped_12pratt_parser___pyx_scope_struct_5_genexpr[__pyx_freecount_6typped_12pratt_parser___pyx_scope_struct_5_genexpr++] = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_5_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_c) {
    e = (*v)(p->__pyx_v_c, a); if (e) return e;
  }
  if (p->__pyx_t_0) {
    e = (*v)(p->__pyx_t_0, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_5_genexpr(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *p = (struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr *)o;
  tmp = ((PyObject*)p->__pyx_outer_scope);
  p->__pyx_outer_scope = ((struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_c);
  p->__pyx_v_c = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_t_0);
  p->__pyx_t_0 = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_6typped_12pratt_parser___pyx_scope_struct_5_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "typped.pratt_parser.__pyx_scope_struct_5_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_6typped_12pratt_parser___pyx_scope_struct_5_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6typped_12pratt_parser___pyx_scope_struct_5_genexpr, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_6typped_12pratt_parser___pyx_scope_struct_5_genexpr, /*tp_traverse*/
  __pyx_tp_clear_6typped_12pratt_parser___pyx_scope_struct_5_genexpr, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6typped_12pratt_parser___pyx_scope_struct_5_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "pratt_parser",
    __pyx_k_A_general_Pratt_parser_module_t, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_0___uniquelabel___1, __pyx_k_0___uniquelabel___1, sizeof(__pyx_k_0___uniquelabel___1), 0, 0, 1, 0},
  {&__pyx_kp_s_A_jop_token_is_already_defined_I, __pyx_k_A_jop_token_is_already_defined_I, sizeof(__pyx_k_A_jop_token_is_already_defined_I), 0, 0, 1, 0},
  {&__pyx_kp_s_A_null_string_token_is_already_d, __pyx_k_A_null_string_token_is_already_d, sizeof(__pyx_k_A_null_string_token_is_already_d), 0, 0, 1, 0},
  {&__pyx_kp_s_A_parser_object_Each_parser_obje, __pyx_k_A_parser_object_Each_parser_obje, sizeof(__pyx_k_A_parser_object_Each_parser_obje), 0, 0, 1, 0},
  {&__pyx_kp_s_A_trivial_metaclass_that_will_ac, __pyx_k_A_trivial_metaclass_that_will_ac, sizeof(__pyx_k_A_trivial_metaclass_that_will_ac), 0, 0, 1, 0},
  {&__pyx_kp_s_All_tokens_used_in_the_parser_mu, __pyx_k_All_tokens_used_in_the_parser_mu, sizeof(__pyx_k_All_tokens_used_in_the_parser_mu), 0, 0, 1, 0},
  {&__pyx_kp_s_Ambiguous_type_resolution_The_ac, __pyx_k_Ambiguous_type_resolution_The_ac, sizeof(__pyx_k_Ambiguous_type_resolution_The_ac), 0, 0, 1, 0},
  {&__pyx_kp_s_Ambiguous_type_resolution_second, __pyx_k_Ambiguous_type_resolution_second, sizeof(__pyx_k_Ambiguous_type_resolution_second), 0, 0, 1, 0},
  {&__pyx_kp_s_Attempt_to_define_a_construct_fo, __pyx_k_Attempt_to_define_a_construct_fo, sizeof(__pyx_k_Attempt_to_define_a_construct_fo), 0, 0, 1, 0},
  {&__pyx_kp_s_Attempt_to_define_a_construct_fo_2, __pyx_k_Attempt_to_define_a_construct_fo_2, sizeof(__pyx_k_Attempt_to_define_a_construct_fo_2), 0, 0, 1, 0},
  {&__pyx_kp_s_Bad_call_to_def_token_master_wit, __pyx_k_Bad_call_to_def_token_master_wit, sizeof(__pyx_k_Bad_call_to_def_token_master_wit), 0, 0, 1, 0},
  {&__pyx_kp_s_Call_to_def_construct_with_preco, __pyx_k_Call_to_def_construct_with_preco, sizeof(__pyx_k_Call_to_def_construct_with_preco), 0, 0, 1, 0},
  {&__pyx_n_s_CalledBeginTokenHandler, __pyx_k_CalledBeginTokenHandler, sizeof(__pyx_k_CalledBeginTokenHandler), 0, 0, 1, 1},
  {&__pyx_n_s_CalledEndTokenHandler, __pyx_k_CalledEndTokenHandler, sizeof(__pyx_k_CalledEndTokenHandler), 0, 0, 1, 1},
  {&__pyx_kp_s_Called_head_handler_for_begin_to, __pyx_k_Called_head_handler_for_begin_to, sizeof(__pyx_k_Called_head_handler_for_begin_to), 0, 0, 1, 0},
  {&__pyx_kp_s_Called_head_handler_for_end_toke, __pyx_k_Called_head_handler_for_end_toke, sizeof(__pyx_k_Called_head_handler_for_end_toke), 0, 0, 1, 0},
  {&__pyx_kp_s_Called_tail_handler_for_begin_to, __pyx_k_Called_tail_handler_for_begin_to, sizeof(__pyx_k_Called_tail_handler_for_begin_to), 0, 0, 1, 0},
  {&__pyx_kp_s_Called_tail_handler_for_end_toke, __pyx_k_Called_tail_handler_for_end_toke, sizeof(__pyx_k_Called_tail_handler_for_end_toke), 0, 0, 1, 0},
  {&__pyx_n_s_ConstructTable, __pyx_k_ConstructTable, sizeof(__pyx_k_ConstructTable), 0, 0, 1, 1},
  {&__pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_FUN, __pyx_k_DEFAULT_ALWAYS_TRUE_PRECOND_FUN, sizeof(__pyx_k_DEFAULT_ALWAYS_TRUE_PRECOND_FUN), 0, 0, 1, 1},
  {&__pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_LABE, __pyx_k_DEFAULT_ALWAYS_TRUE_PRECOND_LABE, sizeof(__pyx_k_DEFAULT_ALWAYS_TRUE_PRECOND_LABE), 0, 0, 1, 1},
  {&__pyx_n_s_DEFAULT_PRECOND_AUTOLABEL_PREFIX, __pyx_k_DEFAULT_PRECOND_AUTOLABEL_PREFIX, sizeof(__pyx_k_DEFAULT_PRECOND_AUTOLABEL_PREFIX), 0, 0, 1, 1},
  {&__pyx_kp_s_Error_in_parse_from_lexer_method, __pyx_k_Error_in_parse_from_lexer_method, sizeof(__pyx_k_Error_in_parse_from_lexer_method), 0, 0, 1, 0},
  {&__pyx_n_s_HEAD, __pyx_k_HEAD, sizeof(__pyx_k_HEAD), 0, 0, 1, 1},
  {&__pyx_n_s_IGNORED, __pyx_k_IGNORED, sizeof(__pyx_k_IGNORED), 0, 0, 1, 1},
  {&__pyx_kp_s_In_call_to_def_construct_subclas, __pyx_k_In_call_to_def_construct_subclas, sizeof(__pyx_k_In_call_to_def_construct_subclas), 0, 0, 1, 0},
  {&__pyx_n_s_IncompleteParseException, __pyx_k_IncompleteParseException, sizeof(__pyx_k_IncompleteParseException), 0, 0, 1, 1},
  {&__pyx_n_s_Lexer, __pyx_k_Lexer, sizeof(__pyx_k_Lexer), 0, 0, 1, 1},
  {&__pyx_n_s_NoHandlerFunctionDefined, __pyx_k_NoHandlerFunctionDefined, sizeof(__pyx_k_NoHandlerFunctionDefined), 0, 0, 1, 1},
  {&__pyx_n_s_Not, __pyx_k_Not, sizeof(__pyx_k_Not), 0, 0, 1, 1},
  {&__pyx_kp_s_Only_raised_at_the_end_of_the_Pr, __pyx_k_Only_raised_at_the_end_of_the_Pr, sizeof(__pyx_k_Only_raised_at_the_end_of_the_Pr), 0, 0, 1, 0},
  {&__pyx_n_s_ParserException, __pyx_k_ParserException, sizeof(__pyx_k_ParserException), 0, 0, 1, 1},
  {&__pyx_kp_s_Parsing_never_reached_the_end_of, __pyx_k_Parsing_never_reached_the_end_of, sizeof(__pyx_k_Parsing_never_reached_the_end_of), 0, 0, 1, 0},
  {&__pyx_n_s_PrattParser, __pyx_k_PrattParser, sizeof(__pyx_k_PrattParser), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser___init, __pyx_k_PrattParser___init, sizeof(__pyx_k_PrattParser___init), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser__next_unique_precond, __pyx_k_PrattParser__next_unique_precond, sizeof(__pyx_k_PrattParser__next_unique_precond), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_begin_end_tokens, __pyx_k_PrattParser_def_begin_end_tokens, sizeof(__pyx_k_PrattParser_def_begin_end_tokens), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_construct, __pyx_k_PrattParser_def_construct, sizeof(__pyx_k_PrattParser_def_construct), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_ignored_token, __pyx_k_PrattParser_def_ignored_token, sizeof(__pyx_k_PrattParser_def_ignored_token), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_jop_token, __pyx_k_PrattParser_def_jop_token, sizeof(__pyx_k_PrattParser_def_jop_token), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_null_string_toke, __pyx_k_PrattParser_def_null_string_toke, sizeof(__pyx_k_PrattParser_def_null_string_toke), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_token, __pyx_k_PrattParser_def_token, sizeof(__pyx_k_PrattParser_def_token), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_token_master, __pyx_k_PrattParser_def_token_master, sizeof(__pyx_k_PrattParser_def_token_master), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_token_master_loc, __pyx_k_PrattParser_def_token_master_loc, sizeof(__pyx_k_PrattParser_def_token_master_loc), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_token_master_loc_2, __pyx_k_PrattParser_def_token_master_loc_2, sizeof(__pyx_k_PrattParser_def_token_master_loc_2), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_token_master_loc_3, __pyx_k_PrattParser_def_token_master_loc_3, sizeof(__pyx_k_PrattParser_def_token_master_loc_3), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_token_master_loc_4, __pyx_k_PrattParser_def_token_master_loc_4, sizeof(__pyx_k_PrattParser_def_token_master_loc_4), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_def_type, __pyx_k_PrattParser_def_type, sizeof(__pyx_k_PrattParser_def_type), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_get_token, __pyx_k_PrattParser_get_token, sizeof(__pyx_k_PrattParser_get_token), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_parse, __pyx_k_PrattParser_parse, sizeof(__pyx_k_PrattParser_parse), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_parse_from_lexer, __pyx_k_PrattParser_parse_from_lexer, sizeof(__pyx_k_PrattParser_parse_from_lexer), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_undef_construct, __pyx_k_PrattParser_undef_construct, sizeof(__pyx_k_PrattParser_undef_construct), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_undef_token, __pyx_k_PrattParser_undef_token, sizeof(__pyx_k_PrattParser_undef_token), 0, 0, 1, 1},
  {&__pyx_n_s_PrattParser_undef_type, __pyx_k_PrattParser_undef_type, sizeof(__pyx_k_PrattParser_undef_type), 0, 0, 1, 1},
  {&__pyx_n_s_Prec, __pyx_k_Prec, sizeof(__pyx_k_Prec), 0, 0, 1, 1},
  {&__pyx_n_s_Repeat, __pyx_k_Repeat, sizeof(__pyx_k_Repeat), 0, 0, 1, 1},
  {&__pyx_n_s_TAIL, __pyx_k_TAIL, sizeof(__pyx_k_TAIL), 0, 0, 1, 1},
  {&__pyx_kp_s_The_arg_types_argument_to_token, __pyx_k_The_arg_types_argument_to_token, sizeof(__pyx_k_The_arg_types_argument_to_token), 0, 0, 1, 0},
  {&__pyx_kp_s_The_current_token_has_value_0_a, __pyx_k_The_current_token_has_value_0_a, sizeof(__pyx_k_The_current_token_has_value_0_a), 0, 0, 1, 0},
  {&__pyx_kp_s_The_factory_function_returns_thi, __pyx_k_The_factory_function_returns_thi, sizeof(__pyx_k_The_factory_function_returns_thi), 0, 0, 1, 0},
  {&__pyx_n_s_Tok, __pyx_k_Tok, sizeof(__pyx_k_Tok), 0, 0, 1, 1},
  {&__pyx_kp_s_TokenClass__0, __pyx_k_TokenClass__0, sizeof(__pyx_k_TokenClass__0), 0, 0, 1, 0},
  {&__pyx_n_s_TokenNode, __pyx_k_TokenNode, sizeof(__pyx_k_TokenNode), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclass, __pyx_k_TokenSubclass, sizeof(__pyx_k_TokenSubclass), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta, __pyx_k_TokenSubclassMeta, sizeof(__pyx_k_TokenSubclassMeta), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___add, __pyx_k_TokenSubclassMeta___add, sizeof(__pyx_k_TokenSubclassMeta___add), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___getitem, __pyx_k_TokenSubclassMeta___getitem, sizeof(__pyx_k_TokenSubclassMeta___getitem), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___invert, __pyx_k_TokenSubclassMeta___invert, sizeof(__pyx_k_TokenSubclassMeta___invert), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___new, __pyx_k_TokenSubclassMeta___new, sizeof(__pyx_k_TokenSubclassMeta___new), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___or, __pyx_k_TokenSubclassMeta___or, sizeof(__pyx_k_TokenSubclassMeta___or), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___radd, __pyx_k_TokenSubclassMeta___radd, sizeof(__pyx_k_TokenSubclassMeta___radd), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___repr, __pyx_k_TokenSubclassMeta___repr, sizeof(__pyx_k_TokenSubclassMeta___repr), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___rmul, __pyx_k_TokenSubclassMeta___rmul, sizeof(__pyx_k_TokenSubclassMeta___rmul), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___ror, __pyx_k_TokenSubclassMeta___ror, sizeof(__pyx_k_TokenSubclassMeta___ror), 0, 0, 1, 1},
  {&__pyx_n_s_TokenSubclassMeta___rpow, __pyx_k_TokenSubclassMeta___rpow, sizeof(__pyx_k_TokenSubclassMeta___rpow), 0, 0, 1, 1},
  {&__pyx_n_s_TokenTable, __pyx_k_TokenTable, sizeof(__pyx_k_TokenTable), 0, 0, 1, 1},
  {&__pyx_kp_s_Token_0, __pyx_k_Token_0, sizeof(__pyx_k_Token_0), 0, 0, 1, 0},
  {&__pyx_kp_s_Token_node_has_multiple_signatur, __pyx_k_Token_node_has_multiple_signatur, sizeof(__pyx_k_Token_node_has_multiple_signatur), 0, 0, 1, 0},
  {&__pyx_n_s_TypeErrorInParsedLanguage, __pyx_k_TypeErrorInParsedLanguage, sizeof(__pyx_k_TypeErrorInParsedLanguage), 0, 0, 1, 1},
  {&__pyx_n_s_TypeSig, __pyx_k_TypeSig, sizeof(__pyx_k_TypeSig), 0, 0, 1, 1},
  {&__pyx_n_s_TypeTable, __pyx_k_TypeTable, sizeof(__pyx_k_TypeTable), 0, 0, 1, 1},
  {&__pyx_n_s_Unresolved, __pyx_k_Unresolved, sizeof(__pyx_k_Unresolved), 0, 0, 1, 1},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_kp_s_Value_of_autolabel_prefix_value, __pyx_k_Value_of_autolabel_prefix_value, sizeof(__pyx_k_Value_of_autolabel_prefix_value), 0, 0, 1, 0},
  {&__pyx_kp_s__10, __pyx_k__10, sizeof(__pyx_k__10), 0, 0, 1, 0},
  {&__pyx_kp_s__11, __pyx_k__11, sizeof(__pyx_k__11), 0, 0, 1, 0},
  {&__pyx_kp_s__12, __pyx_k__12, sizeof(__pyx_k__12), 0, 0, 1, 0},
  {&__pyx_kp_s__13, __pyx_k__13, sizeof(__pyx_k__13), 0, 0, 1, 0},
  {&__pyx_kp_s__14, __pyx_k__14, sizeof(__pyx_k__14), 0, 0, 1, 0},
  {&__pyx_kp_s__15, __pyx_k__15, sizeof(__pyx_k__15), 0, 0, 1, 0},
  {&__pyx_kp_s__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 0, 1, 0},
  {&__pyx_kp_s__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 0, 1, 0},
  {&__pyx_kp_s__8, __pyx_k__8, sizeof(__pyx_k__8), 0, 0, 1, 0},
  {&__pyx_kp_s__9, __pyx_k__9, sizeof(__pyx_k__9), 0, 0, 1, 0},
  {&__pyx_n_s_actual_sig, __pyx_k_actual_sig, sizeof(__pyx_k_actual_sig), 0, 0, 1, 1},
  {&__pyx_n_s_add, __pyx_k_add, sizeof(__pyx_k_add), 0, 0, 1, 1},
  {&__pyx_n_s_all_handlers, __pyx_k_all_handlers, sizeof(__pyx_k_all_handlers), 0, 0, 1, 1},
  {&__pyx_n_s_all_possible_sigs, __pyx_k_all_possible_sigs, sizeof(__pyx_k_all_possible_sigs), 0, 0, 1, 1},
  {&__pyx_n_s_all_vals_override, __pyx_k_all_vals_override, sizeof(__pyx_k_all_vals_override), 0, 0, 1, 1},
  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
  {&__pyx_n_s_arg, __pyx_k_arg, sizeof(__pyx_k_arg), 0, 0, 1, 1},
  {&__pyx_n_s_arg_types, __pyx_k_arg_types, sizeof(__pyx_k_arg_types), 0, 0, 1, 1},
  {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
  {&__pyx_n_s_ast_data, __pyx_k_ast_data, sizeof(__pyx_k_ast_data), 0, 0, 1, 1},
  {&__pyx_n_s_autolabel_prefix, __pyx_k_autolabel_prefix, sizeof(__pyx_k_autolabel_prefix), 0, 0, 1, 1},
  {&__pyx_n_s_bases, __pyx_k_bases, sizeof(__pyx_k_bases), 0, 0, 1, 1},
  {&__pyx_n_s_basic_msg, __pyx_k_basic_msg, sizeof(__pyx_k_basic_msg), 0, 0, 1, 1},
  {&__pyx_n_s_begin, __pyx_k_begin, sizeof(__pyx_k_begin), 0, 0, 1, 1},
  {&__pyx_n_s_begin_head, __pyx_k_begin_head, sizeof(__pyx_k_begin_head), 0, 0, 1, 1},
  {&__pyx_n_s_begin_tail, __pyx_k_begin_tail, sizeof(__pyx_k_begin_tail), 0, 0, 1, 1},
  {&__pyx_n_s_begin_tok, __pyx_k_begin_tok, sizeof(__pyx_k_begin_tok), 0, 0, 1, 1},
  {&__pyx_n_s_begin_token_label, __pyx_k_begin_token_label, sizeof(__pyx_k_begin_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_begin_token_subclass, __pyx_k_begin_token_subclass, sizeof(__pyx_k_begin_token_subclass), 0, 0, 1, 1},
  {&__pyx_n_s_builtin_parse_methods, __pyx_k_builtin_parse_methods, sizeof(__pyx_k_builtin_parse_methods), 0, 0, 1, 1},
  {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
  {&__pyx_n_s_check_types_first_of_two_passes, __pyx_k_check_types_first_of_two_passes, sizeof(__pyx_k_check_types_first_of_two_passes), 0, 0, 1, 1},
  {&__pyx_n_s_check_types_in_tree_second_pass, __pyx_k_check_types_in_tree_second_pass, sizeof(__pyx_k_check_types_in_tree_second_pass), 0, 0, 1, 1},
  {&__pyx_n_s_check_types_one_pass, __pyx_k_check_types_one_pass, sizeof(__pyx_k_check_types_one_pass), 0, 0, 1, 1},
  {&__pyx_n_s_check_types_pass_two, __pyx_k_check_types_pass_two, sizeof(__pyx_k_check_types_pass_two), 0, 0, 1, 1},
  {&__pyx_n_s_child, __pyx_k_child, sizeof(__pyx_k_child), 0, 0, 1, 1},
  {&__pyx_n_s_children, __pyx_k_children, sizeof(__pyx_k_children), 0, 0, 1, 1},
  {&__pyx_n_s_class_repr, __pyx_k_class_repr, sizeof(__pyx_k_class_repr), 0, 0, 1, 1},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
  {&__pyx_n_s_cls, __pyx_k_cls, sizeof(__pyx_k_cls), 0, 0, 1, 1},
  {&__pyx_n_s_construct, __pyx_k_construct, sizeof(__pyx_k_construct), 0, 0, 1, 1},
  {&__pyx_n_s_construct_table, __pyx_k_construct_table, sizeof(__pyx_k_construct_table), 0, 0, 1, 1},
  {&__pyx_n_s_copy, __pyx_k_copy, sizeof(__pyx_k_copy), 0, 0, 1, 1},
  {&__pyx_n_s_copy_2, __pyx_k_copy_2, sizeof(__pyx_k_copy_2), 0, 0, 1, 1},
  {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
  {&__pyx_n_s_create_typeobject, __pyx_k_create_typeobject, sizeof(__pyx_k_create_typeobject), 0, 0, 1, 1},
  {&__pyx_n_s_curr_token, __pyx_k_curr_token, sizeof(__pyx_k_curr_token), 0, 0, 1, 1},
  {&__pyx_n_s_dct, __pyx_k_dct, sizeof(__pyx_k_dct), 0, 0, 1, 1},
  {&__pyx_n_s_def_begin_end_tokens, __pyx_k_def_begin_end_tokens, sizeof(__pyx_k_def_begin_end_tokens), 0, 0, 1, 1},
  {&__pyx_n_s_def_begin_token, __pyx_k_def_begin_token, sizeof(__pyx_k_def_begin_token), 0, 0, 1, 1},
  {&__pyx_n_s_def_construct, __pyx_k_def_construct, sizeof(__pyx_k_def_construct), 0, 0, 1, 1},
  {&__pyx_n_s_def_end_token, __pyx_k_def_end_token, sizeof(__pyx_k_def_end_token), 0, 0, 1, 1},
  {&__pyx_n_s_def_ignored_token, __pyx_k_def_ignored_token, sizeof(__pyx_k_def_ignored_token), 0, 0, 1, 1},
  {&__pyx_n_s_def_jop_token, __pyx_k_def_jop_token, sizeof(__pyx_k_def_jop_token), 0, 0, 1, 1},
  {&__pyx_n_s_def_null_string_token, __pyx_k_def_null_string_token, sizeof(__pyx_k_def_null_string_token), 0, 0, 1, 1},
  {&__pyx_n_s_def_token, __pyx_k_def_token, sizeof(__pyx_k_def_token), 0, 0, 1, 1},
  {&__pyx_n_s_def_token_master, __pyx_k_def_token_master, sizeof(__pyx_k_def_token_master), 0, 0, 1, 1},
  {&__pyx_n_s_def_type, __pyx_k_def_type, sizeof(__pyx_k_def_type), 0, 0, 1, 1},
  {&__pyx_n_s_default_always_true_precond, __pyx_k_default_always_true_precond, sizeof(__pyx_k_default_always_true_precond), 0, 0, 1, 1},
  {&__pyx_n_s_default_begin_end_tokens, __pyx_k_default_begin_end_tokens, sizeof(__pyx_k_default_begin_end_tokens), 0, 0, 1, 1},
  {&__pyx_n_s_default_helper_exception, __pyx_k_default_helper_exception, sizeof(__pyx_k_default_helper_exception), 0, 0, 1, 1},
  {&__pyx_n_s_default_precond_label_number, __pyx_k_default_precond_label_number, sizeof(__pyx_k_default_precond_label_number), 0, 0, 1, 1},
  {&__pyx_n_s_default_unique_precond_label, __pyx_k_default_unique_precond_label, sizeof(__pyx_k_default_unique_precond_label), 0, 0, 1, 1},
  {&__pyx_n_s_diagnostic, __pyx_k_diagnostic, sizeof(__pyx_k_diagnostic), 0, 0, 1, 1},
  {&__pyx_n_s_dispatch_handler, __pyx_k_dispatch_handler, sizeof(__pyx_k_dispatch_handler), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_dummy_handler, __pyx_k_dummy_handler, sizeof(__pyx_k_dummy_handler), 0, 0, 1, 1},
  {&__pyx_n_s_ebnf_classes_and_operators, __pyx_k_ebnf_classes_and_operators, sizeof(__pyx_k_ebnf_classes_and_operators), 0, 0, 1, 1},
  {&__pyx_n_s_end, __pyx_k_end, sizeof(__pyx_k_end), 0, 0, 1, 1},
  {&__pyx_n_s_end_head, __pyx_k_end_head, sizeof(__pyx_k_end_head), 0, 0, 1, 1},
  {&__pyx_n_s_end_tail, __pyx_k_end_tail, sizeof(__pyx_k_end_tail), 0, 0, 1, 1},
  {&__pyx_n_s_end_tok, __pyx_k_end_tok, sizeof(__pyx_k_end_tok), 0, 0, 1, 1},
  {&__pyx_n_s_end_token_label, __pyx_k_end_token_label, sizeof(__pyx_k_end_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_end_token_subclass, __pyx_k_end_token_subclass, sizeof(__pyx_k_end_token_subclass), 0, 0, 1, 1},
  {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
  {&__pyx_n_s_eval_fun, __pyx_k_eval_fun, sizeof(__pyx_k_eval_fun), 0, 0, 1, 1},
  {&__pyx_n_s_eval_subtree, __pyx_k_eval_subtree, sizeof(__pyx_k_eval_subtree), 0, 0, 1, 1},
  {&__pyx_n_s_expanded_formal_sig, __pyx_k_expanded_formal_sig, sizeof(__pyx_k_expanded_formal_sig), 0, 0, 1, 1},
  {&__pyx_n_s_file, __pyx_k_file, sizeof(__pyx_k_file), 0, 0, 1, 1},
  {&__pyx_n_s_final_mod_function, __pyx_k_final_mod_function, sizeof(__pyx_k_final_mod_function), 0, 0, 1, 1},
  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
  {&__pyx_n_s_genexpr, __pyx_k_genexpr, sizeof(__pyx_k_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_get_all_matching_expanded_sigs, __pyx_k_get_all_matching_expanded_sigs, sizeof(__pyx_k_get_all_matching_expanded_sigs), 0, 0, 1, 1},
  {&__pyx_n_s_get_ast_data, __pyx_k_get_ast_data, sizeof(__pyx_k_get_ast_data), 0, 0, 1, 1},
  {&__pyx_n_s_get_child_sigs_matching_return_a, __pyx_k_get_child_sigs_matching_return_a, sizeof(__pyx_k_get_child_sigs_matching_return_a), 0, 0, 1, 1},
  {&__pyx_n_s_get_eval_fun, __pyx_k_get_eval_fun, sizeof(__pyx_k_get_eval_fun), 0, 0, 1, 1},
  {&__pyx_n_s_get_jop_token_instance, __pyx_k_get_jop_token_instance, sizeof(__pyx_k_get_jop_token_instance), 0, 0, 1, 1},
  {&__pyx_n_s_get_null_string_token_and_handle, __pyx_k_get_null_string_token_and_handle, sizeof(__pyx_k_get_null_string_token_and_handle), 0, 0, 1, 1},
  {&__pyx_n_s_get_token, __pyx_k_get_token, sizeof(__pyx_k_get_token), 0, 0, 1, 1},
  {&__pyx_n_s_getitem, __pyx_k_getitem, sizeof(__pyx_k_getitem), 0, 0, 1, 1},
  {&__pyx_n_s_go_back, __pyx_k_go_back, sizeof(__pyx_k_go_back), 0, 0, 1, 1},
  {&__pyx_n_s_handler_fun, __pyx_k_handler_fun, sizeof(__pyx_k_handler_fun), 0, 0, 1, 1},
  {&__pyx_n_s_head_handler, __pyx_k_head_handler, sizeof(__pyx_k_head_handler), 0, 0, 1, 1},
  {&__pyx_n_s_head_or_tail, __pyx_k_head_or_tail, sizeof(__pyx_k_head_or_tail), 0, 0, 1, 1},
  {&__pyx_n_s_ignore, __pyx_k_ignore, sizeof(__pyx_k_ignore), 0, 0, 1, 1},
  {&__pyx_n_s_ignored, __pyx_k_ignored, sizeof(__pyx_k_ignored), 0, 0, 1, 1},
  {&__pyx_n_s_ignored_before_labels, __pyx_k_ignored_before_labels, sizeof(__pyx_k_ignored_before_labels), 0, 0, 1, 1},
  {&__pyx_n_s_ignored_token_label, __pyx_k_ignored_token_label, sizeof(__pyx_k_ignored_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_indent, __pyx_k_indent, sizeof(__pyx_k_indent), 0, 0, 1, 1},
  {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
  {&__pyx_n_s_invert, __pyx_k_invert, sizeof(__pyx_k_invert), 0, 0, 1, 1},
  {&__pyx_n_s_is_end_token, __pyx_k_is_end_token, sizeof(__pyx_k_is_end_token), 0, 0, 1, 1},
  {&__pyx_n_s_is_head, __pyx_k_is_head, sizeof(__pyx_k_is_head), 0, 0, 1, 1},
  {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
  {&__pyx_n_s_jop, __pyx_k_jop, sizeof(__pyx_k_jop), 0, 0, 1, 1},
  {&__pyx_n_s_jop_ignored_token_label, __pyx_k_jop_ignored_token_label, sizeof(__pyx_k_jop_ignored_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_jop_instance, __pyx_k_jop_instance, sizeof(__pyx_k_jop_instance), 0, 0, 1, 1},
  {&__pyx_n_s_jop_token_label, __pyx_k_jop_token_label, sizeof(__pyx_k_jop_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_jop_token_subclass, __pyx_k_jop_token_subclass, sizeof(__pyx_k_jop_token_subclass), 0, 0, 1, 1},
  {&__pyx_n_s_k_begin, __pyx_k_k_begin, sizeof(__pyx_k_k_begin), 0, 0, 1, 1},
  {&__pyx_n_s_k_end, __pyx_k_k_end, sizeof(__pyx_k_k_end), 0, 0, 1, 1},
  {&__pyx_kp_s_k_null_string, __pyx_k_k_null_string, sizeof(__pyx_k_k_null_string), 0, 0, 1, 0},
  {&__pyx_n_s_kind, __pyx_k_kind, sizeof(__pyx_k_kind), 0, 0, 1, 1},
  {&__pyx_n_s_label, __pyx_k_label, sizeof(__pyx_k_label), 0, 0, 1, 1},
  {&__pyx_n_s_left, __pyx_k_left, sizeof(__pyx_k_left), 0, 0, 1, 1},
  {&__pyx_n_s_left_other, __pyx_k_left_other, sizeof(__pyx_k_left_other), 0, 0, 1, 1},
  {&__pyx_n_s_lex, __pyx_k_lex, sizeof(__pyx_k_lex), 0, 0, 1, 1},
  {&__pyx_n_s_lexer, __pyx_k_lexer, sizeof(__pyx_k_lexer), 0, 0, 1, 1},
  {&__pyx_n_s_lexer_add_parser_instance_attrib, __pyx_k_lexer_add_parser_instance_attrib, sizeof(__pyx_k_lexer_add_parser_instance_attrib), 0, 0, 1, 1},
  {&__pyx_n_s_lexer_to_use, __pyx_k_lexer_to_use, sizeof(__pyx_k_lexer_to_use), 0, 0, 1, 1},
  {&__pyx_n_s_lexer_to_use_usual_table, __pyx_k_lexer_to_use_usual_table, sizeof(__pyx_k_lexer_to_use_usual_table), 0, 0, 1, 1},
  {&__pyx_n_s_list_of_child_sig_lists, __pyx_k_list_of_child_sig_lists, sizeof(__pyx_k_list_of_child_sig_lists), 0, 0, 1, 1},
  {&__pyx_n_s_lookbehind, __pyx_k_lookbehind, sizeof(__pyx_k_lookbehind), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_matched_sigs, __pyx_k_matched_sigs, sizeof(__pyx_k_matched_sigs), 0, 0, 1, 1},
  {&__pyx_n_s_matcher_options, __pyx_k_matcher_options, sizeof(__pyx_k_matcher_options), 0, 0, 1, 1},
  {&__pyx_n_s_matching_sigs, __pyx_k_matching_sigs, sizeof(__pyx_k_matching_sigs), 0, 0, 1, 1},
  {&__pyx_n_s_max_deque_size, __pyx_k_max_deque_size, sizeof(__pyx_k_max_deque_size), 0, 0, 1, 1},
  {&__pyx_n_s_max_peek_tokens, __pyx_k_max_peek_tokens, sizeof(__pyx_k_max_peek_tokens), 0, 0, 1, 1},
  {&__pyx_n_s_mcs, __pyx_k_mcs, sizeof(__pyx_k_mcs), 0, 0, 1, 1},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_method, __pyx_k_method, sizeof(__pyx_k_method), 0, 0, 1, 1},
  {&__pyx_n_s_modified_children, __pyx_k_modified_children, sizeof(__pyx_k_modified_children), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_nExactly, __pyx_k_nExactly, sizeof(__pyx_k_nExactly), 0, 0, 1, 1},
  {&__pyx_n_s_nOrMore, __pyx_k_nOrMore, sizeof(__pyx_k_nOrMore), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
  {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
  {&__pyx_n_s_new_class, __pyx_k_new_class, sizeof(__pyx_k_new_class), 0, 0, 1, 1},
  {&__pyx_n_s_next, __pyx_k_next, sizeof(__pyx_k_next), 0, 0, 1, 1},
  {&__pyx_n_s_next_unique_precond_label, __pyx_k_next_unique_precond_label, sizeof(__pyx_k_next_unique_precond_label), 0, 0, 1, 1},
  {&__pyx_n_s_not_in_tree, __pyx_k_not_in_tree, sizeof(__pyx_k_not_in_tree), 0, 0, 1, 1},
  {&__pyx_kp_s_null_string, __pyx_k_null_string, sizeof(__pyx_k_null_string), 0, 0, 1, 0},
  {&__pyx_n_s_null_string_ignored_token_label, __pyx_k_null_string_ignored_token_label, sizeof(__pyx_k_null_string_ignored_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_null_string_token, __pyx_k_null_string_token, sizeof(__pyx_k_null_string_token), 0, 0, 1, 1},
  {&__pyx_n_s_null_string_token_label, __pyx_k_null_string_token_label, sizeof(__pyx_k_null_string_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_null_string_token_subclass, __pyx_k_null_string_token_subclass, sizeof(__pyx_k_null_string_token_subclass), 0, 0, 1, 1},
  {&__pyx_n_s_num_indent, __pyx_k_num_indent, sizeof(__pyx_k_num_indent), 0, 0, 1, 1},
  {&__pyx_n_s_num_lookahead_tokens, __pyx_k_num_lookahead_tokens, sizeof(__pyx_k_num_lookahead_tokens), 0, 0, 1, 1},
  {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
  {&__pyx_n_s_on_ties, __pyx_k_on_ties, sizeof(__pyx_k_on_ties), 0, 0, 1, 1},
  {&__pyx_n_s_or, __pyx_k_or, sizeof(__pyx_k_or), 0, 0, 1, 1},
  {&__pyx_n_s_orig_sig, __pyx_k_orig_sig, sizeof(__pyx_k_orig_sig), 0, 0, 1, 1},
  {&__pyx_n_s_original_formal_sig, __pyx_k_original_formal_sig, sizeof(__pyx_k_original_formal_sig), 0, 0, 1, 1},
  {&__pyx_n_s_original_sigs, __pyx_k_original_sigs, sizeof(__pyx_k_original_sigs), 0, 0, 1, 1},
  {&__pyx_n_s_other, __pyx_k_other, sizeof(__pyx_k_other), 0, 0, 1, 1},
  {&__pyx_n_s_overload_on_arg_types, __pyx_k_overload_on_arg_types, sizeof(__pyx_k_overload_on_arg_types), 0, 0, 1, 1},
  {&__pyx_n_s_overload_on_ret_types, __pyx_k_overload_on_ret_types, sizeof(__pyx_k_overload_on_ret_types), 0, 0, 1, 1},
  {&__pyx_n_s_parent, __pyx_k_parent, sizeof(__pyx_k_parent), 0, 0, 1, 1},
  {&__pyx_n_s_parent_args_so_far, __pyx_k_parent_args_so_far, sizeof(__pyx_k_parent_args_so_far), 0, 0, 1, 1},
  {&__pyx_n_s_parse, __pyx_k_parse, sizeof(__pyx_k_parse), 0, 0, 1, 1},
  {&__pyx_n_s_parse_from_lexer, __pyx_k_parse_from_lexer, sizeof(__pyx_k_parse_from_lexer), 0, 0, 1, 1},
  {&__pyx_n_s_parse_methods, __pyx_k_parse_methods, sizeof(__pyx_k_parse_methods), 0, 0, 1, 1},
  {&__pyx_n_s_parse_tree, __pyx_k_parse_tree, sizeof(__pyx_k_parse_tree), 0, 0, 1, 1},
  {&__pyx_n_s_parsed_subexpression, __pyx_k_parsed_subexpression, sizeof(__pyx_k_parsed_subexpression), 0, 0, 1, 1},
  {&__pyx_n_s_parser_instance, __pyx_k_parser_instance, sizeof(__pyx_k_parser_instance), 0, 0, 1, 1},
  {&__pyx_n_s_partial_expressions, __pyx_k_partial_expressions, sizeof(__pyx_k_partial_expressions), 0, 0, 1, 1},
  {&__pyx_n_s_peek, __pyx_k_peek, sizeof(__pyx_k_peek), 0, 0, 1, 1},
  {&__pyx_n_s_peek_head_handler, __pyx_k_peek_head_handler, sizeof(__pyx_k_peek_head_handler), 0, 0, 1, 1},
  {&__pyx_n_s_peek_tail_handler, __pyx_k_peek_tail_handler, sizeof(__pyx_k_peek_tail_handler), 0, 0, 1, 1},
  {&__pyx_n_s_pratt_constructs, __pyx_k_pratt_constructs, sizeof(__pyx_k_pratt_constructs), 0, 0, 1, 1},
  {&__pyx_n_s_pratt_types, __pyx_k_pratt_types, sizeof(__pyx_k_pratt_types), 0, 0, 1, 1},
  {&__pyx_n_s_prec, __pyx_k_prec, sizeof(__pyx_k_prec), 0, 0, 1, 1},
  {&__pyx_n_s_precond_fun, __pyx_k_precond_fun, sizeof(__pyx_k_precond_fun), 0, 0, 1, 1},
  {&__pyx_n_s_precond_label, __pyx_k_precond_label, sizeof(__pyx_k_precond_label), 0, 0, 1, 1},
  {&__pyx_n_s_precond_priority, __pyx_k_precond_priority, sizeof(__pyx_k_precond_priority), 0, 0, 1, 1},
  {&__pyx_n_s_predefined_token_sets, __pyx_k_predefined_token_sets, sizeof(__pyx_k_predefined_token_sets), 0, 0, 1, 1},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_print, __pyx_k_print, sizeof(__pyx_k_print), 0, 0, 1, 1},
  {&__pyx_n_s_process_and_check_node, __pyx_k_process_and_check_node, sizeof(__pyx_k_process_and_check_node), 0, 0, 1, 1},
  {&__pyx_n_s_process_not_in_tree, __pyx_k_process_not_in_tree, sizeof(__pyx_k_process_not_in_tree), 0, 0, 1, 1},
  {&__pyx_n_s_processed_left, __pyx_k_processed_left, sizeof(__pyx_k_processed_left), 0, 0, 1, 1},
  {&__pyx_n_s_prod_rule_funs, __pyx_k_prod_rule_funs, sizeof(__pyx_k_prod_rule_funs), 0, 0, 1, 1},
  {&__pyx_n_s_program, __pyx_k_program, sizeof(__pyx_k_program), 0, 0, 1, 1},
  {&__pyx_n_s_property, __pyx_k_property, sizeof(__pyx_k_property), 0, 0, 1, 1},
  {&__pyx_n_s_pstate, __pyx_k_pstate, sizeof(__pyx_k_pstate), 0, 0, 1, 1},
  {&__pyx_n_s_pstate_stack, __pyx_k_pstate_stack, sizeof(__pyx_k_pstate_stack), 0, 0, 1, 1},
  {&__pyx_n_s_pytest_args, __pyx_k_pytest_args, sizeof(__pyx_k_pytest_args), 0, 0, 1, 1},
  {&__pyx_n_s_pytest_helper, __pyx_k_pytest_helper, sizeof(__pyx_k_pytest_helper), 0, 0, 1, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_s_radd, __pyx_k_radd, sizeof(__pyx_k_radd), 0, 0, 1, 1},
  {&__pyx_n_s_raise_on_equal_priority_preconds, __pyx_k_raise_on_equal_priority_preconds, sizeof(__pyx_k_raise_on_equal_priority_preconds), 0, 0, 1, 1},
  {&__pyx_n_s_raise_type_mismatch_error, __pyx_k_raise_type_mismatch_error, sizeof(__pyx_k_raise_type_mismatch_error), 0, 0, 1, 1},
  {&__pyx_n_s_recursive_parse, __pyx_k_recursive_parse, sizeof(__pyx_k_recursive_parse), 0, 0, 1, 1},
  {&__pyx_n_s_regex_string, __pyx_k_regex_string, sizeof(__pyx_k_regex_string), 0, 0, 1, 1},
  {&__pyx_n_s_register_construct, __pyx_k_register_construct, sizeof(__pyx_k_register_construct), 0, 0, 1, 1},
  {&__pyx_n_s_regular, __pyx_k_regular, sizeof(__pyx_k_regular), 0, 0, 1, 1},
  {&__pyx_n_s_repr, __pyx_k_repr, sizeof(__pyx_k_repr), 0, 0, 1, 1},
  {&__pyx_n_s_rmul, __pyx_k_rmul, sizeof(__pyx_k_rmul), 0, 0, 1, 1},
  {&__pyx_n_s_root, __pyx_k_root, sizeof(__pyx_k_root), 0, 0, 1, 1},
  {&__pyx_n_s_ror, __pyx_k_ror, sizeof(__pyx_k_ror), 0, 0, 1, 1},
  {&__pyx_n_s_rpow, __pyx_k_rpow, sizeof(__pyx_k_rpow), 0, 0, 1, 1},
  {&__pyx_n_s_s, __pyx_k_s, sizeof(__pyx_k_s), 0, 0, 1, 1},
  {&__pyx_n_s_saved_subexp_prec, __pyx_k_saved_subexp_prec, sizeof(__pyx_k_saved_subexp_prec), 0, 0, 1, 1},
  {&__pyx_n_s_script_run, __pyx_k_script_run, sizeof(__pyx_k_script_run), 0, 0, 1, 1},
  {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
  {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
  {&__pyx_n_s_set_text, __pyx_k_set_text, sizeof(__pyx_k_set_text), 0, 0, 1, 1},
  {&__pyx_n_s_set_token_table, __pyx_k_set_token_table, sizeof(__pyx_k_set_token_table), 0, 0, 1, 1},
  {&__pyx_n_s_shared_settings_and_exceptions, __pyx_k_shared_settings_and_exceptions, sizeof(__pyx_k_shared_settings_and_exceptions), 0, 0, 1, 1},
  {&__pyx_n_s_skip_lex_setup, __pyx_k_skip_lex_setup, sizeof(__pyx_k_skip_lex_setup), 0, 0, 1, 1},
  {&__pyx_n_s_skip_type_checking, __pyx_k_skip_type_checking, sizeof(__pyx_k_skip_type_checking), 0, 0, 1, 1},
  {&__pyx_kp_s_src_typped_pratt_parser_py, __pyx_k_src_typped_pratt_parser_py, sizeof(__pyx_k_src_typped_pratt_parser_py), 0, 0, 1, 0},
  {&__pyx_n_s_static_prec, __pyx_k_static_prec, sizeof(__pyx_k_static_prec), 0, 0, 1, 1},
  {&__pyx_n_s_stderr, __pyx_k_stderr, sizeof(__pyx_k_stderr), 0, 0, 1, 1},
  {&__pyx_n_s_string, __pyx_k_string, sizeof(__pyx_k_string), 0, 0, 1, 1},
  {&__pyx_n_s_string_prefix, __pyx_k_string_prefix, sizeof(__pyx_k_string_prefix), 0, 0, 1, 1},
  {&__pyx_n_s_string_repr_with_types, __pyx_k_string_repr_with_types, sizeof(__pyx_k_string_repr_with_types), 0, 0, 1, 1},
  {&__pyx_n_s_subexp_prec, __pyx_k_subexp_prec, sizeof(__pyx_k_subexp_prec), 0, 0, 1, 1},
  {&__pyx_n_s_summary_repr, __pyx_k_summary_repr, sizeof(__pyx_k_summary_repr), 0, 0, 1, 1},
  {&__pyx_n_s_summary_repr_with_types, __pyx_k_summary_repr_with_types, sizeof(__pyx_k_summary_repr_with_types), 0, 0, 1, 1},
  {&__pyx_n_s_super, __pyx_k_super, sizeof(__pyx_k_super), 0, 0, 1, 1},
  {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
  {&__pyx_n_s_tail_handler, __pyx_k_tail_handler, sizeof(__pyx_k_tail_handler), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_kp_s_test_test_basic_usage_section_e, __pyx_k_test_test_basic_usage_section_e, sizeof(__pyx_k_test_test_basic_usage_section_e), 0, 0, 1, 0},
  {&__pyx_kp_s_test_test_ebnf_classes_and_oper, __pyx_k_test_test_ebnf_classes_and_oper, sizeof(__pyx_k_test_test_ebnf_classes_and_oper), 0, 0, 1, 0},
  {&__pyx_kp_s_test_test_example_calculator_id, __pyx_k_test_test_example_calculator_id, sizeof(__pyx_k_test_test_example_calculator_id), 0, 0, 1, 0},
  {&__pyx_kp_s_test_test_example_calculator_py, __pyx_k_test_test_example_calculator_py, sizeof(__pyx_k_test_test_example_calculator_py), 0, 0, 1, 0},
  {&__pyx_kp_s_test_test_parser_called_from_pa, __pyx_k_test_test_parser_called_from_pa, sizeof(__pyx_k_test_test_parser_called_from_pa), 0, 0, 1, 0},
  {&__pyx_kp_s_test_test_pratt_parser_py, __pyx_k_test_test_pratt_parser_py, sizeof(__pyx_k_test_test_pratt_parser_py), 0, 0, 1, 0},
  {&__pyx_kp_s_test_test_pratt_types_py, __pyx_k_test_test_pratt_types_py, sizeof(__pyx_k_test_test_pratt_types_py), 0, 0, 1, 0},
  {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
  {&__pyx_n_s_tnode, __pyx_k_tnode, sizeof(__pyx_k_tnode), 0, 0, 1, 1},
  {&__pyx_n_s_tok, __pyx_k_tok, sizeof(__pyx_k_tok), 0, 0, 1, 1},
  {&__pyx_n_s_token, __pyx_k_token, sizeof(__pyx_k_token), 0, 0, 1, 1},
  {&__pyx_n_s_token_defining_methods, __pyx_k_token_defining_methods, sizeof(__pyx_k_token_defining_methods), 0, 0, 1, 1},
  {&__pyx_n_s_token_kind, __pyx_k_token_kind, sizeof(__pyx_k_token_kind), 0, 0, 1, 1},
  {&__pyx_n_s_token_label, __pyx_k_token_label, sizeof(__pyx_k_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass, __pyx_k_token_subclass, sizeof(__pyx_k_token_subclass), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory, __pyx_k_token_subclass_factory, sizeof(__pyx_k_token_subclass_factory), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_fun, __pyx_k_token_subclass_factory_fun, sizeof(__pyx_k_token_subclass_factory_fun), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To, __pyx_k_token_subclass_factory_locals_To, sizeof(__pyx_k_token_subclass_factory_locals_To), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_10, __pyx_k_token_subclass_factory_locals_To_10, sizeof(__pyx_k_token_subclass_factory_locals_To_10), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_11, __pyx_k_token_subclass_factory_locals_To_11, sizeof(__pyx_k_token_subclass_factory_locals_To_11), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_12, __pyx_k_token_subclass_factory_locals_To_12, sizeof(__pyx_k_token_subclass_factory_locals_To_12), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_13, __pyx_k_token_subclass_factory_locals_To_13, sizeof(__pyx_k_token_subclass_factory_locals_To_13), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_14, __pyx_k_token_subclass_factory_locals_To_14, sizeof(__pyx_k_token_subclass_factory_locals_To_14), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_15, __pyx_k_token_subclass_factory_locals_To_15, sizeof(__pyx_k_token_subclass_factory_locals_To_15), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_16, __pyx_k_token_subclass_factory_locals_To_16, sizeof(__pyx_k_token_subclass_factory_locals_To_16), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_17, __pyx_k_token_subclass_factory_locals_To_17, sizeof(__pyx_k_token_subclass_factory_locals_To_17), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_18, __pyx_k_token_subclass_factory_locals_To_18, sizeof(__pyx_k_token_subclass_factory_locals_To_18), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_19, __pyx_k_token_subclass_factory_locals_To_19, sizeof(__pyx_k_token_subclass_factory_locals_To_19), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_2, __pyx_k_token_subclass_factory_locals_To_2, sizeof(__pyx_k_token_subclass_factory_locals_To_2), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_20, __pyx_k_token_subclass_factory_locals_To_20, sizeof(__pyx_k_token_subclass_factory_locals_To_20), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_21, __pyx_k_token_subclass_factory_locals_To_21, sizeof(__pyx_k_token_subclass_factory_locals_To_21), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_22, __pyx_k_token_subclass_factory_locals_To_22, sizeof(__pyx_k_token_subclass_factory_locals_To_22), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_23, __pyx_k_token_subclass_factory_locals_To_23, sizeof(__pyx_k_token_subclass_factory_locals_To_23), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_24, __pyx_k_token_subclass_factory_locals_To_24, sizeof(__pyx_k_token_subclass_factory_locals_To_24), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_3, __pyx_k_token_subclass_factory_locals_To_3, sizeof(__pyx_k_token_subclass_factory_locals_To_3), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_4, __pyx_k_token_subclass_factory_locals_To_4, sizeof(__pyx_k_token_subclass_factory_locals_To_4), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_5, __pyx_k_token_subclass_factory_locals_To_5, sizeof(__pyx_k_token_subclass_factory_locals_To_5), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_6, __pyx_k_token_subclass_factory_locals_To_6, sizeof(__pyx_k_token_subclass_factory_locals_To_6), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_7, __pyx_k_token_subclass_factory_locals_To_7, sizeof(__pyx_k_token_subclass_factory_locals_To_7), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_8, __pyx_k_token_subclass_factory_locals_To_8, sizeof(__pyx_k_token_subclass_factory_locals_To_8), 0, 0, 1, 1},
  {&__pyx_n_s_token_subclass_factory_locals_To_9, __pyx_k_token_subclass_factory_locals_To_9, sizeof(__pyx_k_token_subclass_factory_locals_To_9), 0, 0, 1, 1},
  {&__pyx_n_s_token_table, __pyx_k_token_table, sizeof(__pyx_k_token_table), 0, 0, 1, 1},
  {&__pyx_n_s_top_level_production, __pyx_k_top_level_production, sizeof(__pyx_k_top_level_production), 0, 0, 1, 1},
  {&__pyx_n_s_tree_repr, __pyx_k_tree_repr, sizeof(__pyx_k_tree_repr), 0, 0, 1, 1},
  {&__pyx_n_s_tree_repr_with_types, __pyx_k_tree_repr_with_types, sizeof(__pyx_k_tree_repr_with_types), 0, 0, 1, 1},
  {&__pyx_n_s_trigger_token_label, __pyx_k_trigger_token_label, sizeof(__pyx_k_trigger_token_label), 0, 0, 1, 1},
  {&__pyx_n_s_type_label, __pyx_k_type_label, sizeof(__pyx_k_type_label), 0, 0, 1, 1},
  {&__pyx_n_s_type_sig, __pyx_k_type_sig, sizeof(__pyx_k_type_sig), 0, 0, 1, 1},
  {&__pyx_n_s_type_table, __pyx_k_type_table, sizeof(__pyx_k_type_table), 0, 0, 1, 1},
  {&__pyx_n_s_typesig_override, __pyx_k_typesig_override, sizeof(__pyx_k_typesig_override), 0, 0, 1, 1},
  {&__pyx_n_s_typped_pratt_parser, __pyx_k_typped_pratt_parser, sizeof(__pyx_k_typped_pratt_parser), 0, 0, 1, 1},
  {&__pyx_n_s_undef_construct, __pyx_k_undef_construct, sizeof(__pyx_k_undef_construct), 0, 0, 1, 1},
  {&__pyx_n_s_undef_token, __pyx_k_undef_token, sizeof(__pyx_k_undef_token), 0, 0, 1, 1},
  {&__pyx_n_s_undef_type, __pyx_k_undef_type, sizeof(__pyx_k_undef_type), 0, 0, 1, 1},
  {&__pyx_n_s_undef_typeobject, __pyx_k_undef_typeobject, sizeof(__pyx_k_undef_typeobject), 0, 0, 1, 1},
  {&__pyx_n_s_unregister_construct, __pyx_k_unregister_construct, sizeof(__pyx_k_unregister_construct), 0, 0, 1, 1},
  {&__pyx_n_s_unresolved_children, __pyx_k_unresolved_children, sizeof(__pyx_k_unresolved_children), 0, 0, 1, 1},
  {&__pyx_n_s_usual_lexer, __pyx_k_usual_lexer, sizeof(__pyx_k_usual_lexer), 0, 0, 1, 1},
  {&__pyx_kp_s_v, __pyx_k_v, sizeof(__pyx_k_v), 0, 0, 1, 0},
  {&__pyx_n_s_val_type, __pyx_k_val_type, sizeof(__pyx_k_val_type), 0, 0, 1, 1},
  {&__pyx_n_s_val_type_override, __pyx_k_val_type_override, sizeof(__pyx_k_val_type_override), 0, 0, 1, 1},
  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
  {&__pyx_n_s_value_key, __pyx_k_value_key, sizeof(__pyx_k_value_key), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_object = __Pyx_GetBuiltinName(__pyx_n_s_object); if (!__pyx_builtin_object) __PYX_ERR(0, 977, __pyx_L1_error)
  __pyx_builtin_super = __Pyx_GetBuiltinName(__pyx_n_s_super); if (!__pyx_builtin_super) __PYX_ERR(0, 277, __pyx_L1_error)
  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s_property); if (!__pyx_builtin_property) __PYX_ERR(0, 666, __pyx_L1_error)
  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(0, 624, __pyx_L1_error)
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 937, __pyx_L1_error)
  __pyx_builtin_print = __Pyx_GetBuiltinName(__pyx_n_s_print); if (!__pyx_builtin_print) __PYX_ERR(0, 1470, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "typped/pratt_parser.py":741
 *                 # lexer to dress it up more like a "real" token, with ignored_before
 *                 # and line numbers, etc. (without putting it in the buffer, of course).
 *                 jop_instance = parser_instance.jop_token_subclass(None)             # <<<<<<<<<<<<<<
 * 
 *                 # This is a little inefficient (since it uses a `go_back` call)
 */
  __pyx_tuple_ = PyTuple_Pack(1, Py_None); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 741, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "typped/pratt_parser.py":770
 *                     return None # No precondition matches, assume no jop.
 *                 finally:
 *                     lex.go_back(1)             # <<<<<<<<<<<<<<
 *             else:
 *                 return None
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_int_1); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 770, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_int_1); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 770, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "typped/pratt_parser.py":799
 *             # See if a null-string token is set and a handler matches preconds.
 *             if parser_instance.null_string_token_label:
 *                 null_string_token = parser_instance.null_string_token_subclass(None)             # <<<<<<<<<<<<<<
 *                 try:
 *                     handler_fun = null_string_token.dispatch_handler(
 */
  __pyx_tuple__4 = PyTuple_Pack(1, Py_None); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 799, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "typped/pratt_parser.py":860
 *             if not hasattr(self, "parser_instance"):
 *                 # This catches some cases of tokens defined via Lexer, not all.
 *                 raise ParserException("All tokens used in the parser must be"             # <<<<<<<<<<<<<<
 *                         " defined in via parser's methods, not the lexer's.")
 *             #parser_instance = self.parser_instance # If needed, avoid otherwise.
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_All_tokens_used_in_the_parser_mu); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 860, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "typped/pratt_parser.py":384
 *         #parser_instance = None # Set during parsing by recursive_parse. AVOID if not needed.
 * 
 *         def __init__(self, value):             # <<<<<<<<<<<<<<
 *             """Initialize an instance of the subclass for a token of the kind
 *             labeled with `token_label`.  The `value` is the actual parsed
 */
  __pyx_tuple__16 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_value); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 384, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);
  __pyx_codeobj__17 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__16, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_init, 384, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__17)) __PYX_ERR(0, 384, __pyx_L1_error)

  /* "typped/pratt_parser.py":410
 * 
 *         @classmethod
 *         def prec(cls):             # <<<<<<<<<<<<<<
 *             """Return the precedence for the token.  This is currently a static
 *             value for each type of token.  Later it may be dynamic value
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 410, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);
  __pyx_codeobj__19 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__18, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_prec, 410, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__19)) __PYX_ERR(0, 410, __pyx_L1_error)

  /* "typped/pratt_parser.py":417
 *             return cls.static_prec
 * 
 *         def dispatch_handler(self, head_or_tail, lex, left=None, lookbehind=None):             # <<<<<<<<<<<<<<
 *             """Dispatch a callable function what will work as a handler.  The
 *             function also does type-checking after running the defined handler."""
 */
  __pyx_tuple__20 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_head_or_tail, __pyx_n_s_lex, __pyx_n_s_left, __pyx_n_s_lookbehind); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);
  __pyx_codeobj__21 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_dispatch_handler, 417, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__21)) __PYX_ERR(0, 417, __pyx_L1_error)
  __pyx_tuple__22 = PyTuple_Pack(2, ((PyObject *)Py_None), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "typped/pratt_parser.py":423
 *                                         head_or_tail, self, lex, left, lookbehind)
 * 
 *         def process_not_in_tree(self):             # <<<<<<<<<<<<<<
 *             """Removes any immediate children which have `not_in_tree` set."""
 *             modified_children = []
 */
  __pyx_tuple__23 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_modified_children, __pyx_n_s_child); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 423, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);
  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_process_not_in_tree, 423, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(0, 423, __pyx_L1_error)

  /* "typped/pratt_parser.py":433
 *             self.children = modified_children
 * 
 *         def process_and_check_node(self, construct,             # <<<<<<<<<<<<<<
 *                                    val_type_override=None, all_vals_override=None,
 *                                    typesig_override=None):
 */
  __pyx_tuple__25 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_construct, __pyx_n_s_val_type_override, __pyx_n_s_all_vals_override, __pyx_n_s_typesig_override, __pyx_n_s_all_possible_sigs, __pyx_n_s_s); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);
  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_process_and_check_node, 433, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 433, __pyx_L1_error)
  __pyx_tuple__27 = PyTuple_Pack(3, ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "typped/pratt_parser.py":495
 *                 self.actual_sig = TypeSig(val_type_override, self.actual_sig.arg_types)
 * 
 *         def _check_types_one_pass(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to check
 *             the actual types against their signatures when overloading is only on
 */
  __pyx_tuple__28 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_all_possible_sigs, __pyx_n_s_list_of_child_sig_lists, __pyx_n_s_c); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 495, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);
  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_check_types_one_pass, 495, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(0, 495, __pyx_L1_error)

  /* "typped/pratt_parser.py":528
 *             delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_first_of_two_passes(self):             # <<<<<<<<<<<<<<
 *             """Utility function called from `process_and_check_node` to do the
 *             first pass in checking the actual types against their signatures.
 */
  __pyx_tuple__30 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_all_possible_sigs, __pyx_n_s_list_of_child_sig_lists, __pyx_n_s_c); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 528, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);
  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__30, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_check_types_first_of_two_passes, 528, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 528, __pyx_L1_error)

  /* "typped/pratt_parser.py":543
 *                                       tnode=self)
 * 
 *         def check_types_in_tree_second_pass(self, root=False):             # <<<<<<<<<<<<<<
 *             """Recursively run the second pass on the token subtree with the
 *             `self` node as the root.
 */
  __pyx_tuple__32 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_root, __pyx_n_s_unresolved_children, __pyx_n_s_child, __pyx_n_s_c); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 543, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);
  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__32, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_check_types_in_tree_second_pass, 543, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(0, 543, __pyx_L1_error)
  __pyx_tuple__34 = PyTuple_Pack(1, ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 543, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);

  /* "typped/pratt_parser.py":566
 *                 delattr(self, "all_possible_sigs")
 * 
 *         def _check_types_pass_two(self):             # <<<<<<<<<<<<<<
 *             """A second pass is only used when overloading on return types is
 *             allowed.  It is a top-down pass where each node chooses a unique
 */
  __pyx_tuple__35 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_parent_args_so_far, __pyx_n_s_count, __pyx_n_s_child, __pyx_n_s_matched_sigs); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 566, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__35);
  __Pyx_GIVEREF(__pyx_tuple__35);
  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_check_types_pass_two, 566, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 566, __pyx_L1_error)

  /* "typped/pratt_parser.py":642
 *             return
 * 
 *         def _raise_type_mismatch_error(self, matching_sigs, basic_msg):             # <<<<<<<<<<<<<<
 *             """Raise an error, printing a helpful diagnostic message.  Assumes
 *             that `_check_types` has been called (to set `self.all_possible_sigs`)."""
 */
  __pyx_tuple__37 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_matching_sigs, __pyx_n_s_basic_msg, __pyx_n_s_diagnostic, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__37);
  __Pyx_GIVEREF(__pyx_tuple__37);
  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(3, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_raise_type_mismatch_error, 642, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 642, __pyx_L1_error)

  /* "typped/pratt_parser.py":667
 * 
 *         @property
 *         def eval_fun(self):             # <<<<<<<<<<<<<<
 *             """Return the evaluation function saved by `_save_eval_fun_and_ast_data`.
 *             Must be called after parsing because the `original_formal_sig` attribute
 */
  __pyx_tuple__39 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_orig_sig); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 667, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__39);
  __Pyx_GIVEREF(__pyx_tuple__39);
  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_eval_fun, 667, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 667, __pyx_L1_error)

  /* "typped/pratt_parser.py":675
 * 
 *         @property
 *         def ast_data(self):             # <<<<<<<<<<<<<<
 *             """Return the ast data saved by `_save_ast_data_and_ast_data`.
 *             Must be called after parsing because the `precond_label` attribute must
 */
  __pyx_tuple__41 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_orig_sig); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 675, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__41);
  __Pyx_GIVEREF(__pyx_tuple__41);
  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_ast_data, 675, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 675, __pyx_L1_error)

  /* "typped/pratt_parser.py":682
 *             return self.parser_instance.construct_table.get_ast_data(orig_sig, self)
 * 
 *         def eval_subtree(self):             # <<<<<<<<<<<<<<
 *             """Run the saved evaluation function on the token, if one was
 *             registered with it.  Returns `None` if no evaluation function is found."""
 */
  __pyx_tuple__43 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_orig_sig, __pyx_n_s_eval_fun); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 682, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__43);
  __Pyx_GIVEREF(__pyx_tuple__43);
  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_eval_subtree, 682, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(0, 682, __pyx_L1_error)

  /* "typped/pratt_parser.py":710
 *         #
 * 
 *         def get_jop_token_instance(self, lex, processed_left, lookbehind, subexp_prec):             # <<<<<<<<<<<<<<
 *             """Returns an instance of the jop token iff one should be inferred in the
 *             current context; otherwise returns `None`."""
 */
  __pyx_tuple__45 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_lex, __pyx_n_s_processed_left, __pyx_n_s_lookbehind, __pyx_n_s_subexp_prec, __pyx_n_s_parser_instance, __pyx_n_s_jop_instance, __pyx_n_s_curr_token, __pyx_n_s_peek_head_handler, __pyx_n_s_peek_tail_handler); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 710, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);
  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(5, 0, 10, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_get_jop_token_instance, 710, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(0, 710, __pyx_L1_error)

  /* "typped/pratt_parser.py":774
 *                 return None
 * 
 *         def get_null_string_token_and_handler(self, head_or_tail, lex, subexp_prec,             # <<<<<<<<<<<<<<
 *                                          processed_left=None, lookbehind=None):
 *             """Check for any possible matching null-string token handlers;
 */
  __pyx_tuple__47 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_head_or_tail, __pyx_n_s_lex, __pyx_n_s_subexp_prec, __pyx_n_s_processed_left, __pyx_n_s_lookbehind, __pyx_n_s_parser_instance, __pyx_n_s_curr_token, __pyx_n_s_handler_fun, __pyx_n_s_null_string_token); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 774, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);
  __pyx_codeobj__48 = (PyObject*)__Pyx_PyCode_New(6, 0, 10, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__47, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_get_null_string_token_and_handle, 774, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__48)) __PYX_ERR(0, 774, __pyx_L1_error)
  __pyx_tuple__49 = PyTuple_Pack(2, ((PyObject *)Py_None), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(0, 774, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__49);
  __Pyx_GIVEREF(__pyx_tuple__49);

  /* "typped/pratt_parser.py":812
 *             return curr_token, handler_fun
 * 
 *         def recursive_parse(self, subexp_prec,             # <<<<<<<<<<<<<<
 *                             # Below parameters ONLY used in null-string handler funs.
 *                             processed_left=None, lookbehind=None):
 */
  __pyx_tuple__50 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_subexp_prec, __pyx_n_s_processed_left, __pyx_n_s_lookbehind, __pyx_n_s_lex, __pyx_n_s_curr_token, __pyx_n_s_head_handler, __pyx_n_s_tail_handler, __pyx_n_s_jop_instance); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);
  __pyx_codeobj__51 = (PyObject*)__Pyx_PyCode_New(4, 0, 9, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__50, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_recursive_parse, 812, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__51)) __PYX_ERR(0, 812, __pyx_L1_error)
  __pyx_tuple__52 = PyTuple_Pack(2, ((PyObject *)Py_None), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 812, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);

  /* "typped/pratt_parser.py":915
 *         #
 * 
 *         def __copy__(self):             # <<<<<<<<<<<<<<
 *             """Return a shallow copy of the token."""
 *             return copy.copy(self)
 */
  __pyx_tuple__53 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 915, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);
  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_copy_2, 915, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(0, 915, __pyx_L1_error)

  /* "typped/pratt_parser.py":923
 *         #
 * 
 *         def summary_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A short summary repr of the node, without its children."""
 *             return ("<" + str(self.token_label) +
 */
  __pyx_tuple__55 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 923, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);
  __pyx_codeobj__56 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__55, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_summary_repr_with_types, 923, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__56)) __PYX_ERR(0, 923, __pyx_L1_error)

  /* "typped/pratt_parser.py":929
 *                     "'," + str(self.expanded_formal_sig.val_type) + ">")
 * 
 *         def tree_repr_with_types(self, indent=""):             # <<<<<<<<<<<<<<
 *             """Token representation as the root of a parse subtree, with formatting.
 *             The optional `indent` parameter can be either an indent string or else
 */
  __pyx_tuple__57 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_indent, __pyx_n_s_num_indent, __pyx_n_s_string, __pyx_n_s_c); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 929, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);
  __pyx_codeobj__58 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__57, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_tree_repr_with_types, 929, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__58)) __PYX_ERR(0, 929, __pyx_L1_error)
  __pyx_tuple__59 = PyTuple_Pack(1, ((PyObject*)__pyx_kp_s__10)); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 929, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);

  /* "typped/pratt_parser.py":946
 *             return string
 * 
 *         def string_repr_with_types(self):             # <<<<<<<<<<<<<<
 *             """A string repr for the tree that includes type information."""
 *             string = self.summary_repr_with_types()
 */
  __pyx_tuple__60 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_string, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__60)) __PYX_ERR(0, 946, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__60);
  __Pyx_GIVEREF(__pyx_tuple__60);
  __pyx_codeobj__61 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__60, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_string_repr_with_types, 946, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__61)) __PYX_ERR(0, 946, __pyx_L1_error)

  /* "typped/pratt_parser.py":956
 * 
 *         @classmethod
 *         def class_repr(cls):             # <<<<<<<<<<<<<<
 *             """Print out the `TokenSubclass` classes (representing tokens) in a
 *             nice way.  The default is hard to read."""
 */
  __pyx_tuple__62 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_string); if (unlikely(!__pyx_tuple__62)) __PYX_ERR(0, 956, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__62);
  __Pyx_GIVEREF(__pyx_tuple__62);
  __pyx_codeobj__63 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__62, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_class_repr, 956, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__63)) __PYX_ERR(0, 956, __pyx_L1_error)

  /* "typped/pratt_parser.py":1151
 *             def begin_head(self, lex):
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")             # <<<<<<<<<<<<<<
 *             def begin_tail(self, lex, left):
 *                 """Dummy tail-handler for begin-tokens."""
 */
  __pyx_tuple__64 = PyTuple_Pack(1, __pyx_kp_s_Called_head_handler_for_begin_to); if (unlikely(!__pyx_tuple__64)) __PYX_ERR(0, 1151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__64);
  __Pyx_GIVEREF(__pyx_tuple__64);

  /* "typped/pratt_parser.py":1154
 *             def begin_tail(self, lex, left):
 *                 """Dummy tail-handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")             # <<<<<<<<<<<<<<
 *             self.def_construct(HEAD, begin_head, token_label)
 *             self.def_construct(TAIL, begin_tail, token_label, dummy_handler=True)
 */
  __pyx_tuple__65 = PyTuple_Pack(1, __pyx_kp_s_Called_tail_handler_for_begin_to); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 1154, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);

  /* "typped/pratt_parser.py":1165
 *             def end_head(self, lex):
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")             # <<<<<<<<<<<<<<
 *             def end_tail(self, lex, left):
 *                 """Dummy tail-handler for end-tokens."""
 */
  __pyx_tuple__66 = PyTuple_Pack(1, __pyx_kp_s_Called_head_handler_for_end_toke); if (unlikely(!__pyx_tuple__66)) __PYX_ERR(0, 1165, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);

  /* "typped/pratt_parser.py":1168
 *             def end_tail(self, lex, left):
 *                 """Dummy tail-handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")             # <<<<<<<<<<<<<<
 *             self.def_construct(HEAD, end_head, token_label)
 *             self.def_construct(TAIL, end_tail, token_label, dummy_handler=True)
 */
  __pyx_tuple__67 = PyTuple_Pack(1, __pyx_kp_s_Called_tail_handler_for_end_toke); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 1168, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);

  /* "typped/pratt_parser.py":1149
 *             self.begin_token_label = token_label
 *             # Define dummy handlers for the begin-token, just to catch errors.
 *             def begin_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 */
  __pyx_tuple__68 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_lex); if (unlikely(!__pyx_tuple__68)) __PYX_ERR(0, 1149, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__68);
  __Pyx_GIVEREF(__pyx_tuple__68);
  __pyx_codeobj__69 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__68, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_begin_head, 1149, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__69)) __PYX_ERR(0, 1149, __pyx_L1_error)

  /* "typped/pratt_parser.py":1152
 *                 """Dummy head handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called head-handler for begin token.")
 *             def begin_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for begin-tokens."""
 *                 raise CalledBeginTokenHandler("Called tail-handler for begin token.")
 */
  __pyx_tuple__70 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_lex, __pyx_n_s_left); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 1152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__70);
  __Pyx_GIVEREF(__pyx_tuple__70);
  __pyx_codeobj__71 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__70, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_begin_tail, 1152, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__71)) __PYX_ERR(0, 1152, __pyx_L1_error)

  /* "typped/pratt_parser.py":1163
 *             self.end_token_label = token_label
 *             # Define dummy handlers for the end-token, just to catch errors.
 *             def end_head(self, lex):             # <<<<<<<<<<<<<<
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 */
  __pyx_tuple__72 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_lex); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 1163, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__72);
  __Pyx_GIVEREF(__pyx_tuple__72);
  __pyx_codeobj__73 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__72, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_end_head, 1163, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__73)) __PYX_ERR(0, 1163, __pyx_L1_error)

  /* "typped/pratt_parser.py":1166
 *                 """Dummy head handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called head-handler for end token.")
 *             def end_tail(self, lex, left):             # <<<<<<<<<<<<<<
 *                 """Dummy tail-handler for end-tokens."""
 *                 raise CalledEndTokenHandler("Called tail-handler for end token.")
 */
  __pyx_tuple__74 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_lex, __pyx_n_s_left); if (unlikely(!__pyx_tuple__74)) __PYX_ERR(0, 1166, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__74);
  __Pyx_GIVEREF(__pyx_tuple__74);
  __pyx_codeobj__75 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__74, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_end_tail, 1166, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__75)) __PYX_ERR(0, 1166, __pyx_L1_error)

  /* "typped/pratt_parser.py":1175
 *         elif token_kind == "jop":
 *             if self.jop_token_subclass:
 *                 raise ParserException("A jop token is already defined.  It must be "             # <<<<<<<<<<<<<<
 *                                       "undefined before defining a new one.")
 *             self.jop_token_label = token_label
 */
  __pyx_tuple__76 = PyTuple_Pack(1, __pyx_kp_s_A_jop_token_is_already_defined_I); if (unlikely(!__pyx_tuple__76)) __PYX_ERR(0, 1175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__76);
  __Pyx_GIVEREF(__pyx_tuple__76);

  /* "typped/pratt_parser.py":1185
 *         elif token_kind == "null-string":
 *             if self.null_string_token_subclass:
 *                 raise ParserException("A null-string token is already defined.  It"             # <<<<<<<<<<<<<<
 *                          " must be undefined before defining an new one.")
 *             self.null_string_token_label = token_label
 */
  __pyx_tuple__77 = PyTuple_Pack(1, __pyx_kp_s_A_null_string_token_is_already_d); if (unlikely(!__pyx_tuple__77)) __PYX_ERR(0, 1185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__77);
  __Pyx_GIVEREF(__pyx_tuple__77);

  /* "typped/pratt_parser.py":1352
 * 
 *         if isinstance(arg_types, str):
 *             raise ParserException("The arg_types argument to token_subclass must"             # <<<<<<<<<<<<<<
 *                     " be None or an iterable returning type labels (e.g., a list"
 *                     " or tuple).")
 */
  __pyx_tuple__78 = PyTuple_Pack(1, __pyx_kp_s_The_arg_types_argument_to_token); if (unlikely(!__pyx_tuple__78)) __PYX_ERR(0, 1352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__78);
  __Pyx_GIVEREF(__pyx_tuple__78);

  /* "typped/pratt_parser.py":1466
 * 
 *         try:
 *             parsed_subexpression = self.parse("IGNORED", pstate=pstate,             # <<<<<<<<<<<<<<
 *                                     partial_expressions=True,
 *                                     skip_lex_setup=True)
 */
  __pyx_tuple__79 = PyTuple_Pack(1, __pyx_n_s_IGNORED); if (unlikely(!__pyx_tuple__79)) __PYX_ERR(0, 1466, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__79);
  __Pyx_GIVEREF(__pyx_tuple__79);

  /* "typped/pratt_parser.py":1470
 *                                     skip_lex_setup=True)
 *         except ParserException:
 *             print("Error in `parse_from_lexer` method, in call to `parse` method"             # <<<<<<<<<<<<<<
 *                     " using a different parser's lexer for a subexpression.",
 *                     file=sys.stderr)
 */
  __pyx_tuple__80 = PyTuple_Pack(1, __pyx_kp_s_Error_in_parse_from_lexer_method); if (unlikely(!__pyx_tuple__80)) __PYX_ERR(0, 1470, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__80);
  __Pyx_GIVEREF(__pyx_tuple__80);

  /* "typped/pratt_parser.py":1514
 *             self.lex.set_text(program)
 *         begin_tok = self.lex.token # Get the first token to access recursive_parse.
 *         parse_tree = begin_tok.recursive_parse(0)             # <<<<<<<<<<<<<<
 * 
 *         # Finalize type-checking for root when overloading on return types.
 */
  __pyx_tuple__81 = PyTuple_Pack(1, __pyx_int_0); if (unlikely(!__pyx_tuple__81)) __PYX_ERR(0, 1514, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__81);
  __Pyx_GIVEREF(__pyx_tuple__81);

  /* "typped/pratt_parser.py":244
 * DEFAULT_ALWAYS_TRUE_PRECOND_LABEL = "default_always_true_precond"
 * 
 * def DEFAULT_ALWAYS_TRUE_PRECOND_FUN(lex, lookbehind):             # <<<<<<<<<<<<<<
 *     """The default precondition function; always returns true."""
 *     return True
 */
  __pyx_tuple__82 = PyTuple_Pack(2, __pyx_n_s_lex, __pyx_n_s_lookbehind); if (unlikely(!__pyx_tuple__82)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__82);
  __Pyx_GIVEREF(__pyx_tuple__82);
  __pyx_codeobj__83 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__82, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_FUN, 244, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__83)) __PYX_ERR(0, 244, __pyx_L1_error)

  /* "typped/pratt_parser.py":276
 *     ugly for tokens) and to overload operators to work for token operands
 *     in the EBNF-like grammar."""
 *     def __new__(mcs, name, bases, dct):             # <<<<<<<<<<<<<<
 *         new_class = super(TokenSubclassMeta, mcs).__new__(mcs, name, bases, dct)
 * 
 */
  __pyx_tuple__84 = PyTuple_Pack(11, __pyx_n_s_mcs, __pyx_n_s_name, __pyx_n_s_bases, __pyx_n_s_dct, __pyx_n_s_new_class, __pyx_n_s_Tok, __pyx_n_s_Not, __pyx_n_s_Prec, __pyx_n_s_nExactly, __pyx_n_s_nOrMore, __pyx_n_s_Repeat); if (unlikely(!__pyx_tuple__84)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__84);
  __Pyx_GIVEREF(__pyx_tuple__84);
  __pyx_codeobj__85 = (PyObject*)__Pyx_PyCode_New(4, 0, 11, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__84, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_new, 276, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__85)) __PYX_ERR(0, 276, __pyx_L1_error)

  /* "typped/pratt_parser.py":301
 *     #
 * 
 *     def __repr__(cls):             # <<<<<<<<<<<<<<
 *         """The representation for tokens.  Tokens are commonly used in the
 *         code but, being classes, have an ugly default `__repr__` when printed out.
 */
  __pyx_tuple__86 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_string); if (unlikely(!__pyx_tuple__86)) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__86);
  __Pyx_GIVEREF(__pyx_tuple__86);
  __pyx_codeobj__87 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__86, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_repr, 301, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__87)) __PYX_ERR(0, 301, __pyx_L1_error)

  /* "typped/pratt_parser.py":321
 *     # should catch most accidentals just because of that.
 * 
 *     def __add__(cls, other):             # <<<<<<<<<<<<<<
 *         """Addition of two tokens is defined to simply return a tuple of
 *         both tokens.  This is so raw tokens can be used in the operator
 */
  __pyx_tuple__88 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_other); if (unlikely(!__pyx_tuple__88)) __PYX_ERR(0, 321, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__88);
  __Pyx_GIVEREF(__pyx_tuple__88);
  __pyx_codeobj__89 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__88, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_add, 321, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__89)) __PYX_ERR(0, 321, __pyx_L1_error)

  /* "typped/pratt_parser.py":327
 *         return cls.prod_rule_funs["Tok"](cls) + other
 * 
 *     def __radd__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__add__` above."""
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 */
  __pyx_tuple__90 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_left_other); if (unlikely(!__pyx_tuple__90)) __PYX_ERR(0, 327, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__90);
  __Pyx_GIVEREF(__pyx_tuple__90);
  __pyx_codeobj__91 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__90, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_radd, 327, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__91)) __PYX_ERR(0, 327, __pyx_L1_error)

  /* "typped/pratt_parser.py":331
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __or__(cls, other):             # <<<<<<<<<<<<<<
 *         """The `|` symbol simply converts this object into an `ItemList`
 *         and then calls `__or__` for those objects."""
 */
  __pyx_tuple__92 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_other); if (unlikely(!__pyx_tuple__92)) __PYX_ERR(0, 331, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__92);
  __Pyx_GIVEREF(__pyx_tuple__92);
  __pyx_codeobj__93 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__92, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_or, 331, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__93)) __PYX_ERR(0, 331, __pyx_L1_error)

  /* "typped/pratt_parser.py":336
 *         return cls.prod_rule_funs["Tok"](cls) | other
 * 
 *     def __ror__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__or__` above."""
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 */
  __pyx_tuple__94 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_left_other); if (unlikely(!__pyx_tuple__94)) __PYX_ERR(0, 336, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__94);
  __Pyx_GIVEREF(__pyx_tuple__94);
  __pyx_codeobj__95 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__94, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_ror, 336, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__95)) __PYX_ERR(0, 336, __pyx_L1_error)

  /* "typped/pratt_parser.py":340
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __rmul__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n*token` for an int `n` is "n occurrences of"
 *         `token`."""
 */
  __pyx_tuple__96 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_left_other); if (unlikely(!__pyx_tuple__96)) __PYX_ERR(0, 340, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__96);
  __Pyx_GIVEREF(__pyx_tuple__96);
  __pyx_codeobj__97 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__96, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_rmul, 340, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__97)) __PYX_ERR(0, 340, __pyx_L1_error)

  /* "typped/pratt_parser.py":345
 *         return cls.prod_rule_funs["Repeat"](left_other, cls)
 * 
 *     def __rpow__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n**token` for an int `n` is "n or more occurrences of"
 *         `token`."""
 */
  __pyx_tuple__98 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_left_other); if (unlikely(!__pyx_tuple__98)) __PYX_ERR(0, 345, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__98);
  __Pyx_GIVEREF(__pyx_tuple__98);
  __pyx_codeobj__99 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__98, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_rpow, 345, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__99)) __PYX_ERR(0, 345, __pyx_L1_error)

  /* "typped/pratt_parser.py":350
 *         return cls.prod_rule_funs["nOrMore"](left_other, cls)
 * 
 *     def __invert__(cls):             # <<<<<<<<<<<<<<
 *         """Define the `~` operator for production rule grammars."""
 *         return cls.prod_rule_funs["Not"](cls)
 */
  __pyx_tuple__100 = PyTuple_Pack(1, __pyx_n_s_cls); if (unlikely(!__pyx_tuple__100)) __PYX_ERR(0, 350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__100);
  __Pyx_GIVEREF(__pyx_tuple__100);
  __pyx_codeobj__101 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__100, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_invert, 350, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__101)) __PYX_ERR(0, 350, __pyx_L1_error)

  /* "typped/pratt_parser.py":354
 *         return cls.prod_rule_funs["Not"](cls)
 * 
 *     def __getitem__(cls, arg):             # <<<<<<<<<<<<<<
 *         """Define the bracket indexing operator for production rule grammars
 *         to set the precedence."""
 */
  __pyx_tuple__102 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_arg); if (unlikely(!__pyx_tuple__102)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__102);
  __Pyx_GIVEREF(__pyx_tuple__102);
  __pyx_codeobj__103 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__102, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_getitem, 354, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__103)) __PYX_ERR(0, 354, __pyx_L1_error)

  /* "typped/pratt_parser.py":359
 *         return cls.prod_rule_funs["Prec"](cls, arg)
 * 
 * def token_subclass_factory():             # <<<<<<<<<<<<<<
 *     """This function is called from the `create_token_subclass` method of
 *     `TokenTable` when it needs to create a new subclass to begin
 */
  __pyx_tuple__104 = PyTuple_Pack(1, __pyx_n_s_TokenSubclass); if (unlikely(!__pyx_tuple__104)) __PYX_ERR(0, 359, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__104);
  __Pyx_GIVEREF(__pyx_tuple__104);
  __pyx_codeobj__105 = (PyObject*)__Pyx_PyCode_New(0, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__104, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_token_subclass_factory, 359, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__105)) __PYX_ERR(0, 359, __pyx_L1_error)

  /* "typped/pratt_parser.py":968
 * #
 * 
 * def lexer_add_parser_instance_attribute(lexer, token):             # <<<<<<<<<<<<<<
 *     """Passed to lexer to add a `parser_instance` attribute to each token it
 *     returns.  This attribute is added to instances at the lexer, from its
 */
  __pyx_tuple__106 = PyTuple_Pack(2, __pyx_n_s_lexer, __pyx_n_s_token); if (unlikely(!__pyx_tuple__106)) __PYX_ERR(0, 968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__106);
  __Pyx_GIVEREF(__pyx_tuple__106);
  __pyx_codeobj__107 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__106, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_lexer_add_parser_instance_attrib, 968, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__107)) __PYX_ERR(0, 968, __pyx_L1_error)

  /* "typped/pratt_parser.py":980
 *     """A parser object.  Each parser object contains its own token table for tokens
 *     and its own lexer."""
 *     def __init__(self, max_peek_tokens=None,             # <<<<<<<<<<<<<<
 *                        max_deque_size=None,
 *                        lexer = None,
 */
  __pyx_tuple__108 = PyTuple_Pack(11, __pyx_n_s_self, __pyx_n_s_max_peek_tokens, __pyx_n_s_max_deque_size, __pyx_n_s_lexer, __pyx_n_s_default_begin_end_tokens, __pyx_n_s_type_table, __pyx_n_s_skip_type_checking, __pyx_n_s_overload_on_arg_types, __pyx_n_s_overload_on_ret_types, __pyx_n_s_partial_expressions, __pyx_n_s_raise_on_equal_priority_preconds); if (unlikely(!__pyx_tuple__108)) __PYX_ERR(0, 980, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__108);
  __Pyx_GIVEREF(__pyx_tuple__108);
  __pyx_codeobj__109 = (PyObject*)__Pyx_PyCode_New(11, 0, 11, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__108, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_init, 980, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__109)) __PYX_ERR(0, 980, __pyx_L1_error)
  __pyx_tuple__110 = PyTuple_Pack(10, ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_True), ((PyObject *)Py_None), ((PyObject *)Py_False), ((PyObject *)Py_True), ((PyObject *)Py_False), ((PyObject *)Py_False), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__110)) __PYX_ERR(0, 980, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__110);
  __Pyx_GIVEREF(__pyx_tuple__110);

  /* "typped/pratt_parser.py":1097
 *         self.top_level_production = False # If true, force prod. rule to consume all.
 * 
 *     def _next_unique_precond_label(self, autolabel_prefix=None):             # <<<<<<<<<<<<<<
 *         """Return the next unique default label for constructs.  It is a tuple so it
 *         never matches an actual string label."""
 */
  __pyx_tuple__111 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_autolabel_prefix, __pyx_n_s_string_prefix, __pyx_n_s_label); if (unlikely(!__pyx_tuple__111)) __PYX_ERR(0, 1097, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__111);
  __Pyx_GIVEREF(__pyx_tuple__111);
  __pyx_codeobj__112 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__111, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_next_unique_precond_label, 1097, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__112)) __PYX_ERR(0, 1097, __pyx_L1_error)
  __pyx_tuple__113 = PyTuple_Pack(1, ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__113)) __PYX_ERR(0, 1097, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__113);
  __Pyx_GIVEREF(__pyx_tuple__113);

  /* "typped/pratt_parser.py":1116
 *     #
 * 
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                          token_kind="regular", ignored_token_label=None,
 *                          matcher_options=None):
 */
  __pyx_tuple__114 = PyTuple_Pack(18, __pyx_n_s_self, __pyx_n_s_token_label, __pyx_n_s_regex_string, __pyx_n_s_on_ties, __pyx_n_s_ignore, __pyx_n_s_token_kind, __pyx_n_s_ignored_token_label, __pyx_n_s_matcher_options, __pyx_n_s_token_table, __pyx_n_s_tok, __pyx_n_s_begin_head, __pyx_n_s_begin_head, __pyx_n_s_begin_tail, __pyx_n_s_begin_tail, __pyx_n_s_end_head, __pyx_n_s_end_head, __pyx_n_s_end_tail, __pyx_n_s_end_tail); if (unlikely(!__pyx_tuple__114)) __PYX_ERR(0, 1116, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__114);
  __Pyx_GIVEREF(__pyx_tuple__114);
  __pyx_codeobj__115 = (PyObject*)__Pyx_PyCode_New(8, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__114, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_token_master, 1116, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__115)) __PYX_ERR(0, 1116, __pyx_L1_error)
  __pyx_tuple__116 = PyTuple_Pack(6, ((PyObject *)Py_None), ((PyObject *)__pyx_int_0), ((PyObject *)Py_False), ((PyObject*)__pyx_n_s_regular), ((PyObject *)Py_None), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__116)) __PYX_ERR(0, 1116, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__116);
  __Pyx_GIVEREF(__pyx_tuple__116);

  /* "typped/pratt_parser.py":1201
 *         return tok
 * 
 *     def def_token(self, token_label, regex_string, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                   matcher_options=None):
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 */
  __pyx_tuple__117 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_token_label, __pyx_n_s_regex_string, __pyx_n_s_on_ties, __pyx_n_s_ignore, __pyx_n_s_matcher_options); if (unlikely(!__pyx_tuple__117)) __PYX_ERR(0, 1201, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__117);
  __Pyx_GIVEREF(__pyx_tuple__117);
  __pyx_codeobj__118 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__117, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_token, 1201, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__118)) __PYX_ERR(0, 1201, __pyx_L1_error)
  __pyx_tuple__119 = PyTuple_Pack(3, ((PyObject *)__pyx_int_0), ((PyObject *)Py_False), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__119)) __PYX_ERR(0, 1201, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__119);
  __Pyx_GIVEREF(__pyx_tuple__119);

  /* "typped/pratt_parser.py":1208
 *                               token_kind="regular", matcher_options=matcher_options)
 * 
 *     def def_ignored_token(self, token_label, regex_string, on_ties=0,             # <<<<<<<<<<<<<<
 *                           matcher_options=None):
 *         """A convenience function to define a token with `ignored=True`."""
 */
  __pyx_tuple__120 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_token_label, __pyx_n_s_regex_string, __pyx_n_s_on_ties, __pyx_n_s_matcher_options); if (unlikely(!__pyx_tuple__120)) __PYX_ERR(0, 1208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__120);
  __Pyx_GIVEREF(__pyx_tuple__120);
  __pyx_codeobj__121 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__120, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_ignored_token, 1208, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__121)) __PYX_ERR(0, 1208, __pyx_L1_error)
  __pyx_tuple__122 = PyTuple_Pack(2, ((PyObject *)__pyx_int_0), ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__122)) __PYX_ERR(0, 1208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__122);
  __Pyx_GIVEREF(__pyx_tuple__122);

  /* "typped/pratt_parser.py":1214
 *                               token_kind="ignored", matcher_options=matcher_options)
 * 
 *     def def_begin_end_tokens(self, begin_token_label="k_begin",             # <<<<<<<<<<<<<<
 *                                    end_token_label="k_end"):
 *         """Calls the `Lexer` method to define begin- and end-tokens.  The
 */
  __pyx_tuple__123 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_begin_token_label, __pyx_n_s_end_token_label, __pyx_n_s_begin_tok, __pyx_n_s_end_tok); if (unlikely(!__pyx_tuple__123)) __PYX_ERR(0, 1214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__123);
  __Pyx_GIVEREF(__pyx_tuple__123);
  __pyx_codeobj__124 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__123, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_begin_end_tokens, 1214, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__124)) __PYX_ERR(0, 1214, __pyx_L1_error)
  __pyx_tuple__125 = PyTuple_Pack(2, ((PyObject*)__pyx_n_s_k_begin), ((PyObject*)__pyx_n_s_k_end)); if (unlikely(!__pyx_tuple__125)) __PYX_ERR(0, 1214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__125);
  __Pyx_GIVEREF(__pyx_tuple__125);

  /* "typped/pratt_parser.py":1231
 *         return begin_tok, end_tok
 * 
 *     def def_jop_token(self, jop_token_label, ignored_token_label):             # <<<<<<<<<<<<<<
 *         """Define a token for the juxtaposition operator.  This token has no
 *         regex pattern.  An instance is inserted in `recursive_parse` when it is
 */
  __pyx_tuple__126 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_jop_token_label, __pyx_n_s_ignored_token_label); if (unlikely(!__pyx_tuple__126)) __PYX_ERR(0, 1231, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__126);
  __Pyx_GIVEREF(__pyx_tuple__126);
  __pyx_codeobj__127 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__126, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_jop_token, 1231, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__127)) __PYX_ERR(0, 1231, __pyx_L1_error)

  /* "typped/pratt_parser.py":1247
 *                                      token_kind="jop")
 * 
 *     def def_null_string_token(self, null_string_token_label="k_null-string"):             # <<<<<<<<<<<<<<
 *         """Define the null-string token.  This token has no regex pattern.  An
 *         instance is inserted in `recursive_parse` when it is inferred to be
 */
  __pyx_tuple__128 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_null_string_token_label); if (unlikely(!__pyx_tuple__128)) __PYX_ERR(0, 1247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__128);
  __Pyx_GIVEREF(__pyx_tuple__128);
  __pyx_codeobj__129 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__128, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_null_string_token, 1247, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__129)) __PYX_ERR(0, 1247, __pyx_L1_error)
  __pyx_tuple__130 = PyTuple_Pack(1, ((PyObject*)__pyx_kp_s_k_null_string)); if (unlikely(!__pyx_tuple__130)) __PYX_ERR(0, 1247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__130);
  __Pyx_GIVEREF(__pyx_tuple__130);

  /* "typped/pratt_parser.py":1257
 *                                      token_kind="null-string")
 * 
 *     def get_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """Return the token with the label `token_label`.  The reverse
 *         operation, getting a label from a token instance, can be done by
 */
  __pyx_tuple__131 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_token_label); if (unlikely(!__pyx_tuple__131)) __PYX_ERR(0, 1257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__131);
  __Pyx_GIVEREF(__pyx_tuple__131);
  __pyx_codeobj__132 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__131, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_get_token, 1257, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__132)) __PYX_ERR(0, 1257, __pyx_L1_error)

  /* "typped/pratt_parser.py":1267
 *     #
 * 
 *     def undef_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """A method for undefining any token defined by the `PrattParser` methods.
 *         Since the `token_kind` was set for all tokens when they were defined
 */
  __pyx_tuple__133 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_token_label, __pyx_n_s_token_table, __pyx_n_s_tok, __pyx_n_s_kind); if (unlikely(!__pyx_tuple__133)) __PYX_ERR(0, 1267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__133);
  __Pyx_GIVEREF(__pyx_tuple__133);
  __pyx_codeobj__134 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__133, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_undef_token, 1267, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__134)) __PYX_ERR(0, 1267, __pyx_L1_error)

  /* "typped/pratt_parser.py":1292
 *     #
 * 
 *     def def_construct(self, head_or_tail, handler_fun, trigger_token_label,             # <<<<<<<<<<<<<<
 *                       prec=0, precond_label=None, precond_fun=None,
 *                       precond_priority=0, val_type=None, arg_types=None,
 */
  __pyx_tuple__135 = PyTuple_Pack(18, __pyx_n_s_self, __pyx_n_s_head_or_tail, __pyx_n_s_handler_fun, __pyx_n_s_trigger_token_label, __pyx_n_s_prec, __pyx_n_s_precond_label, __pyx_n_s_precond_fun, __pyx_n_s_precond_priority, __pyx_n_s_val_type, __pyx_n_s_arg_types, __pyx_n_s_eval_fun, __pyx_n_s_ast_data, __pyx_n_s_value_key, __pyx_n_s_autolabel_prefix, __pyx_n_s_dummy_handler, __pyx_n_s_token_subclass, __pyx_n_s_type_sig, __pyx_n_s_construct); if (unlikely(!__pyx_tuple__135)) __PYX_ERR(0, 1292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__135);
  __Pyx_GIVEREF(__pyx_tuple__135);
  __pyx_codeobj__136 = (PyObject*)__Pyx_PyCode_New(15, 0, 18, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__135, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_construct, 1292, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__136)) __PYX_ERR(0, 1292, __pyx_L1_error)
  __pyx_tuple__137 = PyTuple_Pack(11, ((PyObject *)__pyx_int_0), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)__pyx_int_0), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__137)) __PYX_ERR(0, 1292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__137);
  __Pyx_GIVEREF(__pyx_tuple__137);

  /* "typped/pratt_parser.py":1405
 *         return construct
 * 
 *     def undef_construct(self, head_or_tail, trigger_token_label, precond_label=None,             # <<<<<<<<<<<<<<
 *                          val_type=None, arg_types=None, all_handlers=False):
 *         """Undefine a head or tail function with the given `token_label`,
 */
  __pyx_tuple__138 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_head_or_tail, __pyx_n_s_trigger_token_label, __pyx_n_s_precond_label, __pyx_n_s_val_type, __pyx_n_s_arg_types, __pyx_n_s_all_handlers); if (unlikely(!__pyx_tuple__138)) __PYX_ERR(0, 1405, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__138);
  __Pyx_GIVEREF(__pyx_tuple__138);
  __pyx_codeobj__139 = (PyObject*)__Pyx_PyCode_New(7, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__138, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_undef_construct, 1405, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__139)) __PYX_ERR(0, 1405, __pyx_L1_error)
  __pyx_tuple__140 = PyTuple_Pack(4, ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__140)) __PYX_ERR(0, 1405, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__140);
  __Pyx_GIVEREF(__pyx_tuple__140);

  /* "typped/pratt_parser.py":1426
 *     #
 * 
 *     def def_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Define a type associated with the name `type_label`."""
 *         return self.type_table.create_typeobject(type_label)
 */
  __pyx_tuple__141 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_type_label); if (unlikely(!__pyx_tuple__141)) __PYX_ERR(0, 1426, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__141);
  __Pyx_GIVEREF(__pyx_tuple__141);
  __pyx_codeobj__142 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__141, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_def_type, 1426, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__142)) __PYX_ERR(0, 1426, __pyx_L1_error)

  /* "typped/pratt_parser.py":1430
 *         return self.type_table.create_typeobject(type_label)
 * 
 *     def undef_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Undefine the type associated with the name `type_label`."""
 *         self.type_table.undef_typeobject(type_label)
 */
  __pyx_tuple__143 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_type_label); if (unlikely(!__pyx_tuple__143)) __PYX_ERR(0, 1430, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__143);
  __Pyx_GIVEREF(__pyx_tuple__143);
  __pyx_codeobj__144 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__143, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_undef_type, 1430, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__144)) __PYX_ERR(0, 1430, __pyx_L1_error)

  /* "typped/pratt_parser.py":1438
 *     #
 * 
 *     def parse_from_lexer(self, lexer_to_use, pstate=None):             # <<<<<<<<<<<<<<
 *         """The same as the `parse` method, but a lexer_to_use is already assumed to be
 *         initialized.  This is ONLY used when one parser instance calls another
 */
  __pyx_tuple__145 = PyTuple_Pack(6, __pyx_n_s_self, __pyx_n_s_lexer_to_use, __pyx_n_s_pstate, __pyx_n_s_lexer_to_use_usual_table, __pyx_n_s_usual_lexer, __pyx_n_s_parsed_subexpression); if (unlikely(!__pyx_tuple__145)) __PYX_ERR(0, 1438, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__145);
  __Pyx_GIVEREF(__pyx_tuple__145);
  __pyx_codeobj__146 = (PyObject*)__Pyx_PyCode_New(3, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__145, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_parse_from_lexer, 1438, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__146)) __PYX_ERR(0, 1438, __pyx_L1_error)
  __pyx_tuple__147 = PyTuple_Pack(1, ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__147)) __PYX_ERR(0, 1438, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__147);
  __Pyx_GIVEREF(__pyx_tuple__147);

  /* "typped/pratt_parser.py":1480
 *         return parsed_subexpression
 * 
 *     def parse(self, program, pstate=None, partial_expressions=None,             # <<<<<<<<<<<<<<
 *                                                       skip_lex_setup=False):
 *         """The main routine for parsing a full program or expression.  Users of
 */
  __pyx_tuple__148 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_program, __pyx_n_s_pstate, __pyx_n_s_partial_expressions, __pyx_n_s_skip_lex_setup, __pyx_n_s_begin_tok, __pyx_n_s_parse_tree); if (unlikely(!__pyx_tuple__148)) __PYX_ERR(0, 1480, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__148);
  __Pyx_GIVEREF(__pyx_tuple__148);
  __pyx_codeobj__149 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__148, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_typped_pratt_parser_py, __pyx_n_s_parse, 1480, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__149)) __PYX_ERR(0, 1480, __pyx_L1_error)
  __pyx_tuple__150 = PyTuple_Pack(3, ((PyObject *)Py_None), ((PyObject *)Py_None), ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__150)) __PYX_ERR(0, 1480, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__150);
  __Pyx_GIVEREF(__pyx_tuple__150);
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_4 = PyInt_FromLong(4); if (unlikely(!__pyx_int_4)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initpratt_parser(void); /*proto*/
PyMODINIT_FUNC initpratt_parser(void)
#else
PyMODINIT_FUNC PyInit_pratt_parser(void); /*proto*/
PyMODINIT_FUNC PyInit_pratt_parser(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  PyObject *(*__pyx_t_7)(PyObject *);
  int __pyx_t_8;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_pratt_parser(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("pratt_parser", __pyx_methods, __pyx_k_A_general_Pratt_parser_module_t, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_typped__pratt_parser) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "typped.pratt_parser")) {
      if (unlikely(PyDict_SetItemString(modules, "typped.pratt_parser", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
  __pyx_type_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory.tp_print = 0;
  __pyx_ptype_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory = &__pyx_type_6typped_12pratt_parser___pyx_scope_struct__token_subclass_factory;
  if (PyType_Ready(&__pyx_type_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error) < 0) __PYX_ERR(0, 642, __pyx_L1_error)
  __pyx_type_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error.tp_print = 0;
  __pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error = &__pyx_type_6typped_12pratt_parser___pyx_scope_struct_1__raise_type_mismatch_error;
  if (PyType_Ready(&__pyx_type_6typped_12pratt_parser___pyx_scope_struct_2_genexpr) < 0) __PYX_ERR(0, 654, __pyx_L1_error)
  __pyx_type_6typped_12pratt_parser___pyx_scope_struct_2_genexpr.tp_print = 0;
  __pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_2_genexpr = &__pyx_type_6typped_12pratt_parser___pyx_scope_struct_2_genexpr;
  if (PyType_Ready(&__pyx_type_6typped_12pratt_parser___pyx_scope_struct_3_genexpr) < 0) __PYX_ERR(0, 655, __pyx_L1_error)
  __pyx_type_6typped_12pratt_parser___pyx_scope_struct_3_genexpr.tp_print = 0;
  __pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_3_genexpr = &__pyx_type_6typped_12pratt_parser___pyx_scope_struct_3_genexpr;
  if (PyType_Ready(&__pyx_type_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types) < 0) __PYX_ERR(0, 946, __pyx_L1_error)
  __pyx_type_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types.tp_print = 0;
  __pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types = &__pyx_type_6typped_12pratt_parser___pyx_scope_struct_4_string_repr_with_types;
  if (PyType_Ready(&__pyx_type_6typped_12pratt_parser___pyx_scope_struct_5_genexpr) < 0) __PYX_ERR(0, 951, __pyx_L1_error)
  __pyx_type_6typped_12pratt_parser___pyx_scope_struct_5_genexpr.tp_print = 0;
  __pyx_ptype_6typped_12pratt_parser___pyx_scope_struct_5_genexpr = &__pyx_type_6typped_12pratt_parser___pyx_scope_struct_5_genexpr;
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "typped/pratt_parser.py":194
 * 
 * # Run tests when invoked as a script.
 * if __name__ == "__main__":             # <<<<<<<<<<<<<<
 *     import pytest_helper
 *     pytest_helper.script_run(["../../test/test_ebnf_classes_and_operators.py",
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_main, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 194, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "typped/pratt_parser.py":195
 * # Run tests when invoked as a script.
 * if __name__ == "__main__":
 *     import pytest_helper             # <<<<<<<<<<<<<<
 *     pytest_helper.script_run(["../../test/test_ebnf_classes_and_operators.py",
 *                               "../../test/test_example_calculator.py",
 */
    __pyx_t_1 = __Pyx_Import(__pyx_n_s_pytest_helper, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_d, __pyx_n_s_pytest_helper, __pyx_t_1) < 0) __PYX_ERR(0, 195, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":196
 * if __name__ == "__main__":
 *     import pytest_helper
 *     pytest_helper.script_run(["../../test/test_ebnf_classes_and_operators.py",             # <<<<<<<<<<<<<<
 *                               "../../test/test_example_calculator.py",
 *                               "../../test/test_example_calculator_identifier_keyed_on_values.py",
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_pytest_helper); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_script_run); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 196, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyList_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 196, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_kp_s_test_test_ebnf_classes_and_oper);
    __Pyx_GIVEREF(__pyx_kp_s_test_test_ebnf_classes_and_oper);
    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_kp_s_test_test_ebnf_classes_and_oper);
    __Pyx_INCREF(__pyx_kp_s_test_test_example_calculator_py);
    __Pyx_GIVEREF(__pyx_kp_s_test_test_example_calculator_py);
    PyList_SET_ITEM(__pyx_t_1, 1, __pyx_kp_s_test_test_example_calculator_py);
    __Pyx_INCREF(__pyx_kp_s_test_test_example_calculator_id);
    __Pyx_GIVEREF(__pyx_kp_s_test_test_example_calculator_id);
    PyList_SET_ITEM(__pyx_t_1, 2, __pyx_kp_s_test_test_example_calculator_id);
    __Pyx_INCREF(__pyx_kp_s_test_test_parser_called_from_pa);
    __Pyx_GIVEREF(__pyx_kp_s_test_test_parser_called_from_pa);
    PyList_SET_ITEM(__pyx_t_1, 3, __pyx_kp_s_test_test_parser_called_from_pa);
    __Pyx_INCREF(__pyx_kp_s_test_test_pratt_types_py);
    __Pyx_GIVEREF(__pyx_kp_s_test_test_pratt_types_py);
    PyList_SET_ITEM(__pyx_t_1, 4, __pyx_kp_s_test_test_pratt_types_py);
    __Pyx_INCREF(__pyx_kp_s_test_test_basic_usage_section_e);
    __Pyx_GIVEREF(__pyx_kp_s_test_test_basic_usage_section_e);
    PyList_SET_ITEM(__pyx_t_1, 5, __pyx_kp_s_test_test_basic_usage_section_e);
    __Pyx_INCREF(__pyx_kp_s_test_test_pratt_parser_py);
    __Pyx_GIVEREF(__pyx_kp_s_test_test_pratt_parser_py);
    PyList_SET_ITEM(__pyx_t_1, 6, __pyx_kp_s_test_test_pratt_parser_py);
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 196, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "typped/pratt_parser.py":203
 *                               "../../test/test_basic_usage_section_examples.py",
 *                               "../../test/test_pratt_parser.py",
 *                               ], pytest_args="-v")             # <<<<<<<<<<<<<<
 * 
 * import sys
 */
    __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 203, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_pytest_args, __pyx_kp_s_v) < 0) __PYX_ERR(0, 203, __pyx_L1_error)

    /* "typped/pratt_parser.py":196
 * if __name__ == "__main__":
 *     import pytest_helper
 *     pytest_helper.script_run(["../../test/test_ebnf_classes_and_operators.py",             # <<<<<<<<<<<<<<
 *                               "../../test/test_example_calculator.py",
 *                               "../../test/test_example_calculator_identifier_keyed_on_values.py",
 */
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 196, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":194
 * 
 * # Run tests when invoked as a script.
 * if __name__ == "__main__":             # <<<<<<<<<<<<<<
 *     import pytest_helper
 *     pytest_helper.script_run(["../../test/test_ebnf_classes_and_operators.py",
 */
  }

  /* "typped/pratt_parser.py":205
 *                               ], pytest_args="-v")
 * 
 * import sys             # <<<<<<<<<<<<<<
 * import copy
 * 
 */
  __pyx_t_5 = __Pyx_Import(__pyx_n_s_sys, 0, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_5) < 0) __PYX_ERR(0, 205, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "typped/pratt_parser.py":206
 * 
 * import sys
 * import copy             # <<<<<<<<<<<<<<
 * 
 * from .shared_settings_and_exceptions import (HEAD, TAIL, ParserException,
 */
  __pyx_t_5 = __Pyx_Import(__pyx_n_s_copy, 0, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_copy, __pyx_t_5) < 0) __PYX_ERR(0, 206, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "typped/pratt_parser.py":208
 * import copy
 * 
 * from .shared_settings_and_exceptions import (HEAD, TAIL, ParserException,             # <<<<<<<<<<<<<<
 *         NoHandlerFunctionDefined, CalledBeginTokenHandler, CalledEndTokenHandler)
 * from .lexer import Lexer, TokenNode, TokenTable
 */
  __pyx_t_5 = PyList_New(6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_n_s_HEAD);
  __Pyx_GIVEREF(__pyx_n_s_HEAD);
  PyList_SET_ITEM(__pyx_t_5, 0, __pyx_n_s_HEAD);
  __Pyx_INCREF(__pyx_n_s_TAIL);
  __Pyx_GIVEREF(__pyx_n_s_TAIL);
  PyList_SET_ITEM(__pyx_t_5, 1, __pyx_n_s_TAIL);
  __Pyx_INCREF(__pyx_n_s_ParserException);
  __Pyx_GIVEREF(__pyx_n_s_ParserException);
  PyList_SET_ITEM(__pyx_t_5, 2, __pyx_n_s_ParserException);
  __Pyx_INCREF(__pyx_n_s_NoHandlerFunctionDefined);
  __Pyx_GIVEREF(__pyx_n_s_NoHandlerFunctionDefined);
  PyList_SET_ITEM(__pyx_t_5, 3, __pyx_n_s_NoHandlerFunctionDefined);
  __Pyx_INCREF(__pyx_n_s_CalledBeginTokenHandler);
  __Pyx_GIVEREF(__pyx_n_s_CalledBeginTokenHandler);
  PyList_SET_ITEM(__pyx_t_5, 4, __pyx_n_s_CalledBeginTokenHandler);
  __Pyx_INCREF(__pyx_n_s_CalledEndTokenHandler);
  __Pyx_GIVEREF(__pyx_n_s_CalledEndTokenHandler);
  PyList_SET_ITEM(__pyx_t_5, 5, __pyx_n_s_CalledEndTokenHandler);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_shared_settings_and_exceptions, __pyx_t_5, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_HEAD); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_HEAD, __pyx_t_5) < 0) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_TAIL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TAIL, __pyx_t_5) < 0) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_ParserException); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ParserException, __pyx_t_5) < 0) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_NoHandlerFunctionDefined); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NoHandlerFunctionDefined, __pyx_t_5) < 0) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_CalledBeginTokenHandler); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CalledBeginTokenHandler, __pyx_t_5) < 0) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_CalledEndTokenHandler); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CalledEndTokenHandler, __pyx_t_5) < 0) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":210
 * from .shared_settings_and_exceptions import (HEAD, TAIL, ParserException,
 *         NoHandlerFunctionDefined, CalledBeginTokenHandler, CalledEndTokenHandler)
 * from .lexer import Lexer, TokenNode, TokenTable             # <<<<<<<<<<<<<<
 * from .pratt_types import TypeTable, TypeSig, TypeErrorInParsedLanguage
 * from .pratt_constructs import ConstructTable
 */
  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_Lexer);
  __Pyx_GIVEREF(__pyx_n_s_Lexer);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Lexer);
  __Pyx_INCREF(__pyx_n_s_TokenNode);
  __Pyx_GIVEREF(__pyx_n_s_TokenNode);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_TokenNode);
  __Pyx_INCREF(__pyx_n_s_TokenTable);
  __Pyx_GIVEREF(__pyx_n_s_TokenTable);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_TokenTable);
  __pyx_t_5 = __Pyx_Import(__pyx_n_s_lexer, __pyx_t_1, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_5, __pyx_n_s_Lexer); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Lexer, __pyx_t_1) < 0) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_5, __pyx_n_s_TokenNode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TokenNode, __pyx_t_1) < 0) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_5, __pyx_n_s_TokenTable); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TokenTable, __pyx_t_1) < 0) __PYX_ERR(0, 210, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "typped/pratt_parser.py":211
 *         NoHandlerFunctionDefined, CalledBeginTokenHandler, CalledEndTokenHandler)
 * from .lexer import Lexer, TokenNode, TokenTable
 * from .pratt_types import TypeTable, TypeSig, TypeErrorInParsedLanguage             # <<<<<<<<<<<<<<
 * from .pratt_constructs import ConstructTable
 * #from .matcher import Matcher
 */
  __pyx_t_5 = PyList_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_n_s_TypeTable);
  __Pyx_GIVEREF(__pyx_n_s_TypeTable);
  PyList_SET_ITEM(__pyx_t_5, 0, __pyx_n_s_TypeTable);
  __Pyx_INCREF(__pyx_n_s_TypeSig);
  __Pyx_GIVEREF(__pyx_n_s_TypeSig);
  PyList_SET_ITEM(__pyx_t_5, 1, __pyx_n_s_TypeSig);
  __Pyx_INCREF(__pyx_n_s_TypeErrorInParsedLanguage);
  __Pyx_GIVEREF(__pyx_n_s_TypeErrorInParsedLanguage);
  PyList_SET_ITEM(__pyx_t_5, 2, __pyx_n_s_TypeErrorInParsedLanguage);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_pratt_types, __pyx_t_5, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_TypeTable); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TypeTable, __pyx_t_5) < 0) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_TypeSig); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TypeSig, __pyx_t_5) < 0) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_TypeErrorInParsedLanguage); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TypeErrorInParsedLanguage, __pyx_t_5) < 0) __PYX_ERR(0, 211, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":212
 * from .lexer import Lexer, TokenNode, TokenTable
 * from .pratt_types import TypeTable, TypeSig, TypeErrorInParsedLanguage
 * from .pratt_constructs import ConstructTable             # <<<<<<<<<<<<<<
 * #from .matcher import Matcher
 * from . import builtin_parse_methods, predefined_token_sets
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 212, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_ConstructTable);
  __Pyx_GIVEREF(__pyx_n_s_ConstructTable);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_ConstructTable);
  __pyx_t_5 = __Pyx_Import(__pyx_n_s_pratt_constructs, __pyx_t_1, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 212, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_5, __pyx_n_s_ConstructTable); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 212, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ConstructTable, __pyx_t_1) < 0) __PYX_ERR(0, 212, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "typped/pratt_parser.py":214
 * from .pratt_constructs import ConstructTable
 * #from .matcher import Matcher
 * from . import builtin_parse_methods, predefined_token_sets             # <<<<<<<<<<<<<<
 * 
 * # TODO: clarify when tokens are assigned the parser_instance attribute, if they
 */
  __pyx_t_5 = PyList_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_n_s_builtin_parse_methods);
  __Pyx_GIVEREF(__pyx_n_s_builtin_parse_methods);
  PyList_SET_ITEM(__pyx_t_5, 0, __pyx_n_s_builtin_parse_methods);
  __Pyx_INCREF(__pyx_n_s_predefined_token_sets);
  __Pyx_GIVEREF(__pyx_n_s_predefined_token_sets);
  PyList_SET_ITEM(__pyx_t_5, 1, __pyx_n_s_predefined_token_sets);
  __pyx_t_1 = __Pyx_Import(__pyx_kp_s__10, __pyx_t_5, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_builtin_parse_methods); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_builtin_parse_methods, __pyx_t_5) < 0) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_predefined_token_sets); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_predefined_token_sets, __pyx_t_5) < 0) __PYX_ERR(0, 214, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":241
 * # but you need to clutter it with non-token data.
 * 
 * DEFAULT_PRECOND_AUTOLABEL_PREFIX = "default_unique_precond_label"             # <<<<<<<<<<<<<<
 * DEFAULT_ALWAYS_TRUE_PRECOND_LABEL = "default_always_true_precond"
 * 
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DEFAULT_PRECOND_AUTOLABEL_PREFIX, __pyx_n_s_default_unique_precond_label) < 0) __PYX_ERR(0, 241, __pyx_L1_error)

  /* "typped/pratt_parser.py":242
 * 
 * DEFAULT_PRECOND_AUTOLABEL_PREFIX = "default_unique_precond_label"
 * DEFAULT_ALWAYS_TRUE_PRECOND_LABEL = "default_always_true_precond"             # <<<<<<<<<<<<<<
 * 
 * def DEFAULT_ALWAYS_TRUE_PRECOND_FUN(lex, lookbehind):
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_LABE, __pyx_n_s_default_always_true_precond) < 0) __PYX_ERR(0, 242, __pyx_L1_error)

  /* "typped/pratt_parser.py":244
 * DEFAULT_ALWAYS_TRUE_PRECOND_LABEL = "default_always_true_precond"
 * 
 * def DEFAULT_ALWAYS_TRUE_PRECOND_FUN(lex, lookbehind):             # <<<<<<<<<<<<<<
 *     """The default precondition function; always returns true."""
 *     return True
 */
  __pyx_t_1 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_1DEFAULT_ALWAYS_TRUE_PRECOND_FUN, 0, __pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_FUN, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__83)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DEFAULT_ALWAYS_TRUE_PRECOND_FUN, __pyx_t_1) < 0) __PYX_ERR(0, 244, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":270
 * # stub) to represent particular kinds of tokens.
 * 
 * class TokenSubclassMeta(type):             # <<<<<<<<<<<<<<
 *     """A trivial metaclass that will actually create the `TokenSubclass`
 *     objects.  Since tokens are represented by classes, rather than instances,
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)(&PyType_Type)));
  __Pyx_GIVEREF(((PyObject *)(&PyType_Type)));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&PyType_Type)));
  __pyx_t_5 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = __Pyx_Py3MetaclassPrepare(__pyx_t_5, __pyx_t_1, __pyx_n_s_TokenSubclassMeta, __pyx_n_s_TokenSubclassMeta, (PyObject *) NULL, __pyx_n_s_typped_pratt_parser, __pyx_kp_s_A_trivial_metaclass_that_will_ac); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);

  /* "typped/pratt_parser.py":276
 *     ugly for tokens) and to overload operators to work for token operands
 *     in the EBNF-like grammar."""
 *     def __new__(mcs, name, bases, dct):             # <<<<<<<<<<<<<<
 *         new_class = super(TokenSubclassMeta, mcs).__new__(mcs, name, bases, dct)
 * 
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_1__new__, __Pyx_CYFUNCTION_STATICMETHOD, __pyx_n_s_TokenSubclassMeta___new, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__85)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_new, __pyx_t_3) < 0) __PYX_ERR(0, 276, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":301
 *     #
 * 
 *     def __repr__(cls):             # <<<<<<<<<<<<<<
 *         """The representation for tokens.  Tokens are commonly used in the
 *         code but, being classes, have an ugly default `__repr__` when printed out.
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_3__repr__, 0, __pyx_n_s_TokenSubclassMeta___repr, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__87)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_repr, __pyx_t_3) < 0) __PYX_ERR(0, 301, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":321
 *     # should catch most accidentals just because of that.
 * 
 *     def __add__(cls, other):             # <<<<<<<<<<<<<<
 *         """Addition of two tokens is defined to simply return a tuple of
 *         both tokens.  This is so raw tokens can be used in the operator
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_5__add__, 0, __pyx_n_s_TokenSubclassMeta___add, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__89)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 321, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_add, __pyx_t_3) < 0) __PYX_ERR(0, 321, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":327
 *         return cls.prod_rule_funs["Tok"](cls) + other
 * 
 *     def __radd__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__add__` above."""
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_7__radd__, 0, __pyx_n_s_TokenSubclassMeta___radd, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__91)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 327, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_radd, __pyx_t_3) < 0) __PYX_ERR(0, 327, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":331
 *         return left_other + cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __or__(cls, other):             # <<<<<<<<<<<<<<
 *         """The `|` symbol simply converts this object into an `ItemList`
 *         and then calls `__or__` for those objects."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_9__or__, 0, __pyx_n_s_TokenSubclassMeta___or, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__93)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 331, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_or, __pyx_t_3) < 0) __PYX_ERR(0, 331, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":336
 *         return cls.prod_rule_funs["Tok"](cls) | other
 * 
 *     def __ror__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The right version of `__or__` above."""
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_11__ror__, 0, __pyx_n_s_TokenSubclassMeta___ror, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__95)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 336, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_ror, __pyx_t_3) < 0) __PYX_ERR(0, 336, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":340
 *         return left_other | cls.prod_rule_funs["Tok"](cls)
 * 
 *     def __rmul__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n*token` for an int `n` is "n occurrences of"
 *         `token`."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_13__rmul__, 0, __pyx_n_s_TokenSubclassMeta___rmul, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__97)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 340, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_rmul, __pyx_t_3) < 0) __PYX_ERR(0, 340, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":345
 *         return cls.prod_rule_funs["Repeat"](left_other, cls)
 * 
 *     def __rpow__(cls, left_other):             # <<<<<<<<<<<<<<
 *         """The expression `n**token` for an int `n` is "n or more occurrences of"
 *         `token`."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_15__rpow__, 0, __pyx_n_s_TokenSubclassMeta___rpow, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__99)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 345, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_rpow, __pyx_t_3) < 0) __PYX_ERR(0, 345, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":350
 *         return cls.prod_rule_funs["nOrMore"](left_other, cls)
 * 
 *     def __invert__(cls):             # <<<<<<<<<<<<<<
 *         """Define the `~` operator for production rule grammars."""
 *         return cls.prod_rule_funs["Not"](cls)
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_17__invert__, 0, __pyx_n_s_TokenSubclassMeta___invert, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__101)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_invert, __pyx_t_3) < 0) __PYX_ERR(0, 350, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":354
 *         return cls.prod_rule_funs["Not"](cls)
 * 
 *     def __getitem__(cls, arg):             # <<<<<<<<<<<<<<
 *         """Define the bracket indexing operator for production rule grammars
 *         to set the precedence."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_17TokenSubclassMeta_19__getitem__, 0, __pyx_n_s_TokenSubclassMeta___getitem, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__103)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_getitem, __pyx_t_3) < 0) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":270
 * # stub) to represent particular kinds of tokens.
 * 
 * class TokenSubclassMeta(type):             # <<<<<<<<<<<<<<
 *     """A trivial metaclass that will actually create the `TokenSubclass`
 *     objects.  Since tokens are represented by classes, rather than instances,
 */
  __pyx_t_3 = __Pyx_Py3ClassCreate(__pyx_t_5, __pyx_n_s_TokenSubclassMeta, __pyx_t_1, __pyx_t_4, NULL, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TokenSubclassMeta, __pyx_t_3) < 0) __PYX_ERR(0, 270, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":359
 *         return cls.prod_rule_funs["Prec"](cls, arg)
 * 
 * def token_subclass_factory():             # <<<<<<<<<<<<<<
 *     """This function is called from the `create_token_subclass` method of
 *     `TokenTable` when it needs to create a new subclass to begin
 */
  __pyx_t_1 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_3token_subclass_factory, 0, __pyx_n_s_token_subclass_factory, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__105)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 359, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_token_subclass_factory, __pyx_t_1) < 0) __PYX_ERR(0, 359, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":968
 * #
 * 
 * def lexer_add_parser_instance_attribute(lexer, token):             # <<<<<<<<<<<<<<
 *     """Passed to lexer to add a `parser_instance` attribute to each token it
 *     returns.  This attribute is added to instances at the lexer, from its
 */
  __pyx_t_1 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_5lexer_add_parser_instance_attribute, 0, __pyx_n_s_lexer_add_parser_instance_attrib, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__107)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_lexer_add_parser_instance_attrib, __pyx_t_1) < 0) __PYX_ERR(0, 968, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":977
 *     return token
 * 
 * class PrattParser(object):             # <<<<<<<<<<<<<<
 *     """A parser object.  Each parser object contains its own token table for tokens
 *     and its own lexer."""
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 977, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_builtin_object);
  __Pyx_GIVEREF(__pyx_builtin_object);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_builtin_object);
  __pyx_t_5 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 977, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = __Pyx_Py3MetaclassPrepare(__pyx_t_5, __pyx_t_1, __pyx_n_s_PrattParser, __pyx_n_s_PrattParser, (PyObject *) NULL, __pyx_n_s_typped_pratt_parser, __pyx_kp_s_A_parser_object_Each_parser_obje); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 977, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);

  /* "typped/pratt_parser.py":980
 *     """A parser object.  Each parser object contains its own token table for tokens
 *     and its own lexer."""
 *     def __init__(self, max_peek_tokens=None,             # <<<<<<<<<<<<<<
 *                        max_deque_size=None,
 *                        lexer = None,
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_1__init__, 0, __pyx_n_s_PrattParser___init, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__109)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 980, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__110);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_init, __pyx_t_3) < 0) __PYX_ERR(0, 980, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1097
 *         self.top_level_production = False # If true, force prod. rule to consume all.
 * 
 *     def _next_unique_precond_label(self, autolabel_prefix=None):             # <<<<<<<<<<<<<<
 *         """Return the next unique default label for constructs.  It is a tuple so it
 *         never matches an actual string label."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_3_next_unique_precond_label, 0, __pyx_n_s_PrattParser__next_unique_precond, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__112)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1097, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__113);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_next_unique_precond_label, __pyx_t_3) < 0) __PYX_ERR(0, 1097, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1116
 *     #
 * 
 *     def def_token_master(self, token_label, regex_string=None, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                          token_kind="regular", ignored_token_label=None,
 *                          matcher_options=None):
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_5def_token_master, 0, __pyx_n_s_PrattParser_def_token_master, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__115)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1116, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__116);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_token_master, __pyx_t_3) < 0) __PYX_ERR(0, 1116, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1201
 *         return tok
 * 
 *     def def_token(self, token_label, regex_string, on_ties=0, ignore=False,             # <<<<<<<<<<<<<<
 *                   matcher_options=None):
 *         """Define a token.  Use this instead of the Lexer `def_token` method,
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_7def_token, 0, __pyx_n_s_PrattParser_def_token, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__118)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1201, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__119);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_token, __pyx_t_3) < 0) __PYX_ERR(0, 1201, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1208
 *                               token_kind="regular", matcher_options=matcher_options)
 * 
 *     def def_ignored_token(self, token_label, regex_string, on_ties=0,             # <<<<<<<<<<<<<<
 *                           matcher_options=None):
 *         """A convenience function to define a token with `ignored=True`."""
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_9def_ignored_token, 0, __pyx_n_s_PrattParser_def_ignored_token, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__121)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__122);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_ignored_token, __pyx_t_3) < 0) __PYX_ERR(0, 1208, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1214
 *                               token_kind="ignored", matcher_options=matcher_options)
 * 
 *     def def_begin_end_tokens(self, begin_token_label="k_begin",             # <<<<<<<<<<<<<<
 *                                    end_token_label="k_end"):
 *         """Calls the `Lexer` method to define begin- and end-tokens.  The
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_11def_begin_end_tokens, 0, __pyx_n_s_PrattParser_def_begin_end_tokens, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__124)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__125);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_begin_end_tokens, __pyx_t_3) < 0) __PYX_ERR(0, 1214, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1231
 *         return begin_tok, end_tok
 * 
 *     def def_jop_token(self, jop_token_label, ignored_token_label):             # <<<<<<<<<<<<<<
 *         """Define a token for the juxtaposition operator.  This token has no
 *         regex pattern.  An instance is inserted in `recursive_parse` when it is
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_13def_jop_token, 0, __pyx_n_s_PrattParser_def_jop_token, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__127)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1231, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_jop_token, __pyx_t_3) < 0) __PYX_ERR(0, 1231, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1247
 *                                      token_kind="jop")
 * 
 *     def def_null_string_token(self, null_string_token_label="k_null-string"):             # <<<<<<<<<<<<<<
 *         """Define the null-string token.  This token has no regex pattern.  An
 *         instance is inserted in `recursive_parse` when it is inferred to be
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_15def_null_string_token, 0, __pyx_n_s_PrattParser_def_null_string_toke, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__129)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1247, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__130);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_null_string_token, __pyx_t_3) < 0) __PYX_ERR(0, 1247, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1257
 *                                      token_kind="null-string")
 * 
 *     def get_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """Return the token with the label `token_label`.  The reverse
 *         operation, getting a label from a token instance, can be done by
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_17get_token, 0, __pyx_n_s_PrattParser_get_token, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__132)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_get_token, __pyx_t_3) < 0) __PYX_ERR(0, 1257, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1267
 *     #
 * 
 *     def undef_token(self, token_label):             # <<<<<<<<<<<<<<
 *         """A method for undefining any token defined by the `PrattParser` methods.
 *         Since the `token_kind` was set for all tokens when they were defined
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_19undef_token, 0, __pyx_n_s_PrattParser_undef_token, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__134)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_undef_token, __pyx_t_3) < 0) __PYX_ERR(0, 1267, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1292
 *     #
 * 
 *     def def_construct(self, head_or_tail, handler_fun, trigger_token_label,             # <<<<<<<<<<<<<<
 *                       prec=0, precond_label=None, precond_fun=None,
 *                       precond_priority=0, val_type=None, arg_types=None,
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_21def_construct, 0, __pyx_n_s_PrattParser_def_construct, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__136)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1292, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__137);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_construct, __pyx_t_3) < 0) __PYX_ERR(0, 1292, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1405
 *         return construct
 * 
 *     def undef_construct(self, head_or_tail, trigger_token_label, precond_label=None,             # <<<<<<<<<<<<<<
 *                          val_type=None, arg_types=None, all_handlers=False):
 *         """Undefine a head or tail function with the given `token_label`,
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_23undef_construct, 0, __pyx_n_s_PrattParser_undef_construct, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__139)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1405, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__140);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_undef_construct, __pyx_t_3) < 0) __PYX_ERR(0, 1405, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1426
 *     #
 * 
 *     def def_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Define a type associated with the name `type_label`."""
 *         return self.type_table.create_typeobject(type_label)
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_25def_type, 0, __pyx_n_s_PrattParser_def_type, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__142)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1426, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_def_type, __pyx_t_3) < 0) __PYX_ERR(0, 1426, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1430
 *         return self.type_table.create_typeobject(type_label)
 * 
 *     def undef_type(self, type_label):             # <<<<<<<<<<<<<<
 *         """Undefine the type associated with the name `type_label`."""
 *         self.type_table.undef_typeobject(type_label)
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_27undef_type, 0, __pyx_n_s_PrattParser_undef_type, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__144)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1430, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_undef_type, __pyx_t_3) < 0) __PYX_ERR(0, 1430, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1438
 *     #
 * 
 *     def parse_from_lexer(self, lexer_to_use, pstate=None):             # <<<<<<<<<<<<<<
 *         """The same as the `parse` method, but a lexer_to_use is already assumed to be
 *         initialized.  This is ONLY used when one parser instance calls another
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_29parse_from_lexer, 0, __pyx_n_s_PrattParser_parse_from_lexer, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__146)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1438, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__147);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_parse_from_lexer, __pyx_t_3) < 0) __PYX_ERR(0, 1438, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1480
 *         return parsed_subexpression
 * 
 *     def parse(self, program, pstate=None, partial_expressions=None,             # <<<<<<<<<<<<<<
 *                                                       skip_lex_setup=False):
 *         """The main routine for parsing a full program or expression.  Users of
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_6typped_12pratt_parser_11PrattParser_31parse, 0, __pyx_n_s_PrattParser_parse, NULL, __pyx_n_s_typped_pratt_parser, __pyx_d, ((PyObject *)__pyx_codeobj__149)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1480, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__150);
  if (PyObject_SetItem(__pyx_t_4, __pyx_n_s_parse, __pyx_t_3) < 0) __PYX_ERR(0, 1480, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":977
 *     return token
 * 
 * class PrattParser(object):             # <<<<<<<<<<<<<<
 *     """A parser object.  Each parser object contains its own token table for tokens
 *     and its own lexer."""
 */
  __pyx_t_3 = __Pyx_Py3ClassCreate(__pyx_t_5, __pyx_n_s_PrattParser, __pyx_t_1, __pyx_t_4, NULL, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 977, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PrattParser, __pyx_t_3) < 0) __PYX_ERR(0, 977, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1541
 * #
 * 
 * for method in builtin_parse_methods.parse_methods:             # <<<<<<<<<<<<<<
 *     setattr(PrattParser, method.__name__, method)
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_builtin_parse_methods); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1541, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_parse_methods); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1541, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (likely(PyList_CheckExact(__pyx_t_5)) || PyTuple_CheckExact(__pyx_t_5)) {
    __pyx_t_1 = __pyx_t_5; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
    __pyx_t_7 = NULL;
  } else {
    __pyx_t_6 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1541, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1541, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  for (;;) {
    if (likely(!__pyx_t_7)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_5); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1541, __pyx_L1_error)
        #else
        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1541, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        #endif
      } else {
        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_5); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1541, __pyx_L1_error)
        #else
        __pyx_t_5 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1541, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        #endif
      }
    } else {
      __pyx_t_5 = __pyx_t_7(__pyx_t_1);
      if (unlikely(!__pyx_t_5)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1541, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_5);
    }
    if (PyDict_SetItem(__pyx_d, __pyx_n_s_method, __pyx_t_5) < 0) __PYX_ERR(0, 1541, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "typped/pratt_parser.py":1542
 * 
 * for method in builtin_parse_methods.parse_methods:
 *     setattr(PrattParser, method.__name__, method)             # <<<<<<<<<<<<<<
 * 
 * for method in predefined_token_sets.token_defining_methods:
 */
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_PrattParser); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1542, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_method); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1542, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_name_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1542, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_method); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1542, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_8 = PyObject_SetAttr(__pyx_t_5, __pyx_t_3, __pyx_t_4); if (unlikely(__pyx_t_8 == -1)) __PYX_ERR(0, 1542, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":1541
 * #
 * 
 * for method in builtin_parse_methods.parse_methods:             # <<<<<<<<<<<<<<
 *     setattr(PrattParser, method.__name__, method)
 * 
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1544
 *     setattr(PrattParser, method.__name__, method)
 * 
 * for method in predefined_token_sets.token_defining_methods:             # <<<<<<<<<<<<<<
 *     setattr(PrattParser, method.__name__, method)
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_predefined_token_sets); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1544, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_token_defining_methods); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1544, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (likely(PyList_CheckExact(__pyx_t_4)) || PyTuple_CheckExact(__pyx_t_4)) {
    __pyx_t_1 = __pyx_t_4; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
    __pyx_t_7 = NULL;
  } else {
    __pyx_t_6 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1544, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1544, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  for (;;) {
    if (likely(!__pyx_t_7)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1544, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1544, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1544, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1544, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_7(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1544, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    if (PyDict_SetItem(__pyx_d, __pyx_n_s_method, __pyx_t_4) < 0) __PYX_ERR(0, 1544, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "typped/pratt_parser.py":1545
 * 
 * for method in predefined_token_sets.token_defining_methods:
 *     setattr(PrattParser, method.__name__, method)             # <<<<<<<<<<<<<<
 * 
 * #
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_PrattParser); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1545, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_method); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1545, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_name_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1545, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_method); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1545, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = PyObject_SetAttr(__pyx_t_4, __pyx_t_5, __pyx_t_3); if (unlikely(__pyx_t_8 == -1)) __PYX_ERR(0, 1545, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "typped/pratt_parser.py":1544
 *     setattr(PrattParser, method.__name__, method)
 * 
 * for method in predefined_token_sets.token_defining_methods:             # <<<<<<<<<<<<<<
 *     setattr(PrattParser, method.__name__, method)
 * 
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "typped/pratt_parser.py":1551
 * #
 * 
 * class IncompleteParseException(ParserException):             # <<<<<<<<<<<<<<
 *     """Only raised at the end of the `PrattParser` function `parse` if tokens
 *     remain in the lexer after the parser finishes its parsing."""
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_ParserException); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_3, __pyx_n_s_IncompleteParseException, __pyx_n_s_IncompleteParseException, (PyObject *) NULL, __pyx_n_s_typped_pratt_parser, __pyx_kp_s_Only_raised_at_the_end_of_the_Pr); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_IncompleteParseException, __pyx_t_3, __pyx_t_5, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_IncompleteParseException, __pyx_t_4) < 0) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "typped/pratt_parser.py":1
 * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
 * """
 * 
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_3) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init typped.pratt_parser", 0, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init typped.pratt_parser");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* GetModuleGlobalName */
static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

/* PyObjectCall */
  #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyFunctionFastCall */
  #if CYTHON_FAST_PYCALL
#include "frameobject.h"
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = PyThreadState_GET();
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = f->f_localsplus;
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif
#endif

/* PyCFunctionFastCall */
  #if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    int flags = PyCFunction_GET_FLAGS(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
        return (*((__Pyx_PyCFunctionFastWithKeywords)meth)) (self, args, nargs, NULL);
    } else {
        return (*((__Pyx_PyCFunctionFast)meth)) (self, args, nargs);
    }
}
#endif

/* Import */
  static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* ImportFrom */
  static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

/* PyObjectCallMethO */
  #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
  #if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
    if (likely(PyCFunction_Check(func))) {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* None */
  static CYTHON_INLINE void __Pyx_RaiseClosureNameError(const char *varname) {
    PyErr_Format(PyExc_NameError, "free variable '%s' referenced before assignment in enclosing scope", varname);
}

/* PyObjectCallNoArg */
  #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, NULL, 0);
    }
#endif
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* GetAttr */
    static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
#if CYTHON_COMPILING_IN_CPYTHON
#if PY_MAJOR_VERSION >= 3
    if (likely(PyUnicode_Check(n)))
#else
    if (likely(PyString_Check(n)))
#endif
        return __Pyx_PyObject_GetAttrStr(o, n);
#endif
    return PyObject_GetAttr(o, n);
}

/* HasAttr */
    static CYTHON_INLINE int __Pyx_HasAttr(PyObject *o, PyObject *n) {
    PyObject *r;
    if (unlikely(!__Pyx_PyBaseString_Check(n))) {
        PyErr_SetString(PyExc_TypeError,
                        "hasattr(): attribute name must be string");
        return -1;
    }
    r = __Pyx_GetAttr(o, n);
    if (unlikely(!r)) {
        PyErr_Clear();
        return 0;
    } else {
        Py_DECREF(r);
        return 1;
    }
}

/* PyObjectCallMethod1 */
    static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method, *result = NULL;
    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
    if (unlikely(!method)) goto done;
#if CYTHON_UNPACK_METHODS
    if (likely(PyMethod_Check(method))) {
        PyObject *self = PyMethod_GET_SELF(method);
        if (likely(self)) {
            PyObject *args;
            PyObject *function = PyMethod_GET_FUNCTION(method);
            #if CYTHON_FAST_PYCALL
            if (PyFunction_Check(function)) {
                PyObject *args[2] = {self, arg};
                result = __Pyx_PyFunction_FastCall(function, args, 2);
                goto done;
            }
            #endif
            #if CYTHON_FAST_PYCCALL
            if (__Pyx_PyFastCFunction_Check(function)) {
                PyObject *args[2] = {self, arg};
                result = __Pyx_PyCFunction_FastCall(function, args, 2);
                goto done;
            }
            #endif
            args = PyTuple_New(2);
            if (unlikely(!args)) goto done;
            Py_INCREF(self);
            PyTuple_SET_ITEM(args, 0, self);
            Py_INCREF(arg);
            PyTuple_SET_ITEM(args, 1, arg);
            Py_INCREF(function);
            Py_DECREF(method); method = NULL;
            result = __Pyx_PyObject_Call(function, args, NULL);
            Py_DECREF(args);
            Py_DECREF(function);
            return result;
        }
    }
#endif
    result = __Pyx_PyObject_CallOneArg(method, arg);
done:
    Py_XDECREF(method);
    return result;
}

/* append */
    static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
    if (likely(PyList_CheckExact(L))) {
        if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
    } else {
        PyObject* retval = __Pyx_PyObject_CallMethod1(L, __pyx_n_s_append, x);
        if (unlikely(!retval))
            return -1;
        Py_DECREF(retval);
    }
    return 0;
}

/* GetItemInt */
    static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyList_GET_SIZE(o);
    }
    if ((!boundscheck) || likely((0 <= wrapped_i) & (wrapped_i < PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyTuple_GET_SIZE(o);
    }
    if ((!boundscheck) || likely((0 <= wrapped_i) & (wrapped_i < PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
                                                     CYTHON_NCP_UNUSED int wraparound,
                                                     CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return NULL;
                    PyErr_Clear();
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

/* PyIntBinop */
    #if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a + b);
            if (likely((x^a) >= 0 || (x^b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_add(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
#ifdef HAVE_LONG_LONG
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
#endif
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
            }
        }
                x = a + b;
            return PyLong_FromLong(x);
#ifdef HAVE_LONG_LONG
        long_long:
                llx = lla + llb;
            return PyLong_FromLongLong(llx);
#endif
        
        
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("add", return NULL)
            result = ((double)a) + (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
}
#endif

/* PyErrFetchRestore */
    #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
    #if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* SaveResetException */
      #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* PyErrExceptionMatches */
      #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    return PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* GetException */
      #if CYTHON_FAST_THREAD_STATE
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
#endif
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_FAST_THREAD_STATE
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_FAST_THREAD_STATE
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_FAST_THREAD_STATE
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* SwapException */
        #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#endif

/* RaiseTooManyValuesToUnpack */
        static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

/* RaiseNeedMoreValuesToUnpack */
        static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

/* IterFinish */
        static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_FAST_THREAD_STATE
    PyThreadState *tstate = PyThreadState_GET();
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(exc_type == PyExc_StopIteration) || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

/* UnpackItemEndCheck */
        static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

/* StringJoin */
        #if !CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values) {
    return PyObject_CallMethodObjArgs(sep, __pyx_n_s_join, values, NULL);
}
#endif

/* CalculateMetaclass */
        static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

/* FetchCommonType */
        static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

/* CythonFunction */
        static PyObject *
__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
{
    if (unlikely(op->func_doc == NULL)) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (unlikely(op->func_doc == NULL))
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_name == NULL)) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (unlikely(op->func_name == NULL))
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_qualname);
    return op->func_qualname;
}
static int
__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = op->func_qualname;
    Py_INCREF(value);
    op->func_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_dict == NULL)) {
        op->func_dict = PyDict_New();
        if (unlikely(op->func_dict == NULL))
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
    if (unlikely(value == NULL)) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if (unlikely(!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
    int result = 0;
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (unlikely(!res))
        return -1;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    #else
    op->defaults_tuple = PySequence_ITEM(res, 0);
    if (unlikely(!op->defaults_tuple)) result = -1;
    else {
        op->defaults_kwdict = PySequence_ITEM(res, 1);
        if (unlikely(!op->defaults_kwdict)) result = -1;
    }
    #endif
    Py_DECREF(res);
    return result;
}
static int
__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_tuple;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_kwdict;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op) {
    PyObject* result = op->func_annotations;
    if (unlikely(!result)) {
        result = PyDict_New();
        if (unlikely(!result)) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef __pyx_CyFunction_getsets[] = {
    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef __pyx_CyFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(__pyx_CyFunctionObject, func.m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromString(m->func.m_ml->ml_name);
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef __pyx_CyFunction_methods[] = {
    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *__Pyx_CyFunction_New(PyTypeObject *type, PyMethodDef *ml, int flags, PyObject* qualname,
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    __pyx_CyFunctionObject *op = PyObject_GC_New(__pyx_CyFunctionObject, type);
    if (op == NULL)
        return NULL;
    op->flags = flags;
    __Pyx_CyFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    Py_INCREF(qualname);
    op->func_qualname = qualname;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    PyObject_GC_Track(op);
    return (PyObject *) op;
}
static int
__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_qualname);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyObject_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    if (__Pyx_CyFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    __Pyx_CyFunction_clear(m);
    PyObject_GC_Del(m);
}
static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_qualname);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
    return __Pyx_PyMethod_New(func, obj, type);
}
static PyObject*
__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromFormat("<cyfunction %U at %p>",
                                op->func_qualname, (void *)op);
#else
    return PyString_FromFormat("<cyfunction %s at %p>",
                               PyString_AsString(op->func_qualname), (void *)op);
#endif
}
static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = f->m_ml->ml_meth;
    Py_ssize_t size;
    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
    case METH_VARARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0))
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)meth)(self, arg, kw);
    case METH_NOARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 0))
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    case METH_O:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 1)) {
                PyObject *result, *arg0 = PySequence_ITEM(arg, 0);
                if (unlikely(!arg0)) return NULL;
                result = (*meth)(self, arg0);
                Py_DECREF(arg0);
                return result;
            }
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
}
static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
    PyObject *result;
    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
        Py_ssize_t argc;
        PyObject *new_args;
        PyObject *self;
        argc = PyTuple_GET_SIZE(args);
        new_args = PyTuple_GetSlice(args, 1, argc);
        if (unlikely(!new_args))
            return NULL;
        self = PyTuple_GetItem(args, 0);
        if (unlikely(!self)) {
            Py_DECREF(new_args);
            return NULL;
        }
        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
        Py_DECREF(new_args);
    } else {
        result = __Pyx_CyFunction_Call(func, args, kw);
    }
    return result;
}
static PyTypeObject __pyx_CyFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(__pyx_CyFunctionObject),
    0,
    (destructor) __Pyx_CyFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) __Pyx_CyFunction_repr,
    0,
    0,
    0,
    0,
    __Pyx_CyFunction_CallAsMethod,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) __Pyx_CyFunction_traverse,
    (inquiry) __Pyx_CyFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(__pyx_CyFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    __pyx_CyFunction_methods,
    __pyx_CyFunction_members,
    __pyx_CyFunction_getsets,
    0,
    0,
    __Pyx_CyFunction_descr_get,
    0,
    offsetof(__pyx_CyFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
};
static int __pyx_CyFunction_init(void) {
    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
    if (__pyx_CyFunctionType == NULL) {
        return -1;
    }
    return 0;
}
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults = PyObject_Malloc(size);
    if (!m->defaults)
        return PyErr_NoMemory();
    memset(m->defaults, 0, size);
    m->defaults_pyobjects = pyobjects;
    return m->defaults;
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_tuple = tuple;
    Py_INCREF(tuple);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_kwdict = dict;
    Py_INCREF(dict);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->func_annotations = dict;
    Py_INCREF(dict);
}

/* ClassMethod */
            static PyObject* __Pyx_Method_ClassMethod(PyObject *method) {
#if CYTHON_COMPILING_IN_PYPY
    if (PyObject_TypeCheck(method, &PyWrapperDescr_Type)) {
        return PyClassMethod_New(method);
    }
#else
#if CYTHON_COMPILING_IN_PYSTON
    if (PyMethodDescr_Check(method)) {
#else
    static PyTypeObject *methoddescr_type = NULL;
    if (methoddescr_type == NULL) {
       PyObject *meth = PyObject_GetAttrString((PyObject*)&PyList_Type, "append");
       if (!meth) return NULL;
       methoddescr_type = Py_TYPE(meth);
       Py_DECREF(meth);
    }
    if (PyObject_TypeCheck(method, methoddescr_type)) {
#endif
        PyMethodDescrObject *descr = (PyMethodDescrObject *)method;
        #if PY_VERSION_HEX < 0x03020000
        PyTypeObject *d_type = descr->d_type;
        #else
        PyTypeObject *d_type = descr->d_common.d_type;
        #endif
        return PyDescr_NewClassMethod(d_type, descr->d_method);
    }
#endif
    else if (PyMethod_Check(method)) {
        return PyClassMethod_New(PyMethod_GET_FUNCTION(method));
    }
    else if (PyCFunction_Check(method)) {
        return PyClassMethod_New(method);
    }
#ifdef __Pyx_CyFunction_USED
    else if (PyObject_TypeCheck(method, __pyx_CyFunctionType)) {
        return PyClassMethod_New(method);
    }
#endif
    PyErr_SetString(PyExc_TypeError,
                   "Class-level classmethod() can only be called on "
                   "a method_descriptor or instance method.");
    return NULL;
}

/* Py3ClassCreate */
              static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

/* BytesEquals */
              static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
    if (s1 == s2) {
        return (equals == Py_EQ);
    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
        const char *ps1, *ps2;
        Py_ssize_t length = PyBytes_GET_SIZE(s1);
        if (length != PyBytes_GET_SIZE(s2))
            return (equals == Py_NE);
        ps1 = PyBytes_AS_STRING(s1);
        ps2 = PyBytes_AS_STRING(s2);
        if (ps1[0] != ps2[0]) {
            return (equals == Py_NE);
        } else if (length == 1) {
            return (equals == Py_EQ);
        } else {
            int result;
#if CYTHON_USE_UNICODE_INTERNALS
            Py_hash_t hash1, hash2;
            hash1 = ((PyBytesObject*)s1)->ob_shash;
            hash2 = ((PyBytesObject*)s2)->ob_shash;
            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                return (equals == Py_NE);
            }
#endif
            result = memcmp(ps1, ps2, (size_t)length);
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
        return (equals == Py_NE);
    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
        return (equals == Py_NE);
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
#endif
}

/* UnicodeEquals */
              static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
#if PY_MAJOR_VERSION < 3
    PyObject* owned_ref = NULL;
#endif
    int s1_is_unicode, s2_is_unicode;
    if (s1 == s2) {
        goto return_eq;
    }
    s1_is_unicode = PyUnicode_CheckExact(s1);
    s2_is_unicode = PyUnicode_CheckExact(s2);
#if PY_MAJOR_VERSION < 3
    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
        owned_ref = PyUnicode_FromObject(s2);
        if (unlikely(!owned_ref))
            return -1;
        s2 = owned_ref;
        s2_is_unicode = 1;
    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
        owned_ref = PyUnicode_FromObject(s1);
        if (unlikely(!owned_ref))
            return -1;
        s1 = owned_ref;
        s1_is_unicode = 1;
    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
        return __Pyx_PyBytes_Equals(s1, s2, equals);
    }
#endif
    if (s1_is_unicode & s2_is_unicode) {
        Py_ssize_t length;
        int kind;
        void *data1, *data2;
        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
            return -1;
        length = __Pyx_PyUnicode_GET_LENGTH(s1);
        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
            goto return_ne;
        }
#if CYTHON_USE_UNICODE_INTERNALS
        {
            Py_hash_t hash1, hash2;
        #if CYTHON_PEP393_ENABLED
            hash1 = ((PyASCIIObject*)s1)->hash;
            hash2 = ((PyASCIIObject*)s2)->hash;
        #else
            hash1 = ((PyUnicodeObject*)s1)->hash;
            hash2 = ((PyUnicodeObject*)s2)->hash;
        #endif
            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                goto return_ne;
            }
        }
#endif
        kind = __Pyx_PyUnicode_KIND(s1);
        if (kind != __Pyx_PyUnicode_KIND(s2)) {
            goto return_ne;
        }
        data1 = __Pyx_PyUnicode_DATA(s1);
        data2 = __Pyx_PyUnicode_DATA(s2);
        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
            goto return_ne;
        } else if (length == 1) {
            goto return_eq;
        } else {
            int result = memcmp(data1, data2, (size_t)(length * kind));
            #if PY_MAJOR_VERSION < 3
            Py_XDECREF(owned_ref);
            #endif
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & s2_is_unicode) {
        goto return_ne;
    } else if ((s2 == Py_None) & s1_is_unicode) {
        goto return_ne;
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
return_eq:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_EQ);
return_ne:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_NE);
#endif
}

/* CLineInTraceback */
              static int __Pyx_CLineForTraceback(int c_line) {
#ifdef CYTHON_CLINE_IN_TRACEBACK
    return ((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0;
#else
    PyObject *use_cline;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
      use_cline = PyDict_GetItem(*cython_runtime_dict, __pyx_n_s_cline_in_traceback);
    } else
#endif
    {
      PyObject *ptype, *pvalue, *ptraceback;
      PyObject *use_cline_obj;
      PyErr_Fetch(&ptype, &pvalue, &ptraceback);
      use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        use_cline = NULL;
      }
      PyErr_Restore(ptype, pvalue, ptraceback);
    }
    if (!use_cline) {
        c_line = 0;
        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (PyObject_Not(use_cline) != 0) {
        c_line = 0;
    }
    return c_line;
#endif
}

/* CodeObjectCache */
              static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
              #include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntToPy */
              static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntFromPyVerify */
              #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntFromPy */
              static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntFromPy */
              static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* CoroutineBase */
              #include <structmember.h>
#include <frameobject.h>
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value);
static PyObject *__Pyx_Coroutine_Close(PyObject *self);
static PyObject *__Pyx_Coroutine_Throw(PyObject *gen, PyObject *args);
#define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
#if 1 || PY_VERSION_HEX < 0x030300B0
static int __Pyx_PyGen_FetchStopIterationValue(PyObject **pvalue) {
    PyObject *et, *ev, *tb;
    PyObject *value = NULL;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&et, &ev, &tb);
    if (!et) {
        Py_XDECREF(tb);
        Py_XDECREF(ev);
        Py_INCREF(Py_None);
        *pvalue = Py_None;
        return 0;
    }
    if (likely(et == PyExc_StopIteration)) {
        if (!ev) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#if PY_VERSION_HEX >= 0x030300A0
        else if (Py_TYPE(ev) == (PyTypeObject*)PyExc_StopIteration) {
            value = ((PyStopIterationObject *)ev)->value;
            Py_INCREF(value);
            Py_DECREF(ev);
        }
#endif
        else if (unlikely(PyTuple_Check(ev))) {
            if (PyTuple_GET_SIZE(ev) >= 1) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                value = PyTuple_GET_ITEM(ev, 0);
                Py_INCREF(value);
#else
                value = PySequence_ITEM(ev, 0);
#endif
            } else {
                Py_INCREF(Py_None);
                value = Py_None;
            }
            Py_DECREF(ev);
        }
        else if (!PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration)) {
            value = ev;
        }
        if (likely(value)) {
            Py_XDECREF(tb);
            Py_DECREF(et);
            *pvalue = value;
            return 0;
        }
    } else if (!PyErr_GivenExceptionMatches(et, PyExc_StopIteration)) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    PyErr_NormalizeException(&et, &ev, &tb);
    if (unlikely(!PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration))) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    Py_XDECREF(tb);
    Py_DECREF(et);
#if PY_VERSION_HEX >= 0x030300A0
    value = ((PyStopIterationObject *)ev)->value;
    Py_INCREF(value);
    Py_DECREF(ev);
#else
    {
        PyObject* args = __Pyx_PyObject_GetAttrStr(ev, __pyx_n_s_args);
        Py_DECREF(ev);
        if (likely(args)) {
            value = PySequence_GetItem(args, 0);
            Py_DECREF(args);
        }
        if (unlikely(!value)) {
            __Pyx_ErrRestore(NULL, NULL, NULL);
            Py_INCREF(Py_None);
            value = Py_None;
        }
    }
#endif
    *pvalue = value;
    return 0;
}
#endif
static CYTHON_INLINE
void __Pyx_Coroutine_ExceptionClear(__pyx_CoroutineObject *self) {
    PyObject *exc_type = self->exc_type;
    PyObject *exc_value = self->exc_value;
    PyObject *exc_traceback = self->exc_traceback;
    self->exc_type = NULL;
    self->exc_value = NULL;
    self->exc_traceback = NULL;
    Py_XDECREF(exc_type);
    Py_XDECREF(exc_value);
    Py_XDECREF(exc_traceback);
}
static CYTHON_INLINE
int __Pyx_Coroutine_CheckRunning(__pyx_CoroutineObject *gen) {
    if (unlikely(gen->is_running)) {
        PyErr_SetString(PyExc_ValueError,
                        "generator already executing");
        return 1;
    }
    return 0;
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value) {
    PyObject *retval;
    __Pyx_PyThreadState_declare
    assert(!self->is_running);
    if (unlikely(self->resume_label == 0)) {
        if (unlikely(value && value != Py_None)) {
            PyErr_SetString(PyExc_TypeError,
                            "can't send non-None value to a "
                            "just-started generator");
            return NULL;
        }
    }
    if (unlikely(self->resume_label == -1)) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    __Pyx_PyThreadState_assign
    if (value) {
#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
#else
        if (self->exc_traceback) {
            PyTracebackObject *tb = (PyTracebackObject *) self->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            Py_XINCREF(__pyx_tstate->frame);
            assert(f->f_back == NULL);
            f->f_back = __pyx_tstate->frame;
        }
#endif
        __Pyx_ExceptionSwap(&self->exc_type, &self->exc_value,
                            &self->exc_traceback);
    } else {
        __Pyx_Coroutine_ExceptionClear(self);
    }
    self->is_running = 1;
    retval = self->body((PyObject *) self, value);
    self->is_running = 0;
    if (retval) {
        __Pyx_ExceptionSwap(&self->exc_type, &self->exc_value,
                            &self->exc_traceback);
#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
#else
        if (self->exc_traceback) {
            PyTracebackObject *tb = (PyTracebackObject *) self->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            Py_CLEAR(f->f_back);
        }
#endif
    } else {
        __Pyx_Coroutine_ExceptionClear(self);
    }
    return retval;
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_MethodReturn(PyObject *retval) {
    if (unlikely(!retval && !PyErr_Occurred())) {
        PyErr_SetNone(PyExc_StopIteration);
    }
    return retval;
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_FinishDelegation(__pyx_CoroutineObject *gen) {
    PyObject *ret;
    PyObject *val = NULL;
    __Pyx_Coroutine_Undelegate(gen);
    __Pyx_PyGen_FetchStopIterationValue(&val);
    ret = __Pyx_Coroutine_SendEx(gen, val);
    Py_XDECREF(val);
    return ret;
}
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value) {
    PyObject *retval;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        {
            if (value == Py_None)
                ret = Py_TYPE(yf)->tp_iternext(yf);
            else
                ret = __Pyx_PyObject_CallMethod1(yf, __pyx_n_s_send, value);
        }
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        retval = __Pyx_Coroutine_FinishDelegation(gen);
    } else {
        retval = __Pyx_Coroutine_SendEx(gen, value);
    }
    return __Pyx_Coroutine_MethodReturn(retval);
}
static int __Pyx_Coroutine_CloseIter(__pyx_CoroutineObject *gen, PyObject *yf) {
    PyObject *retval = NULL;
    int err = 0;
    #ifdef __Pyx_Generator_USED
    if (__Pyx_Generator_CheckExact(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    #endif
    #ifdef __Pyx_Coroutine_USED
    if (__Pyx_Coroutine_CheckExact(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    #endif
    {
        PyObject *meth;
        gen->is_running = 1;
        meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_close);
        if (unlikely(!meth)) {
            if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                PyErr_WriteUnraisable(yf);
            }
            PyErr_Clear();
        } else {
            retval = PyObject_CallFunction(meth, NULL);
            Py_DECREF(meth);
            if (!retval)
                err = -1;
        }
        gen->is_running = 0;
    }
    Py_XDECREF(retval);
    return err;
}
static PyObject *__Pyx_Generator_Next(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Generator_Next(yf);
        } else
        #endif
            ret = Py_TYPE(yf)->tp_iternext(yf);
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        return __Pyx_Coroutine_FinishDelegation(gen);
    }
    return __Pyx_Coroutine_SendEx(gen, Py_None);
}
static PyObject *__Pyx_Coroutine_Close(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *retval, *raised_exception;
    PyObject *yf = gen->yieldfrom;
    int err = 0;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        Py_INCREF(yf);
        err = __Pyx_Coroutine_CloseIter(gen, yf);
        __Pyx_Coroutine_Undelegate(gen);
        Py_DECREF(yf);
    }
    if (err == 0)
        PyErr_SetNone(PyExc_GeneratorExit);
    retval = __Pyx_Coroutine_SendEx(gen, NULL);
    if (retval) {
        Py_DECREF(retval);
        PyErr_SetString(PyExc_RuntimeError,
                        "generator ignored GeneratorExit");
        return NULL;
    }
    raised_exception = PyErr_Occurred();
    if (!raised_exception
        || raised_exception == PyExc_StopIteration
        || raised_exception == PyExc_GeneratorExit
        || PyErr_GivenExceptionMatches(raised_exception, PyExc_GeneratorExit)
        || PyErr_GivenExceptionMatches(raised_exception, PyExc_StopIteration))
    {
        if (raised_exception) PyErr_Clear();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}
static PyObject *__Pyx_Coroutine_Throw(PyObject *self, PyObject *args) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *typ;
    PyObject *tb = NULL;
    PyObject *val = NULL;
    PyObject *yf = gen->yieldfrom;
    if (!PyArg_UnpackTuple(args, (char *)"throw", 1, 3, &typ, &val, &tb))
        return NULL;
    if (unlikely(__Pyx_Coroutine_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        Py_INCREF(yf);
        if (PyErr_GivenExceptionMatches(typ, PyExc_GeneratorExit)) {
            int err = __Pyx_Coroutine_CloseIter(gen, yf);
            Py_DECREF(yf);
            __Pyx_Coroutine_Undelegate(gen);
            if (err < 0)
                return __Pyx_Coroutine_MethodReturn(__Pyx_Coroutine_SendEx(gen, NULL));
            goto throw_here;
        }
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Throw(yf, args);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Throw(yf, args);
        } else
        #endif
        {
            PyObject *meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_throw);
            if (unlikely(!meth)) {
                Py_DECREF(yf);
                if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                    gen->is_running = 0;
                    return NULL;
                }
                PyErr_Clear();
                __Pyx_Coroutine_Undelegate(gen);
                gen->is_running = 0;
                goto throw_here;
            }
            ret = PyObject_CallObject(meth, args);
            Py_DECREF(meth);
        }
        gen->is_running = 0;
        Py_DECREF(yf);
        if (!ret) {
            ret = __Pyx_Coroutine_FinishDelegation(gen);
        }
        return __Pyx_Coroutine_MethodReturn(ret);
    }
throw_here:
    __Pyx_Raise(typ, val, tb, NULL);
    return __Pyx_Coroutine_MethodReturn(__Pyx_Coroutine_SendEx(gen, NULL));
}
static int __Pyx_Coroutine_traverse(PyObject *self, visitproc visit, void *arg) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    Py_VISIT(gen->closure);
    Py_VISIT(gen->classobj);
    Py_VISIT(gen->yieldfrom);
    Py_VISIT(gen->exc_type);
    Py_VISIT(gen->exc_value);
    Py_VISIT(gen->exc_traceback);
    return 0;
}
static int __Pyx_Coroutine_clear(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    Py_CLEAR(gen->closure);
    Py_CLEAR(gen->classobj);
    Py_CLEAR(gen->yieldfrom);
    Py_CLEAR(gen->exc_type);
    Py_CLEAR(gen->exc_value);
    Py_CLEAR(gen->exc_traceback);
    Py_CLEAR(gen->gi_name);
    Py_CLEAR(gen->gi_qualname);
    return 0;
}
static void __Pyx_Coroutine_dealloc(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject_GC_UnTrack(gen);
    if (gen->gi_weakreflist != NULL)
        PyObject_ClearWeakRefs(self);
    if (gen->resume_label > 0) {
        PyObject_GC_Track(self);
#if PY_VERSION_HEX >= 0x030400a1
        if (PyObject_CallFinalizerFromDealloc(self))
#else
        Py_TYPE(gen)->tp_del(self);
        if (self->ob_refcnt > 0)
#endif
        {
            return;
        }
        PyObject_GC_UnTrack(self);
    }
    __Pyx_Coroutine_clear(self);
    PyObject_GC_Del(gen);
}
static void __Pyx_Coroutine_del(PyObject *self) {
    PyObject *res;
    PyObject *error_type, *error_value, *error_traceback;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    __Pyx_PyThreadState_declare
    if (gen->resume_label <= 0)
        return ;
#if PY_VERSION_HEX < 0x030400a1
    assert(self->ob_refcnt == 0);
    self->ob_refcnt = 1;
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&error_type, &error_value, &error_traceback);
    res = __Pyx_Coroutine_Close(self);
    if (res == NULL)
        PyErr_WriteUnraisable(self);
    else
        Py_DECREF(res);
    __Pyx_ErrRestore(error_type, error_value, error_traceback);
#if PY_VERSION_HEX < 0x030400a1
    assert(self->ob_refcnt > 0);
    if (--self->ob_refcnt == 0) {
        return;
    }
    {
        Py_ssize_t refcnt = self->ob_refcnt;
        _Py_NewReference(self);
        self->ob_refcnt = refcnt;
    }
#if CYTHON_COMPILING_IN_CPYTHON
    assert(PyType_IS_GC(self->ob_type) &&
           _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
    _Py_DEC_REFTOTAL;
#endif
#ifdef COUNT_ALLOCS
    --Py_TYPE(self)->tp_frees;
    --Py_TYPE(self)->tp_allocs;
#endif
#endif
}
static PyObject *
__Pyx_Coroutine_get_name(__pyx_CoroutineObject *self)
{
    PyObject *name = self->gi_name;
    if (unlikely(!name)) name = Py_None;
    Py_INCREF(name);
    return name;
}
static int
__Pyx_Coroutine_set_name(__pyx_CoroutineObject *self, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_name;
    Py_INCREF(value);
    self->gi_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_Coroutine_get_qualname(__pyx_CoroutineObject *self)
{
    PyObject *name = self->gi_qualname;
    if (unlikely(!name)) name = Py_None;
    Py_INCREF(name);
    return name;
}
static int
__Pyx_Coroutine_set_qualname(__pyx_CoroutineObject *self, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_qualname;
    Py_INCREF(value);
    self->gi_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static __pyx_CoroutineObject *__Pyx__Coroutine_New(
            PyTypeObject* type, __pyx_coroutine_body_t body, PyObject *closure,
            PyObject *name, PyObject *qualname, PyObject *module_name) {
    __pyx_CoroutineObject *gen = PyObject_GC_New(__pyx_CoroutineObject, type);
    if (gen == NULL)
        return NULL;
    gen->body = body;
    gen->closure = closure;
    Py_XINCREF(closure);
    gen->is_running = 0;
    gen->resume_label = 0;
    gen->classobj = NULL;
    gen->yieldfrom = NULL;
    gen->exc_type = NULL;
    gen->exc_value = NULL;
    gen->exc_traceback = NULL;
    gen->gi_weakreflist = NULL;
    Py_XINCREF(qualname);
    gen->gi_qualname = qualname;
    Py_XINCREF(name);
    gen->gi_name = name;
    Py_XINCREF(module_name);
    gen->gi_modulename = module_name;
    PyObject_GC_Track(gen);
    return gen;
}

/* PatchModuleWithCoroutine */
                  static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    int result;
    PyObject *globals, *result_obj;
    globals = PyDict_New();  if (unlikely(!globals)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_coroutine_type",
    #ifdef __Pyx_Coroutine_USED
        (PyObject*)__pyx_CoroutineType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_generator_type",
    #ifdef __Pyx_Generator_USED
        (PyObject*)__pyx_GeneratorType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "_module", module) < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "__builtins__", __pyx_b) < 0)) goto ignore;
    result_obj = PyRun_String(py_code, Py_file_input, globals, globals);
    if (unlikely(!result_obj)) goto ignore;
    Py_DECREF(result_obj);
    Py_DECREF(globals);
    return module;
ignore:
    Py_XDECREF(globals);
    PyErr_WriteUnraisable(module);
    if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, "Cython module failed to patch module with custom type", 1) < 0)) {
        Py_DECREF(module);
        module = NULL;
    }
#else
    py_code++;
#endif
    return module;
}

/* PatchGeneratorABC */
                  #ifndef CYTHON_REGISTER_ABCS
#define CYTHON_REGISTER_ABCS 1
#endif
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
static PyObject* __Pyx_patch_abc_module(PyObject *module);
static PyObject* __Pyx_patch_abc_module(PyObject *module) {
    module = __Pyx_Coroutine_patch_module(
        module, ""
"if _cython_generator_type is not None:\n"
"    try: Generator = _module.Generator\n"
"    except AttributeError: pass\n"
"    else: Generator.register(_cython_generator_type)\n"
"if _cython_coroutine_type is not None:\n"
"    try: Coroutine = _module.Coroutine\n"
"    except AttributeError: pass\n"
"    else: Coroutine.register(_cython_coroutine_type)\n"
    );
    return module;
}
#endif
static int __Pyx_patch_abc(void) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    static int abc_patched = 0;
    if (CYTHON_REGISTER_ABCS && !abc_patched) {
        PyObject *module;
        module = PyImport_ImportModule((PY_VERSION_HEX >= 0x03030000) ? "collections.abc" : "collections");
        if (!module) {
            PyErr_WriteUnraisable(NULL);
            if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning,
                    ((PY_VERSION_HEX >= 0x03030000) ?
                        "Cython module failed to register with collections.abc module" :
                        "Cython module failed to register with collections module"), 1) < 0)) {
                return -1;
            }
        } else {
            module = __Pyx_patch_abc_module(module);
            abc_patched = 1;
            if (unlikely(!module))
                return -1;
            Py_DECREF(module);
        }
        module = PyImport_ImportModule("backports_abc");
        if (module) {
            module = __Pyx_patch_abc_module(module);
            Py_XDECREF(module);
        }
        if (!module) {
            PyErr_Clear();
        }
    }
#else
    if ((0)) __Pyx_Coroutine_patch_module(NULL, NULL);
#endif
    return 0;
}

/* Generator */
                  static PyMethodDef __pyx_Generator_methods[] = {
    {"send", (PyCFunction) __Pyx_Coroutine_Send, METH_O,
     (char*) PyDoc_STR("send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration.")},
    {"throw", (PyCFunction) __Pyx_Coroutine_Throw, METH_VARARGS,
     (char*) PyDoc_STR("throw(typ[,val[,tb]]) -> raise exception in generator,\nreturn next yielded value or raise StopIteration.")},
    {"close", (PyCFunction) __Pyx_Coroutine_Close, METH_NOARGS,
     (char*) PyDoc_STR("close() -> raise GeneratorExit inside generator.")},
    {0, 0, 0, 0}
};
static PyMemberDef __pyx_Generator_memberlist[] = {
    {(char *) "gi_running", T_BOOL, offsetof(__pyx_CoroutineObject, is_running), READONLY, NULL},
    {(char*) "gi_yieldfrom", T_OBJECT, offsetof(__pyx_CoroutineObject, yieldfrom), READONLY,
     (char*) PyDoc_STR("object being iterated by 'yield from', or None")},
    {0, 0, 0, 0, 0}
};
static PyGetSetDef __pyx_Generator_getsets[] = {
    {(char *) "__name__", (getter)__Pyx_Coroutine_get_name, (setter)__Pyx_Coroutine_set_name,
     (char*) PyDoc_STR("name of the generator"), 0},
    {(char *) "__qualname__", (getter)__Pyx_Coroutine_get_qualname, (setter)__Pyx_Coroutine_set_qualname,
     (char*) PyDoc_STR("qualified name of the generator"), 0},
    {0, 0, 0, 0, 0}
};
static PyTypeObject __pyx_GeneratorType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "generator",
    sizeof(__pyx_CoroutineObject),
    0,
    (destructor) __Pyx_Coroutine_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
    0,
    (traverseproc) __Pyx_Coroutine_traverse,
    0,
    0,
    offsetof(__pyx_CoroutineObject, gi_weakreflist),
    0,
    (iternextfunc) __Pyx_Generator_Next,
    __pyx_Generator_methods,
    __pyx_Generator_memberlist,
    __pyx_Generator_getsets,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#else
    __Pyx_Coroutine_del,
#endif
    0,
#if PY_VERSION_HEX >= 0x030400a1
    __Pyx_Coroutine_del,
#endif
};
static int __pyx_Generator_init(void) {
    __pyx_GeneratorType_type.tp_getattro = PyObject_GenericGetAttr;
    __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
    __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
    if (unlikely(!__pyx_GeneratorType)) {
        return -1;
    }
    return 0;
}

/* CheckBinaryVersion */
                  static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
                  static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            PyErr_Clear();
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if CYTHON_COMPILING_IN_CPYTHON && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
  #else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
  #endif
#else
  res = PyNumber_Int(x);
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(x);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
