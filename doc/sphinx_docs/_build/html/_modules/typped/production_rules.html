<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>typped.production_rules &#8212; Typped  documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="top" title="Typped  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for typped.production_rules</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">This module implements a nice frontend for parsing grammars using `EBNF</span>
<span class="sd">&lt;https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form&gt;`_-like Python</span>
<span class="sd">expressions.  The backend is the recursive-descent parsing capabilities of the</span>
<span class="sd">`PrattParser` class, implemented using precondition functions and null-string</span>
<span class="sd">token handlers.</span>

<span class="sd">Here are a few (but not all) similar Python parsing packages.  Some use string</span>
<span class="sd">representations of the grammar, while others use overloaded Python operators.</span>
<span class="sd">Most do not automatically produce a parse tree.</span>

<span class="sd">* **pyparsing** -- Uses Python overloading to define the grammar, similar to</span>
<span class="sd">  this module.</span>
<span class="sd">  http://pyparsing.wikispaces.com/home</span>

<span class="sd">* **Parsimonius** -- Passed a string containing the EBNF of the grammar and</span>
<span class="sd">  returns a parse tree.</span>
<span class="sd">  https://github.com/erikrose/parsimonious</span>

<span class="sd">* **Parsley** -- Passed a string containing the EBNF of the grammar.</span>
<span class="sd">  https://github.com/python-parsley/parsley/</span>

<span class="sd">* **yeanpypa** -- Uses Python overloading, similar to this module.</span>
<span class="sd">  https://github.com/DerNamenlose/yeanpypa</span>

<span class="sd">* **Lark** -- Passed a string. Implements Earley &amp; LALR(1) and returns a parse tree.</span>
<span class="sd">  https://github.com/erezsh/Lark</span>

<span class="sd">For more, see https://wiki.python.org/moin/LanguageParsing and</span>
<span class="sd">https://github.com/webmaven/python-parsing-tools.</span>

<span class="sd">Terminology and notation</span>
<span class="sd">========================</span>

<span class="sd">These terms are used in the description:</span>

<span class="sd">* **Production rules**</span>
<span class="sd">  are the individual rewrite rules such as `&lt;expression&gt; ::= &lt;term&gt;` in a BNF</span>
<span class="sd">  grammar.  They are also called **productions** or just **rules**.  The</span>
<span class="sd">  symbols on the l.h.s. of productions (which can also appear in the r.h.s.)</span>
<span class="sd">  are called **nonterminal symbols**.  The r.h.s of a production is called the</span>
<span class="sd">  **parsing expression**.  The r.h.s. of productions can contain terminal symbols,</span>
<span class="sd">  **nonterminal symbols** and perhaps other symbols such as the special</span>
<span class="sd">  **epsilon symbol** which matches an empty string. |br|</span>

<span class="sd">* Production rules with the the same l.h.s. nonterminal symbol will be referred to</span>
<span class="sd">  as different **cases** of the nonterminal symbol.  A common notation is</span>
<span class="sd">  to define multiple cases in one production rule expression by using the &quot;or&quot;</span>
<span class="sd">  symbol `|`.  This form of definition is currently *required* by this</span>
<span class="sd">  module.  That is, all the cases for any nonterminal must occur</span>
<span class="sd">  in a single expression, using `|` if there are multiple cases.  The ordered list</span>
<span class="sd">  of all the rule cases for a nonterminal will be called the **caselist** for</span>
<span class="sd">  the nonterminal.  Order matters for resolving ambiguity. |br|</span>

<span class="sd">* The separate symbol elements within a case will be collectively called the</span>
<span class="sd">  **items** of that case.  They include terminal symbols, nonterminal symbols,</span>
<span class="sd">  and possibly the epsilon symbol.  In this module there are no explicit</span>
<span class="sd">  terminal symbols.  Instead, terminals are either tokens (defined for the</span>
<span class="sd">  lexer and returned by it) or else consecutive sequences of tokens.</span>

<span class="sd">This is an example of a definition of a caselist with two cases in the Typped</span>
<span class="sd">EBNF-like code:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">   arglist = ( Rule(&quot;arg&quot;) + Tok(&quot;k_comma&quot;) + Rule(&quot;arglist&quot;)</span>
<span class="sd">             | Rule(&quot;arg&quot;)</span>
<span class="sd">             )</span>

<span class="sd">The tokens involved must already be defined (and the token itself can be used</span>
<span class="sd">in the rule instead of the label inside a call to ``Tok``).  The caselist for</span>
<span class="sd">``arg`` is not shown, but it could be defined before or after the ``arglist``</span>
<span class="sd">caselist.  The order in which the caselists of production rules are written</span>
<span class="sd">does not matter, so they can be written top-down, beginning with the</span>
<span class="sd">start-state nonterminal, or in any other convenient way.</span>

<span class="sd">Nonterminals are written as strings passed to ``Rule`` precisely so they can be</span>
<span class="sd">used in the r.h.s. of caselist definitions even when they have not yet been</span>
<span class="sd">defined.  They are resolved later when the `compile` method of the grammar is</span>
<span class="sd">called (passed the start nonterminal and the locals dict).  These r.h.s.</span>
<span class="sd">strings for nonterminals **must be identical** to the l.h.s. Python variable</span>
<span class="sd">names for the nonterminals (since they are looked up in the locals dict).</span>

<span class="sd">The order in which the cases of a nonterminal are defined within a caselist</span>
<span class="sd">*does* matter, at least for ambiguous grammars and to avoid or minimize</span>
<span class="sd">backtracking.  The order of the cases is the order in which the algorithm will</span>
<span class="sd">test the cases.  The first successful parse is returned.  In this sense the</span>
<span class="sd">grammar is similar to a **parsing expression grammar (PEG)** rather than a</span>
<span class="sd">**context-free grammar (CFG)**, which can be ambiguous.  See, e.g.,</span>
<span class="sd">https://en.wikipedia.org/wiki/Parsing_expression_grammar</span>

<span class="sd">Implementation</span>
<span class="sd">==============</span>

<span class="sd">This module is a work-in-progress.  As of now the syntactic Python interface</span>
<span class="sd">mostly all works, but not all of the features have been coded into the backend</span>
<span class="sd">&quot;compiling&quot; algorithm.  Currently it does basic BNF types production rules, but</span>
<span class="sd">not many EBNF extensions.  See the test file cases for examples.  Here is a</span>
<span class="sd">summary of what is implemented and what is not yet implemented.</span>

<span class="sd">Implemented:</span>

<span class="sd">   * Backtracking recursive descent search.</span>
<span class="sd">   * `Rule`</span>
<span class="sd">   * `Tok`</span>

<span class="sd">Not yet implemented:</span>

<span class="sd">   * `Prec` and precedences in productions</span>
<span class="sd">   * `Sig` type handling</span>
<span class="sd">   * `Pratt` calls to the Pratt parser</span>
<span class="sd">   * `Opt`</span>
<span class="sd">   * Repeated items (`OneOrMore`, `ZeroOrMore`, `Between`, etc.)</span>
<span class="sd">   * `Not`</span>
<span class="sd">   * `AnyOf`</span>
<span class="sd">   * `Hide`</span>
<span class="sd">   * LL(1) optimization</span>
<span class="sd">   * Epsilon production handling.</span>
<span class="sd">   * Undo compile in the `Grammar` class.</span>

<span class="sd">Wrapper functions</span>
<span class="sd">=================</span>

<span class="sd">Strings in the rule-defining expressions must be wrapped by some function call,</span>
<span class="sd">even though allowing the plain strings would be convenient for rules or for</span>
<span class="sd">using token labels instead of the token objects.  That would work in most</span>
<span class="sd">cases, but since addition is defined for strings it would not work for two</span>
<span class="sd">strings at the beginning of the expression.</span>

<span class="sd">Wrapper functions:</span>

<span class="sd">============   =========================== =============</span>
<span class="sd">Function       Arguments                   Shortcut</span>
<span class="sd">============   =========================== =============</span>
<span class="sd">`Rule`         rule-label (a string)</span>
<span class="sd">`Tok`          token                       token</span>
<span class="sd">`Root`         item</span>
<span class="sd">`Prec`         item, prec                  item[prec]</span>
<span class="sd">`Sig`          item, type sig              item(sig)</span>
<span class="sd">`Pratt`        (optional) pstate, type sig</span>
<span class="sd">`Opt`          item</span>
<span class="sd">`nExactly`     int, item                   n * item</span>
<span class="sd">`nOrMore`      int, item                   (n,) * item</span>
<span class="sd">`OneOrMore`    item                        (1,) * item</span>
<span class="sd">`ZeroOrMore`   item                        (0,) * item</span>
<span class="sd">`Between`      int, int, item              (m,n) * item</span>
<span class="sd">`Hide`         item</span>
<span class="sd">`Not`          item</span>
<span class="sd">`AnyOf`        itemlist</span>
<span class="sd">============   =========================== =============</span>

<span class="sd">Overloaded operator API</span>
<span class="sd">=======================</span>

<span class="sd">The basic objects that make up rule definitions are `Item` objects, `ItemList`</span>
<span class="sd">objects, and `CaseList` objects.  The latter two are just list-like objects</span>
<span class="sd">with most of the list operations overloaded.  An `ItemList` only holds `Item`</span>
<span class="sd">instances, and a `CaseList` only holds `ItemList` instances.  These objects do</span>
<span class="sd">not nest, and so they have some important differences from ordinary Python</span>
<span class="sd">lists.</span>

<span class="sd">The `ItemList` and `CaseList` classes are basically designed for concatenation</span>
<span class="sd">operations, since that is what is used to build up production rule expressions.</span>
<span class="sd">In their constructors they they both take an arbitrary number of arguments.</span>
<span class="sd">All the arguments are converted to elements of the single type that they hold.</span>
<span class="sd">The new instance then initially contains all those converted arguments as</span>
<span class="sd">elements.  When an `ItemList` is passed another `ItemList` in its initializer</span>
<span class="sd">argument list it just takes the elements within that list and puts them on its</span>
<span class="sd">list.  The `CaseList` class works similarly.</span>

<span class="sd">So the initializers basically form the concatenation of all the passed-in</span>
<span class="sd">arguments, after converting each one to the type of object that the list-like</span>
<span class="sd">object holds (each holds only one type of object).  The addition and &quot;or&quot;</span>
<span class="sd">operations are essentially shorthand for putting both operands on an</span>
<span class="sd">initializer list of the appropriate return type.  Appending to a list works the</span>
<span class="sd">same except it gives the in-place result of appending that item after</span>
<span class="sd">converting it.</span>

<span class="sd">Summary of the operations:</span>

<span class="sd">* **Addition**: Two `Item` and/or `ItemList` instances can be combined</span>
<span class="sd">  with `+`, which always returns an `ItemList`.  The operation is the same as</span>
<span class="sd">  if the operands had both been on the initializer list for `ItemList`.  The</span>
<span class="sd">  `+=` operator is also defined.  The addition operator is not defined for</span>
<span class="sd">  `CaseList` objects in order to possibly catch some syntax errors in</span>
<span class="sd">  expressions (although there are ordinary `add` and `iadd` methods). |br|</span>

<span class="sd">* **Case joining**: The &quot;or&quot; operation `|` is defined for `Item`,</span>
<span class="sd">  `ItemList`, or `CaseList` instances.  It always returns a `CaseList`.  The</span>
<span class="sd">  operands are joined together as if they had been arguments to the initializer</span>
<span class="sd">  of a `CaseList`. |br|</span>

<span class="sd">* **Tokens in expressions**: The `+` and `|` operators are defined for tokens</span>
<span class="sd">  (in the `PrattParser` module) to behave in the same way as for `Item`</span>
<span class="sd">  instances.  This allows the use of the tokens directly, without having to</span>
<span class="sd">  convert them into `Item` instances by wrapping them in the `Tok` function. |br|</span>

<span class="sd">* **Other list-like operations**: The methods `append` and</span>
<span class="sd">  `insert` are defined for these list-like classes.  They convert their</span>
<span class="sd">  argument to the correct type for the container and then append it to the list</span>
<span class="sd">  in-place.  Indexing of these list-like objects is also supported, including</span>
<span class="sd">  negative indices and slices.  This allows them to be iterated over.  They</span>
<span class="sd">  also have a `len`, so they can be tested for emptiness.</span>

<span class="sd">.. note::</span>

<span class="sd">   Since the `+` operator has a higher precedence than the `|` operator, all</span>
<span class="sd">   the additions within a case will always be carried-out before any &quot;or&quot;</span>
<span class="sd">   operations.  So each argument to `|` will be either a single token, a single</span>
<span class="sd">   `Item` or a single `ItemList`.</span>

<span class="sd">   Note that after a full expression containing these objects and operators is</span>
<span class="sd">   evaluated the resulting r.h.s. object (which is set to the l.h.s. variable</span>
<span class="sd">   name for a production rule) can be 1) a single token, 2) a single `Item`, 3)</span>
<span class="sd">   a single `ItemList`, or 4) a `CaseList`.  The `compile` method of a</span>
<span class="sd">   `Grammar` instance will always convert the value into a `CaseList` instance.</span>
<span class="sd">   (It would be possible to overload the `&lt;&lt;=` operator and use it instead of</span>
<span class="sd">   `=` to automatically do the conversion, but that does not seem worth the</span>
<span class="sd">   extra notation and boilerplate.)</span>

<span class="sd">Modifiers for items</span>
<span class="sd">===================</span>

<span class="sd">Items can have several begin/end modifiers to indicate when special processing</span>
<span class="sd">starts or ends.  These are stored in a list attribute called</span>
<span class="sd">`begin_end_modifiers`.  End modifiers are always the string &quot;)&quot;.  Begin</span>
<span class="sd">modifiers can be any of these (set by the corresponding function applied to the</span>
<span class="sd">Item or ItemList):</span>

<span class="sd">* `&quot;Opt(&quot;`</span>
<span class="sd">* `&quot;OneOrMore(&quot;`</span>
<span class="sd">* `&quot;ZeroOrMore(&quot;`</span>

<span class="sd">Operator precedences expressed in grammar</span>
<span class="sd">=========================================</span>

<span class="sd">In order to use Pratt-parser style operator precedences in a grammar two things</span>
<span class="sd">must be done.</span>

<span class="sd">1. The relevant items in a case of a production must be set to some nonzero</span>
<span class="sd">value.</span>

<span class="sd">2. The item before the expression (before the first argument) must be wrapped</span>
<span class="sd">in a special function.</span>

<span class="sd">To see how this works, consider these productions below, parsing the expressions</span>
<span class="sd">`x + y * z` (compared with `x * y + z`).</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    term = Regex()</span>

<span class="sd">    add = Head(Rule(&quot;term&quot;)) + Rule(&quot;operator&quot;)</span>

<span class="sd">    operator = Tail( k_add[20] + Rule(&quot;term&quot;)</span>
<span class="sd">                   | k_ast[40] + Rule(&quot;term&quot;)</span>
<span class="sd">                   )</span>

<span class="sd">1. The `add` production is somehow on the top of the `pstack` and</span>
<span class="sd">`recursive_parse(0)` is called.  This invokes the head-handler for the `add`</span>
<span class="sd">production (which is a handler for the null-string token with the precondition</span>
<span class="sd">that &quot;add&quot; is on top of the stack).</span>

<span class="sd">2. The head-handler for the `add` production then pushes `&quot;term&quot;` onto the</span>
<span class="sd">`pstack` and calls `recursive_parse(0)` to get the first argument.</span>

<span class="sd">3. The head-handler for the `term` rule is then invoked.  It fetches the</span>
<span class="sd">first term, which is `x` and returns it as a subtree leaf.</span>

<span class="sd">4. We are now back to the `add` handler, having gotten `x` as `processed_left`.</span>
<span class="sd">It now pops the `term` state and pushes the `operator` state onto the `pstack`.</span>
<span class="sd">It then calls `recursive_parse(0, processed_left)`, which runs as a</span>
<span class="sd">tail-handler.  Notice how the recursive descent handler for the `add`</span>
<span class="sd">production is essentially mimicking the `recursive_parse` routine but pushing</span>
<span class="sd">and popping states.</span>

<span class="sd">----&gt; Should the whole loop of recursive_parse run, or just one iteration</span>
<span class="sd">      when passed the explicit argument?????  As it is here, just one iteration?</span>
<span class="sd">      Could split up the head and tail parts as two functions... each loop</span>
<span class="sd">      iteration could be a function (but would be less efficient).</span>

<span class="sd">----&gt; Do we need any special wrappers like `Tail`?</span>

<span class="sd">5. The tail-handler for `k_add` is now called, since the `+` token was returned</span>
<span class="sd">by the lexer.  It pushes the state `term` and calls `recursive_parse(20,</span>
<span class="sd">processed_left`.</span>

<span class="sd">6. The head-handler for `term` calls `recursive_parse(0)`, which fetches the</span>
<span class="sd">token `y`.</span>

<span class="sd">7. HERE IS INTERESTING PART, iron out above and figure out how to make it</span>
<span class="sd">work...</span>

<span class="sd">So the expression `x + y * z` will be evalated as `x + (y*z)`.</span>

<span class="sd">Optimizing the grammar</span>
<span class="sd">======================</span>

<span class="sd">predictive parsing</span>
<span class="sd">------------------</span>

<span class="sd">In order to optimize the parsing of a recursive descent grammar, many</span>
<span class="sd">grammars allow the use of **predictive parsing**, which requires no</span>
<span class="sd">backtracking.  Even when predictive parsing is not possible, often</span>
<span class="sd">partial predictive parsing can make the algorithm more efficient</span>
<span class="sd">(falling back to backtracking search only when necessary).</span>

<span class="sd">To use a predicive parse you need to generate a **first set** for</span>
<span class="sd">each non-terminal (i.e., recursive rule call) in the grammar.  Call</span>
<span class="sd">this `first_set(nonterminal)`.</span>

<span class="sd">When epsilon productions are allowed a **follow set** acts similarly to</span>
<span class="sd">a first set.</span>

<span class="sd">See:</span>

<span class="sd">http://faculty.ycp.edu/~dhovemey/fall2010/cs340/lecture/lecture9.html</span>
<span class="sd">http://www.csd.uwo.ca/~moreno//CS447/Lectures/Syntax.html/node12.html</span>

<span class="sd">Maybe also consider packrat parsing:</span>
<span class="sd">https://en.wikipedia.org/wiki/Parsing_expression_grammar#Implementing_parsers_from_parsing_expression_grammars</span>

<span class="sd">grammar transformations</span>
<span class="sd">-----------------------</span>

<span class="sd">Not implemented.  Just an idea for now, but you could do any number of</span>
<span class="sd">grammar transformations on the rules of a `Grammar` object.</span>

<span class="sd">One possibility is to remove at least trivial left recursion.  Just change the</span>
<span class="sd">ordering of any obvious left recursive cases.</span>

<span class="sd">In a more complicated transformation you could do **left factoring** on the</span>
<span class="sd">grammar to remove the left recursion.</span>

<span class="sd">Consider curtailment of left recursion, too.  If it is going to repeat will it</span>
<span class="sd">repeat in n levels, where that is the number of rules?  What is the limit, etc.</span>
<span class="sd">See some of those articles and maybe do a simple thing.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># TODO: some simple example grammars for use in tests:</span>
<span class="c1">#    https://www.cs.rochester.edu/~nelson/courses/csc_173/grammars/cfg.html</span>
<span class="c1">#    https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form</span>

<span class="c1"># TODO: Make the call to external parser a user-settable thing (just as a</span>
<span class="c1"># module var, since developers not users would do it) and this becomes a</span>
<span class="c1"># general EBNF-like-Python-expression definition and parsing module.</span>
<span class="c1"># Most does not depend on the final parser.  Also some TokenNode dependencies.</span>

<span class="c1"># TODO really need a TokenList that works like an Item and can go on an</span>
<span class="c1"># itemlist.  They are the terminals, after all.  Also: 2 * (k_lpar + k_lpar)</span>
<span class="c1"># Does the modifier list stuff handle that OK?  What about an `Item` that holds</span>
<span class="c1"># a list of tokens, with addition of tokens producing an `Item`?  But how</span>
<span class="c1"># do `ItemList` and `CaseList` handle this?  What about just a postprocessing</span>
<span class="c1"># to gather them up or mark them somehow?  Could mark them as a TokenGroup(...)</span>
<span class="c1"># or similar.</span>

<span class="c1"># Interesting discussion of precedence in recursive descent.  Does this essentially</span>
<span class="c1"># use one of those methods (assume precedence is implemented)?</span>
<span class="c1"># http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">pytest_helper</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="s2">&quot;../../test/test_production_rules.py&quot;</span><span class="p">,</span>
                             <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">.shared_settings_and_exceptions</span> <span class="k">import</span> <span class="n">ParserException</span><span class="p">,</span> <span class="n">is_subclass_of</span><span class="p">,</span> <span class="n">is_class</span>

<span class="kn">from</span> <span class="nn">.pratt_types</span> <span class="k">import</span> <span class="n">TypeSig</span><span class="p">,</span> <span class="n">TypeObject</span><span class="p">,</span> <span class="n">NONE</span>
<span class="kn">from</span> <span class="nn">.lexer</span> <span class="k">import</span> <span class="n">TokenNode</span>
<span class="kn">from</span> <span class="nn">.register_grammar_with_parser</span> <span class="k">import</span> <span class="n">register_rule_handlers_with_parser</span>

<div class="viewcode-block" id="Grammar"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Grammar">[docs]</a><span class="k">class</span> <span class="nc">Grammar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An object representing a context-free grammar.  It is basically a</span>
<span class="sd">    dict of caselists indexed by nonterminal labels.  Provides various</span>
<span class="sd">    methods for processing the caselists.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delimiter</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># Could be static but Item would need moving.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_in_progress</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># To avoid infinite recurse in compile.</span>

<div class="viewcode-block" id="Grammar.compile"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Grammar.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_nonterm_label</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">locals_dict</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the Pratt parser handlers in `parser` to parse the current</span>
<span class="sd">        grammar.</span>

<span class="sd">        The `start_nonterm_label` is the starting nonterminal.  Only rules</span>
<span class="sd">        which are reachable from the rule cases for this starting nonterminal</span>
<span class="sd">        will be processed.</span>

<span class="sd">        The `parser` is a `PrattParser` instance.</span>

<span class="sd">        The `locals_dict` should be passed `locals=locals()`.  If you also need</span>
<span class="sd">        globals then you have to merge the `locals()` and `globals()` dicts</span>
<span class="sd">        (with locals overwriting) and pass that dict instead.</span>

<span class="sd">        If `register` is true the rules are registered with the `PrattParser`</span>
<span class="sd">        instance `parser` to enable it to parse the grammar.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Make sure we don&#39;t accidentally re-register something.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Reset all the caselists.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_in_progress</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_nonterm_label</span> <span class="o">=</span> <span class="n">start_nonterm_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locals_dict</span> <span class="o">=</span> <span class="n">locals_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_nonterm_caselist</span><span class="p">(</span><span class="n">start_nonterm_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_in_progress</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The final dict is</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">caselist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   </span><span class="si">{0}</span><span class="s2"> = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">caselist</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">register</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">caselist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">register_rule_handlers_with_parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_process_nonterm_caselist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonterm_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively process rules, converting string labels into their</span>
<span class="sd">        definitions from the locals dict, and looking up the tokens that go</span>
<span class="sd">        with token labels.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_in_progress</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nonterm_label</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">locals_caselist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locals_dict</span><span class="p">[</span><span class="n">nonterm_label</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;The rule </span><span class="se">\&quot;</span><span class="si">{0}</span><span class="se">\&quot;</span><span class="s2"> was not found&quot;</span>
                    <span class="s2">&quot; in the locals dict that was passed to the compile method&quot;</span>
                    <span class="s2">&quot; of the `Grammar` class.  Remember that the string passed&quot;</span>
                    <span class="s2">&quot; to the Rule function must correspond exactly to the name of a&quot;</span>
                    <span class="s2">&quot; Python varible on the l.h.s. of a definition.&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nonterm_label</span><span class="p">))</span>
        <span class="n">locals_caselist</span> <span class="o">=</span> <span class="n">CaseList</span><span class="p">(</span><span class="o">*</span><span class="n">locals_caselist</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;label of caselist being processed is&quot;</span><span class="p">,</span> <span class="n">nonterm_label</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;processing this caselist from locals():</span><span class="se">\n</span><span class="s2">   &quot;</span><span class="p">,</span> <span class="n">locals_caselist</span><span class="p">)</span>

        <span class="n">processed_caselist</span> <span class="o">=</span> <span class="n">CaseList</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">itemlist</span> <span class="ow">in</span> <span class="n">locals_caselist</span><span class="p">:</span>
            <span class="n">new_itemlist</span> <span class="o">=</span> <span class="n">ItemList</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">itemlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;token&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">item</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">get_token</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;nonterminal&quot;</span><span class="p">:</span>
                    <span class="n">recursion_nonterm_label</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">if</span> <span class="n">recursion_nonterm_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_in_progress</span><span class="p">:</span>
                        <span class="k">pass</span> <span class="c1"># Nonterminal is currently being processed.</span>
                    <span class="k">elif</span> <span class="n">recursion_nonterm_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_process_nonterm_caselist</span><span class="p">(</span><span class="n">recursion_nonterm_label</span><span class="p">)</span>
                <span class="n">new_itemlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">processed_caselist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_itemlist</span><span class="p">)</span>

        <span class="n">processed_caselist</span><span class="o">.</span><span class="n">grammar_object</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">processed_caselist</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span>
        <span class="n">processed_caselist</span><span class="o">.</span><span class="n">nonterm_label</span> <span class="o">=</span> <span class="n">nonterm_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span><span class="p">[</span><span class="n">nonterm_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_caselist</span>

        <span class="k">return</span> <span class="n">processed_caselist</span>

<div class="viewcode-block" id="Grammar.uncompile"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Grammar.uncompile">[docs]</a>    <span class="k">def</span> <span class="nf">uncompile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Undo the effect of the `compile` command.  Can be used for dynamic</span>
<span class="sd">        grammars, but NOT IMPLEMENTED YET.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not yet implemented&quot;</span><span class="p">)</span></div>

    <span class="c1">#def __iter__(self, rule_label):</span>
    <span class="c1">#    &quot;&quot;&quot;Generator to iteratively return the cases in production rule</span>
    <span class="c1">#    `rule_label`&quot;&quot;&quot;</span>
    <span class="c1">#    for rule in self.production_caselists[rule_label]:</span>
    <span class="c1">#        yield rule</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">production_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Access like a dict to get production rules from their labels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span><span class="p">[</span><span class="n">production_label</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonterm_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For use with the &#39;in&#39; keyword, like testing keys in a dict.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nonterm_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span>

    <span class="k">def</span> <span class="nf">_optimize_grammar_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do a search of the grammar tree and find lookahead tokens to</span>
<span class="sd">        make the parsing more efficient. Called from the `compile` method.</span>
<span class="sd">        NOT IMPLEMENTED.&quot;&quot;&quot;</span>
        <span class="c1"># In future optimizations this routine could search the tree the</span>
        <span class="c1"># grammar to find the tokens for, say LL(1) grammars which can be used</span>
        <span class="c1"># to avoid the backtracking by using a lookahead.  They are relayed</span>
        <span class="c1"># back up the CFG tree after a recursive search down.  After they are</span>
        <span class="c1"># found they can be passed to the Pratt null-string handler function.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not implemented.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_first_and_follow_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the first and follow sets for every case of every nonterminal.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">nonterm_label</span><span class="p">,</span> <span class="n">caselist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">production_caselists</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">caselist</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_set_first_sets</span><span class="p">(</span><span class="n">nonterm_label</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>
        <span class="c1"># TODO do follow sets separately, if done at all.</span>

    <span class="k">def</span> <span class="nf">_recursive_set_first_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonterm_label</span><span class="p">,</span> <span class="n">rule</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively compute the first set for each rule and store it with that</span>
<span class="sd">        rule object.&quot;&quot;&quot;</span>

        <span class="c1"># TODO Only partial implementation below.  Need to work out how to map</span>
        <span class="c1"># the concepts to a regex token based parser.  Suppose we base things</span>
        <span class="c1"># on the token label of the token returned by the lexer?</span>
        <span class="c1">#</span>
        <span class="c1"># To prune the tree based on lookahead we need to guarantee that all</span>
        <span class="c1"># the regexes are DISJOINT in the sense that their languages are</span>
        <span class="c1"># disjoint.  An intersection would disallow the pruning cutoff.  This</span>
        <span class="c1"># could still be interpreted in various ways.  The token labels,</span>
        <span class="c1"># though, could be used as a simple way to determine disjointness.</span>
        <span class="c1"># This would probably work in most cases, and the tokens could be</span>
        <span class="c1"># defined slightly differently if necessary...  Note that priorities</span>
        <span class="c1"># could also come into play...  In some sense the tokens ARE disjoint</span>
        <span class="c1"># in the sense that the lexer will uniquely choose one and not the other.</span>
        <span class="c1"># Is that sufficient here?</span>
        <span class="c1">#</span>
        <span class="c1"># Consider using the first token-literal label as the thing to compare</span>
        <span class="c1"># with.  This assumes one-token lookahead.  Can this be proved to work?</span>
        <span class="c1"># How about sequences of token-literal labels when multiple</span>
        <span class="c1"># token-literals start a rule, multiple token lookahead, etc?</span>

        <span class="c1"># See algorithm on this page:</span>
        <span class="c1"># http://faculty.ycp.edu/~dhovemey/fall2010/cs340/lecture/lecture9.html</span>
        <span class="c1"># http://www.csd.uwo.ca/~moreno/CS447/Lectures/Syntax.html/node12.html</span>
        <span class="c1">#</span>
        <span class="c1"># Note that epsilon is neither a terminal nor a nonterminal.  Terminals</span>
        <span class="c1"># cannot expand to epsilon.</span>
        <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">first_set</span> <span class="ow">and</span> <span class="n">rule</span><span class="o">.</span><span class="n">follow_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rule</span>

        <span class="n">rule</span><span class="o">.</span><span class="n">first_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">rule</span><span class="o">.</span><span class="n">expands_to_epsilon</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">rule</span><span class="o">.</span><span class="n">first_item_not_epsilon_expanding</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;epsilon&quot;</span><span class="p">:</span> <span class="c1"># Handle epsilon production.</span>
            <span class="k">pass</span> <span class="c1"># TODO, also raise exception if len not one, return.</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;nonterminal&quot;</span><span class="p">:</span>
                <span class="c1"># Recursively set the attributes of the subrule.</span>
                <span class="n">subrule_nonterm</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">value</span>
                <span class="k">if</span> <span class="n">subrule_nonterm</span> <span class="o">!=</span> <span class="n">nonterm_label</span><span class="p">:</span>
                    <span class="n">subrule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_first_and_follow_sets</span><span class="p">(</span><span class="n">subrule_nonterm</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Expand the first set with subrule&#39;s first set.</span>
                <span class="n">rule</span><span class="o">.</span><span class="n">first_set</span> <span class="o">|=</span> <span class="n">subrule</span><span class="o">.</span><span class="n">first_set</span>

                <span class="c1"># Handle epsilon stuff.</span>
                <span class="k">if</span> <span class="n">subrule</span><span class="o">.</span><span class="n">expands_to_epsilon</span><span class="p">:</span>
                    <span class="n">rule</span><span class="o">.</span><span class="n">expands_to_epsilon</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">subrule</span><span class="o">.</span><span class="n">expands_to_epsilon</span>
                        <span class="ow">and</span> <span class="n">rule</span><span class="o">.</span><span class="n">first_item_not_epsilon_expanding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">rule</span><span class="o">.</span><span class="n">first_item_not_epsilon_expanding</span> <span class="o">=</span> <span class="n">item</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1"># terminal (i.e., token)</span>
                <span class="n">rule</span><span class="o">.</span><span class="n">first_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="c1"># TODO should be token group....</span>
                <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">first_item_not_epsilon_expanding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rule</span><span class="o">.</span><span class="n">first_item_not_epsilon_expanding</span> <span class="o">=</span> <span class="n">item</span>

        <span class="c1"># Include epsilon-based first items.</span>
        <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">first_item_not_epsilon_expanding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rule</span><span class="o">.</span><span class="n">first_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EPSILON</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rule</span><span class="o">.</span><span class="n">first_set</span> <span class="o">|=</span> <span class="n">rule</span><span class="o">.</span><span class="n">first_item_not_epsilon_expanding</span>

        <span class="k">return</span> <span class="n">rule</span></div>

<div class="viewcode-block" id="Item"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Item">[docs]</a><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class representing the basic elements that make up the cases of the</span>
<span class="sd">    production rules.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an initial `Item` instance.  These plain `Item` instances are</span>
<span class="sd">        not used in expressions.  Before that they must be &quot;decorated&quot; by</span>
<span class="sd">        functions like `Tok` and `Rule` to set the `kind_of_item` attribute,</span>
<span class="sd">        and possibly others.</span>

<span class="sd">        If a string is passed in as the value it is assumed to be a nonterminal</span>
<span class="sd">        label.</span>

<span class="sd">        If a token is passed in it is converted to an `Item`.</span>

<span class="sd">        If an `Item` instance is passed in then its attributes will be copied</span>
<span class="sd">        to this instance.</span>

<span class="sd">        If no `value` is specified or value is `None` then a dummy `Item` is</span>
<span class="sd">        created, which must be processed further to be used in expressions.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Item</span><span class="p">):</span> <span class="c1"># Already was an Item, just copy attrs.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">root</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">prec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstate</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">pstate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">type_sig</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">modifiers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">kind_of_item</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pstate</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Things like &quot;Opt(&quot; and &quot;)&quot; added by funs.</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># A dummy Item; must be set to something else to be used.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="s2">&quot;dummy&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># A string nonterminal label, unless the Tok function resets it.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="s2">&quot;nonterminal&quot;</span>
        <span class="k">elif</span> <span class="n">is_subclass_of</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">TokenNode</span><span class="p">):</span> <span class="c1"># A token.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="s2">&quot;token&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Unrecognized case item: </span><span class="si">{0}</span><span class="s2">&quot;</span>
                                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="c1"># No longer used; lists with [...] will be optional sections.</span>
        <span class="sd">&quot;&quot;&quot;Use bracket-indexing as a shortcut for the `Prec` function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Prec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_sig</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use function call as a synonym for the `Sig` function.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: consider changing so that the arguments are automatically</span>
        <span class="c1"># passed to type_sig... since it will always be one.  But if it is</span>
        <span class="c1"># already one, then just use that (check isinstance).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="n">type_sig</span>
        <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_sig</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Item(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;token&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">token_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">token_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">token_label</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Tok(</span><span class="se">\&quot;</span><span class="si">{0}</span><span class="se">\&quot;</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">token_label</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;nonterminal&quot;</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Rule(</span><span class="se">\&quot;</span><span class="si">{0}</span><span class="se">\&quot;</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;pratt_call&quot;</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Pratt(</span><span class="se">\&quot;</span><span class="si">{0}</span><span class="se">\&quot;</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="o">.</span><span class="n">val_type</span><span class="o">.</span><span class="n">type_label</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">NONE</span><span class="p">:</span> <span class="n">val</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="n">arg_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="o">.</span><span class="n">arg_types</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">,</span> <span class="n">TypeObject</span><span class="p">):</span>
                <span class="n">arg_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="o">.</span><span class="n">arg_types</span><span class="o">.</span><span class="n">type_label</span>
                <span class="k">if</span> <span class="n">arg_list</span> <span class="o">==</span> <span class="n">NONE</span><span class="p">:</span> <span class="n">arg_list</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">type_label</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">type_label</span> <span class="o">!=</span> <span class="n">NONE</span>
                                         <span class="k">else</span> <span class="s2">&quot;None&quot;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">arg_list</span><span class="p">]</span>
                <span class="n">arg_list</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
            <span class="n">sig_string</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg_list</span><span class="p">)</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prec</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;[</span><span class="si">{0}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;Root(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span> <span class="n">string</span> <span class="o">+=</span> <span class="n">m</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">string</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">string</span>
        <span class="k">return</span> <span class="n">string</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload `+` from the left operand.&quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">right_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ItemList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">right_other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload `+` from the right operand.&quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">left_other</span><span class="p">)</span> <span class="o">+</span> <span class="n">ItemList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload `|` from the left operand.&quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">right_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">|</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">right_other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload `|` from the right operand.&quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">left_other</span><span class="p">)</span> <span class="o">|</span> <span class="n">CaseList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The expression `n*item` for an int `n` is &quot;n occurrences of&quot; `item`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Repeat</span><span class="p">(</span><span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload the prefix operator &#39;~&#39;.&quot;&quot;&quot;</span>
        <span class="c1"># TODO, raise_if_not doesn&#39;t work yet for unary operators.</span>
        <span class="k">return</span> <span class="n">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="ItemList"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.ItemList">[docs]</a><span class="k">class</span> <span class="nc">ItemList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A list of `Item` instances.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an `ItemList` with one or more items.  The arguments</span>
<span class="sd">        can include `Item` instances, `ItemList` instances, and `TokenNode`</span>
<span class="sd">        subclasses.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_subclass_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">TokenNode</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Item</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data_list</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Unknown type in initializer to&quot;</span>
                        <span class="s2">&quot; ItemList class.  Object is: </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<div class="viewcode-block" id="ItemList.append"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.ItemList.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append an item to the list.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="n">item</span><span class="p">))</span></div>

<div class="viewcode-block" id="ItemList.insert"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.ItemList.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert an item.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Item</span><span class="p">(</span><span class="n">item</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Index an element of the `ItemList`.  Negative indices are implemented,</span>
<span class="sd">        but slices are not.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an element of the `ItemList`.  Negative indices are implemented,</span>
<span class="sd">        but slices are not.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Item</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">right_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Overload `+` from the left operand.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ItemList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Overload `+` from the right operand.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload `+=` operation.&quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span> <span class="o">+=</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">data_list</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">right_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Overload `|` from the left operand.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">|</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">right_other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Overload `|` from the right operand.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">left_other</span><span class="p">)</span> <span class="o">|</span> <span class="n">CaseList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The expression `n*itemlist` for an int `n` is &quot;n occurrences of&quot;</span>
<span class="sd">        `itemlist`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Repeat</span><span class="p">(</span><span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ItemList(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">]))</span></div>

<div class="viewcode-block" id="CaseList"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.CaseList">[docs]</a><span class="k">class</span> <span class="nc">CaseList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A list of `Case` objects.  Note, though, that a single Item or ItemList can</span>
<span class="sd">    also be a case (when there are no &quot;or&quot; operations to form the case).&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take an arbitrary number of `ItemList` arguments and make a `CaseList`</span>
<span class="sd">        out of them.  Arguments can include `Item` instances and `TokenNode`</span>
<span class="sd">        subclasses.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_subclass_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">TokenNode</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ItemList</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Item</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ItemList</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Unknown type in initializer to&quot;</span>
                        <span class="s2">&quot; CaseList class.  Object is: </span><span class="si">{0}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

<div class="viewcode-block" id="CaseList.append"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.CaseList.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append an item to the list.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ItemList</span><span class="p">(</span><span class="n">item</span><span class="p">))</span></div>

<div class="viewcode-block" id="CaseList.insert"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.CaseList.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert an item.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">item</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Index and element of the `ItemList`.  Negative indices are implemented,</span>
<span class="sd">        but slices are not.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an element of the `ItemList`.  Negative indices are implemented,</span>
<span class="sd">        but slices are not.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">index</span><span class="o">.</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ItemList</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handle negative indices.</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

<div class="viewcode-block" id="CaseList.add"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.CaseList.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a `CaseList` to some other object, which must be convertable to</span>
<span class="sd">        a `CaseList`.  This method is purposely not overloaded with the operator</span>
<span class="sd">        `+` because that operator is used in the production rule strings for</span>
<span class="sd">        `ItemList` objects, but in that context is an error if applied to</span>
<span class="sd">        `CaseList` objects.&quot;&quot;&quot;</span>
        <span class="c1"># Note this doesn&#39;t add in-place.  Returns a new one.</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="CaseList.iadd"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.CaseList.iadd">[docs]</a>    <span class="k">def</span> <span class="nf">iadd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a `CaseList` to some other object, in place.  Like `add` but in-place.&quot;&quot;&quot;</span>
        <span class="c1"># Note this doesn&#39;t add in-place.  Returns a new one.</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span> <span class="o">+=</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">data_list</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">right_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="c1"># Error to add CaseLists.</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span> <span class="c1"># Error to add CaseLists.</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">raise_if_not</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;+=&quot;</span><span class="p">)</span> <span class="c1"># Error to add CaseLists.</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload `|` from the left operand.&quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">right_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right_other</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">|</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">right_other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right_other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload `|` from the right operand.&quot;&quot;&quot;</span>
        <span class="n">raise_if_not</span><span class="p">([</span><span class="n">Item</span><span class="p">,</span> <span class="n">ItemList</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">],</span> <span class="p">[</span><span class="n">TokenNode</span><span class="p">],</span> <span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left_other</span><span class="p">,</span> <span class="n">CaseList</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">left_other</span><span class="p">)</span> <span class="o">|</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">CaseList</span><span class="p">(</span><span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left_other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The expression `n*caselist` for an int `n` is &quot;n occurrences of&quot;</span>
<span class="sd">        `caselist`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Repeat</span><span class="p">(</span><span class="n">left_other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;CaseList(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_list</span><span class="p">]))</span></div>

<span class="c1">#</span>
<span class="c1"># Define some special items.</span>
<span class="c1">#</span>

<span class="n">EPSILON</span> <span class="o">=</span> <span class="n">Item</span><span class="p">()</span> <span class="c1"># For an epsilon production, item expands to empty string.</span>
<span class="n">EPSILON</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;epsilon&quot;</span>

<span class="n">DOLLAR</span> <span class="o">=</span> <span class="n">Item</span><span class="p">()</span> <span class="c1"># Dollar sign, matches end of text, i.e., end-token.</span>
<span class="n">DOLLAR</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="s2">&quot;dollar&quot;</span>

<span class="c1">#</span>
<span class="c1"># Define wrapper functions.</span>
<span class="c1">#</span>

<div class="viewcode-block" id="Rule"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Rule">[docs]</a><span class="k">def</span> <span class="nf">Rule</span><span class="p">(</span><span class="n">nonterm_label</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an `Item` to represent the nonterminal with the string label</span>
<span class="sd">    `nonterm_label`.&quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">nonterm_label</span><span class="p">)</span>
    <span class="n">item</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="s2">&quot;nonterminal&quot;</span>
    <span class="k">return</span> <span class="n">item</span></div>

<div class="viewcode-block" id="Tok"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Tok">[docs]</a><span class="k">def</span> <span class="nf">Tok</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Turn a token into an item.  Used before overloading defined on tokens.</span>
<span class="sd">    Can be passed a token object or a string token label.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_subclass_of</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">TokenNode</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Bad argument </span><span class="si">{0}</span><span class="s2"> passed to the&quot;</span>
                <span class="s2">&quot; Tok function.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="n">item</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="s2">&quot;token&quot;</span>
    <span class="k">return</span> <span class="n">item</span></div>

<div class="viewcode-block" id="Root"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Root">[docs]</a><span class="k">def</span> <span class="nf">Root</span><span class="p">(</span><span class="n">item_init_arg</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A function to designate that the token for the item should made into the</span>
<span class="sd">    root of the resulting parse subtree, if possible.&quot;&quot;&quot;</span>
    <span class="c1"># This can only be called once per case, and can only take one `Item` argument.</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">item_init_arg</span><span class="p">)</span>
    <span class="n">item</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">item</span></div>

<div class="viewcode-block" id="Prec"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Prec">[docs]</a><span class="k">def</span> <span class="nf">Prec</span><span class="p">(</span><span class="n">item_init_arg</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the operator precedence when called from a tail handler.  Can only</span>
<span class="sd">    wrap an item.&quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">item_init_arg</span><span class="p">)</span>
    <span class="n">item</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="k">return</span> <span class="n">item</span></div>

<div class="viewcode-block" id="Sig"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Sig">[docs]</a><span class="k">def</span> <span class="nf">Sig</span><span class="p">(</span><span class="n">item_init_arg</span><span class="p">,</span> <span class="n">type_sig</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the type signature for an item.&quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">item_init_arg</span><span class="p">)</span>
    <span class="n">item</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="n">type_sig</span>
    <span class="k">return</span> <span class="n">item</span></div>

<div class="viewcode-block" id="Pratt"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Pratt">[docs]</a><span class="k">def</span> <span class="nf">Pratt</span><span class="p">(</span><span class="n">pstate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">type_sig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Todo: type_sig no longer needed, but doesn&#39;t hurt.</span>
    <span class="sd">&quot;&quot;&quot;Use an ordinary Pratt parser `recursive_parse` to get a subexpression.</span>
<span class="sd">    The paramter `pstate` is a state that will be temporarily pushed on the</span>
<span class="sd">    `pstate_stack` during the parsing (which can be used as a precondition).</span>
<span class="sd">    The optional type signature can also be set to be checked.&quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">()</span>
    <span class="n">item</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">=</span> <span class="s2">&quot;pratt_call&quot;</span>
    <span class="n">item</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="n">type_sig</span>
    <span class="n">item</span><span class="o">.</span><span class="n">pstate</span> <span class="o">=</span> <span class="n">pstate</span>
    <span class="k">return</span> <span class="n">item</span></div>

<div class="viewcode-block" id="Opt"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Opt">[docs]</a><span class="k">def</span> <span class="nf">Opt</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="n">itemlist</span> <span class="o">=</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">itemlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Opt(&quot;</span><span class="p">)</span>
    <span class="n">itemlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">itemlist</span></div>

<div class="viewcode-block" id="Repeat"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Repeat">[docs]</a><span class="k">def</span> <span class="nf">Repeat</span><span class="p">(</span><span class="n">range_spec</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used to process overload of multiplication for repetition.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_spec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_spec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#return nOrMore(range_spec[0], arg)</span>
            <span class="n">range_spec</span> <span class="o">=</span> <span class="p">[</span><span class="n">range_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_spec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1">#return Between(range_spec[0], range_spec[1], arg)</span>
            <span class="n">range_spec</span> <span class="o">=</span> <span class="p">[</span><span class="n">range_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Tuple or list must contain one or two integers.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_spec</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1">#return nExactly(range_spec, arg)</span>
        <span class="n">range_spec</span> <span class="o">=</span> <span class="p">[</span><span class="n">range_spec</span><span class="p">,</span> <span class="n">range_spec</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Can only multiply by an int, tuple, or list.&quot;</span><span class="p">)</span>

    <span class="n">itemlist</span> <span class="o">=</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">itemlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Repeat(</span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1}</span><span class="s2">, &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">range_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">itemlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">itemlist</span></div>


<div class="viewcode-block" id="nExactly"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.nExactly">[docs]</a><span class="k">def</span> <span class="nf">nExactly</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Repeat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span></div>

<div class="viewcode-block" id="nOrMore"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.nOrMore">[docs]</a><span class="k">def</span> <span class="nf">nOrMore</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Repeat</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">arg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Between"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Between">[docs]</a><span class="k">def</span> <span class="nf">Between</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Repeat</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">arg</span><span class="p">)</span></div>

<div class="viewcode-block" id="OneOrMore"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.OneOrMore">[docs]</a><span class="k">def</span> <span class="nf">OneOrMore</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Repeat</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">arg</span><span class="p">)</span></div>

<div class="viewcode-block" id="ZeroOrMore"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.ZeroOrMore">[docs]</a><span class="k">def</span> <span class="nf">ZeroOrMore</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Repeat</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">arg</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hide"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Hide">[docs]</a><span class="k">def</span> <span class="nf">Hide</span><span class="p">(</span><span class="n">itemlist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Do not show the items in the final tree.  For example, parentheses can</span>
<span class="sd">    be ignored in function argument lists.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not yet implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Not"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.Not">[docs]</a><span class="k">def</span> <span class="nf">Not</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The token cannot appear or the case fails.&quot;&quot;&quot;</span>
    <span class="n">itemlist</span> <span class="o">=</span> <span class="n">ItemList</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">kind_of_item</span> <span class="o">==</span> <span class="s2">&quot;token&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itemlist</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Only tokens can appear inside Not(...).&quot;</span><span class="p">)</span>
    <span class="n">itemlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Not(&quot;</span><span class="p">)</span>
    <span class="n">itemlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">modifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">itemlist</span></div>

<div class="viewcode-block" id="AnyOf"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.AnyOf">[docs]</a><span class="k">def</span> <span class="nf">AnyOf</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Maybe, give you a choice of possibilities from several.  Same as &quot;Or&quot; but</span>
    <span class="c1"># maybe a little more descriptive.</span>
    <span class="k">pass</span></div>

<span class="c1">#</span>
<span class="c1"># Utility functions.</span>
<span class="c1">#</span>

<div class="viewcode-block" id="raise_if_not"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.raise_if_not">[docs]</a><span class="k">def</span> <span class="nf">raise_if_not</span><span class="p">(</span><span class="n">instanceof_list</span><span class="p">,</span> <span class="n">issubclass_list</span><span class="p">,</span> <span class="n">operand_or_arg</span><span class="p">,</span> <span class="n">calling_instance</span><span class="p">,</span>
                 <span class="n">operator_or_method_string</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;op&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error-checking routine called from overloaded operators.  If `operand_or_arg`</span>
<span class="sd">    is not an instance a class in `instanceof_list` or a subclass of a class in</span>
<span class="sd">    `issubclass_list` then raise a `ParserGrammarRuleException` with a helpful</span>
<span class="sd">    error message.</span>

<span class="sd">    If `kind` is `&quot;op&quot;` the message is for an operator.  If it is `&quot;method&quot;`</span>
<span class="sd">    then the message is for a method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">operand_or_arg</span><span class="p">,</span> <span class="n">classname</span><span class="p">)</span> <span class="k">for</span> <span class="n">classname</span> <span class="ow">in</span> <span class="n">instanceof_list</span><span class="p">]):</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">is_subclass_of</span><span class="p">(</span><span class="n">operand_or_arg</span><span class="p">,</span> <span class="n">classname</span><span class="p">)</span> <span class="k">for</span> <span class="n">classname</span> <span class="ow">in</span> <span class="n">issubclass_list</span><span class="p">]):</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">is_class</span><span class="p">(</span><span class="n">operand_or_arg</span><span class="p">):</span>
        <span class="n">operand_string</span> <span class="o">=</span> <span class="s2">&quot;class &quot;</span> <span class="o">+</span> <span class="n">operand_or_arg</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">operand_string</span> <span class="o">=</span> <span class="s2">&quot;instances of class &quot;</span> <span class="o">+</span> <span class="n">operand_or_arg</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;op&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Overloading of operator &#39;</span><span class="si">{0}</span><span class="s2">&#39; is not&quot;</span>
                <span class="s2">&quot; defined between </span><span class="si">{1}</span><span class="s2"> and instances of class </span><span class="si">{2}</span><span class="s2">.  The two&quot;</span>
                <span class="s2">&quot; operands are </span><span class="si">{3}</span><span class="s2"> and </span><span class="si">{4}</span><span class="s2">.&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator_or_method_string</span><span class="p">,</span> <span class="n">operand_string</span><span class="p">,</span>
                        <span class="n">calling_instance</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                        <span class="n">calling_instance</span><span class="p">,</span> <span class="n">operand_or_arg</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="c1"># TODO this isn&#39;t tested.</span>
        <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Method &#39;</span><span class="si">{0}</span><span class="s2">&#39; of </span><span class="si">{1}</span><span class="s2"> is not&quot;</span>
                <span class="s2">&quot; defined for arguments that are </span><span class="si">{1}</span><span class="s2">.&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator_or_method_string</span><span class="p">,</span>
                        <span class="n">calling_instance</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">operand_string</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParserGrammarRuleException</span><span class="p">(</span><span class="s2">&quot;Bad flag to raise_if_not.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="print_indented_caselist"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.print_indented_caselist">[docs]</a><span class="k">def</span> <span class="nf">print_indented_caselist</span><span class="p">(</span><span class="n">string_before</span><span class="p">,</span> <span class="n">caselist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print routine for debugging.&quot;&quot;&quot;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">string_before</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Caselist(</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">string2</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">case</span> <span class="ow">in</span> <span class="n">caselist</span><span class="p">:</span>
        <span class="n">string2</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">case</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">string2</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="n">string2</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">)&quot;</span> <span class="c1"># Lose last comma, close paren.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span></div>

<span class="c1">#</span>
<span class="c1"># Exceptions.</span>
<span class="c1">#</span>

<div class="viewcode-block" id="ParserGrammarRuleException"><a class="viewcode-back" href="../../typped.production_rules.html#typped.production_rules.ParserGrammarRuleException">[docs]</a><span class="k">class</span> <span class="nc">ParserGrammarRuleException</span><span class="p">(</span><span class="n">ParserException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised by grammar classes.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>