
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>typped.regex_trie_dict &#8212; Typped  documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for typped.regex_trie_dict</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Introduction to `RegexTrieDict`</span>
<span class="sd">===============================</span>

<span class="sd">The `RegexTrieDict` class is a subclass of `TrieDict` which adds</span>
<span class="sd">pattern-matching capabilities.  To use these capabilities, you first create a</span>
<span class="sd">key which contains some special meta-elements (which are meta-characters when</span>
<span class="sd">the keys are strings).  Then you insert that key (meta-key) and an associated</span>
<span class="sd">value into the `RegexTrieDict`.  These meta-keys are treated simply as ordinary</span>
<span class="sd">keys by the usual `TrieDict` operations.  The `RegexTrieDict` adds some special</span>
<span class="sd">methods, `has_key_meta` and `get_meta`, which interpret the meta-keys as</span>
<span class="sd">regex patterns on queries, rather than treating them as ordinary saved items.</span>

<span class="sd">The `RegexTrieDict` class implements a full (though bare-bones) regex</span>
<span class="sd">pattern-matching language.  The syntax of the language is slightly modified due</span>
<span class="sd">to the tree structure in which the patterns are stored.  Basically, the special</span>
<span class="sd">characters are made into prefix operators rather than postfix operators so that</span>
<span class="sd">they are encountered first when going down the trie from the root.  The syntax</span>
<span class="sd">is described in a later section.  It implements a subset of the many features</span>
<span class="sd">of the built-in Python regex module.</span>

<span class="sd">The pattern match for a call to `has_key_meta` with a single pattern in the</span>
<span class="sd">trie is close to the function/method `fullmatch` in the Python regex module</span>
<span class="sd">(modulo the minor syntactic variation).  Equivalently, it is as if all the</span>
<span class="sd">Python regex patterns start with `^` and end with `$`.  The key that is queried</span>
<span class="sd">must match the full pattern, from beginning to end, in order to return a value</span>
<span class="sd">that evaluates `True`.</span>

<span class="sd">The actual value returned by `has_key_meta` is the number of matches against</span>
<span class="sd">patterns in the trie.  When the trie contains multiple regex patterns the query</span>
<span class="sd">key is tested against all the patterns in it; the result is like a giant &quot;or&quot;</span>
<span class="sd">against all the stored patterns.</span>

<span class="sd">The `get` method of a `RegexTrieDict` is like the corresponding method of an</span>
<span class="sd">ordinary Python `dict` in that it returns any data elements which were stored</span>
<span class="sd">with the matching patterns in the trie.  The difference is that it can return</span>
<span class="sd">more than one match.  If you need the data stored with matches then call this</span>
<span class="sd">instead of `has_key_meta`.  You can check for the number of matches by</span>
<span class="sd">looking at the `len` of the returned deque.</span>

<span class="sd">There is no method to get the actual matching patterns themselves, but since</span>
<span class="sd">the query keys must match from beginning to end they are always known</span>
<span class="sd">beforehand.</span>

<span class="sd">Terminology</span>
<span class="sd">===========</span>

<span class="sd">The system is defined to be very general, working on **sequences** made up of</span>
<span class="sd">**elements**.  Sequences are just iterable objects which return some fixed,</span>
<span class="sd">hashable kind of object as elements when iterated over.  Both the stored regex</span>
<span class="sd">patterns and the query keys are sequences.</span>

<span class="sd">The most common case is that the sequences are Python strings, and the elements</span>
<span class="sd">are the characters of the strings.  In reading the documentation it can be</span>
<span class="sd">helpful to think of the example where sequences=strings and</span>
<span class="sd">elements=characters.  Sequences do not need to be strings, however.  For</span>
<span class="sd">example, the sequences could be lists of strings.  In that case the elements</span>
<span class="sd">would be the strings in those lists.  Regex patterns would then be lists of</span>
<span class="sd">strings with certain of those strings designated as escape elements and the</span>
<span class="sd">pattern-defining elements such as parentheses, the repetition &quot;*&quot;, and so</span>
<span class="sd">forth.</span>

<span class="sd">Meta-methods</span>
<span class="sd">============</span>

<span class="sd">As mentioned above, the `RegexTrieDict` adds some methods to the ordinary</span>
<span class="sd">`TrieDict` to allow for keys stored in the dict to be intepreted at a</span>
<span class="sd">meta-level, as regex patterns.  The two main methods are `has_key_meta` and</span>
<span class="sd">`get_meta`.</span>

<span class="sd">Every `RegexTrieDict` is also a `TrieDict`, and items can be stored in and</span>
<span class="sd">retrieved from it using the methods of the `TrieDict` class.  A `RegexTrieDict`</span>
<span class="sd">used for pattern matching is basically a `TrieDict` which has had regex</span>
<span class="sd">patterns inserted into it as the &quot;ordinary&quot; keys.  It then provides special</span>
<span class="sd">meta-methods which interpret those stored keys as regex patterns during</span>
<span class="sd">queries, rather than as ordinary sequences.</span>

<span class="sd">The `has_key_meta` and `get_meta` methods take ordinary sequences as arguments,</span>
<span class="sd">i.e., they to not take pattern-sequences as arguments.  Instead, they match the</span>
<span class="sd">ordinary sequence as a key against the patterns in the trie, interpreting the</span>
<span class="sd">sequences stored in the trie as regex patterns.  So calling `has_key_meta` for</span>
<span class="sd">an ordinary, non-meta key returns `True` if any current key in the trie matches</span>
<span class="sd">exactly *or* if any meta-key pattern in the trie matches as a pattern.</span>
<span class="sd">Similarly, `get_meta` finds any key or meta-key pattern in the trie which</span>
<span class="sd">matches and returns a tuple containing all the data associated with those</span>
<span class="sd">matching items.</span>

<span class="sd">The special meta-symbol elements which make up patterns can be user-defined,</span>
<span class="sd">but their interpretations as meta-symbols are fixed.  By default the values are</span>
<span class="sd">defined assuming that keys are strings of characters.  (In general, keys can be</span>
<span class="sd">sequences of any kind of hashable elements.)  The default definitions are as</span>
<span class="sd">follows::</span>

<span class="sd">   define_meta_elems(escape=&quot;.g\\\&quot;, repetition=&quot;*&quot;, l_group=&quot;(&quot;, r_group=&quot;)&quot;,</span>
<span class="sd">                     l_wildcard=&quot;[&quot;, r_wildcard=&quot;]&quot;, range_elem=&quot;-&quot;,</span>
<span class="sd">                     or_elem=&quot;|&quot;, dot=&quot;.&quot;, wildcard_patt_match_fun=None,</span>
<span class="sd">                     elem_to_digit_fun=None, canonicalize_fun=None)</span>

<span class="sd">In order for an element of a key to be interpreted as a meta-symbol it **must**</span>
<span class="sd">be preceded by the defined escape element.  So, assuming the keys are strings,</span>
<span class="sd">pattern strings containing the above meta-symbols with their default</span>
<span class="sd">definitions above would always appear as `&quot;.g\\\\\\\\\*&quot;`, `&quot;\\\\\\\\\\(&quot;`,</span>
<span class="sd">`&quot;.g\\\\\\\\\)&quot;`, `&quot;\\\\\\\\\\[&quot;`, `&quot;\\\\\\\\\\]&quot;`, `&quot;\\\\\\\\\\-&quot;`, and</span>
<span class="sd">`&quot;.g\\\\\\\\\|&quot;`.  When the backslash character is the escape it is convenient</span>
<span class="sd">to use raw strings, but remember that Python raw strings cannot end with a</span>
<span class="sd">single backslash.</span>

<span class="sd">There are no exceptions to the requirement that all meta-elements must be</span>
<span class="sd">escaped, so it is a consistent rule which does not require memorization of</span>
<span class="sd">which elements need to be escaped and which do not.  As usual, a double escape</span>
<span class="sd">such as `r&quot;.g\\\\\\\\\&quot;` or `&quot;\\\\\\\\\\\\\\\\&quot;` reverts to the literal escape</span>
<span class="sd">symbol, as does an escape not followed by any of the defined meta-elements.</span>

<span class="sd">Keep in mind that when a `RegexTrieDict` is used with escaped elements in the</span>
<span class="sd">keys, to be treated as meta-elements, all the literal escape-elements in the</span>
<span class="sd">keys must be escaped as described above.  Even keys consisting of ordinary text</span>
<span class="sd">which are inserted into the `RegexTrieDict` to be used as a pattern with the</span>
<span class="sd">meta routines must have any escape elements escaped.  The escape element as a</span>
<span class="sd">literal must also be escaped.  Ordinary strings as regexes are still regex</span>
<span class="sd">patterns, just simple ones.  In the query sequences (query keys), however,</span>
<span class="sd">escape elements are always simply treated as literals.  That is, no</span>
<span class="sd">meta-interpretation is ever performed on the query-key sequences and the escape</span>
<span class="sd">character has no special meaning.  So a single escape on a key-query matches an</span>
<span class="sd">escaped escape in the stored key-sequences in the Trie.</span>

<span class="sd">The meta-level and the object-level are intentionally kept distinct in order to</span>
<span class="sd">minimize some of the confusions that can occur.  The ordinary dict methods</span>
<span class="sd">always operate on trie keys as if they were literals.  To get an extra level of</span>
<span class="sd">interpretation, the special meta-level methods must be used.  These operations,</span>
<span class="sd">however, can be freely mixed.  Patterns can be inserted and deleted on the fly,</span>
<span class="sd">etc.</span>

<span class="sd">Pattern scanning is left-to-right in a key&#39;s elements.  For example, with</span>
<span class="sd">strings as the keys the characters of the key strings are scanned from left to</span>
<span class="sd">right.</span>

<span class="sd">Syntax of the regex language</span>
<span class="sd">============================</span>

<span class="sd">The `RegexTrieDict` class implements all the basic regex patterns (though not</span>
<span class="sd">the fancier ones that some regex implementations allow for).  Because it needs</span>
<span class="sd">to be implemented in a trie, however, some of the usual syntax is modified.  In</span>
<span class="sd">particular, the operations like `*` which are usually postfix operations are</span>
<span class="sd">instead prefix operations so they are encountered first when walking down the</span>
<span class="sd">trie.</span>

<span class="sd">Wildcards</span>
<span class="sd">~~~~~~~~~</span>

<span class="sd">The language allows for single-character wildcards, i.e., wildcards which match</span>
<span class="sd">a single character from some set of possibilities.  Like Python regexes, this</span>
<span class="sd">language also recognizes an escaped dot as a metacharacter that matches</span>
<span class="sd">anything (including newlines, as if `DOTALL` were set in Python).  For strings</span>
<span class="sd">the default dot symbol is set to `r&quot;.g\.&quot;`.</span>

<span class="sd">As an example of character ranges with strings, consider these patterns are</span>
<span class="sd">valid meta-keys using wildcards::</span>

<span class="sd">   patt1 = r&quot;abc.g\[123\\]def&quot;</span>
<span class="sd">   patt2 = r&quot;abc.g\[1\\-3\\]def&quot;</span>

<span class="sd">The first pattern, `patt1`, matches `abc1def`, `abd2def`, and `abc3def` on</span>
<span class="sd">meta-queries.  The second pattern, `patt2`, matches the same strings but uses a</span>
<span class="sd">range specifier.</span>

<span class="sd">&lt;TODO note we now let them define the whole wildcard-processing...&gt;</span>

<span class="sd">The boolean-valued function `rangeTestFun` will be called for the first and</span>
<span class="sd">last argument of the range, along with the element to test.  The default</span>
<span class="sd">range-function (when the values is set to `None` in the call to</span>
<span class="sd">`define_meta_elems`) only works for character ranges.</span>

<span class="sd">&lt;TODO note that Python patterns are allowed, and test some.&gt;</span>

<span class="sd">&lt;TODO note that user can essentially redefine the processing of the part inside</span>
<span class="sd">the brackets in any way desired.&gt;</span>

<span class="sd">Repetition patterns</span>
<span class="sd">~~~~~~~~~~~~~~~~~~~</span>

<span class="sd">Repetition patterns match zero or more occurrences of the pattern group.  Here</span>
<span class="sd">is an example with strings as keys::</span>

<span class="sd">   patt1 = r&quot;abc.g\*\\(DD\\)efg&quot;</span>

<span class="sd">This would match &quot;abcefg&quot;, &quot;abcDDefg&quot;, abcDDDDefg&quot;, etc.  The repetition</span>
<span class="sd">pattern can also take optional numeric arguments, each separated by another</span>
<span class="sd">asterick.  A single numeric argument, like in ::</span>

<span class="sd">   patt = r&quot;abc.g\*10\\(DD\\)efg</span>

<span class="sd">specifies a minimum number of repetitions.  The previous example must have</span>
<span class="sd">ten or more occurrences of `&quot;dd&quot;` in it.  So `&quot;abcDDefg&quot;` would not match,</span>
<span class="sd">but `&quot;abcDDDDDDDDDDDDDDDDDDDDefg&quot;` would match.  When two numbers are given</span>
<span class="sd">they represent the minimum and the maximum number of repetitions, respectively.</span>
<span class="sd">So the pattern ::</span>

<span class="sd">   patt = r&quot;abc.g\*2\\*3\\(DD\\)efg&quot;</span>

<span class="sd">would not match `&quot;abcDDefg&quot;`, would match `&quot;abcDDDDefg&quot;` and `&quot;abcDDDDDDefg&quot;`, and</span>
<span class="sd">would not match `&quot;abcDDDDDDDDefg&quot;`.</span>

<span class="sd">If groups</span>
<span class="sd">~~~~~~~~~</span>

<span class="sd">&lt;TODO, document&gt;</span>

<span class="sd">Greediness and non-greediness in Python regexes</span>
<span class="sd">===============================================</span>

<span class="sd">In Python regexes, the &quot;or&quot; cases are always non-greedy and the repetition</span>
<span class="sd">patterns are optionally non-greedy.  The greediness of this sort of regex</span>
<span class="sd">algorithm tends to be a side-effect of search algorithm, which is basically a</span>
<span class="sd">depth-first search.  For example, the &quot;or&quot; cases can all be searched in order</span>
<span class="sd">and if any path eventually succeeds then the rest of the search can be cut off.</span>
<span class="sd">The optional greediness vs. non-greediness for repetition looping can be</span>
<span class="sd">implemented by choosing whether first expand the loops as far as possible or</span>
<span class="sd">whether to start at the smallest expansion.  If anything path succeeds in</span>
<span class="sd">matching the rest of the search of the search can be cut off.</span>

<span class="sd">As an example, the two greedy search groups in `r&quot;(.*)(B+)&quot;` will always match</span>
<span class="sd">`&quot;BBBBB&quot;` by eating up the all the &#39;B&#39; characters but one in the first group,</span>
<span class="sd">and the last one in the second group.  If the repetitions are made non-greedy</span>
<span class="sd">then the first repetition group will match nothing and the second will match a</span>
<span class="sd">single &#39;B&#39;.  If the &#39;$&#39; character is added to the end of the pattern then the</span>
<span class="sd">first group matches nothing and the second group matches the full string.</span>

<span class="sd">Unlike the search in the Python library, a `RegexTrieDict` essentially uses a</span>
<span class="sd">breadth-first search.  This allows for online recognition of patterns, but does</span>
<span class="sd">not naturally map into Python&#39;s definition of greedy vs. non-greedy.  Patterns</span>
<span class="sd">either match the full query sequence or they do not.  Data for all the matching</span>
<span class="sd">patterns is returned.  To find a prefix you use a `PrefixMatcher` object and</span>
<span class="sd">sequentially insert elements of the sequence.  You can look at the results</span>
<span class="sd">along the way and take the shortest (first) match or the longest match.  The</span>
<span class="sd">longest match is determined by taking the last valid match before the</span>
<span class="sd">`PrefixMatcher` method `cannot_match` returns true (which happens when all the</span>
<span class="sd">parallel pattern-matching states have &quot;died&quot; due to mismatches).  Other</span>
<span class="sd">criteria can be defined based on analyzing the list of matched states.</span>

<span class="sd">Computational complexity</span>
<span class="sd">========================</span>

<span class="sd">The time and space complexity of this particular implementation has not been</span>
<span class="sd">formally analyzed.  It should be similar to other implementations of regexes</span>
<span class="sd">(i.e., other non-optimal ones with respect to time and space and ignoring</span>
<span class="sd">insert and delete time).  The worst case is exponential in the length of the</span>
<span class="sd">query key, like most such implementations.</span>

<span class="sd">This implementation is like a nondeterministic finite automata in the sense</span>
<span class="sd">that it can have multiple states in parallel.  The states are `NodeStateData`</span>
<span class="sd">instances, which point to a node and also hold extra state data.  The full</span>
<span class="sd">state of the system is kept in a `NodeStateDataList` instance, which is</span>
<span class="sd">basically a list of `NodeStateData` instances.  These states are all walked down</span>
<span class="sd">the trie, one step with each element of the query sequence, checking for</span>
<span class="sd">matches and looping back and/or splitting when necessary.  When such a state</span>
<span class="sd">fails to match it dies, i.e., it is not propagated to be considered against the</span>
<span class="sd">next element in the sequence.</span>

<span class="sd">While traversing the trie, the repetition and &quot;or&quot; groups can cause branching which</span>
<span class="sd">increases the number of these parallel states.  Assuming a single item in the</span>
<span class="sd">trie, branching of states occurs in these cases:</span>

<span class="sd">1. For repetitions like `r&quot;.g*\(123\)&quot;` each time the end of the loop is reached</span>
<span class="sd">the single state inside the loop splits into two states.  One loops back to the</span>
<span class="sd">beginning of the loop, and one breaks out of the loop and continues.  So the</span>
<span class="sd">worst-case number of states from such a loop is linear in the number of</span>
<span class="sd">repetition of that loop so far in the query key-string (starting at two, since</span>
<span class="sd">empty patterns can match).</span>

<span class="sd">2. When a state reaches an &quot;or&quot; group like `r&quot;.g(A\|B\|C\)&quot;` it splits into</span>
<span class="sd">new states for each sub-group inside the group.  So that one state becomes as</span>
<span class="sd">many states as there are sub-groups in the &quot;or&quot; group.</span>

<span class="sd">When there are multiple patterns in the trie patterns with identical prefixes</span>
<span class="sd">are treated the same up until the point where they diverge.  For ordinary</span>
<span class="sd">elements in pattern sequences the traversal is</span>
<span class="sd">the same as before, since the element either matches or it does not.</span>

<span class="sd">When special meta-elements are encountered in the trie traversal then the state</span>
<span class="sd">can split into multiple states.  This is because these points possibly allow</span>
<span class="sd">multiple possible matches.  Consider pattern wildcard brackets on character</span>
<span class="sd">string sequences as an example.  With only one pattern in the trie no new</span>
<span class="sd">states would ever be created by a wildcard.  The single character either</span>
<span class="sd">matches or it does not, so the state either proceeds or dies.  But suppose</span>
<span class="sd">there are two different patterns stored in the trie, containing different</span>
<span class="sd">wildcards that happen to have the starting &#39;[&#39; symbol at the same index-point</span>
<span class="sd">into the string.  In that case when the &#39;[&#39; element is reached in walking the</span>
<span class="sd">trie (assuming it is) the state walking that path needs to split.  It splits</span>
<span class="sd">into a new state for each stored pattern which was identical up the &#39;[&#39;</span>
<span class="sd">character and which then differs inside that wildcard bracket.</span>

<span class="sd">Repetition and &quot;or&quot; special elements are handled similarly.  Keep in mind that</span>
<span class="sd">this state-splitting is due to multiple possibly-matching patterns, and is in</span>
<span class="sd">addition to any state-splitting due to the repetition groups or &quot;or&quot; groups</span>
<span class="sd">themselves.  The number of states created this way is at most equal to the</span>
<span class="sd">number of different patterns stored in the trie.</span>

<span class="sd">In many cases this latter kind of state-splitting does not happen very often,</span>
<span class="sd">and when it does most of the new states die off quickly.  For example, when the</span>
<span class="sd">patterns are strings containing mostly ordinary characters (which can happen</span>
<span class="sd">when they define the tokens of a lexical scanner).  In those cases the</span>
<span class="sd">`RegexTrieDict` has an advantage over alternative methods that save a list of</span>
<span class="sd">individual patterns and loop over all the patterns, checking each pattern for a</span>
<span class="sd">match.</span>

<span class="sd">Another alternative approach is to form a giant regex which is the &quot;or&quot; of all</span>
<span class="sd">the regexes that need to be checked.  (There is example code for this in the</span>
<span class="sd">Python 3 regex documentation.)  Because of the non-greedy way Python evaluates</span>
<span class="sd">&quot;or&quot; cases this gives &quot;first not longest&quot; behavior based on the ordering in the</span>
<span class="sd">giant &quot;or.&quot;  Ignoring insertion and deletion of patterns, though, this method</span>
<span class="sd">will tend to be faster than using a `RegexTrieDict`.  Insertion and deletion</span>
<span class="sd">costs can be significant when many different patterns need to be compiled into</span>
<span class="sd">the large regex each time.</span>

<span class="sd">Neither one of the alternative approaches using Python regexes works for online</span>
<span class="sd">applications, where the goal is to produce a token as soon as possible, from as</span>
<span class="sd">little text as possible.  One approach might be to successively match on longer</span>
<span class="sd">and longer prefixes, starting from length 0, until an &quot;acceptable&quot; match is</span>
<span class="sd">found (which already repeats work).  But without more information about the</span>
<span class="sd">internal pattern state or the class of patterns you never know until the end of</span>
<span class="sd">the string if some greedy repetition group is still active but has not yet</span>
<span class="sd">finished consuming characters.  In cases where there is no such group or they</span>
<span class="sd">have all failed the result can be returned sooner.</span>

<span class="sd">[Note that the hidden Python `Scanner` class apparently does &quot;keep going&quot;, so</span>
<span class="sd">also consider that or slight modifications to its code.]</span>

<span class="sd">The usual Python routines also only work for strings, rather than general</span>
<span class="sd">sequences of elements.</span>

<span class="sd">Pattern-matching implementation details</span>
<span class="sd">=======================================</span>

<span class="sd">As noted, meta-keys are inserted and stored in a `TrieDict` simply as ordinary</span>
<span class="sd">keys.  It is the traversal algorithm in the routine `get_nodes_meta` which</span>
<span class="sd">differs from the usual `get_node` algorithm of an ordinary `TrieDict` (which</span>
<span class="sd">finds the node in the trie corresponding to a key).  Note first off that the</span>
<span class="sd">`get_nodes_meta` routine can returns a list of nodes, not just a single node.</span>
<span class="sd">This is because multiple patterns can match the same query-key.</span>

<span class="sd">The traversal algorithm is the same as usual except when meta-characters are</span>
<span class="sd">encountered.  In this case the state can split into a list of states (similar</span>
<span class="sd">to a nondeterministic automata).  That is, instead of just keeping one</span>
<span class="sd">current-node, we keep a list of them and update each one for each input</span>
<span class="sd">query-key element.  If any current node in the list matches then the key</span>
<span class="sd">matches.  If the set becomes empty without a match then the pattern fails to</span>
<span class="sd">match.</span>

<span class="sd">In the case of a wildcard pattern, suppose the child list of a current node</span>
<span class="sd">includes a begin-wildcard element, i.e., a wildcard is one possible</span>
<span class="sd">continuation.  Keep in mind that there may be multiple different wildcard</span>
<span class="sd">patterns stored in the subtree of the begin-wildcard element.  Now suppose the</span>
<span class="sd">next element of the query-key comes in, and we want to move down the trie.  The</span>
<span class="sd">state splits.  One new state is just the usual child-node from any literal</span>
<span class="sd">continuation which is stored in the tree (as in the non-meta version).  But</span>
<span class="sd">also, the algorithm fast-forwards from the current-node&#39;s begin-wildcard child</span>
<span class="sd">node to the first end-wildcard node in each branch of the subtree beneath it.</span>
<span class="sd">Along the way, it is noted whether the current query-key element matches the</span>
<span class="sd">wildcard.  For each end-wildcard node which matched the query-key element, the</span>
<span class="sd">end-wildcard node is added to the current-node list (and is also checked to see</span>
<span class="sd">if it is an end-node of some pattern).</span>

<span class="sd">In the case of a repetition pattern, suppose the child list of a current node</span>
<span class="sd">includes a begin-repetition element.  In this case the state splits (as before</span>
<span class="sd">with wildcards), with the usual literal-character child node becoming one new</span>
<span class="sd">state.  But also, the algorithm fast forwards to the corresponding</span>
<span class="sd">end-repetition element of each subtree and makes that a new state (the state</span>
<span class="sd">starts at the end in order to match zero repetitions).  They also remember</span>
<span class="sd">their begin-repetition point.  On the next query-key element both states</span>
<span class="sd">continue, one skipping and one looping back.</span>

<span class="sd">To handle uniqueness issues (if we want each distinct pattern to be represented</span>
<span class="sd">by the same pattern-string, with the same associated value) the meta-key</span>
<span class="sd">patterns can be preprocessed before they are entered into the `TrieDict`, to</span>
<span class="sd">canonicalize them.  For character wildcards, at least, the characters can be</span>
<span class="sd">sorted and all continuous sequences can be turned into character ranges.</span>

<span class="sd">Note that we can freely add and remove keys from the tree in the usual way,</span>
<span class="sd">since they are stored just as if they were ordinary strings.</span>

<span class="sd">The code implementing the pattern-matching algorithm is currently not optimized</span>
<span class="sd">(though asymptotically the algorithm shouldn&#39;t be bad except for the known</span>
<span class="sd">worst cases for this kind of implementation).  For example, due to the</span>
<span class="sd">difficulties of debugging the initial algorithm some copies are made of items</span>
<span class="sd">which do not need to be copied.  As far as the looping implementation for</span>
<span class="sd">repetition patterns, each time a repetition-loop is encountered it re-processes</span>
<span class="sd">the entire thing, searching forward for the end-group element.  This data could</span>
<span class="sd">instead be cached (such as by having a dict map begin-repetition nodes to the</span>
<span class="sd">cached data, valid until an insertion or deletion invalidates, or the space</span>
<span class="sd">needs to be freed).  Overriding the children on repetition loops can use up a</span>
<span class="sd">lot of space for long repetition patterns.  It is hard to avoid going to the</span>
<span class="sd">end in the zero-repetition match form, since the end is a valid continuation.</span>
<span class="sd">At-least-one repetition patterns could potentially process from the beginning,</span>
<span class="sd">though.  Overriding the insert (`__setitem__`) method to keep precalculated</span>
<span class="sd">pointers to the loop-ends and different sections sections of each &quot;or&quot; group</span>
<span class="sd">would speed things up at the cost of some memory.  A common dict indexed by</span>
<span class="sd">node ids could be used, but deletion would have to del the deleted-node</span>
<span class="sd">entries.  Then zero-repetition states could be started but just set the stacks</span>
<span class="sd">for the first loop, fixing the children in `append_child_node` if the stack is</span>
<span class="sd">not empty.</span>

<span class="sd">.. TODO: move any &quot;future implementation&quot; stuff to comments in the code itself.</span>
<span class="sd">   This stuff below is questionable for the docs proper but still useful.</span>

<span class="sd">.. note::</span>

<span class="sd">    If this algorithm were to be rewritten (partly or in whole), based on</span>
<span class="sd">    experience from this implementation, what should change?  The insert method</span>
<span class="sd">    for `RegexTrieDict` should probably be modified to create a virtual trie.</span>
<span class="sd">    (The delete method would also need to be modified to fix the virtual trie</span>
<span class="sd">    on deletes.) This can be hashed on the ids of nodes, for example, to avoid</span>
<span class="sd">    pasting things onto the actual nodes which must later be deleted.  The</span>
<span class="sd">    virtual trie can be created by overloading the child function for nodes.</span>
<span class="sd">    Like for states currently, but it can be global and saved.  The virtual</span>
<span class="sd">    trie should add virtual nodes for close-repetition and open-group nodes for</span>
<span class="sd">    &#39;or&#39;s.  This would allow the processing for repetitions to keep track of</span>
<span class="sd">    the loop stacks, and the processing for &#39;or&#39; sections to keep track of</span>
<span class="sd">    which paths were originally together in a common pattern, but otherwise the</span>
<span class="sd">    repetitions should just virtually both loop back and break out, and the</span>
<span class="sd">    &#39;or&#39; patterns should be flattened down to an &#39;or&#39; for each section starting</span>
<span class="sd">    at the initial open-group and then converging back to a common close-group</span>
<span class="sd">    node (but note the importance of keeping track of which ones were initially</span>
<span class="sd">    in the same pattern to avoid crosstalk amongst the patterns).</span>

<span class="sd">Prefix matcher class</span>
<span class="sd">====================</span>

<span class="sd">The class `PrefixMatcher` is closely related to the `RegexTrieDict` class.</span>
<span class="sd">Every instance of a `PrefixMatcher` is associated with a particular instance of</span>
<span class="sd">a `RegexTrieDict`.  The `PrefixMatcher` class is used to search for prefix</span>
<span class="sd">matches in the keys of the `RegexTrieDict`, where the keys are treated as</span>
<span class="sd">meta-sequences representing regex patterns.</span>

<span class="sd">To use the `PrefixMatcher` class you sequentially add elements (characters when</span>
<span class="sd">strings are stored in the trie) to an instance using the `add_key_elem` method.</span>
<span class="sd">You can then use the `get_meta` method to get the data associated with a</span>
<span class="sd">meta-pattern, if any.  The data associated with the matching pattern string is</span>
<span class="sd">returned.  The `has_key_meta` method is similar, but returns the number of</span>
<span class="sd">matches (which acts as `False` when it is zero).</span>

<span class="sd">In order to find the first prefix match in an ongoing sequence, such as one</span>
<span class="sd">typed by a user, you need to determine when no further prefix matches are</span>
<span class="sd">possible.  The `cannot_match` boolean method determines this.  When all of the</span>
<span class="sd">parallel match searches are exhausted, i.e., when there are no more active</span>
<span class="sd">match states, it returns true.</span>

<span class="sd">In order to get the equivalent of the Python regex function/method `match` --</span>
<span class="sd">which always matches from the beginning of the pattern but not necessarily to</span>
<span class="sd">the end -- you use a `PrefixMatcher` object initialized with the</span>
<span class="sd">`RegexTrieDict` instance containing the pattern sequences.  By checking</span>
<span class="sd">`cannot_match` after each element is added and returning the last result when</span>
<span class="sd">`cannot_match` is `True` you get the equivalent of `match` on the prefix.  You</span>
<span class="sd">can also look at the matches along the way using the `get` method.  The</span>
<span class="sd">separate `RegexTrieDictScanner` module does this.</span>

<span class="sd">In order to match the next prefix when using a `PrefixMatcher` you need to</span>
<span class="sd">clear the `PrefixMatcher` and start again after removing the matched prefix</span>
<span class="sd">removed from the query key sequence.  While this seems inefficient, it works</span>
<span class="sd">online and returns the prefix as spoon as it can be determined based on the</span>
<span class="sd">patterns in the trie and the key to be matched.  Remember, also, that it is</span>
<span class="sd">efficiently comparing against a large &quot;or&quot; of many different patterns such as</span>
<span class="sd">in a lexical scanning/tokenizing situation.  While doing this it retains the</span>
<span class="sd">ability to insert/delete patterns very efficiently.  The `TrieDictScanner` is</span>
<span class="sd">an implementation of a scanner using this method.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="c1"># Run test cases below when invoked as a script.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pytest_helper</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="s2">&quot;../../test/test_regex_trie_dict.py&quot;</span><span class="p">,</span>
                             <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">collections</span> <span class="c1"># to use deque and MutableSequence abstract base class</span>
<span class="kn">from</span> <span class="nn">.trie_dict</span> <span class="k">import</span> <span class="n">TrieDict</span><span class="p">,</span> <span class="n">TrieDictNode</span>
<span class="kn">from</span> <span class="nn">.shared_settings_and_exceptions</span> <span class="k">import</span> <span class="n">TyppedBaseException</span>

<span class="c1"># Todo: Consider a preprocessing routine like the Python regex one `escape`.</span>
<span class="c1"># This one would take an unescaped string and escape all the special chars.</span>
<span class="c1"># Then people who prefer it that way could do it that way.  The default could</span>
<span class="c1"># be easily changed (even as an init parameter).</span>

<div class="viewcode-block" id="NodeStateData"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateData">[docs]</a><span class="k">class</span> <span class="nc">NodeStateData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class is used in pattern-searches.  It is just a fancy data-record,</span>
<span class="sd">    essentially a mutable named tuple.  Each state of a multi-state recognizer</span>
<span class="sd">    is represented by an instance of this class.  The main component is a node</span>
<span class="sd">    in the trie, but other data is also kept.  The state &quot;moves&quot; in the trie</span>
<span class="sd">    as part of pattern matching by updating its current node.</span>

<span class="sd">    A `NodeStateData` is initialized by passing all the stored items to the</span>
<span class="sd">    initializer, just like initializing a tuple.  Alternately, you can use</span>
<span class="sd">    keyword arguments or just assign values to the attributes.</span>

<span class="sd">    A `NodeStateData` instance consists of a node in the trie as well as some</span>
<span class="sd">    extra information for keeping track of loops.  These states locally (for</span>
<span class="sd">    the particular state and search) redefine the children for each node they</span>
<span class="sd">    have visited and followed a child link from.  That particular child is made</span>
<span class="sd">    into the only child.</span>

<span class="sd">    Each branch in the trie represents a different pattern, connected by &quot;or&quot;.</span>
<span class="sd">    The pattern-prefix for a node is always the same; a pattern with a</span>
<span class="sd">    different prefix would end at a different node.  When a choice of moving</span>
<span class="sd">    down the trie is made the prefix is further restricted.  So `NodeStateData`</span>
<span class="sd">    stores a dict for looking up the children of any visited state, and they</span>
<span class="sd">    are all restricted to the single path that they took previously.  This way,</span>
<span class="sd">    looping back in a repetition always gives the same pattern prefix.  (States</span>
<span class="sd">    can also split into two or more states, as necessary, and run in parallel</span>
<span class="sd">    essentially as an NFA.)  Patterns within &#39;or&#39; groups inside a repetition</span>
<span class="sd">    need to be treated similarly, since they may match a different section on</span>
<span class="sd">    each repetition.</span>

<span class="sd">    The `node` slot/attribute holds a node in the trie.</span>

<span class="sd">    The boolean `node_is_escape` is true for nodes representing the escape</span>
<span class="sd">    element `self.escape`.</span>

<span class="sd">    The stacks attributes are used to keep track of looping in repetition</span>
<span class="sd">    patterns.  A stack is used because the loops can be nested.  The</span>
<span class="sd">    `loopback_stack` contains a pointer to the place in the trie where the</span>
<span class="sd">    loop should loop back to, like with a goto.  The `loop_counter_stack`</span>
<span class="sd">    contains the current loop count.  The `loop_bounds_stack` contains the</span>
<span class="sd">    defined bounds for the loop.</span>

<span class="sd">    The `bound_node_child_dict` is used to override the children of the node,</span>
<span class="sd">    so that the same path down the trie is always followed in a repetition</span>
<span class="sd">    loop.  With only one regex this would not be needed, but remember that the</span>
<span class="sd">    trie contains many regexes being searched in parallel with an implicit &quot;or&quot;</span>
<span class="sd">    between them.  A repetition loop which goes back in the trie must be fixed</span>
<span class="sd">    to a single pattern, i.e., the path it took the first time through the</span>
<span class="sd">    loop.  Otherwise there will be &quot;crosstalk&quot; between the different stored</span>
<span class="sd">    patterns.</span>

<span class="sd">    The `visited_repetition_node_id_set` set is a set of the ids of all the loopback</span>
<span class="sd">    repetition nodes visited, but it is reset each time a literal element</span>
<span class="sd">    matches the query element (i.e., on a literal or a wildcard match).  This</span>
<span class="sd">    is used to avoid infinite recursion in processing repetition patterns which</span>
<span class="sd">    match zero elements, i.e., which match the empty string.&quot;&quot;&quot;</span>
    <span class="c1"># If slots are causing problems (such as with pickling) you can just globally</span>
    <span class="c1"># substitute some other variable name, like `_slots`, for `__slots__` and</span>
    <span class="c1"># things should still work (but more space will be used in pattern matches).</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="s2">&quot;node_is_escape&quot;</span><span class="p">,</span> <span class="s2">&quot;loopback_stack&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;loop_counter_stack&quot;</span><span class="p">,</span> <span class="s2">&quot;loop_bounds_stack&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;bound_node_child_dict&quot;</span><span class="p">,</span> <span class="s2">&quot;visited_repetition_node_id_set&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">val_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the instance.  This just sets the values to the ones passed</span>
<span class="sd">        in by calling `set_vals`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vals</span><span class="p">(</span><span class="o">*</span><span class="n">val_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_vals</span><span class="p">)</span>

<div class="viewcode-block" id="NodeStateData.set_vals"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateData.set_vals">[docs]</a>    <span class="k">def</span> <span class="nf">set_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">val_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the values in the `NodeStateData` instance.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val_list</span><span class="p">:</span> <span class="c1"># Either args or kwargs, not both.  If args then all args.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Need seven arguments for NodeStateData object, only&quot;</span>
                        <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2"> found.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val_list</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val_list</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kw_vals</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kw_vals</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span>

<div class="viewcode-block" id="NodeStateData.copy"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateData.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the state (not a deep copy).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NodeStateData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_is_escape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loopback_stack</span><span class="p">[:],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">loop_counter_stack</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_bounds_stack</span><span class="p">[:],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">bound_node_child_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">visited_repetition_node_id_set</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="NodeStateData.set_child"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateData.set_child">[docs]</a>    <span class="k">def</span> <span class="nf">set_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child_elem</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign the node (default to self.node) to have single child child_elem.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span>
        <span class="n">node_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound_node_child_dict</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">child_elem</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child_elem</span><span class="p">]}</span></div>

<div class="viewcode-block" id="NodeStateData.children"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateData.children">[docs]</a>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;During patern matches the children of a node are temporarily modified,</span>
<span class="sd">        so that ordinary characters in a repetition loop are bound until the</span>
<span class="sd">        loop exits.  To do this, the pattern-match routines use the NodeStateData</span>
<span class="sd">        children method, rather than the node&#39;s children method.  If node is</span>
<span class="sd">        set then that node&#39;s children dict is returned; default is self.node.&quot;&quot;&quot;</span>
        <span class="c1"># If the trie is not modified, the ids of nodes will not change.  If it</span>
        <span class="c1"># is modified then any search-in-progress becomes invalid anyway.</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span>
        <span class="n">node_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_node_child_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_node_child_dict</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;NodeStateData(&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">=</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">slotname</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slotname</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span> <span class="k">for</span> <span class="n">slotname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span></div>


<div class="viewcode-block" id="NodeStateDataList"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateDataList">[docs]</a><span class="k">class</span> <span class="nc">NodeStateDataList</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is essentially just a list, used to hold a collection of</span>
<span class="sd">    `NodeStateData` objects representing the full (nondeterministic) state.  A</span>
<span class="sd">    derived class is used so that extra attributes and methods can be added.</span>
<span class="sd">    The initialization arguments, if any, are the same as for a list.</span>

<span class="sd">    Using this class instead of a list allows for checking whether or not the</span>
<span class="sd">    state-data is still valid in the underlying trie (since there might have</span>
<span class="sd">    been insertions and/or deletions).&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex_trie_dict</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># The list node_data_list does the real work.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_count</span> <span class="o">=</span> <span class="n">regex_trie_dict</span><span class="o">.</span><span class="n">insert_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_count</span> <span class="o">=</span> <span class="n">regex_trie_dict</span><span class="o">.</span><span class="n">delete_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex_trie_dict_instance_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">regex_trie_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex_trie_dict</span> <span class="o">=</span> <span class="n">regex_trie_dict</span>

<div class="viewcode-block" id="NodeStateDataList.is_valid_in"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateDataList.is_valid_in">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex_trie_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether or not the state-data stored in a node data list is still</span>
<span class="sd">        valid in the current trie.  If any insertions or deletions have occurred</span>
<span class="sd">        since its creation this routine returns False, otherwise True.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regex_trie_dict_instance_id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">regex_trie_dict</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">regex_trie_dict</span><span class="o">.</span><span class="n">insert_count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_count</span> <span class="ow">and</span>
                    <span class="n">regex_trie_dict</span><span class="o">.</span><span class="n">delete_count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">delete_count</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">)</span>

<div class="viewcode-block" id="NodeStateDataList.insert"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateDataList.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="NodeStateDataList.append"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateDataList.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></div>

<div class="viewcode-block" id="NodeStateDataList.append_child_node"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.NodeStateDataList.append_child_node">[docs]</a>    <span class="k">def</span> <span class="nf">append_child_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">node_is_escape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A utility routine that appends a `NodeStateData` instance for a</span>
<span class="sd">        child of the node in the one passed in.  The child is the one</span>
<span class="sd">        corresponding to the key `query_elem`.  All other data is kept the</span>
<span class="sd">        same.  Return `True` if anything actually added.</span>

<span class="sd">        If the `node_is_escape` argument is not `None` then the</span>
<span class="sd">        `node_is_escape` value of the `NodeStateData` instance is set to that</span>
<span class="sd">        value.  Note that if a `NodeStateData` instance is added outside of</span>
<span class="sd">        this loop (such as in processing wildcards) that routine must take care</span>
<span class="sd">        of any necessary set_child calls for binding in repetition loops.&quot;&quot;&quot;</span>
        <span class="n">children_dict</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">query_elem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">children_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">node_data_copy</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_data_copy</span> <span class="o">=</span> <span class="n">node_data</span>

        <span class="c1"># Fix the overridden children dict of states inside repetition loops</span>
        <span class="c1"># to the single child path which is actually traveled down (so later</span>
        <span class="c1"># repetitions are for the same pattern in the trie).  Only needed on</span>
        <span class="c1"># the first time through, and not for outer-level loops with max of</span>
        <span class="c1"># one repetition (which is how &#39;or&#39; groups are treated).  The latter</span>
        <span class="c1"># optimization is not currently implemented.  (It doesn&#39;t hurt</span>
        <span class="c1"># correctness to always run set_child, but a lot of unnecessary state</span>
        <span class="c1"># data is then saved and copied.)</span>
        <span class="k">if</span> <span class="n">node_data</span><span class="o">.</span><span class="n">loopback_stack</span><span class="p">:</span>  <span class="c1"># debug below test, put back later</span>
            <span class="c1">#if node_data.loop_counter_stack[-1] == 1 and len(children_dict) &gt; 1:</span>
            <span class="n">node_data_copy</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span><span class="n">query_elem</span><span class="p">)</span> <span class="c1"># fix to one child</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_data_copy</span><span class="o">.</span><span class="n">bound_node_child_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Can&#39;t loop back, free the memory.</span>
        <span class="n">node_data_copy</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">children_dict</span><span class="p">[</span><span class="n">query_elem</span><span class="p">]</span>

        <span class="c1"># Set node_is_escape if that arg is given.</span>
        <span class="k">if</span> <span class="n">node_is_escape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_data_copy</span><span class="o">.</span><span class="n">node_is_escape</span> <span class="o">=</span> <span class="n">node_is_escape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_data_copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;NodeStateDataList([&quot;</span>
        <span class="n">string</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span> <span class="o">+</span> <span class="s2">&quot;])&quot;</span></div>

<div class="viewcode-block" id="MagicElem"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.MagicElem">[docs]</a><span class="k">class</span> <span class="nc">MagicElem</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Instances are special elements, considered unique (and checked by id).</span>
<span class="sd">    They are currently used to represent an element which doesn&#39;t match</span>
<span class="sd">    anything and one which matches everything.  Type doesn&#39;t matter (since no</span>
<span class="sd">    real comparisons are needed).  Not the same as a null string.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_of_magic</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_of_magic</span> <span class="o">=</span> <span class="n">type_of_magic</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_of_magic</span><span class="p">)</span></div>

<span class="n">magic_elem_never_matches</span> <span class="o">=</span> <span class="n">MagicElem</span><span class="p">(</span><span class="s2">&quot;never_matches&quot;</span><span class="p">)</span>
<span class="c1"># TODO: Always match is partially implemented, either get working or delete in all places.</span>
<span class="c1"># Had bugs that need to be worked out...</span>
<span class="n">magic_elem_always_matches</span> <span class="o">=</span> <span class="n">MagicElem</span><span class="p">(</span><span class="s2">&quot;always_matches&quot;</span><span class="p">)</span>

<span class="c1"># TODO maybe add a non-greedy flag which will work on prexix-matches</span>
<span class="c1"># and return the first matches only.  Maybe.  Still might be nice to</span>
<span class="c1"># have a break-as-soon-as-possible flag, though if the syntax is</span>
<span class="c1"># unambiguous the other way won&#39;t branch, anyway.</span>

<div class="viewcode-block" id="RegexTrieDict"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict">[docs]</a><span class="k">class</span> <span class="nc">RegexTrieDict</span><span class="p">(</span><span class="n">TrieDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subclass of the `TrieDict` class which adds regex processing for patterns</span>
<span class="sd">    stored in the trie.&quot;&quot;&quot;</span>
    <span class="n">magic_elem_never_matches</span> <span class="o">=</span> <span class="n">magic_elem_never_matches</span> <span class="c1"># Convenient in class namespace.</span>
    <span class="n">magic_elem_always_matches</span> <span class="o">=</span> <span class="n">magic_elem_always_matches</span> <span class="c1"># Convenient in class namespace.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the `RegexTrieDict` instance.  All arguments are simply passed</span>
<span class="sd">        to the base `TrieDict` initializer.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RegexTrieDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<div class="viewcode-block" id="RegexTrieDict.clear"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the `RegexTrieDict` instance, starting at a new root.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert_count</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Used to test if inserts were done.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_count</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Used to test if deletes were done.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Used in sequential meta mode to persist states.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_meta_elems</span><span class="p">()</span> <span class="c1"># Set the meta-elems to their default definitions.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RegexTrieDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span> <span class="c1"># Call superclass clear method.</span></div>

<div class="viewcode-block" id="RegexTrieDict.test_pattern_sequence"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.test_pattern_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">test_pattern_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_seq</span><span class="p">,</span> <span class="n">raise_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs some basic tests on a pattern sequence.  This routine is always</span>
<span class="sd">        called by the insert method, with `raise_errors=True`.  Users can use</span>
<span class="sd">        it to test patterns before inserting them.  By default the routine will</span>
<span class="sd">        just return a boolean value specifying whether the string passes or</span>
<span class="sd">        not.  If `raise_errors=True` then, assuming no errors are raised, the</span>
<span class="sd">        escape-processed version of `key_seq` is returned.  Note that simply</span>
<span class="sd">        passing the tests is no guarantee that the pattern is correct, just</span>
<span class="sd">        that it passes these tests.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">found_error</span><span class="p">(</span><span class="n">error_string</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="n">PatternMatchError</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Utility function to raise errors or return bool as appropriate.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">raise_errors</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exception</span><span class="p">(</span><span class="n">error_string</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_string_for_key_seq</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Try to get a string representation for key_seq for more-helpful</span>
<span class="sd">            error messages.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">err_patt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key_seq</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">err_patt</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">return</span> <span class="n">err_patt</span>

        <span class="k">def</span> <span class="nf">test_matched_open_close</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">,</span> <span class="n">close_elem</span><span class="p">,</span> <span class="n">no_nest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Simple test for mismatched open and close group parens.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">escaped_key_elem_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="n">escaped_key_elem_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">close_elem</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">no_nest</span> <span class="ow">and</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">escaped_key_elem_list</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">test_no_empty_open_close</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Simple test for open-group paren followed immediately by close-group.</span>
<span class="sd">            Any parLevel in escaped_key_elem_list must have at least three elements.&quot;&quot;&quot;</span>
            <span class="n">last_par_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">is_escaped</span><span class="p">,</span> <span class="n">par_level</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">par_level</span> <span class="o">&gt;</span> <span class="n">last_par_level</span><span class="p">:</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">par_level</span> <span class="o">==</span> <span class="n">last_par_level</span><span class="p">:</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">par_level</span> <span class="o">&lt;</span> <span class="n">last_par_level</span>
                   <span class="ow">or</span> <span class="p">(</span><span class="n">par_level</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="n">last_par_level</span> <span class="o">=</span> <span class="n">par_level</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1">#</span>
        <span class="c1"># Begin the main body of the method.</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_seq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">found_error</span><span class="p">(</span><span class="s2">&quot;The empty element is not a valid key.&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="ne">KeyError</span><span class="p">)</span>

        <span class="c1"># Process the escapes counting open and close wildcard brackets.</span>
        <span class="n">escaped_key_elem_list</span> <span class="o">=</span> <span class="n">process_elem_list_for_escapes</span><span class="p">(</span><span class="n">key_seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span>
                                 <span class="n">open_group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_wildcard</span><span class="p">,</span> <span class="n">close_group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r_wildcard</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">test_matched_open_close</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_wildcard</span><span class="p">,</span> <span class="n">no_nest</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">found_error</span><span class="p">(</span><span class="s2">&quot;Mismatched open and close wildcard brackets in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">get_string_for_key_seq</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">test_no_empty_open_close</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">):</span>
            <span class="n">found_error</span><span class="p">(</span><span class="s2">&quot;Empty open and close wildcard brackets in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">get_string_for_key_seq</span><span class="p">())</span>

        <span class="c1"># Process the escapes counting open and close group parens.</span>
        <span class="n">escaped_key_elem_list</span> <span class="o">=</span> <span class="n">process_elem_list_for_escapes</span><span class="p">(</span><span class="n">key_seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span>
                                 <span class="n">open_group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">,</span> <span class="n">close_group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">test_matched_open_close</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">):</span>
            <span class="n">found_error</span><span class="p">(</span><span class="s2">&quot;Mismatched open and close group elements in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">get_string_for_key_seq</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">test_no_empty_open_close</span><span class="p">(</span><span class="n">escaped_key_elem_list</span><span class="p">):</span>
            <span class="n">found_error</span><span class="p">(</span><span class="s2">&quot;Empty open and close group elements in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">get_string_for_key_seq</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">raise_errors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">escaped_key_elem_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="RegexTrieDict.insert"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_seq</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the data item in the dict with the key key_seq.  Any existing</span>
<span class="sd">        data at that key is overwritten.  This method is aliased to __setitem__.</span>
<span class="sd">        It overrides the superclass definition and adds some syntax checking on</span>
<span class="sd">        the input patterns.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonicalize_fun</span><span class="p">:</span>
            <span class="n">key_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonicalize_fun</span><span class="p">(</span><span class="n">key_seq</span><span class="p">)</span>

        <span class="n">escaped_key_elem_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_pattern_sequence</span><span class="p">(</span><span class="n">key_seq</span><span class="p">,</span>
                                                           <span class="n">raise_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span><span class="p">,</span> <span class="n">paren_count</span> <span class="ow">in</span> <span class="n">escaped_key_elem_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieDictNode</span><span class="p">()</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieDictNode</span><span class="p">()</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_last_elem_of_key</span><span class="p">:</span> <span class="c1"># Don&#39;t increment if just resetting data.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_keys</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># This is an attribute of the underlying TrieDict.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">node</span><span class="o">.</span><span class="n">is_last_elem_of_key</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># End of key_seq, isLastElemOfKey is True.</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span></div>

    <span class="fm">__setitem__</span> <span class="o">=</span> <span class="n">setitem</span> <span class="o">=</span> <span class="n">insert</span> <span class="c1"># Alias for insert, to use `rtd[patt] = val`</span>

<div class="viewcode-block" id="RegexTrieDict.delitem"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.delitem">[docs]</a>    <span class="k">def</span> <span class="nf">delitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the stored key and its data.  Raises KeyError if the key wasn&#39;t</span>
<span class="sd">        found in the trie.  If d is a dict, the syntax del d[key] also invokes</span>
<span class="sd">        this function.  This overrides the delete method of the base class to</span>
<span class="sd">        update a deletion counter to test pattern-match state validity.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">TrieDict</span><span class="o">.</span><span class="n">delitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span></div>

    <span class="fm">__delitem__</span> <span class="o">=</span> <span class="n">delitem</span> <span class="c1"># Alias for delitem, to use `del rtd[patt]`</span>

<div class="viewcode-block" id="RegexTrieDict.define_meta_elems"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.define_meta_elems">[docs]</a>    <span class="k">def</span> <span class="nf">define_meta_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">l_group</span><span class="o">=</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">r_group</span><span class="o">=</span><span class="s2">&quot;)&quot;</span><span class="p">,</span>
                        <span class="n">l_wildcard</span><span class="o">=</span><span class="s2">&quot;[&quot;</span><span class="p">,</span> <span class="n">r_wildcard</span><span class="o">=</span><span class="s2">&quot;]&quot;</span><span class="p">,</span> <span class="n">range_elem</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">or_elem</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="n">dot</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">wildcard_patt_match_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">elem_to_digit_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">canonicalize_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the meta-elements in pattern-matching.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="o">=</span> <span class="n">escape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span> <span class="o">=</span> <span class="n">repetition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_group</span> <span class="o">=</span> <span class="n">l_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_group</span> <span class="o">=</span> <span class="n">r_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_wildcard</span> <span class="o">=</span> <span class="n">l_wildcard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_wildcard</span> <span class="o">=</span> <span class="n">r_wildcard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_elem</span> <span class="o">=</span> <span class="n">range_elem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">or_elem</span> <span class="o">=</span> <span class="n">or_elem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">=</span> <span class="n">dot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">canonicalize_fun</span> <span class="o">=</span> <span class="n">canonicalize_fun</span>
        <span class="k">if</span> <span class="n">wildcard_patt_match_fun</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wildcard_patt_match_fun</span> <span class="o">=</span> <span class="n">wildcard_patt_match_fun</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wildcard_patt_match_fun</span> <span class="o">=</span> <span class="n">char_pattern_match_test</span>
        <span class="k">if</span> <span class="n">elem_to_digit_fun</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elem_to_digit_fun</span> <span class="o">=</span> <span class="n">elem_to_digit_fun</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elem_to_digit_fun</span> <span class="o">=</span> <span class="n">char_elem_to_int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escape_meta_elems</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">repetition</span><span class="p">,</span> <span class="n">l_group</span><span class="p">,</span> <span class="n">r_group</span><span class="p">,</span> <span class="n">l_wildcard</span><span class="p">,</span> <span class="n">r_wildcard</span><span class="p">,</span> <span class="n">range_elem</span><span class="p">,</span> <span class="n">dot</span><span class="p">}</span></div>

<div class="viewcode-block" id="RegexTrieDict.get_dfs_gen"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.get_dfs_gen">[docs]</a>    <span class="k">def</span> <span class="nf">get_dfs_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtree_root_node</span><span class="p">,</span> <span class="n">fun_to_apply</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">yield_on_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">yield_on_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">stop_at_elems</span><span class="o">=</span><span class="p">[],</span> <span class="n">stop_at_escaped_elems</span><span class="o">=</span><span class="p">[],</span>
                    <span class="n">stop_at_depth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">only_follow_elems</span><span class="o">=</span><span class="p">[],</span>
                    <span class="n">stop_if_paren_level_zero</span><span class="o">=</span><span class="p">[],</span> <span class="n">first_paren_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">subtree_root_escaped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_children</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">subtree_root_elem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">child_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a generator which will do a depth-first traversal of the trie,</span>
<span class="sd">        starting at node `subtree_root_node`.  This is a Swiss Army knife routine</span>
<span class="sd">        which is used in many places to do the real work.  This definition</span>
<span class="sd">        overrides the corresponding definition in the superclass `TrieDict` and</span>
<span class="sd">        adds new options that apply to regex tries.</span>

<span class="sd">        On each call this method returns a list of `(nodeElem, node)` pairs for</span>
<span class="sd">        each node on some path from the root to a leaf of the tree.  It</span>
<span class="sd">        generates such a list for each path from the root to a leaf (one on</span>
<span class="sd">        each call).  If `yield_on_match` is set `True` then the current list</span>
<span class="sd">        being constructed on a path down the tree is returned on the first time</span>
<span class="sd">        any match-marked node is encountered, even if the node is not a leaf.</span>
<span class="sd">        If `yield_on_leaves` is set `False` then yields will only be done on</span>
<span class="sd">        matches.  (If both are `False` then the routine returns nothing.)</span>

<span class="sd">        If the list `stop_at_elems` contains any elements then nodes for those</span>
<span class="sd">        elements are treated as leaves.  Similarly, `stop_at_escaped_elems` treats</span>
<span class="sd">        escaped nodes for an element in the list to be like leaf nodes.  If</span>
<span class="sd">        `stop_at_depth` has a positive integer value then nodes at that depth are</span>
<span class="sd">        treated as leaves.  The `only_follow_elems` list is like the negation for</span>
<span class="sd">        `stop_at_elems`: it treats everything not on the list like a leaf node (i.e.,</span>
<span class="sd">        it only folows child-links which are on the list).</span>

<span class="sd">        If `first_paren_level` is set to a positive integer then that integer will be</span>
<span class="sd">        incremented on each open-group meta-elem (`self.l_group`) encountered on a</span>
<span class="sd">        path and decremented on each close-group meta-elem (`self.r_group`)</span>
<span class="sd">        encountered on the path.  The default value is zero.  If</span>
<span class="sd">        `stop_if_paren_level_zero` is non-empty then any elements in the list will be</span>
<span class="sd">        treated as leaves if they are encountered when the paren-count equals</span>
<span class="sd">        zero.  Note that paren-counts are updated after the comparison with zero.</span>
<span class="sd">        If the root is a node for a left-paren and `first_paren_level==0` then the</span>
<span class="sd">        matching right-paren is at paren-level zero.</span>

<span class="sd">        If `fun_to_apply` is defined it will be called for each `(nodeElem, node)` pair</span>
<span class="sd">        on the returned lists.  The function should take two arguments; the list</span>
<span class="sd">        will contain the function&#39;s return value.  A copy of the node list is</span>
<span class="sd">        returned on each generation, but the nodes are always the actual nodes in</span>
<span class="sd">        the trie.  If `include_root` is `True` then output from the `subtree_root_node`</span>
<span class="sd">        itself will be included in the output (with `None` as the corresponding</span>
<span class="sd">        `nodeElem`).</span>

<span class="sd">        If copies is set `False` then a single node list is used; this may be a</span>
<span class="sd">        little faster, but the returned list will change after each</span>
<span class="sd">        generation-cycle.  If `sort_children` is `True` then the children of</span>
<span class="sd">        each node will be sorted in the DFS search ordering.</span>

<span class="sd">        Setting `subtree_root_elem` to an element will set that as the element on</span>
<span class="sd">        the returned list corresponding to the subtree root (otherwise it is</span>
<span class="sd">        None.  Sometimes the value is known when the function call is made,</span>
<span class="sd">        and it can be convenient to have a uniform list pattern.</span>

<span class="sd">        If `child_fun` is set to a function then the children of a node are obtained</span>
<span class="sd">        by calling that function with the node as the argument.  This is helpful,</span>
<span class="sd">        for example, in pattern-matches where the child dict is locally modified</span>
<span class="sd">        per state.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">dfs_recursion</span><span class="p">(</span><span class="n">curr_node_elem</span><span class="p">,</span> <span class="n">curr_node</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">is_escaped</span><span class="p">,</span> <span class="n">paren_count</span><span class="p">):</span>
            <span class="c1"># Put the node on the running list of nodes (down current tree path).</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">include_root</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fun_to_apply</span><span class="p">:</span>
                    <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fun_to_apply</span><span class="p">(</span><span class="n">curr_node_elem</span><span class="p">,</span> <span class="n">curr_node</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">curr_node_elem</span><span class="p">,</span> <span class="n">curr_node</span><span class="p">))</span>
            <span class="c1"># Get the current node&#39;s child list and modify it.</span>
            <span class="k">if</span> <span class="n">child_fun</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">child_dict</span> <span class="o">=</span> <span class="n">child_fun</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">child_dict</span> <span class="o">=</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">children</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">child_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">stop_at_elems</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">curr_node_elem</span><span class="p">:</span> <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">stop_at_escaped_elems</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_escaped</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">curr_node_elem</span><span class="p">:</span> <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_escaped</span> <span class="ow">and</span> <span class="n">curr_node_elem</span> <span class="ow">in</span> <span class="n">stop_if_paren_level_zero</span>
                    <span class="ow">and</span> <span class="n">paren_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">stop_at_depth</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">==</span> <span class="n">max_depth</span><span class="p">:</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">only_follow_elems</span><span class="p">:</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">only_follow_elems</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sort_children</span><span class="p">:</span>
                <span class="n">children</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="c1"># Update the paren counter.</span>
            <span class="k">if</span> <span class="n">curr_node_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">:</span>
                <span class="n">paren_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">curr_node_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">:</span>
                <span class="n">paren_count</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># Yield the results, according to the selected criteria.</span>
            <span class="n">yielded_already</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">copies</span><span class="p">:</span>
                <span class="n">yield_value</span> <span class="o">=</span> <span class="n">node_list</span><span class="p">[:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yield_value</span> <span class="o">=</span> <span class="n">node_list</span>
            <span class="k">if</span> <span class="n">yield_on_leaves</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span> <span class="c1"># match only leaves (or pseudo-leaves)</span>
                <span class="k">yield</span> <span class="n">yield_value</span>
                <span class="n">yielded_already</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">yield_on_match</span> <span class="ow">and</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">is_last_elem_of_key</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">yielded_already</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">yield_value</span>
            <span class="c1"># Set the escape-value to pass to the recursive calls.</span>
            <span class="n">is_escaped</span> <span class="o">=</span> <span class="n">curr_node_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_escaped</span>
            <span class="c1"># Recurse for each child.</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dfs_recursion</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">child_dict</span><span class="p">[</span><span class="n">elem</span><span class="p">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="n">is_escaped</span><span class="p">,</span> <span class="n">paren_count</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">node_list</span><span class="p">:</span>
                    <span class="n">node_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1"># each child adds one, so pop one</span>

        <span class="n">node_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">stop_at_depth</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">stop_at_depth</span>
            <span class="n">stop_at_depth</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># because 0 evals to False as a bool</span>

        <span class="k">return</span> <span class="n">dfs_recursion</span><span class="p">(</span><span class="n">subtree_root_elem</span><span class="p">,</span> <span class="n">subtree_root_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">subtree_root_escaped</span><span class="p">,</span>
                            <span class="n">first_paren_level</span><span class="p">)</span></div>

<div class="viewcode-block" id="RegexTrieDict.get_root_node_data_list"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.get_root_node_data_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_root_node_data_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This routine returns the initial node data list, for the root node.</span>
<span class="sd">        This list is used by get_next_nodes_meta to save the state of the</span>
<span class="sd">        pattern-matching between iterations.  Multiple instances are allowed.&quot;&quot;&quot;</span>
        <span class="c1"># The tuple of state-information on a NodeDataList is:</span>
        <span class="c1">#     (node, node_is_escape, loopback_stack, loop_counter_stack, loop_bounds_stack,</span>
        <span class="c1">#                                                       bound_node_child_dict)</span>
        <span class="n">node_data_list</span> <span class="o">=</span> <span class="n">NodeStateDataList</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">NodeStateData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">{},</span> <span class="nb">set</span><span class="p">())])</span>
        <span class="k">return</span> <span class="n">node_data_list</span></div>

<div class="viewcode-block" id="RegexTrieDict.has_key_meta"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.has_key_meta">[docs]</a>    <span class="k">def</span> <span class="nf">has_key_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test of whether the sequence of elements `key_seq` matches any of the</span>
<span class="sd">        regexp patterns stored in the `RegexTrieDict`.  Returns the number of</span>
<span class="sd">        matches.  Remember that any literal escapes in the trie must be</span>
<span class="sd">        escaped, but escapes in `key_seq` are always treated as literal.&quot;&quot;&quot;</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">SequentialPrefixMatcher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">key_seq</span><span class="p">:</span>
            <span class="n">matcher</span><span class="o">.</span><span class="n">append_key_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">matcher</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">:</span> <span class="c1"># No more states in matcher.</span>
                <span class="n">matcher</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="k">return</span> <span class="mi">0</span> <span class="c1"># No more nodes, can&#39;t match.</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">has_key_meta</span><span class="p">()</span>
        <span class="n">matcher</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span> <span class="c1"># Ends match and frees memory.</span>
        <span class="k">return</span> <span class="n">retval</span></div>

<div class="viewcode-block" id="RegexTrieDict.get_meta"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.get_meta">[docs]</a>    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_seq</span><span class="p">,</span> <span class="n">no_matches_retval</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the data items of all the stored strings which</span>
<span class="sd">        match the sequence of elements `key_seq` (based on the regex patterns</span>
<span class="sd">        stored in the `RegexTrieDict`).  The default with no matches is to</span>
<span class="sd">        return the empty list, which can be set via `no_matches_retval`.</span>
<span class="sd">        Remember that any literal escapes in the trie must be escaped, but</span>
<span class="sd">        escapes in `key_seq` are always treated as literal.&quot;&quot;&quot;</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">SequentialPrefixMatcher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">key_seq</span><span class="p">:</span>
            <span class="n">matcher</span><span class="o">.</span><span class="n">append_key_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">matcher</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">:</span> <span class="c1"># No more states in matcher.</span>
                <span class="n">matcher</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">no_matches_retval</span> <span class="c1"># No more nodes, can&#39;t match.</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">no_matches_retval</span><span class="o">=</span><span class="n">no_matches_retval</span><span class="p">)</span>
        <span class="n">matcher</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span> <span class="c1"># Ends match and frees memory.</span>
        <span class="k">return</span> <span class="n">retval</span></div>

<div class="viewcode-block" id="RegexTrieDict.match_prefixes_meta"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.match_prefixes_meta">[docs]</a>    <span class="k">def</span> <span class="nf">match_prefixes_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_seq</span><span class="p">,</span> <span class="n">only_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">longest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">join_elems</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is similar to the `match` method of the Python libarary&#39;s</span>
<span class="sd">        regex module.  Matches the longest prefix of `elem_seq`.</span>

<span class="sd">        When a match is identified it returns a two-tuple.  The first component</span>
<span class="sd">        contains the sequence of elements that gave the longest match (i.e.,</span>
<span class="sd">        the matching prefix).  If `join_elems` is true (the default) these</span>
<span class="sd">        elements will be combined using the `+=` operator; otherwise a</span>
<span class="sd">        tuple of elements is returned.  The second component of the returned</span>
<span class="sd">        tuple will contain a tuple of each data item stored in the trie for</span>
<span class="sd">        each pattern that the sequence matched.&quot;&quot;&quot;</span>
        <span class="c1"># TODO not finished..... working on greedy stuff in PrefixMatcher and</span>
        <span class="c1"># FULL vs. PREFIX matches first.  Should this just be left to the scanner</span>
        <span class="c1"># instead?</span>
        <span class="n">match_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">elem_deque</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">elem_seq</span><span class="p">)</span> <span class="c1"># Note this copies, too.</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">SequentialPrefixMatcher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">matcher</span><span class="o">.</span><span class="n">append_key_elem</span><span class="p">(</span><span class="n">elem_deque</span><span class="o">.</span><span class="n">pop_left</span><span class="p">())</span>
                <span class="c1"># CHECK HERE IF WE GOT A MATCH</span>

                <span class="c1">#if matcher.cannot_match():</span>
                <span class="c1">#    matcher.reset()</span>
                <span class="c1">#    return default # No more nodes, can&#39;t match.</span>
            <span class="n">match_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matcher</span><span class="o">.</span><span class="n">get_meta</span><span class="p">())</span>
            <span class="n">matcher</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span> <span class="c1"># Ends match and frees memory.</span>
        <span class="k">return</span> <span class="n">match_list</span></div>

<div class="viewcode-block" id="RegexTrieDict.get_next_nodes_meta"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.get_next_nodes_meta">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_nodes_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data_list</span><span class="p">,</span>
                                                       <span class="n">ignore_validity</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of next nodes for each node on `node_data_list`,</span>
<span class="sd">        interpreting any stored pattern-matching meta-elements, when the</span>
<span class="sd">        query-key element query_elem is received.  The `node_data_list` should</span>
<span class="sd">        be a `NodeStateDataList` object.  It stores a list of `NodeStateData`</span>
<span class="sd">        instances, each representing a &quot;live&quot; state in the nondeterministic</span>
<span class="sd">        search.  A state consists of a node in the trie as well as some</span>
<span class="sd">        additional state information.</span>

<span class="sd">        See the routine `has_key_meta` for a simple example of how this method</span>
<span class="sd">        is used.</span>

<span class="sd">        When `query_elem` is set to the special value</span>
<span class="sd">        `self.magic_elem_never_matches` this routine has special behavior</span>
<span class="sd">        defined.  It will simply fast-forward up to the point where that</span>
<span class="sd">        character *would have been* compared to the next one in the</span>
<span class="sd">        query-pattern.  Then it stops, returning those stop-nodes.  This turns</span>
<span class="sd">        out to be very convenient for skipping closing right-group elements as</span>
<span class="sd">        well as zero-repetition-matching patterns at the end of a larger key</span>
<span class="sd">        pattern.  Recall that to check for a match we need to look at the</span>
<span class="sd">        `is_last_elem_of_key` values at the very end of the stored pattern,</span>
<span class="sd">        which for some patterns includes the closing element.  Any</span>
<span class="sd">        `node_data_list` elements which immediately precede a comparison with</span>
<span class="sd">        an element or set of elements (a literal character or a wildcard) are</span>
<span class="sd">        left unchanged.  Any others move forward to such a point.  Any</span>
<span class="sd">        well-defined pattern has such an endpoint.&quot;&quot;&quot;</span>

        <span class="c1">#print(&quot;\ndebug get_next_nodes_meta call, processing query char&quot;, query_elem)</span>
        <span class="c1">#print(&quot;*&quot;*30)</span>
        <span class="c1">#for nd in node_data_list:</span>
        <span class="c1">#   self.print_tree(childFun=nd.children)</span>
        <span class="c1">#print(&quot;*&quot;*30)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_validity</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node_data_list</span><span class="o">.</span><span class="n">is_valid_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ModifiedTrieError</span><span class="p">(</span><span class="s2">&quot;Invalid node_data_list, trie has changed.&quot;</span><span class="p">)</span>

        <span class="c1"># If we are starting a magic_elem search, save the current node with the</span>
        <span class="c1"># state.  This is to avoid infinite recursion in processing repetitions</span>
        <span class="c1"># that match zero times.  The visitedSet is emptied in `process_node_data`</span>
        <span class="c1"># when a valid end-point is reached.  The `append_child_node` routine adds</span>
        <span class="c1"># any nodes to the set that it processes, and drops any that would</span>
        <span class="c1"># loop.</span>
        <span class="c1"># TODO consider just turning off all looping-back in `handleEndRepetition`...</span>
        <span class="c1"># just set a switch here and turn back off at end.  No valid endpoint is</span>
        <span class="c1"># at beginning of a loop, anyway.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_no_loop</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># debug xxx</span>
        <span class="k">if</span> <span class="n">query_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_never_matches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_no_loop</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># debug xxx</span>

        <span class="c1"># Define the list that will be built-up with next states during the</span>
        <span class="c1"># processing.  This object will be the return value of the function.</span>
        <span class="n">next_node_data_list</span> <span class="o">=</span> <span class="n">NodeStateDataList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">node_data_list</span><span class="p">:</span>
            <span class="c1"># Process the node_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_node_data</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">next_node_data_list</span></div>

    <span class="k">def</span> <span class="nf">_skip_node_data_list_escapes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_data_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This utility routine handles pattern-escapes in a list of node-data tuples.</span>
<span class="sd">        It is always called by `process_node_data` as the first step</span>
<span class="sd">        (unless it is called with `skipEscapes=False`).  For each node on</span>
<span class="sd">        `node_data_list`, a parallel node is added for each escape-element child,</span>
<span class="sd">        since that will have to be interpreted specially on the next iteration.</span>
<span class="sd">        We are skipping the escape itself but setting a bool in the `nodeData`</span>
<span class="sd">        state to remember it.  If escape is the only child of a node in a</span>
<span class="sd">        `nodeData` tuple then the original `nodeData` tuple is removed from the list.</span>
<span class="sd">        An ordinary list of `NodeData` instances is OK to pass as `node_data_list`.</span>
<span class="sd">        The return value is a `NodeStateDataList`.&quot;&quot;&quot;</span>
        <span class="n">escaped_node_data_list</span> <span class="o">=</span> <span class="n">NodeStateDataList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">node_data_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="ow">in</span> <span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="c1"># Note copies of the loop states are used.</span>
                <span class="n">node_data_copy</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># TODO can skip copy when single child</span>
                <span class="n">node_data_copy</span><span class="o">.</span><span class="n">node_is_escape</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">escaped_node_data_list</span><span class="o">.</span><span class="n">append_child_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="n">node_data_copy</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># escape is only child</span>
            <span class="n">escaped_node_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_data</span><span class="p">)</span> <span class="c1"># copy the node over unchanged</span>
        <span class="k">return</span> <span class="n">escaped_node_data_list</span>

<div class="viewcode-block" id="RegexTrieDict.process_node_data"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.process_node_data">[docs]</a>    <span class="k">def</span> <span class="nf">process_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">,</span>
                                                            <span class="n">skip_escapes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the instance `node_data`, usually from the `node_data_list`.</span>
<span class="sd">        Put the results on `next_node_data_list`.  This large routine does most</span>
<span class="sd">        of the work in the processing, and is called recursively when</span>
<span class="sd">        necessary.</span>

<span class="sd">        Escapes are skipped (generally producing a list of `NodeStateData`</span>
<span class="sd">        instances) unless `skip_escapes` is set `False`.  Escapes are skipped</span>
<span class="sd">        by default, but when called recursively after finding an escape the</span>
<span class="sd">        value is set to `True`.&quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># If escapes are to be skipped, recursively process all the resulting nodes.</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="n">skip_escapes</span><span class="p">:</span>
            <span class="n">node_data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skip_node_data_list_escapes</span><span class="p">([</span><span class="n">node_data</span><span class="p">])</span>
            <span class="c1"># We have to loop over the recursion because new states may get</span>
            <span class="c1"># added by `_skip_node_data_list_escapes`.</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">node_data_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_node_data</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">,</span>
                                                          <span class="n">skip_escapes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1">#</span>
        <span class="c1"># Handle ordinary, non-escaped nodes in the pattern trie.</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">node_data</span><span class="o">.</span><span class="n">node_is_escape</span><span class="p">:</span>

            <span class="n">node_data</span><span class="o">.</span><span class="n">visited_repetition_node_id_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Got a literal elem, reset.</span>

            <span class="k">if</span> <span class="n">query_elem</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_never_matches</span><span class="p">:</span>
                <span class="n">next_node_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_data</span><span class="p">)</span> <span class="c1"># Just keep the node itself.</span>

            <span class="k">elif</span> <span class="n">query_elem</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_always_matches</span><span class="p">:</span>
                <span class="n">children_dict</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">query_elem</span> <span class="ow">in</span> <span class="n">children_dict</span><span class="p">:</span>
                    <span class="c1"># TODO: consider breaking after first if only testing for cannot_match</span>
                    <span class="n">next_node_data_list</span><span class="o">.</span><span class="n">append_child_node</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span>
                                                          <span class="n">node_is_escape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">query_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                <span class="c1"># Can&#39;t match because node is neither an escaped escape char nor</span>
                <span class="c1"># a meta-pattern.  TODO, is this really needed?  Explain more if so,</span>
                <span class="c1"># delete otherwise.</span>
                <span class="k">pass</span>

            <span class="k">elif</span> <span class="n">query_elem</span> <span class="ow">in</span> <span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">next_node_data_list</span><span class="o">.</span><span class="n">append_child_node</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span>
                                                 <span class="n">node_is_escape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Handle escaped nodes in the pattern trie, which have special meaning.</span>
        <span class="c1">#</span>

        <span class="k">elif</span> <span class="n">node_data</span><span class="o">.</span><span class="n">node_is_escape</span><span class="p">:</span>
            <span class="c1"># At a node for an escape-element, see if any meta-element patterns</span>
            <span class="c1"># are among its keys.  After the first escape in a pattern we can get</span>
            <span class="c1"># a repetition, a left-wildcard bracket, or another escape (to be</span>
            <span class="c1"># treated as a literal).  Multiple are possible.  Inside a</span>
            <span class="c1"># repetition, which are evaluated as normal sequences, we can also</span>
            <span class="c1"># encounter a close-group metacharacter and we have to decide</span>
            <span class="c1"># whether or not to loop back.  All other escaped characters at</span>
            <span class="c1"># this level are errors.</span>

            <span class="n">next_meta_elems</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="c1">#print(&quot;next meta elems are&quot;, next_meta_elems)</span>

            <span class="c1"># Loop through the meta-elems stored at the node and handle each one.</span>
            <span class="k">for</span> <span class="n">meta_elem</span> <span class="ow">in</span> <span class="n">next_meta_elems</span><span class="p">:</span>

                <span class="c1">#</span>
                <span class="c1"># Double escape in a patern matches a single escape in query-key.</span>
                <span class="c1">#</span>
                <span class="k">if</span> <span class="n">meta_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">query_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                        <span class="c1">#print(&quot;got escaped escape, adding to trie as element&quot;)</span>
                        <span class="n">next_node_data_list</span><span class="o">.</span><span class="n">append_child_node</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span>
                                                              <span class="n">node_is_escape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># An escaped escape just doesn&#39;t match, no new node_data.</span>
                        <span class="k">continue</span>

                <span class="c1">#</span>
                <span class="c1"># Handle the dot pattern.</span>
                <span class="c1">#</span>
                <span class="k">elif</span> <span class="n">meta_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">:</span>
                    <span class="c1"># Remember that binding in Python DOES allow resetting wildcards in loops.</span>
                    <span class="k">if</span> <span class="n">query_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_never_matches</span><span class="p">:</span>
                        <span class="n">next_node_data_list</span><span class="o">.</span><span class="n">append_child_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span>
                                                                  <span class="n">node_is_escape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Handle begin-repetitions.</span>
                <span class="c1">#</span>
                <span class="k">elif</span> <span class="n">meta_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">:</span>
                    <span class="c1">#print(&quot;DEBUG got a *, meta_elem is&quot;, meta_elem)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handle_begin_repetitions</span><span class="p">(</span>
                                      <span class="n">node_data</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Handle end-repetitions.</span>
                <span class="c1">#</span>
                <span class="k">elif</span> <span class="n">meta_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">:</span>
                    <span class="n">node_data_copy</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># debug, unnecessary copy? xxx</span>
                    <span class="n">node_data_copy</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">)</span> <span class="c1"># debug, unnecessary? xxx</span>
                    <span class="n">node_data_copy</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node_data_copy</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handle_end_repetitions</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data_copy</span><span class="p">,</span>
                                        <span class="n">next_node_data_list</span><span class="p">,</span> <span class="n">refuse_revisits</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Handle beginning of an &quot;or&quot; group.</span>
                <span class="c1">#</span>
                <span class="k">elif</span> <span class="n">meta_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handle_beginning_of_or_group</span><span class="p">(</span><span class="n">node_data</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span>
                                                              <span class="n">next_node_data_list</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Handle end of non-final end-section of an or-group (an or_elem &quot;|&quot;).</span>
                <span class="c1">#</span>
                <span class="k">elif</span> <span class="n">meta_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_elem</span><span class="p">:</span>
                    <span class="c1">#print(&quot;debug processing non-final &#39;or&#39; group section&quot;)</span>
                    <span class="c1">#print(</span>
                    <span class="c1">#    &quot;   debug node_data.loop_counter_stack is&quot;,</span>
                    <span class="c1">#        node_data.loop_counter_stack)</span>
                    <span class="c1"># Get a generator for all final r_group elems at this point.  There</span>
                    <span class="c1"># should only be one, since the state was fixed to single-children</span>
                    <span class="c1"># when the &#39;or&#39; was first processed.</span>
                    <span class="n">dfs_gen_or_section_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dfs_gen</span><span class="p">(</span>
                                  <span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">or_elem</span><span class="p">],</span> <span class="n">include_root</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">copies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stop_if_paren_level_zero</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">],</span>
                                  <span class="n">first_paren_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">child_fun</span><span class="o">=</span><span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">treePath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfs_gen_or_section_end</span><span class="p">):</span>
                        <span class="c1">#print(&quot;      debug treePathToEndSection in process &#39;or&#39; elem&quot;,</span>
                        <span class="c1">#                                  [t[0] for t in treePath])</span>
                        <span class="c1"># Errors checked earlier, when l_group of the &#39;or&#39; was processed.</span>
                        <span class="n">r_group_elem</span><span class="p">,</span> <span class="n">r_group_node</span> <span class="o">=</span> <span class="n">treePath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">node_data_copy</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># debug, unneeded?? xxx</span>
                        <span class="n">node_data_copy</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">or_elem</span><span class="p">)</span> <span class="c1"># debug, unnecessary?? xxx</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">handle_end_repetitions</span><span class="p">(</span>
                            <span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data_copy</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">,</span>
                            <span class="n">replace_node</span><span class="o">=</span><span class="n">r_group_node</span><span class="p">)</span>
                        <span class="c1"># When &#39;or&#39; is set it should give all nodes for state</span>
                        <span class="c1"># single-children</span>
                        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># This is just a consistency-check assertion.</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;Failure in &#39;or&#39; child-setting.&quot;</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Handle wildcards.</span>
                <span class="c1">#</span>
                <span class="k">elif</span> <span class="n">meta_elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_wildcard</span><span class="p">:</span>
                    <span class="c1">#print(&quot;debug processing wildcard&quot;)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handle_wildcards</span><span class="p">(</span><span class="n">node_data</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Error condition otherwise.</span>
                <span class="c1">#</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># An escape in some pattern isn&#39;t followed by a valid meta-elem,</span>
                    <span class="c1"># like r&quot;\Z&quot;.</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid meta-element (unknown escaped element) encountered.&quot;</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Query element is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">query_elem</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Node&#39;s children are:</span><span class="se">\n</span><span class="s2">   &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">next_meta_elems</span><span class="p">))</span>

        <span class="k">return</span> <span class="c1"># from `process_node_data`</span></div>

<div class="viewcode-block" id="RegexTrieDict.handle_wildcards"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.handle_wildcards">[docs]</a>    <span class="k">def</span> <span class="nf">handle_wildcards</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle wildcard patterns in meta-processing the trie.  The</span>
<span class="sd">        `next_node_data` list is appended to for all matches.&quot;&quot;&quot;</span>
        <span class="n">node_data</span><span class="o">.</span><span class="n">visited_repetition_node_id_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># got an actual elem, reset</span>

        <span class="c1"># Magic elem doesn&#39;t match any char; just put current node on</span>
        <span class="c1"># next_node_data_list (so `is_last_elem_of_key` can be checked).</span>
        <span class="n">always_match</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">query_elem</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_never_matches</span><span class="p">:</span>
            <span class="n">next_node_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_data</span><span class="p">)</span> <span class="c1"># just keep the node itself</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">query_elem</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_always_matches</span><span class="p">:</span>
            <span class="n">always_match</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Generate all the wildcard patterns (several can share same prefix in trie).</span>
        <span class="n">wildcard_patt_gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dfs_gen</span><span class="p">(</span><span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_wildcard</span><span class="p">],</span>
                              <span class="n">include_root</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">child_fun</span><span class="o">=</span><span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">,</span>
                              <span class="n">stop_at_escaped_elems</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">r_wildcard</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">wildcard_patt</span> <span class="ow">in</span> <span class="n">wildcard_patt_gen</span><span class="p">:</span>
            <span class="c1"># print(&quot;      debug wildcard patt&quot;, [ t[0] for t in wildcard_patt</span>
            <span class="c1"># ])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wildcard_patt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># root, some char, esc, r_wildcard</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;No closing bracket for wildcard.&quot;</span><span class="p">)</span>
            <span class="n">r_wildcard_elem</span><span class="p">,</span> <span class="n">r_wildcard_node</span> <span class="o">=</span> <span class="n">wildcard_patt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">escape_elem</span><span class="p">,</span> <span class="n">escape_node</span> <span class="o">=</span> <span class="n">wildcard_patt</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">r_wildcard_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_wildcard</span> <span class="ow">or</span> <span class="n">escape_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;No closing bracket for wildcard.&quot;</span><span class="p">)</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">wildcard_patt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># If the character matches the wildcard pattern:</span>
            <span class="c1"># 1) Get a copy NodeStateData.</span>
            <span class="c1"># 2) In the NodeStateData, fix all the nodes on the path to the</span>
            <span class="c1">#    end-element to have one child (the new NodeStateData now</span>
            <span class="c1">#    represents just one pattern instance, not the full subtree).</span>
            <span class="c1"># 3) Append the node to next_node_data_list.</span>
            <span class="k">if</span> <span class="n">always_match</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">wildcard_patt_match_fun</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">range_elem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">):</span>
                <span class="n">node_data_copy</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">node_data_copy</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_wildcard</span><span class="p">)</span>

                <span class="c1"># Fix the children on the wildcard_patt list to only have</span>
                <span class="c1"># one child.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wildcard_patt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">node_data_copy</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span> <span class="c1"># elem of next, node of current</span>
                        <span class="n">wildcard_patt</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="o">=</span><span class="n">wildcard_patt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># Set the other elements and append to next_node_data_list.</span>
                <span class="n">node_data_copy</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">r_wildcard_node</span> <span class="c1"># stacks do not change</span>
                <span class="n">node_data_copy</span><span class="o">.</span><span class="n">node_is_escape</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">next_node_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_data_copy</span><span class="p">)</span></div>

<div class="viewcode-block" id="RegexTrieDict.handle_begin_repetitions"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.handle_begin_repetitions">[docs]</a>    <span class="k">def</span> <span class="nf">handle_begin_repetitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">next_node_data_elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called when a begin-repetition node (i.e. for &#39;*&#39;) is reached in the</span>
<span class="sd">        trie, to handle the repetition.&quot;&quot;&quot;</span>
        <span class="c1"># Add the repetition subtree leaves to the `next_node_data_elem`, and</span>
        <span class="c1"># process them as end-repetition events (generating the loop back and</span>
        <span class="c1"># the continuation.  Note that repetition generally matches zero times,</span>
        <span class="c1"># so the end of every repetition pattern is a valid continuation point.</span>
        <span class="c1"># So we have to go out to the end nodes and start states for those</span>
        <span class="c1"># possibilities.  We only need one new state for going through the</span>
        <span class="c1"># characters inside the repetition group, however, so after the first</span>
        <span class="c1"># one the others are processed with `no_loop=True`.</span>

        <span class="c1"># A repetition element must be followed by an open-group element on</span>
        <span class="c1"># each path following it.  Get a generator for those nodes.  We only</span>
        <span class="c1"># need one new state at the beginning.</span>
        <span class="n">dfs_gen_open</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dfs_gen</span><span class="p">(</span><span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">],</span>
                         <span class="n">include_root</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">stop_at_escaped_elems</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">],</span>
                         <span class="n">child_fun</span><span class="o">=</span><span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tree_path_to_open_group</span> <span class="ow">in</span> <span class="n">dfs_gen_open</span><span class="p">:</span>
            <span class="c1"># Check some error conditions.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_path_to_open_group</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># root, esc, l_group</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                    <span class="s2">&quot;No open-group following a repetition.&quot;</span><span class="p">)</span>
            <span class="n">l_group_elem</span><span class="p">,</span> <span class="n">l_group_node</span> <span class="o">=</span> <span class="n">tree_path_to_open_group</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">l_group_esc</span><span class="p">,</span> <span class="n">l_group_esc_node</span> <span class="o">=</span> <span class="n">tree_path_to_open_group</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1">#print(&quot;   debug tree_path_to_open_group&quot;, [ t[0] for t in</span>
            <span class="c1">#                                          tree_path_to_open_group])</span>
            <span class="k">if</span> <span class="n">l_group_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_group</span> <span class="ow">or</span> <span class="n">l_group_esc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                    <span class="s2">&quot;No open-group element following a repetition element.&quot;</span><span class="p">)</span>
            <span class="n">iter_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_repetition_params</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
                                                         <span class="n">tree_path_to_open_group</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

            <span class="c1"># If at least one iteration is required then we can avoid having</span>
            <span class="c1"># to find all the closing-group elements for the subtree and</span>
            <span class="c1"># launching new states for each one (they are the zero-repetition</span>
            <span class="c1"># states). We can just start a state and wait and later see which</span>
            <span class="c1"># ones ever reach their end-group loopback points.</span>
            <span class="k">if</span> <span class="n">iter_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># At least one iteration is required.</span>
                <span class="k">pass</span> <span class="c1"># TODO, just a possible optimization of what already works.</span>

            <span class="c1"># Now, for each opening paren, get a generator for all the closing</span>
            <span class="c1"># parens corresponding to it.</span>
            <span class="n">dfs_gen_close</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dfs_gen</span><span class="p">(</span><span class="n">l_group_node</span><span class="p">,</span> <span class="n">include_root</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">copies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">stop_if_paren_level_zero</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_elem</span><span class="p">],</span>
                                 <span class="n">first_paren_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">child_fun</span><span class="o">=</span><span class="n">node_data</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="n">set_no_loop</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># whether to only create a break-state, no loop-state</span>
            <span class="k">for</span> <span class="n">tree_path_to_close_group</span> <span class="ow">in</span> <span class="n">dfs_gen_close</span><span class="p">:</span>
                <span class="c1"># Do some error checks.</span>
                <span class="k">if</span> <span class="n">tree_path_to_close_group</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_elem</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                        <span class="s2">&quot;Or element without opening paren.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_path_to_close_group</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># root, esc, r_group</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;Illegal empty repetition group &quot;</span>
                                            <span class="s2">&quot;or no close-group for repetition.&quot;</span><span class="p">)</span>
                <span class="n">r_group_elem</span><span class="p">,</span> <span class="n">r_group_node</span> <span class="o">=</span> <span class="n">tree_path_to_close_group</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">r_group_esc</span><span class="p">,</span> <span class="n">r_group_esc_node</span> <span class="o">=</span> <span class="n">tree_path_to_close_group</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1">#print(&quot;      debug tree_path_to_close_group&quot;, [ t[0] for t in</span>
                <span class="c1">#                                      tree_path_to_close_group ])</span>
                <span class="k">if</span> <span class="n">r_group_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_group</span> <span class="ow">or</span> <span class="n">r_group_esc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                        <span class="s2">&quot;No close-group matching a repetition open-group.&quot;</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Push the loopback node on the stack and treat as end repetition.</span>
                <span class="c1">#</span>

                <span class="n">pushed_node_data</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Fix the children of nodes for original repetition and beginning</span>
                <span class="c1"># nodes skipped by dfs, for new state, in case nested</span>
                <span class="c1"># repetitions.</span>
                <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">)</span> <span class="c1"># do before node reassign!</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree_path_to_open_group</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span> <span class="c1"># elem of next, node of current</span>
                        <span class="n">tree_path_to_open_group</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">node</span><span class="o">=</span><span class="n">tree_path_to_open_group</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">r_group_node</span>
                <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">node_is_escape</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">loopback_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_group_node</span><span class="p">)</span>
                <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">loop_counter_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">loop_bounds_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_bounds</span><span class="p">)</span>
                <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">visited_repetition_node_id_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">l_group_node</span><span class="p">))</span>

                <span class="c1"># Process the new pushed_node_data as an end-repetition.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">handle_end_repetitions</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">pushed_node_data</span><span class="p">,</span>
                                            <span class="n">next_node_data_elem</span><span class="p">,</span> <span class="n">no_loop</span><span class="o">=</span><span class="n">set_no_loop</span><span class="p">)</span>
                <span class="n">set_no_loop</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># We only need one new state at the beginning.</span></div>

<div class="viewcode-block" id="RegexTrieDict.handle_end_repetitions"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.handle_end_repetitions">[docs]</a>    <span class="k">def</span> <span class="nf">handle_end_repetitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span> <span class="n">close_paren_node_data</span><span class="p">,</span>
                           <span class="n">next_node_data_list</span><span class="p">,</span> <span class="n">replace_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">no_loop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_break</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">refuse_revisits</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle reaching the close of a repetition group.  The `close_paren_node_data`</span>
<span class="sd">        should corresponding to the node for the closing repetition-group.  If</span>
<span class="sd">        `replace_node` is set to a node then it replaces the node in</span>
<span class="sd">        `close_paren_node_data` as the new node to jump to after a breaking a loop</span>
<span class="sd">        (used in inside sections of &#39;or&#39; patterns).&quot;&quot;&quot;</span>
        <span class="c1">#print(&quot;debug in handleEndRepetition&quot;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">loopback_stack</span>
                <span class="ow">and</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">loop_counter_stack</span>
                <span class="ow">and</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">loop_bounds_stack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                <span class="s2">&quot;IndexError on a stack pop, probably mismatched parentheses.&quot;</span><span class="p">)</span>

        <span class="c1"># Here we branch the state into one branch that repeats the loop,</span>
        <span class="c1"># and one that breaks out of the loop.  Note that ordinary lists are</span>
        <span class="c1"># OK here, we have already checked validity of the original list and</span>
        <span class="c1"># any new NodeStateData instances will be added to next_node_data_list,</span>
        <span class="c1"># which is already a NodeStateDataList.</span>

        <span class="c1"># Get some preliminary values needed for conditional tests.</span>
        <span class="c1">#open_paren_node = close_paren_node_data.loopback_stack[-1] # loop back to open-group node</span>
        <span class="n">loop_count</span> <span class="o">=</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">loop_counter_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">loop_bound_min</span><span class="p">,</span> <span class="n">loop_bound_max</span> <span class="o">=</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">loop_bounds_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># The node_data for breaking out of the loop.  If loop_count is below</span>
        <span class="c1"># loop_bound_min then we cannot break the loop yet.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: Can free up the stored bound_node_child_dict for breaks to empty</span>
        <span class="c1"># stack level 0.</span>
        <span class="c1">#</span>
        <span class="c1"># TODO When the bound_node_child_list is set in repetition we don&#39;t need</span>
        <span class="c1"># to copy it.</span>
        <span class="k">if</span> <span class="n">loop_count</span> <span class="o">&gt;=</span> <span class="n">loop_bound_min</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">no_break</span><span class="p">:</span>
            <span class="n">break_node_data</span> <span class="o">=</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">replace_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">break_node_data</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">replace_node</span>
            <span class="n">break_node_data</span><span class="o">.</span><span class="n">node_is_escape</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">break_node_data</span><span class="o">.</span><span class="n">loopback_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">break_node_data</span><span class="o">.</span><span class="n">loop_counter_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">break_node_data</span><span class="o">.</span><span class="n">loop_bounds_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">break_node_data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">break_node_data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">break_node_data_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">magic_elem_no_loop</span> <span class="ow">or</span> <span class="p">(</span><span class="n">refuse_revisits</span> <span class="ow">and</span>
                                    <span class="nb">id</span><span class="p">(</span><span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">loopback_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                    <span class="ow">in</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">visited_repetition_node_id_set</span><span class="p">):</span>
            <span class="n">no_loop</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># The node_data for continuing the loop.  If loop_count is above</span>
        <span class="c1"># loop_bound_max then we cannot continue the loop and can only break.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">loop_count</span> <span class="o">&lt;</span> <span class="n">loop_bound_max</span> <span class="ow">or</span> <span class="n">loop_bound_max</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">no_loop</span><span class="p">:</span>
            <span class="n">loop_node_data</span> <span class="o">=</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">loop_node_data</span><span class="o">.</span><span class="n">node_is_escape</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">loop_node_data</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">loop_node_data</span><span class="o">.</span><span class="n">loopback_stack</span><span class="p">[</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># loop back to open-group node</span>
            <span class="n">loop_node_data</span><span class="o">.</span><span class="n">loop_counter_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increment the loop counter</span>
            <span class="n">loop_node_data</span><span class="o">.</span><span class="n">visited_repetition_node_id_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">loop_node_data</span><span class="o">.</span><span class="n">node</span><span class="p">))</span>
            <span class="n">loop_node_data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">loop_node_data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loop_node_data_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Combine any nodes generated.</span>
        <span class="n">node_data_list</span> <span class="o">=</span> <span class="n">break_node_data_list</span> <span class="o">+</span> <span class="n">loop_node_data_list</span>

        <span class="c1"># Detect problem with ill-formed pattern of a repetition as the only</span>
        <span class="c1"># thing inside another repetition.  If the loop&#39;s break-point leads to</span>
        <span class="c1"># a close-group and its loopback leads to a repetition then it is the</span>
        <span class="c1"># open-repetition for the loop we just broke out of (because open and</span>
        <span class="c1"># close groups are strictly nested).  So that is one way to detect an</span>
        <span class="c1"># illegal nested repetition with no other elements in the outer</span>
        <span class="c1"># repetition.  If not caught, this will cause an infinite recursion.</span>
        <span class="c1"># (The infinite recursion occurs because the processing below will</span>
        <span class="c1"># immediately process the repetition again, fast-forward to the end,</span>
        <span class="c1"># and we&#39;re right back here again.)</span>
        <span class="c1">#</span>
        <span class="c1"># Note this could be allowed now, since infinite recursions are</span>
        <span class="c1"># limited, but keep it as an error since it likely isn&#39;t intended.</span>
        <span class="k">if</span> <span class="n">break_node_data_list</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">close_paren_node</span> <span class="o">=</span> <span class="n">close_paren_node_data</span><span class="o">.</span><span class="n">node</span>
                <span class="n">close_paren_node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">]</span> <span class="c1"># TODO see below</span>
                <span class="n">break_node_data</span><span class="o">.</span><span class="n">loopback_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span> <span class="c1"># TODO exception for flow control</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">]</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;Illegal nested repetition pattern with no&quot;</span>
                                        <span class="s2">&quot; characters in the outer repetition.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                    <span class="s2">&quot;Index error on stack pop, probably mismatched parentheses.&quot;</span><span class="p">)</span>

        <span class="c1"># The repetition meta-characters do not count as a character of the</span>
        <span class="c1"># literal pattern being matched to query_elem, so run process_node_data on the</span>
        <span class="c1"># computed nodes.</span>
        <span class="k">for</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">node_data_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_node_data</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="RegexTrieDict.process_repetition_params"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.process_repetition_params">[docs]</a>    <span class="k">def</span> <span class="nf">process_repetition_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the sequence between the begin-repetition and the open-group</span>
<span class="sd">        that necessarily follows it.  Return a tuple (minIter, maxIter), with</span>
<span class="sd">        -1 for infinite maxIter.&quot;&quot;&quot;</span>
        <span class="n">tuple_list</span> <span class="o">=</span> <span class="n">process_elem_list_for_escapes</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># The first value if only one, or the second otherwise.</span>
        <span class="n">first_val</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># The second value, if there is one.</span>
        <span class="n">val_set</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span> <span class="ow">in</span> <span class="n">tuple_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">val_set</span><span class="p">:</span>
                        <span class="c1"># Note first value could default to zero if empty, but that would</span>
                        <span class="c1"># add a redundant representation for such patterns.</span>
                        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;No value in first slot of two-place&quot;</span>
                                                <span class="s2">&quot; repetition bounds specification.&quot;</span><span class="p">)</span>
                    <span class="n">first_val</span> <span class="o">=</span> <span class="n">val</span> <span class="c1"># a second value will follow</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;Bad escaped character in repetition&quot;</span>
                                            <span class="s2">&quot; bounds specification.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">digit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elem_to_digit_fun</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">val</span> <span class="o">+</span> <span class="n">digit</span>
                <span class="n">val_set</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">first_val</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">first_val</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>

<div class="viewcode-block" id="RegexTrieDict.handle_beginning_of_or_group"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDict.handle_beginning_of_or_group">[docs]</a>    <span class="k">def</span> <span class="nf">handle_beginning_of_or_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_data</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">,</span>
                                                        <span class="n">next_node_data_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle reaching the beginning of an &quot;or&quot; group in the trie.&quot;&quot;&quot;</span>
        <span class="c1"># TODO if we&#39;re not inside a loop or are guaranteed to break out then</span>
        <span class="c1"># we can just have a single state at each start point, and not</span>
        <span class="c1"># set the children to single-children, either... consider this.</span>

        <span class="c1"># Treat this entire &#39;or&#39; group as a one-repetition loop.  This is so we</span>
        <span class="c1"># know what to do then final r_group is encountered.  The actual</span>
        <span class="c1"># loopback point isn&#39;t required and is set to a dummy node.  The</span>
        <span class="c1"># continuation point will either be the next node in the tree when the</span>
        <span class="c1"># final r_group element is processed as the end of a one-repetition</span>
        <span class="c1"># loop, or else it will be calculated when an or_elem (&quot;|&quot;) is</span>
        <span class="c1"># encountered.</span>

        <span class="c1"># Make a copy of the node_data state for this start-point.</span>
        <span class="n">pushed_node_data</span> <span class="o">=</span> <span class="n">node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">node_is_escape</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">loopback_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">TrieDictNode</span><span class="p">())</span> <span class="c1"># dummy, popped later</span>
        <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">loop_counter_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">loop_bounds_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">)</span>

        <span class="c1"># Get a generator generating each path to a corresponding close-group.</span>
        <span class="c1"># Note the current implementation is inefficient.</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">]</span>
        <span class="n">dfs_gen_or_group_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dfs_gen</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span> <span class="n">include_root</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">copies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stop_if_paren_level_zero</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">],</span>
                               <span class="n">first_paren_level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                               <span class="n">child_fun</span><span class="o">=</span><span class="n">pushed_node_data</span><span class="o">.</span><span class="n">children</span><span class="p">,</span>
                               <span class="n">subtree_root_elem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">)</span>

        <span class="c1"># Iterate the generator, creating states for each section of each tree</span>
        <span class="c1"># path.</span>
        <span class="k">for</span> <span class="n">tree_path_to_end_group</span> <span class="ow">in</span> <span class="n">dfs_gen_or_group_end</span><span class="p">:</span>
            <span class="c1">#print(&quot;debug&quot;, [i[0] for i in tree_path_to_end_group])</span>
            <span class="c1">#print(&quot;debug, query_elem is&quot;, query_elem)</span>
            <span class="c1"># Do some error checks.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_path_to_end_group</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># root, esc, r_group # TODO check</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;Illegal empty &#39;or&#39; group &quot;</span>
                                        <span class="s2">&quot;or no close-group for &#39;or&#39;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tree_path_to_end_group</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span>
               <span class="ow">or</span> <span class="n">tree_path_to_end_group</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                    <span class="s2">&quot;No close-group matching an &#39;or&#39; open-group.&quot;</span><span class="p">)</span>

            <span class="c1"># Fix all the nodes on the path to have one child (for these states).</span>
            <span class="c1"># We make a new copy for each path to the closing r_group, though.</span>
            <span class="n">pushed_node_data_copy</span> <span class="o">=</span> <span class="n">pushed_node_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree_path_to_end_group</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">pushed_node_data_copy</span><span class="o">.</span><span class="n">set_child</span><span class="p">(</span> <span class="c1"># elem of next, node of current</span>
                    <span class="n">tree_path_to_end_group</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="o">=</span><span class="n">tree_path_to_end_group</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Find all the begin-section markers inside the &#39;or&#39; group and start a</span>
            <span class="c1"># new state for each one (i.e., opening paren and all &#39;|&#39;</span>
            <span class="c1"># elements).</span>
            <span class="n">escaped</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># The first l_group is escaped.</span>
            <span class="n">paren_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree_path_to_end_group</span><span class="p">)):</span>
                <span class="n">elem</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">tree_path_to_end_group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># TODO check that each one has at least something in it....</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">escaped</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                    <span class="n">escaped</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="c1"># Always escaped past here.</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">:</span> <span class="n">paren_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_group</span><span class="p">:</span> <span class="n">paren_count</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c1"># If not a valid open-group section then continue.</span>
                <span class="k">if</span> <span class="n">paren_count</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span>
                              <span class="n">elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">or_elem</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_group</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># Create a state for curr_node (copy of general state) and</span>
                <span class="c1"># process it.</span>
                <span class="n">or_section_begin</span> <span class="o">=</span> <span class="n">pushed_node_data_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">or_section_begin</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_node_data</span><span class="p">(</span>
                    <span class="n">query_elem</span><span class="p">,</span> <span class="n">or_section_begin</span><span class="p">,</span> <span class="n">next_node_data_list</span><span class="p">)</span>
                <span class="n">escaped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="c1"># from `handle_beginning_of_or_group`</span></div></div>

<div class="viewcode-block" id="SequentialPrefixMatcher"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher">[docs]</a><span class="k">class</span> <span class="nc">SequentialPrefixMatcher</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insert prefix elements of a key sequence one by one and see what the</span>
<span class="sd">    currently inserted prefix-sequence matches in the trie.  Initialized with</span>
<span class="sd">    an instance of a `RegexTrieDict`.  No trie modifications are allowed</span>
<span class="sd">    between adding an element to the current key and testing for matches of the</span>
<span class="sd">    current key, or `ModifiedTrieError` will be raised.</span>

<span class="sd">    The method `cannot_match` returns true when the currently inserted sequence</span>
<span class="sd">    of elements cannot possibly match the current trie no matter what new</span>
<span class="sd">    elements are added.  This can be used for on-line matching to get the</span>
<span class="sd">    longest pattern match as soon as possible based on the prefixes of the</span>
<span class="sd">    text.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex_trie_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize with a particular `RegexTrieDict` instance.  An instance</span>
<span class="sd">        is required.&quot;&quot;&quot;</span>
        <span class="c1"># Note that we have to deal with patterns that match the empty string.</span>
        <span class="c1"># We also want to wait until the last possible chance to do a reset,</span>
        <span class="c1"># so that we get a NodeStateDataList for the root that is fresh with</span>
        <span class="c1"># respect to any inserts which were done after the initialization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">regex_trie_dict</span><span class="p">)</span>

<div class="viewcode-block" id="SequentialPrefixMatcher.reset"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex_trie_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the `PrefixMatcher` and free any state memory.  A new trie can</span>
<span class="sd">        optionally be passed in.  If no new trie is passed in the previous one is</span>
<span class="sd">        used, starting at its root.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regex_trie_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span> <span class="o">=</span> <span class="n">regex_trie_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_in_progress</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Frees any memory for the garbage collector.</span></div>

<div class="viewcode-block" id="SequentialPrefixMatcher.is_valid"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.is_valid">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether the current match process is still valid.  After any elements</span>
<span class="sd">        are inserted in the matcher any inserts or deletes from the trie will invalidate</span>
<span class="sd">        the current match.  The `reset` method must be called to make return to a valid</span>
<span class="sd">        match.  This is called by the other methods, when necessary, so usually does not</span>
<span class="sd">        need to be explicitly done.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="o">.</span><span class="n">is_valid_in</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="p">)</span></div>

<div class="viewcode-block" id="SequentialPrefixMatcher.append_key_elem"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.append_key_elem">[docs]</a>    <span class="k">def</span> <span class="nf">append_key_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts elem as the next elem of the current key sequence.  (Note</span>
<span class="sd">        elem is usually a character if string patterns are stored in the</span>
<span class="sd">        tree.)  The first insert will start from the root of the trie.  To</span>
<span class="sd">        reset the matcher to the root the `reset` method must be called.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_in_progress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_to_root</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ModifiedTrieError</span><span class="p">(</span><span class="s2">&quot;Matcher state is invalid due to insertions or&quot;</span>
                    <span class="s2">&quot; deletions from the trie.  The `reset` method needs to be called.&quot;</span><span class="p">)</span>
        <span class="c1"># Update the list of node data states according to the element elem.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">get_next_nodes_meta</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="SequentialPrefixMatcher.cannot_match"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.cannot_match">[docs]</a>    <span class="k">def</span> <span class="nf">cannot_match</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if the currently inserted sequence of elements cannot</span>
<span class="sd">        possibly match a regex in the trie no matter what elements are inserted</span>
<span class="sd">        with `add_key_elem`.&quot;&quot;&quot;</span>

        <span class="c1"># Consider or delete: This could be determined by whether or not</span>
        <span class="c1"># there are any active patterns in next state, by passing it a magic</span>
        <span class="c1"># element that matches anything.&quot;&quot;&quot;</span>

        <span class="c1"># TODO: Need better approach to tell sooner, or at least</span>
        <span class="c1"># simplify the below.</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for node_data in self.node_data_list:</span>
<span class="sd">            if node_data.node.children:</span>
<span class="sd">                return False # Still not at end of trie for this state.</span>

<span class="sd">        # Now fast-forward past all the loop ends and &quot;if&quot; ends and check again.</span>
<span class="sd">        matched_nodes = self.get_valid_match_node_state_data_list()</span>
<span class="sd">        for node_data in matched_nodes:</span>
<span class="sd">            if node_data.node.children:</span>
<span class="sd">                return False # Still not at end of trie for this state.</span>
<span class="sd">        return not matched_nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Old way, doesn&#39;t catch nearly as much:</span>
        <span class="c1">#if not self.node_data_list: # No states at all remain; definitely cannot match.</span>
        <span class="c1">#    return True</span>

        <span class="c1"># Maybe new way:</span>
        <span class="c1"># Some states active, see if a magic always-match leaves any of them.</span>
        <span class="c1"># Some may be loops that would expire on the next iteration, for example.</span>
        <span class="n">always_match_next_data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_always_match_node_state_data_list</span><span class="p">()</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">always_match_next_data_list</span></div>

<div class="viewcode-block" id="SequentialPrefixMatcher.can_still_match"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.can_still_match">[docs]</a>    <span class="k">def</span> <span class="nf">can_still_match</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is just the negation of `cannot_match` for convenience.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cannot_match</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set_to_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility routine to set the state back to the root of the trie.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_in_progress</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">get_root_node_data_list</span><span class="p">()</span>

<div class="viewcode-block" id="SequentialPrefixMatcher.has_key_meta"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.has_key_meta">[docs]</a>    <span class="k">def</span> <span class="nf">has_key_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests whether the *full* current sequence of elements inserted by the</span>
<span class="sd">        `add_key_elem` method matches any of the regex patterns stored in the</span>
<span class="sd">        `RegexTrieDict` instance.  Returns the number of matches.  Remember</span>
<span class="sd">        that any literal escapes in the trie must be escaped, but escapes in</span>
<span class="sd">        query keys are always treated as literal.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_in_progress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_to_root</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ModifiedTrieError</span><span class="p">(</span><span class="s2">&quot;Matcher state is invalid due to insertions or&quot;</span>
                    <span class="s2">&quot; deletions from the trie.  The `reset` method needs to be called.&quot;</span><span class="p">)</span>
        <span class="n">matched_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_valid_match_node_state_data_list</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_nodes</span><span class="p">)</span></div>

    <span class="c1"># TODO: Is greedy vs. non-greedy in `PrefixMatcher` just a matter of</span>
    <span class="c1"># looking at the currently &quot;live&quot; states and deciding when to halt the trie</span>
    <span class="c1"># traversal?  If you have reached the end of *any* pattern (which you must</span>
    <span class="c1"># to return something other than failure) then you then you can just return</span>
    <span class="c1"># that.  Do not need to check `cannot_match` function except to see when to</span>
    <span class="c1"># report failure.  That is for non-greedy repetitions and non-greedy &quot;or&quot;</span>
    <span class="c1"># groups.  What about for the greedy repetitions?  Then, you can only take</span>
    <span class="c1"># a prefix result if 1) There are no active repetition groups, and 2) you</span>
    <span class="c1"># have some match for a partial.</span>
    <span class="c1">#</span>
    <span class="c1"># So, assume that we mark the repetitions as greedy vs. non-greedy, and that</span>
    <span class="c1"># this can be determined from the `NodeStateData` info.  Then the rule to examine</span>
    <span class="c1"># the states to determine if one can be returned might be:</span>
    <span class="c1">#   - If there are any active greedy repetition groups then nothing can be returned.</span>
    <span class="c1">#   - Rule out those which are currently inside an &quot;or&quot; group, not at end.</span>
    <span class="c1">#   - Rule out those which are currently inside a repetition group, not at end.</span>
    <span class="c1">#   - Rule out those which are not at the end of some pattern in the trie (leaf).</span>
    <span class="c1"># Testing for being a leaf is just looking at `is_last_elem_of_key` attributes.</span>
    <span class="c1"># The leaf rule might actually subsume the two middle ones.  Consider whether to</span>
    <span class="c1"># offer the option to have non-greedy &quot;or&quot; groups.  Maybe define &#39;|?&#39; to turn</span>
    <span class="c1"># ON greedy, rather than turn it off.</span>
    <span class="c1">#</span>
    <span class="c1"># TODO clarify the FULL match versus PREFIX match in these routines.  Different</span>
    <span class="c1"># methods, or same methods with flags?</span>
<div class="viewcode-block" id="SequentialPrefixMatcher.get_valid_match_node_state_data_list"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.get_valid_match_node_state_data_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_valid_match_node_state_data_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the list of currently-matching `NodeStateData` states (for the</span>
<span class="sd">        elements which have been inserted up to now).  Inserts a magic element</span>
<span class="sd">        that does not match anything.&quot;&quot;&quot;</span>
        <span class="c1"># First use `get_next_nodes_meta` to &quot;insert&quot; a magic element in the</span>
        <span class="c1"># trie (which by definition does not match any element actually in a</span>
        <span class="c1"># pattern).  Note that the trie itself is not modified: The resulting</span>
        <span class="c1"># node data list is saved in a temporary list (not affecting the real,</span>
        <span class="c1"># persistent `self.node_data_list` for this `PrefixMatcher` instance).</span>
        <span class="c1"># This has the side-effect of moving us past any `self.r_group` closing</span>
        <span class="c1"># elements, as well as past any patterns which can match zero times.</span>
        <span class="n">magic_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">magic_elem_never_matches</span>
        <span class="n">tmp_node_data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">get_next_nodes_meta</span><span class="p">(</span><span class="n">magic_elem</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">)</span>
        <span class="n">valid_match_node_data_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">tmp_node_data_list</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_last_elem_of_key</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">valid_match_node_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">valid_match_node_data_list</span></div>

<div class="viewcode-block" id="SequentialPrefixMatcher.get_always_match_node_state_data_list"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.get_always_match_node_state_data_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_always_match_node_state_data_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the next node state data list assuming a magic &quot;always match&quot;</span>
<span class="sd">        character is entered.&quot;&quot;&quot;</span>
        <span class="c1"># First use `get_next_nodes_meta` to &quot;insert&quot; a magic element in the</span>
        <span class="c1"># trie which always matches.</span>
        <span class="c1"># Note that the trie itself is not modified: The resulting</span>
        <span class="c1"># node data list is saved in a temporary list (not affecting the real,</span>
        <span class="c1"># persistent `self.node_data_list` for this `PrefixMatcher` instance).</span>
        <span class="c1"># This has the side-effect of moving us past any `self.r_group` closing</span>
        <span class="c1"># elements, as well as past any patterns which can match zero times.</span>
        <span class="n">magic_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">magic_elem_always_matches</span>
        <span class="n">new_node_data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">get_next_nodes_meta</span><span class="p">(</span><span class="n">magic_elem</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">node_data_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_node_data_list</span></div>

<div class="viewcode-block" id="SequentialPrefixMatcher.get_meta"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.SequentialPrefixMatcher.get_meta">[docs]</a>    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">no_matches_retval</span><span class="o">=</span><span class="p">[],</span> <span class="n">raw_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the data items of all the stored strings which</span>
<span class="sd">        match the *full* sequence of elements which have been added via the</span>
<span class="sd">        `add_key_elem` method.  That defines the current key sequence and the</span>
<span class="sd">        match is based on the regex patterns stored in the `RegexTrieDict`.</span>
<span class="sd">        The default with no matches is to return the empty list.  Remember that</span>
<span class="sd">        any literal escapes in the trie must be escaped, but escapes in query</span>
<span class="sd">        keys are always treated as literal.</span>

<span class="sd">        If `no_matches_retval` is set then its value will be returned when</span>
<span class="sd">        there are no matches.</span>

<span class="sd">        If `raw_nodes` is true then a list of `NodeStateData` instance will be</span>
<span class="sd">        returned rather than just the list of the data attributes of the nodes</span>
<span class="sd">        represented in the list.  This is a shallow copy of a subset of the</span>
<span class="sd">        persistent list, containing all the patterns which are currently</span>
<span class="sd">        matches to some pattern (i.e., they are all at leaf nodes in the</span>
<span class="sd">        trie).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_in_progress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_to_root</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ModifiedTrieError</span><span class="p">(</span><span class="s2">&quot;Matcher state is invalid due to insertions or&quot;</span>
                    <span class="s2">&quot; deletions from the trie.  The `reset` method needs to be called.&quot;</span><span class="p">)</span>
        <span class="n">valid_match_node_data_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_valid_match_node_state_data_list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">raw_nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">valid_match_node_data_list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_match_node_data_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">no_matches_retval</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">valid_match_node_data_list</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="char_elem_to_int"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.char_elem_to_int">[docs]</a><span class="k">def</span> <span class="nf">char_elem_to_int</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This routine is set in `define_meta_elems` as the default value of</span>
<span class="sd">    `elemToDigitFun`, which converts elements to digit values.  Used in calculating</span>
<span class="sd">    repetition bounds.  It is the default setting for `elemToDigitFun` when</span>
<span class="sd">    the elements are characters.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">int_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;Bad digit in repetition bounds specification&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">int_val</span></div>


<div class="viewcode-block" id="char_pattern_match_test"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.char_pattern_match_test">[docs]</a><span class="k">def</span> <span class="nf">char_pattern_match_test</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">patt_list</span><span class="p">,</span> <span class="n">range_elem</span><span class="p">,</span> <span class="n">escape_elem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This utility routine does a pattern-match for characters in the wildcard</span>
<span class="sd">    brackets.  It depends on the elements being characters, since it calls a</span>
<span class="sd">    Python regex.  This has the advantage of allowing all the special</span>
<span class="sd">    characters in Python regex wildcards (character sets) to be used.  This is</span>
<span class="sd">    the default routine set in `define_meta_elems` as `wildcard_patt_match_fun`, for</span>
<span class="sd">    when elements are characters.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">patt_list</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;No pattern in wildcard brackets.&quot;</span><span class="p">)</span>

    <span class="c1"># print(&quot;debug char_pattern_match_test, query elem is&quot;, query_elem, &quot;patt_list</span>
    <span class="c1"># is&quot;, patt_list)</span>

    <span class="c1"># Can this ever be passed a MagicElem?  Handle below, just in case.</span>
    <span class="c1">#if query_elem is magic_elem_never_matches:</span>
    <span class="c1">#    return False</span>


    <span class="n">patt_tuple_list</span> <span class="o">=</span> <span class="n">process_elem_list_for_escapes</span><span class="p">(</span><span class="n">patt_list</span><span class="p">,</span> <span class="n">escape_elem</span><span class="p">)</span>
    <span class="c1">#print(&quot;debug elemList processed for escapes is&quot;, patt_tuple_list)</span>
    <span class="n">python_string</span> <span class="o">=</span> <span class="s2">&quot;^[&quot;</span>
    <span class="n">first_char</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span> <span class="ow">in</span> <span class="n">patt_tuple_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">first_char</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="s2">&quot;^&quot;</span><span class="p">:</span>
                <span class="n">python_string</span> <span class="o">+=</span> <span class="s2">&quot;^&quot;</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="n">python_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span>
        <span class="n">python_string</span> <span class="o">+=</span> <span class="n">elem</span>
        <span class="n">first_char</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">python_string</span> <span class="o">+=</span> <span class="s2">&quot;]$&quot;</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">python_string</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">)</span>
    <span class="c1"># print(&quot;debug char_pattern_match_test, python_string is&quot;, python_string,</span>
    <span class="c1"># &quot;returning&quot;, bool(retval))</span>
    <span class="k">return</span> <span class="n">retval</span></div>


<div class="viewcode-block" id="char_range_test"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.char_range_test">[docs]</a><span class="k">def</span> <span class="nf">char_range_test</span><span class="p">(</span><span class="n">char_lower</span><span class="p">,</span> <span class="n">char_upper</span><span class="p">,</span> <span class="n">test_char</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if `test_char` is in the range from `char_lower` to</span>
<span class="sd">    `char_upper`, inclusive.  Used in testing wildcard patterns in the default</span>
<span class="sd">    with character elements.&quot;&quot;&quot;</span>
    <span class="c1">#print(&quot;debug in char_range_test, comparing queryElem&quot;,</span>
    <span class="c1">#      test_char, &quot;with lower range&quot;, char_lower)</span>
    <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char_lower</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char_upper</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                <span class="s2">&quot;Second element in character range greater than lower.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char_lower</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">test_char</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">test_char</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char_upper</span><span class="p">)</span></div>


<div class="viewcode-block" id="generic_wildcard_match_fun"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.generic_wildcard_match_fun">[docs]</a><span class="k">def</span> <span class="nf">generic_wildcard_match_fun</span><span class="p">(</span><span class="n">query_elem</span><span class="p">,</span> <span class="n">patt_list</span><span class="p">,</span> <span class="n">range_elem</span><span class="p">,</span> <span class="n">escape_elem</span><span class="p">,</span>
                            <span class="n">range_test_fun</span><span class="o">=</span><span class="n">char_range_test</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This utility routine does a generic pattern-match in the wildcard</span>
<span class="sd">    brackets.  This routine is for general sequences of elements and does not</span>
<span class="sd">    depend on the elements being characters.  Only the function `range_test_fun`</span>
<span class="sd">    needs to be defined.  The argument `patt_list` is the content of a wildcard</span>
<span class="sd">    bracket, as a list of elements.  This function tests whether query_elem</span>
<span class="sd">    matches the character pattern.  To simply redefine the range-test function</span>
<span class="sd">    for elements, use something like::</span>

<span class="sd">       def myPattMatchFun(query_elem, patt_list, range_elem, escape_elem):</span>
<span class="sd">           return generic_wildcard_match_fun(query_elem, patt_list, range_elem,</span>
<span class="sd">                                    escape_elem, range_test_fun=myRangeTestFun)</span>

<span class="sd">    Then in calling `define_meta_elems` define `wildcard_patt_match_fun=myPattMatchFun`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(&quot;debug processing pattern patt_list&quot;, patt_list, &quot;for query_elem&quot;, query_elem)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">patt_list</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;No pattern in wildcard brackets.&quot;</span><span class="p">)</span>

    <span class="n">patt_tuple_list</span> <span class="o">=</span> <span class="n">process_elem_list_for_escapes</span><span class="p">(</span><span class="n">patt_list</span><span class="p">,</span> <span class="n">escape_elem</span><span class="p">)</span>
    <span class="n">found_range_elem</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span> <span class="ow">in</span> <span class="n">patt_tuple_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">range_elem</span><span class="p">:</span>
                <span class="n">found_range_elem</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;Invalid escaped elem in wildcard pattern.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">found_range_elem</span><span class="p">:</span>
                <span class="n">found_range_elem</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s2">&quot;No elem before range elem in wildcard.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">range_test_fun</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">elem</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">range_test_fun</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">query_elem</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="process_elem_list_for_escapes"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.process_elem_list_for_escapes">[docs]</a><span class="k">def</span> <span class="nf">process_elem_list_for_escapes</span><span class="p">(</span><span class="n">elem_list</span><span class="p">,</span> <span class="n">escape_char</span><span class="p">,</span>
                                  <span class="n">open_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">close_group</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A utility routine which takes a list of possibly-escaped elements as an</span>
<span class="sd">    argument and returns a list of two-tuples.  The first element of a two-tuple</span>
<span class="sd">    is the actual character, and the second a boolean for whether or not it is</span>
<span class="sd">    escaped.  If open_group and/or close_group is set it returns a three-tuple,</span>
<span class="sd">    where the last element gives the level of parenthesis nesting, starting at zero</span>
<span class="sd">    and increasing.  An open and its corresponding close have the same level.&quot;&quot;&quot;</span>
    <span class="n">escaped</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">tuple_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">p_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elem_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">escape_char</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="n">escaped</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="n">bool_val</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">open_group</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">open_group</span><span class="p">:</span> <span class="n">p_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bool_val</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">open_group</span> <span class="ow">or</span> <span class="n">close_group</span><span class="p">:</span>
            <span class="n">tuple_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elem</span><span class="p">,</span> <span class="n">bool_val</span><span class="p">,</span> <span class="n">p_count</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tuple_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elem</span><span class="p">,</span> <span class="n">bool_val</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="n">escaped</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">close_group</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">close_group</span><span class="p">:</span>
                <span class="n">p_count</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">tuple_list</span></div>


<span class="c1">#</span>
<span class="c1"># Exception classes for RegexTrieDict.</span>
<span class="c1">#</span>


<div class="viewcode-block" id="RegexTrieDictError"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.RegexTrieDictError">[docs]</a><span class="k">class</span> <span class="nc">RegexTrieDictError</span><span class="p">(</span><span class="n">TyppedBaseException</span><span class="p">):</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="PrefixMatcherError"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.PrefixMatcherError">[docs]</a><span class="k">class</span> <span class="nc">PrefixMatcherError</span><span class="p">(</span><span class="n">TyppedBaseException</span><span class="p">):</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="PatternMatchError"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.PatternMatchError">[docs]</a><span class="k">class</span> <span class="nc">PatternMatchError</span><span class="p">(</span><span class="n">RegexTrieDictError</span><span class="p">):</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="ModifiedTrieError"><a class="viewcode-back" href="../../typped.regex_trie_dict.html#typped.regex_trie_dict.ModifiedTrieError">[docs]</a><span class="k">class</span> <span class="nc">ModifiedTrieError</span><span class="p">(</span><span class="n">RegexTrieDictError</span><span class="p">):</span>
    <span class="k">pass</span></div>



</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>