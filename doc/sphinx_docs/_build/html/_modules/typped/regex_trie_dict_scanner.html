
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>typped.regex_trie_dict_scanner &#8212; Typped  documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for typped.regex_trie_dict_scanner</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">RegexTrieDictScanner</span>
<span class="sd">----------------------</span>

<span class="sd">TODO: Update this intro to reflect new implementation using PrefixMatcher.</span>
<span class="sd">TODO: For now, see the docs to the insert_char method...</span>

<span class="sd">This module is mainly intended for scanning text composed of characters as</span>
<span class="sd">elements.  So, unlike the general `RegexTrieDict` module, it is written with</span>
<span class="sd">elements assumed to be characters (one-element strings).  The code itself</span>
<span class="sd">should still work for general elements of sequences, not just character</span>
<span class="sd">elements in text sequences, but this has not been tested.</span>

<span class="sd">========= older below, save what can be ===================================</span>

<span class="sd">The `RegexTrieDictScanner` uses a `RegexTrieDict` for tokenizing a sequence of</span>
<span class="sd">elements.  The underlying `RegexTrieDict`  essentially does the same thing that</span>
<span class="sd">`re.match` would do in a traditional scanner design, except that 1) patterns in</span>
<span class="sd">it can be efficiently dynamically updated, 2) it is fast for large numbers of</span>
<span class="sd">&quot;simple patterns,&quot; and 3) it supports online scanning (i.e., where characters</span>
<span class="sd">are inserted one at a time and the longest-matching result is returned as soon</span>
<span class="sd">possible based on the patterns and the sequence).  The implementation is pure</span>
<span class="sd">Python, though, so there is a constant before any asymptotic efficiency with</span>
<span class="sd">increasing numbers of patterns.  Like Python&#39;s regex (but not some other</span>
<span class="sd">implementations) it has an exponential worst-case match time.  Memory use can</span>
<span class="sd">also be large, since the matching algorithm essentially does a BFS on</span>
<span class="sd">possible pattern matches (which is what makes the online usage work).</span>

<span class="sd">Elements of sequences (usually characters of strings) are inserted one by one,</span>
<span class="sd">from left to right, into the scanner.  Tokens are returned when their patterns</span>
<span class="sd">match.  (The key-sequences inserted into the underlying `RegexTrieDict` define</span>
<span class="sd">the tokens.)  An arbitrary sequence can then be tokenized by inserting it</span>
<span class="sd">element by element.  The all matches are reported, and the shortest or longest</span>
<span class="sd">can be matches can be detected (the longest is only defined assuming the regex</span>
<span class="sd">patterns in the `RegexTrieDict` reach some state where no further characters</span>
<span class="sd">will match cause a match).</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">   td = RegexTrieDict()</span>
<span class="sd">   scanner = RegexTreeDictScanner(td)</span>

<span class="sd">   text_string = &quot;test string here&quot;</span>
<span class="sd">   for char in text_string: # May instead be a realtime string of chars.</span>
<span class="sd">       prefix_match_list = scanner.insert_char(text)</span>
<span class="sd">       if prefix_match_list:</span>
<span class="sd">           for match in prefix_match_list:</span>
<span class="sd">               print(&quot;Matched a prefix:&quot;, match)</span>

<span class="sd">The results of the tokenization are automatically placed in a deque which is</span>
<span class="sd">stored with the `RegexTreeDictScanner` instance.  Users can manipulate this</span>
<span class="sd">deque in any way they want; it is only used for reporting tokens as they are</span>
<span class="sd">detected (i.e., they are inserted when matched).  Note that it may be necessary</span>
<span class="sd">to call `tok.assert_end_of_text()` in order for the tokenizer to deal with</span>
<span class="sd">situations that are currently ambiguous as far as finding the longest match.</span>

<span class="sd">.. topic:: Revise this stuff later...</span>

<span class="sd">    Key strings can be matched as tokens from a sequential character stream,</span>
<span class="sd">    choosing either the longest or the shortest (first) match.  Finding the</span>
<span class="sd">    shortest matches (assuming no regexes) is linear in the overall query string</span>
<span class="sd">    length.  The time when finding the longest matches is still efficient in the</span>
<span class="sd">    usual cases but is not linear in the query-lengths because recursion is used to</span>
<span class="sd">    effectively back up when it becomes known that a recognized pattern is the</span>
<span class="sd">    longest (in that part of the sequence).  But it must wait for a mismatch or the</span>
<span class="sd">    end of the query string to know that a saved possible match was the longest.</span>

<span class="sd">    Worst case, suppose we have these three keys::</span>

<span class="sd">       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span>
<span class="sd">       a</span>
<span class="sd">       b</span>

<span class="sd">    Now, suppose the input query-stream of characters is::</span>

<span class="sd">       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab</span>

<span class="sd">    We save the first `a` as a possible match, and then we have to go all the way</span>
<span class="sd">    to the final `b` to determine that the longer string is not a match (and the</span>
<span class="sd">    single character is the longest match).  Then we go back and start the same</span>
<span class="sd">    thing over from the second `a`, and so forth, getting a time which depends on</span>
<span class="sd">    the length of the longest string stored and the prefix properties of the stored</span>
<span class="sd">    strings.  When the stored strings are relatively short relative to the query</span>
<span class="sd">    length and are distributed in &quot;the usual ways&quot; this should not make much</span>
<span class="sd">    difference in practice.</span>

<span class="sd">    The tree can easily handle whitespace characters if whitespace characters are</span>
<span class="sd">    never valid stored strings or substrings of stored strings.  We just get an</span>
<span class="sd">    unrecognized string result on those characters (depending on how error handling</span>
<span class="sd">    is configured, with fastRecover of not).  Alternately, and better, we can</span>
<span class="sd">    insert one of each whitespace character into the tree and then just test and</span>
<span class="sd">    ignore those matches.  Or we could just do a split on whitespace before feeding</span>
<span class="sd">    data to the tree; that is probably best in most situations.</span>

<span class="sd">    For queries of fixed keys which are either in the structure or not there is</span>
<span class="sd">    no real advantage to using the tree algorithm (it will be slower since it</span>
<span class="sd">    uses a standard dicts at each node for storing child nodes).  What the tree</span>
<span class="sd">    algorithm can do well is recognize stored items (tokens) out of a</span>
<span class="sd">    continuous, sequential stream of characters (either finding the first match</span>
<span class="sd">    or the longest), while also allowing fast inserts and deletes of</span>
<span class="sd">    keys/tokens.</span>

<span class="sd">    Using a standard hashed dict (or REs) for the same thing we would build up</span>
<span class="sd">    the query string character by character and query the hash dict on the</span>
<span class="sd">    query string each time a character is appended to it.  That is, generate</span>
<span class="sd">    the prefixes of the input character string.  Then it would save possible</span>
<span class="sd">    matches, etc., and when a match is recognized as the longest it would</span>
<span class="sd">    remove that prefix and restart, just like the tree version below.  To find</span>
<span class="sd">    the longest match, however, we need to know when a mismatch occurs or else</span>
<span class="sd">    go all the way to the end of the input each time.  This would entail saving</span>
<span class="sd">    all the prefixes of all the keys (in another dict, perhaps), or otherwise</span>
<span class="sd">    coming up with some scheme to detect when no longer-match is possible</span>
<span class="sd">    (because the current query string is not a prefix of any key).  This scheme</span>
<span class="sd">    would have to be able to be quickly updated on inserts and deletes of keys.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="c1"># Run test cases below when invoked as a script.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pytest_helper</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="s2">&quot;../../test/test_regex_trie_dict_scanner.py&quot;</span><span class="p">,</span> <span class="n">pytest_args</span><span class="o">=</span><span class="s2">&quot;-v&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.regex_trie_dict</span> <span class="k">import</span> <span class="n">SequentialPrefixMatcher</span><span class="p">,</span> <span class="n">RegexTrieDictError</span><span class="p">,</span> <span class="n">RegexTrieDict</span>

<div class="viewcode-block" id="RegexTrieDictScanner"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.RegexTrieDictScanner">[docs]</a><span class="k">class</span> <span class="nc">RegexTrieDictScanner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class implements a scanner using the keys of a `RegexTrieDict` as patterns</span>
<span class="sd">    for tokens.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regex_trie_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;User must pass in a valid `RegexTrieDict` containing the token regex</span>
<span class="sd">        patterns.&quot;&quot;&quot;</span>
        <span class="c1"># TODO note that at certain times changes to trie are allowed, others not...</span>
        <span class="c1"># after getting a token you can modify before inserting more....</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span> <span class="o">=</span> <span class="n">regex_trie_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">string_joiner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">combine_elems_fun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix_matcher</span> <span class="o">=</span> <span class="n">SequentialPrefixMatcher</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

<div class="viewcode-block" id="RegexTrieDictScanner.reset"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.RegexTrieDictScanner.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the current character sequence being inserted, i.e., start the</span>
<span class="sd">        next insertion back at the root node of the `RegexTrieDict`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cannot_match</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Set true when nothing in trie can match curr prefix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matching_nodes</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Currently-matching nodes for current prefix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_nodestates</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Last node collection containing a match.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_index</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Prefix index for last match.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_index_inserted_in_rtd_matcher</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Last index of current pattern.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_of_text_asserted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># The list of chars in current prefix being scanned.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix_matcher</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span> <span class="c1"># Reset the regex prefix matcher.</span></div>

<div class="viewcode-block" id="RegexTrieDictScanner.is_valid"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.RegexTrieDictScanner.is_valid">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if the current text sequence being scanned is still valid.</span>
<span class="sd">        Return false otherwise.  A sequence becomes invalid if there are any</span>
<span class="sd">        inserts or deletes in the underlying trie.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_matcher</span><span class="o">.</span><span class="n">is_valid</span><span class="p">()</span></div>

<div class="viewcode-block" id="RegexTrieDictScanner.current_prefix"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.RegexTrieDictScanner.current_prefix">[docs]</a>    <span class="k">def</span> <span class="nf">current_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join_chars</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current (not yet matched) prefix sequence.  This is just</span>
<span class="sd">        the current sequence of characters which have been entered with</span>
<span class="sd">        `append_text`, but with any already-detected prefix matches remover.</span>

<span class="sd">        If `join_chars` is true the characters are joined using the default</span>
<span class="sd">        character joiner of the underlying `RegexTrieDict`.  Otherwise the</span>
<span class="sd">        result is a list of characters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">join_chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_chars_fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span></div>

<div class="viewcode-block" id="RegexTrieDictScanner.append_text"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.RegexTrieDictScanner.append_text">[docs]</a>    <span class="k">def</span> <span class="nf">append_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">final_text</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append the string `text` to the current prefix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_of_text_asserted</span><span class="p">:</span>
            <span class="c1"># TODO: could have option to delete end magic char or auto-call reset text.</span>
            <span class="k">raise</span> <span class="n">TrieDictScannerError</span><span class="p">(</span><span class="s2">&quot;End of text was previously asserted, call&quot;</span>
                                       <span class="s2">&quot; `reset` before inserting more text.&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">magic_elem_never_matches</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TrieDictScannerError</span><span class="p">(</span><span class="s2">&quot;Magic element that cannot match&quot;</span>
                            <span class="s2">&quot;was found in the appended string, not at the end.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">end_of_text_asserted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">final_text</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assert_end_of_text</span><span class="p">()</span></div>

<div class="viewcode-block" id="RegexTrieDictScanner.assert_end_of_text"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.RegexTrieDictScanner.assert_end_of_text">[docs]</a>    <span class="k">def</span> <span class="nf">assert_end_of_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join_chars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reinsert_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Asserts that there are no more characters in the current sequence.</span>
<span class="sd">        Adds a special character that cannot match anything to the current prefix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_of_text_asserted</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_of_text_asserted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">magic_elem_never_matches</span><span class="p">)</span></div>

<div class="viewcode-block" id="RegexTrieDictScanner.get_prefix_matches"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.RegexTrieDictScanner.get_prefix_matches">[docs]</a>    <span class="k">def</span> <span class="nf">get_prefix_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join_chars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all longest prefix match or sequence of matches for the</span>
<span class="sd">        currently-inserted prefix text.  If the currently-inserted characters</span>
<span class="sd">        allow a prefix match to be recognized as the longest possible (with</span>
<span class="sd">        respect to the current patterns in the trie) then a list containing</span>
<span class="sd">        that match string is returned.</span>

<span class="sd">        If `join_chars` is false (the default is true) then the matching</span>
<span class="sd">        character sequence is not joined before being returned.  So the</span>
<span class="sd">        returned list is a list of characters.  Any joining is done using the</span>
<span class="sd">        character-joining operation for the underlying `RegexTrieDict`</span>
<span class="sd">        instance.</span>

<span class="sd">        Immediately after matches are returned the `last_values` attribute of</span>
<span class="sd">        the matcher holds a list of a list of corresponding data values which</span>
<span class="sd">        were stored in the trie with the patterns that matched the returned</span>
<span class="sd">        matches.</span>

<span class="sd">        If `reinsert_on_match` is true then, after a match is found, the</span>
<span class="sd">        scanner is reset and all the text characters which were inserted but</span>
<span class="sd">        not part of the previously-recognized prefix are reinserted until</span>
<span class="sd">        another known-longest match is found.  This continues until no</span>
<span class="sd">        guaranteed longest-prefix matches can be found.  The list of</span>
<span class="sd">        known-longest prefix matches is then returned.  More characters can</span>
<span class="sd">        then be inserted, with the same behavior.  Any remaining suffix becomes</span>
<span class="sd">        the new list attribute `curr_prefix_text` of the scanner instance.</span>
<span class="sd">        The `last_values` attribute in this case holds a list of lists of</span>
<span class="sd">        data items, corresponding to the list of prefix patterns.</span>

<span class="sd">        When a longest match is found that match is returned.   Otherwise, the</span>
<span class="sd">        return values are as follows:</span>

<span class="sd">        * `None` -- No longest match has yet been recognized.  Note that the</span>
<span class="sd">           longest match might actually have been found, but it cannot be</span>
<span class="sd">           returned until it is recognized as being the longest possible.  This</span>
<span class="sd">           can require more characters to be inserted (such as for repetition groups)</span>
<span class="sd">           or a call to the `assert_end_of_text` method.</span>

<span class="sd">        * `[]` -- No matches with respect to the current trie are possible no</span>
<span class="sd">           matter what additional characters are inserted.  The empty list is</span>
<span class="sd">           recognized as the list of matches.  The attribute `cannot_match` of the</span>
<span class="sd">           scanner instance is also set to `True` in this case.</span>

<span class="sd">        Other useful user-accessible attributes of scanner:</span>

<span class="sd">        The `last_matches` attribute is set to the last returned match result,</span>
<span class="sd">        which can be a useful way to access the matches.  The `last_values`</span>
<span class="sd">        attribute holds the corresponding list of lists of associated values.</span>

<span class="sd">        The raw matching nodes in the trie for the last pattern match are in</span>
<span class="sd">        the attribute `last_matching_nodestates`.</span>

<span class="sd">        The list of appended characters which have not yet matched (and hence</span>
<span class="sd">        have not yet been removed from the current prefix) is stored in the</span>
<span class="sd">        attribute `curr_prefix_text`.  This prefix text list is a list of</span>
<span class="sd">        unjoined characters, and includes a magic &quot;matches nothing&quot; character</span>
<span class="sd">        if `assert_end_of_text` has been called.</span>

<span class="sd">        The `cannot_match` attribute is set true if no further character</span>
<span class="sd">        appends can cause a match.&quot;&quot;&quot;</span>
        <span class="c1"># Currently assumes longest match.</span>
        <span class="c1"># Figure out how to do non-greedy things...</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG in get_prefix_matches with prefix of:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">TrieDictScannerError</span><span class="p">(</span><span class="s2">&quot;The trie of regexes has been modified since&quot;</span>
                    <span class="s2">&quot; starting this prefix search, so the search is now invalid.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cannot_match</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span>

        <span class="c1"># TODO: This breaks on sequential inserts!  Need to save the last insertion point</span>
        <span class="c1"># and start there!</span>
        <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_index_inserted_in_rtd_matcher</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">)):</span>
            <span class="n">char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   inserting character&quot;</span><span class="p">,</span> <span class="n">char</span><span class="p">,</span> <span class="s2">&quot;into prefix matcher&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefix_matcher</span><span class="o">.</span><span class="n">append_key_elem</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_index_inserted_in_rtd_matcher</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">matching_nodestates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_matcher</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">no_matches_retval</span><span class="o">=</span><span class="p">[],</span>
                                                          <span class="n">raw_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1">#print(&quot;   matching nodes after char&quot;, char, &quot;are:&quot;)</span>
            <span class="c1">#for n in matching_nodestates:</span>
            <span class="c1">#    print(&quot;     &quot;, n) # DEBUG</span>

            <span class="k">if</span> <span class="n">matching_nodestates</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Found a matching node, setting as last_matching_nodestates and index&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_nodestates</span> <span class="o">=</span> <span class="n">matching_nodestates</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_index</span> <span class="o">=</span> <span class="n">count</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   DEBUG last matching index is:&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   DEBUG the node strings are:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matching_nodestates</span><span class="p">])</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_matcher</span><span class="o">.</span><span class="n">cannot_match</span><span class="p">():</span>
                <span class="c1"># Note we do not need cannot match test if we know the real next chars to insert!?!?</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   DEBUG cannot_match is true in loop with index&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cannot_match</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_nodestates</span><span class="p">:</span> <span class="c1"># Found a previous match, use it.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   breaking the for loop, had a prev match ending at&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_index</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>                        <span class="c1"># No matches were found, return empty.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   returning from inside the loop, no prev match&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">last_values</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># else for the for loop; finished loop without finding a match (no break)</span>
            <span class="c1">#if not self.cannot_match: # No prefixes found, but a match is still possible.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG no matches found in whole prefix string, but still can match, returning None&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_values</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span>

        <span class="c1">#</span>
        <span class="c1"># We know some match was found; remove it, reset the scanner, and recurse if needed.</span>
        <span class="c1">#</span>

        <span class="c1"># The subtraction conditional below is needed because a match of a full string ending</span>
        <span class="c1"># with the magic never-matches is considered to match only the non-magic characters</span>
        <span class="c1"># as a pattern.  So decrement to not include the final magic character.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">last_matching_index</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">magic_elem_never_matches</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_index</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">match_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">last_matching_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;match text is&quot;</span><span class="p">,</span> <span class="n">match_text</span><span class="p">)</span>
        <span class="n">match_data_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matching_nodestates</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;match data_values are&quot;</span><span class="p">,</span> <span class="n">match_data_values</span><span class="p">)</span>
        <span class="n">new_prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">last_matching_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;new_prefix is&quot;</span><span class="p">,</span> <span class="n">new_prefix</span><span class="p">)</span>
        <span class="n">end_of_text_asserted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_of_text_asserted</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;QQQ ready to reset... match_text is&quot;</span><span class="p">,</span> <span class="n">match_text</span><span class="p">)</span>

        <span class="c1"># Reset the scanner.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># Restore a few attributes after the reset.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_text</span><span class="p">(</span><span class="n">new_prefix</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_prefix_text</span> <span class="o">==</span> <span class="n">new_prefix</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_of_text_asserted</span> <span class="o">==</span> <span class="n">end_of_text_asserted</span>

        <span class="k">if</span> <span class="n">join_chars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">string_joiner</span><span class="p">(</span><span class="n">match_text</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">match_text</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">match_data_values</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">only_first</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG returning an only_first match of&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span>

        <span class="c1">#</span>
        <span class="c1"># Reinsert the unmatched text in the reset prefix matcher, calling recursively.</span>
        <span class="c1">#</span>

        <span class="n">return_match_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span>
        <span class="n">return_values_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_values</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;first return match list is&quot;</span><span class="p">,</span> <span class="n">return_match_list</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prefix_matches</span><span class="p">(</span><span class="n">join_chars</span><span class="o">=</span><span class="n">join_chars</span><span class="p">,</span> <span class="n">only_first</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">return_match_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span>
            <span class="n">return_values_list</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_values</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span> <span class="o">=</span> <span class="n">return_match_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_values</span> <span class="o">=</span> <span class="n">return_values_list</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;returning these final matches from scanner&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_matches</span></div></div>

<span class="c1">#</span>
<span class="c1"># Exceptions specific to this module.</span>
<span class="c1">#</span>

<div class="viewcode-block" id="TrieDictScannerError"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.TrieDictScannerError">[docs]</a><span class="k">class</span> <span class="nc">TrieDictScannerError</span><span class="p">(</span><span class="n">RegexTrieDictError</span><span class="p">):</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="PrefixCannotMatch"><a class="viewcode-back" href="../../typped.regex_trie_dict_scanner.html#typped.regex_trie_dict_scanner.PrefixCannotMatch">[docs]</a><span class="k">class</span> <span class="nc">PrefixCannotMatch</span><span class="p">(</span><span class="n">TrieDictScannerError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when a prefix match is determined to be impossible.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Typped  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>