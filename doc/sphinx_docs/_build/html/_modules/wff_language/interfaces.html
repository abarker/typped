<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>wff_language.interfaces &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for wff_language.interfaces</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">This module defines the `implements` function which assigns an implementation</span>
<span class="sd">to an interface definition, checking that the implementation satisfies the</span>
<span class="sd">requirements of the interface.  It also provides the `abstract()` function which</span>
<span class="sd">is called in place of implementation code in interface methods.</span>

<span class="sd">The implementation of the `implements` here function is quite simple: the</span>
<span class="sd">function call</span>

<span class="sd">    implements(implementation_name, interface_name)</span>

<span class="sd">is essentially just an assignment</span>
<span class="sd">    </span>
<span class="sd">    interface_name = implementation_name</span>

<span class="sd">in the same namespace, which then works via duck typing.  Note, though, that</span>
<span class="sd">the order is reversed from assignment to match the intuitive interpretation</span>
<span class="sd">&quot;argument one implements argument two.&quot;</span>

<span class="sd">The only loss of efficiency is the small checking-time overhead before the</span>
<span class="sd">assignment is made.  This should work for any class that provides an interface</span>
<span class="sd">of fixed attributes.  There are some restrictions that follow from this simple</span>
<span class="sd">mechanism.</span>

<span class="sd">Below is an example using a stack interface S with two implementations LS and</span>
<span class="sd">LLS.  The boxed things are the values of the variable names below them.  The</span>
<span class="sd">notation &quot;&lt;Obj1&gt; --&gt; &lt;Obj2&gt;&quot; means that one object &lt;Obj1&gt; has saved a reference</span>
<span class="sd">to another object &lt;Obj2&gt;.</span>

<span class="sd">    class S(object):</span>
<span class="sd">        &lt;public methods of a stack, with abstract() as the implementation&gt;</span>

<span class="sd">    class LS(object):</span>
<span class="sd">        &lt;actual implementation of S&#39;s stack methods (using lists)&gt;</span>

<span class="sd">    class LLS(object):</span>
<span class="sd">        &lt;actual implementation of S&#39;s stack methods (using linked lists)&gt;</span>

<span class="sd">    ---------       ----------      -----------</span>
<span class="sd">    |&lt;S_Obj&gt;|       |&lt;LS_Obj&gt;|      |&lt;LLS_Obj&gt;|</span>
<span class="sd">    ---------       ----------      -----------</span>
<span class="sd">    S               LS              LLS</span>

<span class="sd">    implements(LS, S)</span>

<span class="sd">    ----------------------      ----------------------      -----------</span>
<span class="sd">    |&lt;LS_Obj&gt; --&gt; &lt;S_Obj&gt;|      |&lt;LS_Obj&gt; --&gt; &lt;S_Obj&gt;|      |&lt;LLS_Obj&gt;|</span>
<span class="sd">    ----------------------      ----------------------      -----------</span>
<span class="sd">    S                           LS                          LLS    </span>

<span class="sd">    implements(LLS, S)</span>

<span class="sd">    -----------------------     ----------      -----------------------</span>
<span class="sd">    |&lt;LLS_Obj&gt; --&gt; &lt;S_Obj&gt;|     |&lt;LS_Obj&gt;|      |&lt;LLS_Obj&gt; --&gt; &lt;S_Obj&gt;|</span>
<span class="sd">    -----------------------     ----------      -----------------------</span>
<span class="sd">    S                           LS              LLS    </span>

<span class="sd">Notice that we cannot have two implementations of the same interface at the</span>
<span class="sd">same time, because S can only be assigned to reference one object at a time</span>
<span class="sd">(then making use of duck typing to implement the calls to its interface).  So</span>
<span class="sd">the link from LS to &lt;S_Obj&gt; is deleted when the second `implements` call is</span>
<span class="sd">made.  S now references &lt;LLS_Obj&gt; with a backlink to its definitional object</span>
<span class="sd">&lt;S_Obj&gt;.  The link back to the original definitional object is saved precisely</span>
<span class="sd">so that these kind of reassignments can be made to work, since in the second</span>
<span class="sd">call to implements S actually references &lt;LS_Obj&gt;.</span>

<span class="sd">Aliases to interface definitions are considered to be *different* interface</span>
<span class="sd">definitions, not aliases.  This is because it is difficult to check that</span>
<span class="sd">variable S is used rather than, say, an alias such as from the assignment AS =</span>
<span class="sd">S.  Then implements(LS, AS) in the first line would set the implementation of</span>
<span class="sd">AS to be &lt;LS_Obj&gt;, but S would still point to &lt;S_Obj&gt;, so this fails from a</span>
<span class="sd">syntactic perspective.</span>

<span class="sd">======================</span>

<span class="sd">We could maybe restrict S to not have any aliases by checking the reference</span>
<span class="sd">count of its object, and we can also restrict interfaces to necessarily be</span>
<span class="sd">defined in the same module where implements is called.  Bad idea.</span>

<span class="sd">One way is to look at the globals() dict, keyed on variable names and</span>
<span class="sd">returning their assignments.  See also http://stackoverflow.com/questions/8875202</span>
<span class="sd">We can use the S.__name__ attribute to get the string &quot;S&quot;.  We can use the</span>
<span class="sd">globals dict to look up what S is currently referencing.</span>

<span class="sd">Note that we cannot have multiple interfaces with the same implementation</span>
<span class="sd">if we are storing the original interface with the implementation as an</span>
<span class="sd">attribute.  At the least we&#39;d need to modify how that is done.</span>

<span class="sd">   Strange idea: what if we just copy over all the methods and attributes from</span>
<span class="sd">   LS onto S, saving the old ones somewhere, maybe with a name-prefix on their</span>
<span class="sd">   attributes.  Or maybe keep a deep copy of S.  Then, any references,</span>
<span class="sd">   anywhere, just work.  We can check the methods and attributes as we do it.</span>
<span class="sd">   We still only get one implementation, but it can be changed.</span>
<span class="sd">   - see file in scratch directory... seems to work for most attributes, don&#39;t</span>
<span class="sd">     know what complications it might cause.</span>

<span class="sd">   Another strange idea: what if you overloaded the = operator on interfaces</span>
<span class="sd">   to actually be a deep copy?  Wasteful, perhaps, but would it work?  No,</span>
<span class="sd">   can&#39;t overload = in Python.</span>

<span class="sd">Which one is the case:</span>

<span class="sd">    - Note that it is irrelevant whether `implements` is being called from module</span>
<span class="sd">    scope, function scope, or class scope.  The `interface_name` argument which</span>
<span class="sd">    occurs on the l.h.s. of the assignment is always a defined interface name</span>
<span class="sd">    in correct usage -- even when it has been redefined to point to an</span>
<span class="sd">    implementation object.  The name will assigned in whatever scope it is in.</span>
<span class="sd">    (How to check correct usage?)</span>

<span class="sd">    What if you assign an implementation to an interface that then goes out of</span>
<span class="sd">    scope, and the implementation then points to a dead object as its interface</span>
<span class="sd">    (dangling reference)?  The implementation might be global and the interface</span>
<span class="sd">    could be local in a function, for example.  It is best to always define</span>
<span class="sd">    interfaces at global scope to avoid those problems. (Can that be enforced?</span>
<span class="sd">    Probably.)</span>

<span class="sd">    - Note that we need to notice if `implements` is being called from module</span>
<span class="sd">    scope or function or class scope, since in the former case we need to look</span>
<span class="sd">    up the module, and in the latter case we can just do the assignment (since</span>
<span class="sd">    the scope doesn&#39;t extend beyond the current module).  This should be</span>
<span class="sd">    transparent to a user.</span>

<span class="sd">Reassignments are slightly more complicated, since in that case the</span>
<span class="sd">`interface_name` passed in has already been set to a previous</span>
<span class="sd">`implementation_name`.  Thus the `implements` function needs some way to look</span>
<span class="sd">up the original interface which was set to have that implementation.</span>

<span class="sd">To handle reassignments the `implements` function just pastes a reference to</span>
<span class="sd">the original interface onto every implementation it sets, as an attribute</span>
<span class="sd">called `_implementing_interface`.  If an interface argument has that attribute</span>
<span class="sd">set then the value of that argument will be assigned to the implementation</span>
<span class="sd">name, rather than the actual object passed in.  Note that this imposes the</span>
<span class="sd">slight restriction that implementations must have a __dict__ to allow</span>
<span class="sd">an attribute to be assigned.</span>

<span class="sd">The `_implementing_interface` attribute is never modified after it is set</span>
<span class="sd">(unless `implements` is called again to set it to implement a different</span>
<span class="sd">interface).  The user can do so if desired, but it should not be necessary.  If</span>
<span class="sd">it is set to anything which evaluates to False it will be ignored.</span>

<span class="sd">Implementations are restricted to only implement one interface at a time.  On</span>
<span class="sd">reassignment the previous interface name is set back to its original class</span>
<span class="sd">definition.  Interfaces can, however, have more than one implementation.</span>

<span class="sd">This follows from the implementation as assignment, where we need a single</span>
<span class="sd">implementation to assign to the interface name.  On a reassignment we would not</span>
<span class="sd">know which implementation to choose.  Actually, the reference is still there</span>
<span class="sd">if you define an implementation to implement another interface.  But we need a</span>
<span class="sd">unique interface to assign, so reassignment in the second case will not do what</span>
<span class="sd">is expected (remember the interface name gets assigned the implementation</span>
<span class="sd">object with a link back to the original interface).  Reassignment without the</span>
<span class="sd">restriction will mess up the original interface if someone wants to use it</span>
<span class="sd">(they will get a different interface, the last one that the implementation</span>
<span class="sd">was assigned to use).</span>

<span class="sd">What about subclassing?  Is that affected?  Does that look at the methods, etc.,</span>
<span class="sd">before any instances are made?</span>

<span class="sd">-- update --&gt; Why not just go ahead and let there be multiple implementations?</span>
<span class="sd">              Let namespaces take care of things.  Assume that the user knows</span>
<span class="sd">              the namespaces and knows that the implements just sets a reference</span>
<span class="sd">              with some magic checking added.</span>

<span class="sd">              What really needs to be modified is that the name of the</span>
<span class="sd">              interface saved in the table should be the full packages-module-name</span>
<span class="sd">                 __package__ + __name__  (joined as appropriate)</span>
<span class="sd">              name of the interface, not just the local name.  Then the problem</span>
<span class="sd">              goes away.  It may work already, as implemented.  Check.</span>

<span class="sd">              If they did an import from somewhere, they must have wanted</span>
<span class="sd">              whatever was set in that namespace.</span>

<span class="sd">              If nothing else, you can paste on some identifier attribute</span>
<span class="sd">              whenever some object is set which indexes back.</span>


<span class="sd">Older:</span>

<span class="sd">   Note that the implements call must be made in the same module as the interface.</span>
<span class="sd">   The implementation can be in an arbitrary location.  The interface definition</span>
<span class="sd">   also needs to be in the global scope of the module in which it is defined</span>
<span class="sd">   (since that&#39;s where it will be redefined to point to the implementation).</span>
<span class="sd">   </span>
<span class="sd">   We have to limit to one interface per implementation (since when we get a</span>
<span class="sd">   pointer to an implementation we have to recover the unique interface in order</span>
<span class="sd">   to reassign its name, unless we restrict to exactly one implements call for any</span>
<span class="sd">   interface).  If you really must you could make a copy and modify the __name__</span>
<span class="sd">   of one of them.</span>
<span class="sd">   </span>
<span class="sd">   All the above restrictions are checked at runtime.</span>
<span class="sd">   </span>
<span class="sd">   You can redefine an implementation within a module, for what that&#39;s worth.</span>
<span class="sd">   </span>
<span class="sd">   Note that with this variable-redefinition method of implementing interfaces</span>
<span class="sd">   there can only be one implementation defined at a time.  Any call to implements</span>
<span class="sd">   will change the definition, and all users will get the last one that was</span>
<span class="sd">   dynamically assigned.  Note that if you make an alias reference to the</span>
<span class="sd">   interface you get a reference to the current implementation which will not be</span>
<span class="sd">   updated when the original is updated.  Implements can be called for it, though,</span>
<span class="sd">   to change the implementation assigned to it.</span>
<span class="sd">   </span>
<span class="sd">   If we know that the implements function is called at the global level of the</span>
<span class="sd">   same module where the interface is defined at the global level then we always</span>
<span class="sd">   know that any module which imported the interface variable (&#39;from egg_interface</span>
<span class="sd">   import egg&#39;) will get a reference to the final implementation set within the</span>
<span class="sd">   module and not to the interface itself.  (This is not considering possible</span>
<span class="sd">   weird mutually recursive calls where you import something in the middle of a</span>
<span class="sd">   file which then imports the file.)</span>
<span class="sd">   </span>
<span class="sd">   This restriction on calling the implements function could possibly be loosened</span>
<span class="sd">   by requiring that the interface definition be private within its module (as</span>
<span class="sd">   private as Python allows).  Then at least no one could import the name directly</span>
<span class="sd">   in an import *, but they would have to know better than to import by name class</span>
<span class="sd">   name starting with an underscore (it always has to be accessed in its module</span>
<span class="sd">   scope, where it was redefined).  You could look at the __name__ and see if it</span>
<span class="sd">   starts with an underscore to enforce this.</span>
<span class="sd">   </span>
<span class="sd">   References would be less of a problem if there were a level of indirection on</span>
<span class="sd">   the interface, linking to the implementation.  That adds a layer of overhead in</span>
<span class="sd">   method calls, etc., however, and the syntax might be difficult to arrange to</span>
<span class="sd">   look simple (maybe decorators).  The current approach only has a small startup</span>
<span class="sd">   overhead cost.</span>
<span class="sd">   </span>
<span class="sd">   (Note that we could paste some additional info onto the interface and</span>
<span class="sd">   implementation themselves when they are registered here...)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="c"># TODO: You can get the reference count for any object by using sys.refcount</span>
<span class="c"># on it.  Does this help in some way as far as loosening the requirements</span>
<span class="c"># of declaring interface and implementation in the same file?  Note the call</span>
<span class="c"># gives one higher than you expect.</span>
<span class="c">#    https://docs.python.org/2/library/sys.html</span>

<span class="c"># TODO: maybe implement a separate program that can be called to process the</span>
<span class="c"># files containing interfaces and their implementations.  This should automatically</span>
<span class="c"># copy the docstring of the interface to the docstring of the implementation</span>
<span class="c"># (or vice versa).  This allows them to be kept synchronized.  Can have a special</span>
<span class="c"># optional keyword to separate the last half of such a docstring to keep it</span>
<span class="c"># associated only with its original class.  Useful for implementation details in</span>
<span class="c"># the docscring, for example, which shouldn&#39;t be in the interface docstring.</span>

<span class="c"># TODO consider flags to the implements function.  Maybe allow partial</span>
<span class="c"># implementations which take methods from interface which it does not define.</span>
<span class="c"># Then, you could actually do some implementation in a method if you wanted</span>
<span class="c"># to, or you could keep some things abstract for a later implementation to</span>
<span class="c"># take care of....</span>

<span class="c"># TODO check that objects passed in are classes, later.</span>

<span class="c"># TODO consider if you can define instance variables defined in the __init__</span>
<span class="c"># (and nothing else defined there) and interpret them as the publicly</span>
<span class="c"># accessible variable attributes of an instance.  You could maybe just run it</span>
<span class="c"># and look at the namespace somehow, or otherwise introspect.</span>

<span class="c"># Possible feature: Have code that allows the program to run *through* the</span>
<span class="c"># interface, i.e., to use the interface itself but to relay all the calls</span>
<span class="c"># to the underlying implementation.  Maybe by redefining abstract()?</span>
<span class="c"># This is very inefficient, but it allows for enforcing the use of the</span>
<span class="c"># interface at runtime.  A good check, though not perfect.  Run the test</span>
<span class="c"># suite with that option turned on.</span>

<span class="c"># You could require a decorator @interface on the class which would execute</span>
<span class="c"># at define-time and could do whatever it wanted...  This allows passing</span>
<span class="c"># parameters to the interface actions, also.</span>

<span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>

<div class="viewcode-block" id="abstract"><a class="viewcode-back" href="../../wff_language.interfaces.html#wff_language.interfaces.abstract">[docs]</a><span class="k">def</span> <span class="nf">abstract</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Dummy function to be called for methods of interfaces.&quot;&quot;&quot;</span>
    <span class="c"># TODO in function, look up the calling method with inspect and</span>
    <span class="c"># return better debugging info about what it was called on.</span>
    <span class="c"># Could have self argument abstract() , but that clutters the syntax.</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Abstract method, not implemented.&quot;</span><span class="p">)</span>

<span class="c"># This is a dict where the original interface definition is saved before its</span>
<span class="c"># module-scope name is redefined.  The dict is keyed by the full name of the</span>
<span class="c"># current implementation.  This is so if the implementation is changed by</span>
<span class="c"># another implements call we can recover the original interface variable name</span>
<span class="c"># and its module scope in order to to assign it the new implementation</span>
<span class="c"># definition.</span></div>
<span class="n">impname_to_interface_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c"># add mypy annotations?</span>

<div class="viewcode-block" id="get_object_info"><a class="viewcode-back" href="../../wff_language.interfaces.html#wff_language.interfaces.get_object_info">[docs]</a><span class="k">def</span> <span class="nf">get_object_info</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get basic name and module information about the object.&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">__name__</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">__module__</span> <span class="c"># this includes package info</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span>
    <span class="n">full_name</span> <span class="o">=</span> <span class="n">module_name</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="c"># package??</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">full_name</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="implements"><a class="viewcode-back" href="../../wff_language.interfaces.html#wff_language.interfaces.implements">[docs]</a><span class="k">def</span> <span class="nf">implements</span><span class="p">(</span><span class="n">implementation</span><span class="p">,</span> <span class="n">interface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Assign `implementation` as an implementation of the interface `interface`.&quot;&quot;&quot;</span>
    <span class="c"># Get the name of the module where the implements function is being called</span>
    <span class="c"># from (to enforce the restriction that it can only be called from the same</span>
    <span class="c"># module as the interface definition).</span>
    <span class="n">calling_fun_frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">calling_fun_globals</span> <span class="o">=</span> <span class="n">calling_fun_frame</span><span class="o">.</span><span class="n">f_globals</span>
    <span class="n">calling_module_name</span> <span class="o">=</span> <span class="n">calling_fun_globals</span><span class="p">[</span><span class="s">&quot;__name__&quot;</span><span class="p">]</span>
    <span class="n">calling_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">calling_module_name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">The implements function is being called from module&quot;</span><span class="p">,</span>
                    <span class="n">calling_module_name</span><span class="p">)</span>

    <span class="p">(</span><span class="n">implem_name</span><span class="p">,</span> <span class="n">implem_module_name</span><span class="p">,</span> <span class="n">implem_module</span><span class="p">,</span>
            <span class="n">implem_full_name</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_object_info</span><span class="p">(</span><span class="n">implementation</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">   full implementation name is&quot;</span><span class="p">,</span> <span class="n">implem_full_name</span><span class="p">)</span>

    <span class="c"># Note that if we have called implements with this interface before then</span>
    <span class="c"># the interface passed in is not actually pointing to the interface; the</span>
    <span class="c"># variable has been reassigned to point to a previous implementation.  In</span>
    <span class="c"># that case the inter_full_name is actually the current implementation</span>
    <span class="c"># name (and we&#39;ll have to look up the actual interface).</span>
    <span class="p">(</span><span class="n">inter_name</span><span class="p">,</span> <span class="n">inter_module_name</span><span class="p">,</span> <span class="n">inter_module</span><span class="p">,</span>
            <span class="n">inter_full_name</span><span class="p">)</span> <span class="o">=</span> <span class="n">get_object_info</span><span class="p">(</span><span class="n">interface</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">   full interface name (for now) is&quot;</span><span class="p">,</span> <span class="n">inter_full_name</span><span class="p">)</span>

    <span class="c"># If inter_full_name is a key in the impname_to_interface_dict dict then</span>
    <span class="c"># if was set equal to an implementation before, so restore it.</span>
    <span class="k">if</span> <span class="n">inter_full_name</span> <span class="ow">in</span> <span class="n">impname_to_interface_dict</span><span class="p">:</span>
        <span class="n">interface</span> <span class="o">=</span> <span class="n">impname_to_interface_dict</span><span class="p">[</span><span class="n">inter_full_name</span><span class="p">]</span>
        <span class="c"># redo getting name, since it was set to some implementation before</span>
        <span class="n">inter_name</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">inter_module_name</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">__module__</span>
        <span class="n">inter_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">inter_module_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">   full interface name is&quot;</span><span class="p">,</span> 
                <span class="n">inter_module_name</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">inter_name</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">impname_to_interface_dict</span><span class="p">[</span><span class="n">inter_full_name</span><span class="p">]</span>

    <span class="c"># Make sure the interface definition is at the global level of its</span>
    <span class="c"># definition module (since that&#39;s where it will be redefined).</span>
    <span class="k">if</span> <span class="n">inter_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inter_module</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InterfaceError</span><span class="p">(</span><span class="s">&quot;All interface definitions must be made at the global&quot;</span>
                             <span class="s">&quot; level of the module in which they are defined.&quot;</span><span class="p">)</span>

    <span class="c"># Save the original interface class.</span>
    <span class="c"># TODO: this doesn&#39;t notice if the call is assigning the same thing as before</span>
    <span class="c"># (what it should do in that case is an open question)</span>
    <span class="k">if</span> <span class="n">implem_full_name</span> <span class="ow">in</span> <span class="n">impname_to_interface_dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InterfaceError</span><span class="p">(</span><span class="s">&quot;An implementation is only allowed to implement one&quot;</span>
                             <span class="s">&quot; interface, not multiple interfaces.&quot;</span><span class="p">)</span>
    <span class="n">impname_to_interface_dict</span><span class="p">[</span><span class="n">implem_full_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">interface</span>

    <span class="c"># Enforce the restriction that the implements function must be called</span>
    <span class="c"># from the same module where the interface is defined.</span>
    <span class="k">if</span> <span class="n">calling_module_name</span> <span class="o">!=</span> <span class="n">inter_module_name</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InterfaceError</span><span class="p">(</span><span class="s">&quot;The &#39;implements&#39; function must be called from within&quot;</span>
                             <span class="s">&quot; the same module where the interface is defined.&quot;</span><span class="p">)</span>

    <span class="c"># Set the interface name in the dict of the interface module to point to</span>
    <span class="c"># the implementation, not the original definition.</span>
    <span class="n">inter_module</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">inter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">implementation</span>
    <span class="k">return</span>

</div>
<div class="viewcode-block" id="InterfaceError"><a class="viewcode-back" href="../../wff_language.interfaces.html#wff_language.interfaces.InterfaceError">[docs]</a><span class="k">class</span> <span class="nc">InterfaceError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>