<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>wff_language.pratt_types &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for wff_language.pratt_types</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">enum_wrapper</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="c"># TODO: recall the distinction between formal and actual parameters.  Python</span>
<span class="c"># calls these parameters and arguments, respectively.  Useful for naming</span>
<span class="c"># some classes here?</span>


<div class="viewcode-block" id="TypeObject"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeObject">[docs]</a><span class="k">class</span> <span class="nc">TypeObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subclasses of this object represent parameterized types.  Instances of</span>
<span class="sd">    those subclasses represent the actual types.</span>

<span class="sd">    Each *parameterized* type is represented as a subclass of the `TypeObject`</span>
<span class="sd">    class.  Each type itself is an instance of such a subclass, with the</span>
<span class="sd">    parameters filled in with actual arguments (which may or may not match the</span>
<span class="sd">    required arguments, that is checked elsewhere).&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="k">return</span> <span class="s">&quot;TypeObject()&quot;</span>

</div>
<div class="viewcode-block" id="FunctionTypes"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.FunctionTypes">[docs]</a><span class="k">class</span> <span class="nc">FunctionTypes</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is essentially a tuple `(val_type, arg_types)`.  This container is</span>
<span class="sd">    the base class for both the TypeSig and TypeSpec classes.  (The first one</span>
<span class="sd">    holds actual instantiated types in its slots while the second one can have</span>
<span class="sd">    parameterized types in its slots.)</span>
<span class="sd">    </span>
<span class="sd">    For the purposes of comparison these objects are equivalent to the tuple</span>
<span class="sd">    form.  Making a separate class allows additional information to be stored</span>
<span class="sd">    with the tuple and produces better error messages.  The class also provides</span>
<span class="sd">    a convenient place to localize some routines that operate on type</span>
<span class="sd">    signatures and lists of type signatures.</span>
<span class="sd">    </span>
<span class="sd">    Note that `None` is a wildcard which matches any type, and `None` for the</span>
<span class="sd">    `arg_types` list/tuple matches any arguments and any number of</span>
<span class="sd">    arguments.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">test_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The argument `val_type` should be a hashable type in the language or</span>
<span class="sd">        else `None`.  The argument `arg_types` should be a list, tuple, or</span>
<span class="sd">        other iterable of such hashable types (including `None`) or else simply</span>
<span class="sd">        `None`.  The `None` value is treated as a wildcard that matches any</span>
<span class="sd">        corresponding type; `None` alone for `arg_types` allows any number of</span>
<span class="sd">        arguments of any type.&quot;&quot;&quot;</span>
        <span class="c"># TODO test_fun is unset as a class var and unused.  What is it supposed</span>
        <span class="c"># to do???</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_types</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;The `arg_types` argument must&quot;</span>
                    <span class="s">&quot; be `None` or an iterable returning types (e.g., a list&quot;</span>
                    <span class="s">&quot; or tuple of types).&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_type</span> <span class="o">=</span> <span class="n">val_type</span>
        <span class="k">if</span> <span class="n">arg_types</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_types</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg_types</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_types</span> <span class="o">=</span> <span class="n">arg_types</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="FunctionTypes.get_all_matching_sigs"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.FunctionTypes.get_all_matching_sigs">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_matching_sigs</span><span class="p">(</span><span class="n">sig_list</span><span class="p">,</span> <span class="n">list_of_child_sig_lists</span><span class="p">,</span> <span class="n">tnode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                              <span class="n">repeat_args</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">raise_err_on_empty</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of all the signatures on `sig_list` whose arguments</span>
<span class="sd">        match some choice of child signatures from `list_of_child_sig_lists`.</span>
<span class="sd">        The latter list should be a list of lists, where each sublist is a</span>
<span class="sd">        list of all the possible signatures for a child node.  The sublists</span>
<span class="sd">        should be in the same order as the children/arguments.&quot;&quot;&quot;</span>
        <span class="n">num_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_child_sig_lists</span><span class="p">)</span>
        <span class="n">sig_list</span> <span class="o">=</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">remove_duplicate_sigs</span><span class="p">(</span><span class="n">sig_list</span><span class="p">)</span>
        <span class="n">sig_list</span> <span class="o">=</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">expand_sigs_with_None_args</span><span class="p">(</span><span class="n">num_args</span><span class="p">,</span> <span class="n">sig_list</span><span class="p">)</span>
        <span class="n">sig_list</span> <span class="o">=</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">get_sigs_matching_num_args</span><span class="p">(</span><span class="n">num_args</span><span class="p">,</span> <span class="n">sig_list</span><span class="p">,</span>
                                         <span class="n">repeat_args</span><span class="p">,</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">raise_err_on_empty</span><span class="p">)</span>
        <span class="n">sig_list</span> <span class="o">=</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">get_sigs_matching_child_types</span><span class="p">(</span><span class="n">sig_list</span><span class="p">,</span>
                             <span class="n">list_of_child_sig_lists</span><span class="p">,</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">raise_err_on_empty</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sig_list</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="FunctionTypes.remove_duplicate_sigs"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.FunctionTypes.remove_duplicate_sigs">[docs]</a>    <span class="k">def</span> <span class="nf">remove_duplicate_sigs</span><span class="p">(</span><span class="n">sig_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of signatures in `sig_list`, removing any duplicates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sig_list</span><span class="p">))</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="FunctionTypes.expand_sigs_with_None_args"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.FunctionTypes.expand_sigs_with_None_args">[docs]</a>    <span class="k">def</span> <span class="nf">expand_sigs_with_None_args</span><span class="p">(</span><span class="n">num_args</span><span class="p">,</span> <span class="n">sig_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The signatures on list `sig_list` so that any `None` argument not</span>
<span class="sd">        inside a tuple or list is converted to a tuple of `None` having</span>
<span class="sd">        `num_args` of argument.&quot;&quot;&quot;</span>
        <span class="n">all_sigs_expanded</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">sig_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">arg_types</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">new_sig</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="p">(</span><span class="bp">None</span><span class="p">,)</span><span class="o">*</span><span class="n">num_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">new_sig</span> <span class="o">=</span> <span class="n">sig</span>
            <span class="n">all_sigs_expanded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_sigs_expanded</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="FunctionTypes.get_sigs_matching_num_args"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.FunctionTypes.get_sigs_matching_num_args">[docs]</a>    <span class="k">def</span> <span class="nf">get_sigs_matching_num_args</span><span class="p">(</span><span class="n">num_args</span><span class="p">,</span> <span class="n">sig_list</span><span class="p">,</span> <span class="n">repeat_args</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                        <span class="n">tnode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">raise_err_on_empty</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of signatures from `sig_list` which match `num_args`</span>
<span class="sd">        as the number of arguments.  Expand as necessary by repeating the</span>
<span class="sd">        arguments over and over if `repeat_args` is `True`.  The optional</span>
<span class="sd">        token-tree node `tnode` is only used for improved error reporting.&quot;&quot;&quot;</span>
        <span class="n">sigs_matching_numargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">sig_list</span><span class="p">:</span>
            <span class="n">sig_args_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sig_args_len</span> <span class="o">!=</span> <span class="n">num_args</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">repeat_args</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">num_actual_args</span> <span class="o">%</span> <span class="n">sig_args_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">num_repeats</span> <span class="o">=</span> <span class="n">num_actual_args</span> <span class="o">//</span> <span class="n">sig_args_len</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">arg_types</span> <span class="o">*</span> <span class="n">num_repeats</span><span class="p">)</span>
            <span class="n">sigs_matching_numargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">raise_err_on_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sigs_matching_numargs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Number of arguments does not match any signature.&quot;</span>
            <span class="k">if</span> <span class="n">tnode</span><span class="p">:</span> <span class="n">tnode</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">([],</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sigs_matching_numargs</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="FunctionTypes.get_sigs_matching_child_types"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.FunctionTypes.get_sigs_matching_child_types">[docs]</a>    <span class="k">def</span> <span class="nf">get_sigs_matching_child_types</span><span class="p">(</span><span class="n">sig_list</span><span class="p">,</span> <span class="n">list_of_child_sig_lists</span><span class="p">,</span>
                                          <span class="n">tnode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">raise_err_on_empty</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of all signatures in sig_list which have arguments that</span>
<span class="sd">        match the return types of the child signatures in `list_of_child_sig_lists`.</span>
<span class="sd">        The latter should be a list containing a list of all the signatures for</span>
<span class="sd">        each child, in order.  The number of arguments is assumed to already match</span>
<span class="sd">        (see `get_sigs_matching_num_args`).  The optional token-tree node `tnode`</span>
<span class="sd">        is only used for improved error reporting.&quot;&quot;&quot;</span>
        <span class="n">matching_sigs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Loop over each possible sig, testing for matches.</span>
        <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">sig_list</span><span class="p">:</span>
            <span class="c"># Handle the case of literals, with no children/arguments.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">matching_sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c"># Handle the case with one or more children/arguments.</span>
            <span class="n">mismatch_with_sig</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">child_sig_list</span><span class="p">,</span> <span class="n">arg_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                                    <span class="n">list_of_child_sig_lists</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">):</span>
                <span class="n">some_child_retval_matches</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">child_sig</span> <span class="ow">in</span> <span class="n">child_sig_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">child_sig</span><span class="o">.</span><span class="n">val_type</span> <span class="o">==</span> <span class="n">arg_type</span> <span class="ow">or</span> <span class="n">arg_type</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">some_child_retval_matches</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">some_child_retval_matches</span><span class="p">:</span>
                    <span class="n">mismatch_with_sig</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mismatch_with_sig</span><span class="p">:</span> <span class="n">matching_sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">raise_err_on_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">matching_sigs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Actual argument types do not match any signature.&quot;</span>
            <span class="k">if</span> <span class="n">tnode</span><span class="p">:</span> <span class="n">tnode</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">([],</span> <span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matching_sigs</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_type</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_types</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">IndexError</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_type</span> <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">val_type</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_types</span> <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="k">return</span> <span class="s">&quot;TypeSpec(&#39;{0}&#39;, {1})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_types</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Needed to index dicts and for use in Python sets.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg_types</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="TypeSig"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeSig">[docs]</a><span class="k">class</span> <span class="nc">TypeSig</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The actual type signature for a function, holding actual types.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">test_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TypeSig</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">,</span> <span class="n">test_fun</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="TypeSpec"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeSpec">[docs]</a><span class="k">class</span> <span class="nc">TypeSpec</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The type specification for a function; may have parameterized types.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">test_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TypeSpec</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">,</span> <span class="n">test_fun</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="create_type_template"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.create_type_template">[docs]</a><span class="k">def</span> <span class="nf">create_type_template</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return a subclass of `TypeObject` to represent a type template.  This</span>
<span class="sd">    routine can be redefined for particular applications, but should not be</span>
<span class="sd">    called directly.  Use the `create_typeobject_subclass` method of</span>
<span class="sd">    `TypeTemplateTable` instead (which creates a subclass, adds some</span>
<span class="sd">    attributes, and saves it in a dict).  End users should use the</span>
<span class="sd">    `define_type` method of a `PrattParser` instance, which calls</span>
<span class="sd">    `create_typeobject_subclass`.  The `template_subclass_fun` keyword argument</span>
<span class="sd">    in the initializer `TypeTemplateTable` can be used to change the function</span>
<span class="sd">    which is called.&quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">TypeTemplate</span><span class="p">(</span><span class="n">TypeObject</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instances of this object are used to represent types in the parsed</span>
<span class="sd">        language.&quot;&quot;&quot;</span>
        <span class="n">type_name</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Set by the method that calls create_type_template.</span>
        <span class="n">type_param_types</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Set by the method that calls create_type_template.</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_param_vals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">conversions</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Instantiate an actual type from the parameterized type represented</span>
<span class="sd">            by the subclass.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_params</span> <span class="o">=</span> <span class="n">type_param_vals</span>
            <span class="k">if</span> <span class="n">conversions</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversions</span> <span class="o">=</span> <span class="n">conversions</span>
            <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversions</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># Dict keyed by to_type values.</span>

        <span class="k">def</span> <span class="nf">define_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_type</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tree_data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Define an automatic conversion to be applied to the `TypeObject`</span>
<span class="sd">            instance, to convert it to type `to_type`.  The highest-priority</span>
<span class="sd">            conversion which matches the type spec will always be the one which is</span>
<span class="sd">            chosen.  Exact match has priority zero, so priorities will usually be</span>
<span class="sd">            negative.  Raises `TypeError` if there is still ambiguity (i.e., a</span>
<span class="sd">            tie).  The `tree_data` parameter is an arbitrary object which is</span>
<span class="sd">            associated with the conversion and will be accessible from the</span>
<span class="sd">            `TypeSpec` stored in the parse tree.  It might be a Python function to</span>
<span class="sd">            actually do the conversion, for example.  Or it might be a node to add</span>
<span class="sd">            to the AST to represent the conversion.  No actual conversions are</span>
<span class="sd">            performed; those are considered semantic actions for the user to</span>
<span class="sd">            implement.&quot;&quot;&quot;</span>
            <span class="c"># TODO define for parameterized template version or instantiated versions???</span>
            <span class="c"># TODO may need to redefine priority mechanism, since across a</span>
            <span class="c"># full signature matching there may be problems with the greedy</span>
            <span class="c"># approach to choosing... you find all possible signatures, but</span>
            <span class="c"># then you have to rank the full signatures across all types in</span>
            <span class="c"># them.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conversions</span><span class="p">[</span><span class="n">to_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="n">tree_data</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">undefine_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_type</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversions</span><span class="p">[</span><span class="n">to_type</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeobject</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Define `==` as exact match only.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_name</span> <span class="o">!=</span> <span class="n">typeobject</span><span class="o">.</span><span class="n">type_name</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">typeobject</span><span class="o">.</span><span class="n">parameters</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">typeobject</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeobject</span><span class="p">):</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">typeobject</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Needed to index dicts and for use in Python sets.&quot;&quot;&quot;</span>
            <span class="c"># TODO, hash on only the first few vars, maybe</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">type_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_param_types</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&quot;({0}, {1})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_params</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">TypeTemplate</span>

</div>
<div class="viewcode-block" id="TypeTemplateTable"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeTemplateTable">[docs]</a><span class="k">class</span> <span class="nc">TypeTemplateTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A symbol table holding subclasses of the `TypeObject` class for each</span>
<span class="sd">    defined type in the language.&quot;&quot;&quot;</span>
    <span class="n">aliases</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># A static dict mapping defined aliases to TypeObjects. TODO</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template_subclass_fun</span><span class="o">=</span><span class="n">create_type_template</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the symbol table.  The parameter `token_subclassing_fun`</span>
<span class="sd">        can be passed a function to be used to generate token subclasses,</span>
<span class="sd">        taking a token label as an argument.  The default is</span>
<span class="sd">        `create_token_subclass`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template_subclass_fun</span> <span class="o">=</span> <span class="n">template_subclass_fun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_template_dict</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="TypeTemplateTable.has_key"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeTemplateTable.has_key">[docs]</a>    <span class="k">def</span> <span class="nf">has_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether a `TypeObject` subclass for `type_name` has been stored.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_template_dict</span>
</div>
<div class="viewcode-block" id="TypeTemplateTable.get_typeobject_subclass"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeTemplateTable.get_typeobject_subclass">[docs]</a>    <span class="k">def</span> <span class="nf">get_typeobject_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look up the subclasses of base class `TypeObject` corresponding to</span>
<span class="sd">        `type_name` in the symbol table and return it.  Raises a</span>
<span class="sd">        `TypeException` if no subclass is found for the token label.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_template_dict</span><span class="p">:</span>
            <span class="n">TokenSubclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_template_dict</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">TokenSubclass</span>
</div>
<div class="viewcode-block" id="TypeTemplateTable.create_typeobject_subclass"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeTemplateTable.create_typeobject_subclass">[docs]</a>    <span class="k">def</span> <span class="nf">create_typeobject_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_name</span><span class="p">,</span> <span class="n">type_param_types</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a subclass for a type named `type_name` and store it</span>
<span class="sd">        in the symbol table.  Return the new subclass.  Raises a `TypeException`</span>
<span class="sd">        if a subclass for `type_name` has already been created.&quot;&quot;&quot;</span>
        <span class="c"># TODO: type_param_types field is only set and never used anywhere.</span>
        <span class="c"># What is it supposed to be doing?  How does it differ from the field</span>
        <span class="c"># type_params which is set for the same class objects in __init__?</span>
        <span class="k">if</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_template_dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TypeException</span><span class="p">(</span><span class="s">&quot;In create_type_template, already created a&quot;</span>
                                <span class="s">&quot; type with type_name &#39;{0}&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_name</span><span class="p">))</span>
        <span class="c"># Create a new TypeObject subclass for type_name and add some attributes.</span>
        <span class="n">TypeObjectSubclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">template_subclass_fun</span><span class="p">()</span>
        <span class="n">TypeObjectSubclass</span><span class="o">.</span><span class="n">type_name</span> <span class="o">=</span> <span class="n">type_name</span>
        <span class="n">TypeObjectSubclass</span><span class="o">.</span><span class="n">type_param_types</span> <span class="o">=</span> <span class="n">type_param_types</span>

        <span class="c"># Create an informative name for the subclass for debugging purposes.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">type_param_types</span><span class="p">:</span>
            <span class="n">type_param_type_names</span> <span class="o">=</span> <span class="s">&quot;unparameterized&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_param_type_names</span> <span class="o">=</span> <span class="p">[</span> <span class="n">t</span><span class="o">.</span><span class="n">type_name</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">type_param_types</span> <span class="p">]</span>
        <span class="n">param_names_str</span> <span class="o">=</span> <span class="s">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">type_param_type_names</span><span class="p">)</span>
        <span class="n">TypeObjectSubclass</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;typeobject_subclass-&quot;</span> <span class="o">+</span> <span class="n">type_name</span> 
                                       <span class="o">+</span> <span class="n">param_names_str</span><span class="p">)</span>

        <span class="c"># Store the newly-created subclass in the token_dict and return it, too.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_template_dict</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">TypeObjectSubclass</span>
        <span class="k">return</span> <span class="n">TypeObjectSubclass</span>
</div>
<div class="viewcode-block" id="TypeTemplateTable.undefine_typeobject_subclass"><a class="viewcode-back" href="../../wff_language.pratt_types.html#wff_language.pratt_types.TypeTemplateTable.undefine_typeobject_subclass">[docs]</a>    <span class="k">def</span> <span class="nf">undefine_typeobject_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Un-define the token with label type_name.  The TokenNode subclass</span>
<span class="sd">        previously associated with that label is removed from the dictionary.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_template_dict</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">return</span> <span class="c"># Not saved in dict, ignore.</span>



</div></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pytest_helper</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="s">&quot;test/test_pratt_types.py&quot;</span><span class="p">)</span> <span class="c"># TODO no test file</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>