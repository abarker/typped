<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>wff_language.language_data &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for wff_language.language_data</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Code for the LanguageData class, which is used to store, search, and retrieve</span>
<span class="sd">data about types, variables, etc.  It is essentially the global symbol table</span>
<span class="sd">for the full language.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">basic_defs</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">regex_trie_dict</span> <span class="kn">import</span> <span class="n">RegexTrieDict</span>

<span class="c"># TODO currently for commutative infix operators between different types</span>
<span class="c"># you&#39;d have to treat it as two separate functions.  Could maybe have</span>
<span class="c"># another flag for commutative.</span>

<span class="c"># TODO eliminate or re-do this langElems stuff; only here now, moved from basic_defs.py</span>
<span class="n">langElemLabels</span> <span class="o">=</span> <span class="p">[</span>
                 <span class="s">&quot;type&quot;</span><span class="p">,</span> 
                 <span class="s">&quot;typeAlias&quot;</span><span class="p">,</span> 
                 <span class="s">&quot;quant&quot;</span><span class="p">,</span> 
                 <span class="s">&quot;const&quot;</span><span class="p">,</span> 
                 <span class="s">&quot;var&quot;</span><span class="p">,</span>
                 <span class="s">&quot;stdFun&quot;</span><span class="p">,</span> 
                 <span class="s">&quot;prefixFun&quot;</span><span class="p">,</span> 
                 <span class="s">&quot;infixFun&quot;</span>
                 <span class="p">]</span>
<span class="n">LangElemsTuple</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">&quot;LangElemsTuple&quot;</span><span class="p">,</span> <span class="n">langElemLabels</span><span class="p">)</span>
<span class="n">langElems</span> <span class="o">=</span> <span class="n">LangElemsTuple</span><span class="p">(</span><span class="o">*</span><span class="n">langElemLabels</span><span class="p">)</span> <span class="c"># use same as field name for now</span>



<div class="viewcode-block" id="TypeData"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.TypeData">[docs]</a><span class="k">class</span> <span class="nc">TypeData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An internal record for storing data about types in the types dictionary.</span>
<span class="sd">    Users never see instances of this type, and it may change in different</span>
<span class="sd">    implementations.</span>

<span class="sd">    Only names (name strings) are actually stored in the various field lists.</span>
<span class="sd">    The various other properties associated with a name can then be looked up by</span>
<span class="sd">    using that name as an index into the dict for the corresponding language</span>
<span class="sd">    element.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conversionTypes</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># Types this type can be converted to.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeAliases</span> <span class="o">=</span> <span class="p">[]</span>     <span class="c"># Type aliases for this type (with actual types).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quants</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c"># Quantifiers restricted to this type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consts</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c"># Constants of this type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varNames</span> <span class="o">=</span> <span class="p">[]</span>        <span class="c"># Variable names of this type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stdFuns</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c"># Standard functions returning this type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefixFuns</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c"># Prefix functions returning this type.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infixFuns</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c"># Infix functions returning this type.</span>

</div>
<div class="viewcode-block" id="LanguageData"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData">[docs]</a><span class="k">class</span> <span class="nc">LanguageData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for storing, searching, and retrieving data for the Language</span>
<span class="sd">    class.  The language elements which have data stored for them are defined</span>
<span class="sd">    by</span>

<span class="sd">       langElems = (&quot;type&quot;, &quot;typeAlias&quot;, &quot;quant&quot;, &quot;const&quot;, &quot;var&quot;,</span>
<span class="sd">                    &quot;stdFun&quot;, &quot;prefixFun&quot;, &quot;infixFun&quot;)</span>

<span class="sd">    The program which uses this class is responsible for making sure that any</span>
<span class="sd">    name argument which is passed in is valid in the namespace for the language</span>
<span class="sd">    element it is being added as (&quot;type&quot;, &quot;variable&quot;, etc.)  For example, types</span>
<span class="sd">    and variables may or may not share a namespace or have an intersecting</span>
<span class="sd">    namespace (that is a language-design choice).  We do assume that no name</span>
<span class="sd">    can ever name two different things (over all the language elements), except</span>
<span class="sd">    for functions which can have the same names if they have different type</span>
<span class="sd">    signatures (provided the function overloading flag is set).  Function name</span>
<span class="sd">    overloading is allowed for all the variants of function names.</span>

<span class="sd">    Given that the names are always valid in their namespaces we can just add a</span>
<span class="sd">    valid name for any sort of language element (types, variables, etc.)</span>
<span class="sd">    provided that that name has not been added (stored) for any of the other</span>
<span class="sd">    language elements.  That is, we can iterate over langElems and check that</span>
<span class="sd">    the name is not defined for any of them.  This is described further in the</span>
<span class="sd">    next paragraph.</span>

<span class="sd">    If two language elements, say types and variables, have disjoint namespaces</span>
<span class="sd">    then a valid type name is assumed never to have been added as a variable</span>
<span class="sd">    name in the first place (and vice versa).  So it does not hurt to check if</span>
<span class="sd">    the name has been defined for a variable before adding it as a type (and</span>
<span class="sd">    vice versa).  If the namespaces intersect, any names in the disjoint</span>
<span class="sd">    regions still have this same property.  For names in the intersection of,</span>
<span class="sd">    say, the type and variable namespaces we *do* need to check that the name</span>
<span class="sd">    has not been defined either for types or for variables before adding it as</span>
<span class="sd">    either a type or a variable.  An iteration over langElems takes care of</span>
<span class="sd">    this.</span>

<span class="sd">    Precedence values passed in can be strings or ints, but they will be</span>
<span class="sd">    converted to ints before being stored.</span>

<span class="sd">    In using different block scopes with a dot name convention, such as</span>
<span class="sd">    env1.env2.name, the full dotted names should be added or checked, since</span>
<span class="sd">    env1.name is different from env1.env2.name.  This module does not keep</span>
<span class="sd">    track of any block-scoping environments.</span>

<span class="sd">    Note this is an inefficient prototype implementation.  It just stores all</span>
<span class="sd">    the data in dictionaries indexed by names.  The function dictionaries have</span>
<span class="sd">    lists of function-signature data as values, since function name overloading</span>
<span class="sd">    is allowed.</span>

<span class="sd">    The types dictionary is the only one which is slightly more complicated,</span>
<span class="sd">    but it just contains TypeData class instances to hold various type</span>
<span class="sd">    attributes.</span>

<span class="sd">    The LanguageData class also contains a RegexTrieDict, which it adds all</span>
<span class="sd">    defined types to (and deletes if that is allowed).  An application can</span>
<span class="sd">    insert any other string/value pairs that it chooses to into the</span>
<span class="sd">    RegexTrieDict (like command-names, whitespace, parens, etc).  This allows</span>
<span class="sd">    the data structure to be used for lexical analysis.  It will always know</span>
<span class="sd">    the defined names in the language because the LanguageData class updates it</span>
<span class="sd">    whenever it is updated.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># A dictionary for each kind of language element, indexed by the string</span>
        <span class="c"># for the language element.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conversionTypes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeAliases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quants</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stdFuns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefixFuns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infixFuns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regexTrieDict</span> <span class="o">=</span> <span class="n">RegexTrieDict</span><span class="p">()</span>  <span class="c"># TODO what data should these store??</span>
                                              <span class="c"># will need lang elem, will have name</span>
                                              <span class="c"># but can store, can query on the rest??</span>
                                              <span class="c"># overloading will want to call subs</span>
                                              <span class="c"># with some data on what to look for types</span>
                                              <span class="c"># SEE ABOVE, Pratt parser token instances</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allowStdFunOverloading</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allowPrefixFunOverloading</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allowPrefixFunOverloading</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">overloadStdFunsOnArgsOnly</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overloadPrefixFunsOnArgsOnly</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overloadInfixFunsOnArgsOnly</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Definitions for how to locally handle any errors which occur.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;UndefinedError&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
            <span class="s">&quot;AlreadyDefinedError&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
            <span class="s">&quot;UndefinedLanguageElementError&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
            <span class="s">&quot;BadDataValueError&quot;</span><span class="p">:</span> <span class="bp">True</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;UndefinedError&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
            <span class="s">&quot;AlreadyDefinedError&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
            <span class="s">&quot;UndefinedLanguageElementError&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
            <span class="s">&quot;BadDataValueError&quot;</span><span class="p">:</span> <span class="bp">True</span>
        <span class="p">}</span>

    <span class="c">#</span>
    <span class="c"># Methods to &quot;add&quot; or insert data into the LanguageData object.</span>
    <span class="c">#</span>

<div class="viewcode-block" id="LanguageData.add_type"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_type">[docs]</a>    <span class="k">def</span> <span class="nf">add_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeName</span><span class="p">,</span> <span class="n">conversionTypes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a type and an optional list of types it can be converted</span>
<span class="sd">        to.  Conversion types can be either types or type aliases.  The default</span>
<span class="sd">        for conversionTypes is the empty list.</span>

<span class="sd">        The type typeName cannot have been previously defined in the type</span>
<span class="sd">        namespace or an exception will be raised.  If necessary this can be</span>
<span class="sd">        checked with the isAlreadyDefinedType method before attempting the add,</span>
<span class="sd">        or else the exception can be caught assuming that</span>

<span class="sd">            raiseExceptionOnLanguageDataError[&quot;AlreadyDefinedError&quot;] = False.</span>

<span class="sd">        The other add methods work similarly.&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">conversionTypes</span><span class="p">:</span> <span class="n">conversionTypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">typeName</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">conversionTypes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span>
        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualConvTypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type_list</span><span class="p">(</span><span class="n">conversionTypes</span><span class="p">)</span>
        <span class="c"># Store the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">typeName</span><span class="p">]</span> <span class="o">=</span> <span class="n">TypeData</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">typeName</span><span class="p">]</span><span class="o">.</span><span class="n">conversionTypes</span> <span class="o">=</span> <span class="n">actualConvTypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regexTrieDict</span><span class="p">[</span><span class="n">typeName</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># default to None for now.... what data???????</span>
        <span class="k">return</span>

    <span class="c">#</span>
    <span class="c"># The &quot;add&quot; functions below first update their own dictionary, and</span>
    <span class="c"># then update the types dictionary with the same data (indexed differently)</span>
    <span class="c"># and finally update the common regexTrieDict TrieDict.</span>
    <span class="c">#</span></div>
<div class="viewcode-block" id="LanguageData.add_conversion_type"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_conversion_type">[docs]</a>    <span class="k">def</span> <span class="nf">add_conversion_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromType</span><span class="p">,</span> <span class="n">toType</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a type conversion taking fromType to toType.  Both types must be</span>
<span class="sd">        previously defined types or type aliases.&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">fromType</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">toType</span><span class="p">):</span> <span class="k">return</span>
        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">toType</span><span class="p">)</span>
        <span class="c"># Store the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conversionTypes</span><span class="p">[</span><span class="n">fromType</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">actualType</span><span class="p">)</span>  <span class="c"># own dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">fromType</span><span class="p">]</span><span class="o">.</span><span class="n">conversionTypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">actualType</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="LanguageData.add_type_alias"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_type_alias">[docs]</a>    <span class="k">def</span> <span class="nf">add_type_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeAlias</span><span class="p">,</span> <span class="n">typeNameOrAlias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add typeAlias as a new alias for typeNameOrAlias. Variable</span>
<span class="sd">        typeNameOrAlias must be a previously defined type or type alias, and</span>
<span class="sd">        typeAlias must be undefined in the namespace of type aliases or an</span>
<span class="sd">        exception will be raised.&quot;&quot;&quot;</span>

        <span class="c"># Note that addTypeAlias saves [alias, actualType] pairs in typeAliases dict.</span>
        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">typeAlias</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">typeNameOrAlias</span><span class="p">):</span> <span class="k">return</span>
        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">typeNameOrAlias</span><span class="p">)</span>
        <span class="c"># Store the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeAliases</span><span class="p">[</span><span class="n">typeAlias</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">typeNameOrAlias</span><span class="p">,</span> <span class="n">actualType</span><span class="p">]</span> <span class="c"># own dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">actualType</span><span class="p">]</span><span class="o">.</span><span class="n">typeAliases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">typeAlias</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="LanguageData.add_quant"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_quant">[docs]</a>    <span class="k">def</span> <span class="nf">add_quant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantName</span><span class="p">,</span> <span class="n">retType</span><span class="p">,</span> <span class="n">argType</span><span class="p">,</span> <span class="n">quantPrec</span><span class="p">,</span> <span class="n">restrictionType</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new quantifier symbol quantName, acting on arguments of type</span>
<span class="sd">        quantType (which will almost always be Bool, for a wff argument), of</span>
<span class="sd">        precedence level quantPrec, and restricted to hold over type</span>
<span class="sd">        restrictionType (as a restricted quantifier).  Note that quantifier</span>
<span class="sd">        expressions are essentially treated as prefix functions on one</span>
<span class="sd">        argument.&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">quantName</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">retType</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">argType</span><span class="p">):</span> <span class="k">return</span>
        <span class="n">precInt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_and_check_prec_val</span><span class="p">(</span><span class="n">quantPrec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">restrictionType</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">restrictionType</span><span class="p">):</span> <span class="k">return</span>
            <span class="n">actualRestType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">restrictionType</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">actualRestType</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualRetType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">retType</span><span class="p">)</span>
        <span class="n">actualArgType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">argType</span><span class="p">)</span>
        <span class="c"># Store the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quants</span><span class="p">[</span><span class="n">quantName</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">actualRetType</span><span class="p">,</span> <span class="n">actualArgType</span><span class="p">,</span> <span class="n">quantPrec</span><span class="p">,</span> <span class="n">actualRestType</span><span class="p">]</span> <span class="c"># own dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">retType</span><span class="p">]</span><span class="o">.</span><span class="n">quants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quantName</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="LanguageData.add_const"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_const">[docs]</a>    <span class="k">def</span> <span class="nf">add_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constName</span><span class="p">,</span> <span class="n">constType</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new constant constName of type constType.  The variable</span>
<span class="sd">        constType must be a previously defined type or type alias, and constName</span>
<span class="sd">        must be undefined in the namespace of constants.&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">constName</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">constType</span><span class="p">):</span> <span class="k">return</span>
        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">constType</span><span class="p">)</span>
        <span class="c"># Store the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consts</span><span class="p">[</span><span class="n">constName</span><span class="p">]</span> <span class="o">=</span> <span class="n">actualType</span> <span class="c"># own dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">actualType</span><span class="p">]</span><span class="o">.</span><span class="n">consts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constName</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="LanguageData.add_var"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_var">[docs]</a>    <span class="k">def</span> <span class="nf">add_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varName</span><span class="p">,</span> <span class="n">varType</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new variable varName of type varType.  The variable varType</span>
<span class="sd">        must be a previously defined type or type alias, and varName must be</span>
<span class="sd">        undefined in the namespace of variables.&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">constName</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">varType</span><span class="p">):</span> <span class="k">return</span>
        <span class="c"># Store the data.</span>
        <span class="n">actualType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">varType</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">varName</span><span class="p">]</span> <span class="o">=</span> <span class="n">actualType</span> <span class="c"># own dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">actualType</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">varName</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>

    <span class="c">#</span>
    <span class="c"># Note that the types dict stores fun names indexed by their return type, not args</span>
    <span class="c">#</span></div>
<div class="viewcode-block" id="LanguageData.add_stdfun"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_stdfun">[docs]</a>    <span class="k">def</span> <span class="nf">add_stdfun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funName</span><span class="p">,</span> <span class="n">retType</span><span class="p">,</span> <span class="n">argTypes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new standard function (taking arguments the usual way, e.g.,</span>
<span class="sd">        f(x)) with name funName returning type retType and taking arguments of</span>
<span class="sd">        the types in argTypes.  All types must be previously defined types or</span>
<span class="sd">        type aliases, and function signatures must be unique in the space of</span>
<span class="sd">        standard functions (according to the definition of overloading in force).</span>
<span class="sd">        Note that the number of arguments is len(argTypes).&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">retType</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">argTypes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span>

        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualRetType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">retType</span><span class="p">)</span>
        <span class="n">actualArgTypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type_list</span><span class="p">(</span><span class="n">argTypes</span><span class="p">)</span>

        <span class="c"># Check for already defined, taking overloading into account.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowStdFunOverloading</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">funName</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overloadStdFunsOnArgsOnly</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># dummy</span>
                <span class="c"># TODO: check that the function args do not match an existing one</span>
                <span class="c"># Maybe generate the full function sig strings according to</span>
                <span class="c"># overloading convention and store them, too.  Then can run a</span>
                <span class="c"># check on those similar to the usual check on defined vars, etc.....</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># dummy</span>
                <span class="c"># TODO: check that the fun sig with return doesn&#39;t match</span>
        <span class="c"># Store the data.</span>
        <span class="k">if</span> <span class="n">funName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdFuns</span><span class="p">:</span> <span class="c"># can&#39;t set equal, may be overloaded</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stdFuns</span><span class="p">[</span><span class="n">funName</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stdFuns</span><span class="p">[</span><span class="n">funName</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">actualRetType</span><span class="p">,</span> <span class="n">actualArgTypes</span><span class="p">])</span> <span class="c"># own dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">actualRetType</span><span class="p">]</span><span class="o">.</span><span class="n">stdFuns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">funName</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="LanguageData.add_prefixfun"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_prefixfun">[docs]</a>    <span class="k">def</span> <span class="nf">add_prefixfun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funName</span><span class="p">,</span> <span class="n">retType</span><span class="p">,</span> <span class="n">argTypes</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new prefix function with name funName returning type retType and</span>
<span class="sd">        taking arguments of the types in argTypes.  All types must be previously</span>
<span class="sd">        defined types or type aliases, and function signatures must be unique in</span>
<span class="sd">        the space of prefix functions (according to the definition of overloading</span>
<span class="sd">        in force).  Note that the number of arguments is len(argTypes).&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">retType</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">argTypes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span>
        <span class="n">precInt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_and_check_prec_val</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualRetType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">retType</span><span class="p">)</span>
        <span class="n">actualArgTypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type_list</span><span class="p">(</span><span class="n">argTypes</span><span class="p">)</span>
        <span class="c"># check for already defined, taking overloading into account</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowPrefixFunOverloading</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">funName</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overloadPrefixFunsOnArgsOnly</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># dummy</span>
                <span class="c"># TODO: check that the function args do not match an existing one</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># dummy</span>
                <span class="c"># TODO: check that the fun sig with return doesn&#39;t match</span>
        <span class="c"># Store the data.</span>
        <span class="k">if</span> <span class="n">funName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixFuns</span><span class="p">:</span> <span class="c"># can&#39;t set equal, may be overloaded</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefixFuns</span><span class="p">[</span><span class="n">funName</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefixFuns</span><span class="p">[</span><span class="n">funName</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">actualRetType</span><span class="p">,</span> <span class="n">actualArgTypes</span><span class="p">,</span> <span class="n">prec</span><span class="p">])</span> <span class="c"># own</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">actualRetType</span><span class="p">]</span><span class="o">.</span><span class="n">prefixFuns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">funName</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="LanguageData.add_infixfun"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.add_infixfun">[docs]</a>    <span class="k">def</span> <span class="nf">add_infixfun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funName</span><span class="p">,</span> <span class="n">retType</span><span class="p">,</span> <span class="n">argType1</span><span class="p">,</span> <span class="n">argType2</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">assoc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new infix function with name funName returning type retType and</span>
<span class="sd">        taking arguments argType1 and argType2.  All types must be previously</span>
<span class="sd">        defined types or type aliases, and function signatures must be unique in</span>
<span class="sd">        the space of infix functions (according to the definition of overloading</span>
<span class="sd">        in force).  Note that the number of arguments is len(argTypes).&quot;&quot;&quot;</span>

        <span class="c"># Check the arguments.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">retType</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">argType1</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">argType2</span><span class="p">):</span> <span class="k">return</span>
        <span class="n">precInt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_and_check_prec_val</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="c"># TODO: error check assoc</span>
        <span class="c"># Convert any aliases to actual types.</span>
        <span class="n">actualRetType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="n">retType</span><span class="p">)</span>
        <span class="n">actualArgType1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type_list</span><span class="p">(</span><span class="n">argType1</span><span class="p">)</span>
        <span class="n">actualArgType2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type_list</span><span class="p">(</span><span class="n">argType2</span><span class="p">)</span>
        <span class="c"># check for already defined, taking overloading into account</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowPrefixFunOverloading</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_already_defined_error</span><span class="p">(</span><span class="n">funName</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overloadInfixFunsOnArgsOnly</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c"># TODO: check that the function args do not match an existing one</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c"># TODO: check that the fun sig with return doesn&#39;t match</span>
        <span class="c"># Store the data.</span>
        <span class="k">if</span> <span class="n">funName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infixFuns</span><span class="p">:</span> <span class="c"># can&#39;t set equal, may be overloaded</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infixFuns</span><span class="p">[</span><span class="n">funName</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infixFuns</span><span class="p">[</span><span class="n">funName</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="n">actualRetType</span><span class="p">,</span> <span class="n">actualArgType1</span><span class="p">,</span> <span class="n">actualArgType2</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">assoc</span><span class="p">])</span> <span class="c"># own dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">actualRetType</span><span class="p">]</span><span class="o">.</span><span class="n">infixFuns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">funName</span><span class="p">)</span> <span class="c"># types dict</span>
        <span class="k">return</span>

    <span class="c">#</span>
    <span class="c"># Boolean-valued methods.</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_type"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_type">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_type_alias"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_type_alias">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_type_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined type alias.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeAliases</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_type_or_alias"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_type_or_alias">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_type_or_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined type or type alias.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type_alias</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_quant"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_quant">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_quant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined quantifier.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quants</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_const"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_const">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined constant.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">consts</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_var"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_var">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_stdfun"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_stdfun">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_stdfun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined standard function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stdFuns</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_prefixfun"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_prefixfun">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_prefixfun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined prefix function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefixFuns</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined_infix_fun"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined_infix_fun">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined_infix_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is a defined infix function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infixFuns</span>
</div>
<div class="viewcode-block" id="LanguageData.is_defined"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_defined">[docs]</a>    <span class="k">def</span> <span class="nf">is_defined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">langElem</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if name is defined as a language element langElem.&quot;&quot;&quot;</span>
        <span class="c"># if self.checkUndefinedLangElemError(langElem): return</span>
        <span class="k">if</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;typeAlias&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type_alias</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;quant&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_quant</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;const&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_const</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;var&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_var</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;stdFun&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_stdfun</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;prefixFun&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_prefixfun</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">langElem</span> <span class="o">==</span> <span class="s">&quot;infixFun&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_infix_fun</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LanguageData.is_valid_lang_elem"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.is_valid_lang_elem">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid_lang_elem</span><span class="p">(</span><span class="n">langElem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if langElem is a valid language element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">langElem</span> <span class="ow">in</span> <span class="n">langElems</span>

    <span class="c">#</span>
    <span class="c"># Methods which &quot;get&quot; or return various data.</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="LanguageData.get_actual_type"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.get_actual_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_actual_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typeAlias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the actual type of the type or type alias argument typeAlias.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="n">typeAlias</span><span class="p">):</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type</span><span class="p">(</span><span class="n">typeAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">typeAlias</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type_alias</span><span class="p">(</span><span class="n">typeAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeAliases</span><span class="p">[</span><span class="n">typeAlias</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="LanguageData.get_actual_type_list"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.get_actual_type_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_actual_type_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aliasList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of actual types of a list of types or type aliases.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">,</span> <span class="n">aliasList</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LanguageData.get_regex_trie_dict"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.get_regex_trie_dict">[docs]</a>    <span class="k">def</span> <span class="nf">get_regex_trie_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the RegexTrieDict holding the defined data.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">regexTrieDict</span>

    <span class="c">#</span>
    <span class="c"># Error-checking options.</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="LanguageData.set_error_checking_for_interactive"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.set_error_checking_for_interactive">[docs]</a>    <span class="k">def</span> <span class="nf">set_error_checking_for_interactive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Don&#39;t raise an exception for certain errors, just give a warning and</span>
<span class="sd">        ignore the bad input.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="LanguageData.set_error_checking_for_batch"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.set_error_checking_for_batch">[docs]</a>    <span class="k">def</span> <span class="nf">set_error_checking_for_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise an exception for all errors.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">[</span><span class="n">err</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span>

    <span class="c">#</span>
    <span class="c"># Simple argument-checking routines.</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="LanguageData.check_undefined_type_or_typealias_error"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.check_undefined_type_or_typealias_error">[docs]</a>    <span class="k">def</span> <span class="nf">check_undefined_type_or_typealias_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_or_typealias_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Error check whether type_or_typealias_name has been defined as a type or</span>
<span class="sd">        type alias.  Return True if it has not (and raise an UndefinedError if</span>
<span class="sd">        that flag is set).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type_or_alias</span><span class="p">(</span><span class="n">type_or_typealias_name</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&quot;The type or alias &quot;</span> <span class="o">+</span> <span class="n">type_or_typealias_name</span> <span class="o">+</span> <span class="s">&quot; has not been defined.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;UndefinedError&quot;</span><span class="p">]:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;UndefinedError&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">UndefinedError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="LanguageData.check_undefined_type_error"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.check_undefined_type_error">[docs]</a>    <span class="k">def</span> <span class="nf">check_undefined_type_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Error check whether type_name has been defined as a type.  Return True</span>
<span class="sd">        if it has not (and raise an UndefinedError if that flag is set).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type</span><span class="p">(</span><span class="n">type_name</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&quot;The type &quot;</span> <span class="o">+</span> <span class="n">type_name</span> <span class="o">+</span> <span class="s">&quot; has not been defined.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;UndefinedError&quot;</span><span class="p">]:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;UndefinedError&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">UndefinedError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="LanguageData.check_undefined_typealias_error"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.check_undefined_typealias_error">[docs]</a>    <span class="k">def</span> <span class="nf">check_undefined_typealias_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typealias_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Error check whether typealias_name has been defined as a type alias.</span>
<span class="sd">        Return True if it has not (and raise an UndefinedError if that flag is</span>
<span class="sd">        set).&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined_type_alias</span><span class="p">(</span><span class="n">typealias_name</span><span class="p">):</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&quot;The type alias &quot;</span><span class="o">+</span><span class="n">typealias_name</span><span class="o">+</span><span class="s">&quot; has not been defined.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;UndefinedError&quot;</span><span class="p">]:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;UndefinedError&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">UndefinedError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="LanguageData.check_already_defined_error"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageData.check_already_defined_error">[docs]</a>    <span class="k">def</span> <span class="nf">check_already_defined_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Error check whether name has already been defined for any language</span>
<span class="sd">        element.  Return true if it has (and raise an AlreadyDefinedError if that</span>
<span class="sd">        flag is set).&quot;&quot;&quot;</span>

        <span class="n">error</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">langElems</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="n">error</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">errElem</span> <span class="o">=</span> <span class="n">elem</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&quot;The name &quot;</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">&quot; has already been defined as a &quot;</span><span class="o">+</span><span class="n">errElem</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;AlreadyDefinedError&quot;</span><span class="p">]:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;AlreadyDefinedError&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">AlreadyDefinedError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="k">def</span> <span class="nf">_convert_and_check_prec_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an int value for prec, checking and converting strings if</span>
<span class="sd">        possible.  Note that the range is not currently checked (this is</span>
<span class="sd">        language-design information, which this module does not have access to</span>
<span class="sd">        and assumes is correct).&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">precInt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s">&quot;The precedence value is not an int and cannot be converted.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printWarningOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;BadDataValueError&quot;</span><span class="p">]:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">raiseExceptionOnLanguageDataError</span><span class="p">[</span><span class="s">&quot;BadDataValueError&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">BadDataValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">precInt</span>


<span class="c">#</span>
<span class="c"># The Exception classes.  There could be more of these, but it is kept simple.</span>
<span class="c">#</span>

</div>
<div class="viewcode-block" id="LanguageDataError"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.LanguageDataError">[docs]</a><span class="k">class</span> <span class="nc">LanguageDataError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="UndefinedError"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.UndefinedError">[docs]</a><span class="k">class</span> <span class="nc">UndefinedError</span><span class="p">(</span><span class="n">LanguageDataError</span><span class="p">):</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="AlreadyDefinedError"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.AlreadyDefinedError">[docs]</a><span class="k">class</span> <span class="nc">AlreadyDefinedError</span><span class="p">(</span><span class="n">LanguageDataError</span><span class="p">):</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="BadDataValueError"><a class="viewcode-back" href="../../wff_language.language_data.html#wff_language.language_data.BadDataValueError">[docs]</a><span class="k">class</span> <span class="nc">BadDataValueError</span><span class="p">(</span><span class="n">LanguageDataError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c">#</span>
<span class="c"># Some test cases below.</span>
<span class="c">#</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="k">print</span><span class="p">()</span>
    <span class="k">print</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;testing LanguageData class&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">LanguageData</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">set_error_checking_for_interactive</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s">&quot;Bool&quot;</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">add_type</span><span class="p">(</span><span class="s">&quot;DomElem&quot;</span><span class="p">)</span>
    <span class="c"># data.add_type(&quot;DomElem&quot;) # should give error</span>
    <span class="n">data</span><span class="o">.</span><span class="n">add_type_alias</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="s">&quot;DomElem&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;The actual type for D is (should be DomElem):&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">get_actual_type</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">add_infixfun</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">)</span> <span class="c"># what order for funcall?</span>
    <span class="n">data</span><span class="o">.</span><span class="n">add_infixfun</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="s">&quot;D&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">)</span> <span class="c"># what order for funcall?</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>