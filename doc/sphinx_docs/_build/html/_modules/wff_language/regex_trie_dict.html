<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>wff_language.regex_trie_dict &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for wff_language.regex_trie_dict</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Pattern Matching in RegexTrieDict</span>
<span class="sd">---------------------------------</span>

<span class="sd">The RegexTrieDict also simple built-in pattern-matching capabilities.  To use</span>
<span class="sd">these capabilities, you first create a key which contains some special</span>
<span class="sd">meta-elements (see below).  Then you insert that key (meta-key) and an</span>
<span class="sd">associated value into the TrieDict.  These meta-keys are still treated simply</span>
<span class="sd">as ordinary keys by the usual TrieDict operations.  But the TrieDict also has</span>
<span class="sd">the special methods has_key_meta, get_meta which interpret the meta-elements.</span>

<span class="sd">Calling has_key_meta for a key (an ordinary, non-meta key) returns True if any</span>
<span class="sd">current key matches or if any meta-key pattern happens to match as a pattern.</span>
<span class="sd">Similarly, get_meta finds any key or meta-key pattern which matches and returns</span>
<span class="sd">a tuple of all the data associated with matching items (i.e., associated with</span>
<span class="sd">the ordinary key or with the pattern meta-key it matches).</span>

<span class="sd">The special meta-symbols are user-defined.  By default the values are defined</span>
<span class="sd">for keys which are strings of characters.  The default definitions are:</span>

<span class="sd">&lt;TODO update below, some changed&gt;</span>

<span class="sd">   define_meta_elems(escape=&quot;\\&quot;, repetition=&quot;*&quot;, lGroup=&quot;(&quot;, rGroup=&quot;)&quot;,</span>
<span class="sd">                     lWildcard=&quot;[&quot;, rWildcard=&quot;]&quot;, range=&quot;-&quot;, rangeTestFun=None)</span>

<span class="sd">In order for an element of a key to be interpreted as a meta-symbol it must be</span>
<span class="sd">preceded by the defined escape element.  So in a string key the meta-symbols</span>
<span class="sd">with their default definitions above would always appear as &quot;\\*&quot;, &quot;\\(&quot;, &quot;\\)&quot;,</span>
<span class="sd">&quot;\\[&quot;, &quot;\\]&quot;, and &quot;\\-&quot;.  This is intended to minimize interference with ordinary</span>
<span class="sd">key elements.  All specially-interpreted characters must be escaped, without</span>
<span class="sd">exception.  As usual a double escape such as &quot;\\\\&quot; (or r&quot;\\&quot;) reverts to the</span>
<span class="sd">original symbol, as does an escape not followed by one of the defined</span>
<span class="sd">meta-elements.</span>

<span class="sd">Keep in mind that if a TrieDict is to be used with escaped elements as</span>
<span class="sd">meta-elements then all the literal escape-elements in it must be escaped.  Even</span>
<span class="sd">the non-pattern keys which are inserted into the TrieDict in that case must</span>
<span class="sd">have any escape elements escaped (they are still patterns, just simple ones).</span>
<span class="sd">In the queries sequences themselves, however, escape elements are always simply</span>
<span class="sd">treated as literals (i.e., no meta-interpretation is ever performed on the</span>
<span class="sd">query-key sequences).  So a single escape on a key-query matches an escaped</span>
<span class="sd">escape in the stored key-sequences in the Trie.</span>

<span class="sd">The meta-level and the object-level are intentionally kept distinct in order to</span>
<span class="sd">minimize some of the confusions that can occur (even though there always are</span>
<span class="sd">some).  The ordinary dict methods always operate on trie keys as if they were</span>
<span class="sd">literals.  To get an extra level of interpretation, the special meta-level</span>
<span class="sd">methods must be used.  These operations, however, can be freely mixed.  Patterns</span>
<span class="sd">can be inserted and deleted, etc.</span>

<span class="sd">Pattern scanning is left-to-right in a key&#39;s elements (i.e., with string keys</span>
<span class="sd">the characters are scanned from left to right).</span>

<span class="sd">The language allows single-character wildcards.  As an example with strings,</span>
<span class="sd">consider using these patterns as keys:</span>

<span class="sd">   patt1 = &quot;abc\\[123\\]def&quot;</span>
<span class="sd">   patt2 = &quot;abc\\[1\\-3\\]def&quot;</span>

<span class="sd">The first pattern, patt1, matches abc1def, abd2def, and abc3def.  The second</span>
<span class="sd">pattern, patt2, matches the same strings but uses a range specifier.</span>

<span class="sd">&lt;TODO note we now let them define the whole wildcard-processing...&gt;</span>
<span class="sd">The</span>
<span class="sd">boolean-valued function rangeTestFun will be called for the first and last</span>
<span class="sd">argument of the range, along with the element to test.  The default</span>
<span class="sd">range-function (when the values is set to None in the call to defineMetaElems)</span>
<span class="sd">only works for character ranges.</span>

<span class="sd">&lt;TODO note that Python patterns are allowed, and test some.&gt;</span>
<span class="sd">&lt;TODO note that user can essentially redefine the processing of the part inside</span>
<span class="sd">the brackets in any way desired.&gt;</span>

<span class="sd">Repetition patterns match zero or more occurrences of the pattern group.  Here</span>
<span class="sd">is an example with strings as keys:</span>

<span class="sd">   patt1 = &quot;abc\\*\\(DD\\)efg&quot;</span>

<span class="sd">This would match &quot;abcefg&quot;, &quot;abcDDefg&quot;, abcDDDDefg&quot;, etc.  The repetition</span>
<span class="sd">pattern can also take optional numeric arguments, each separated by another</span>
<span class="sd">asterick.  A single numeric argument, like in</span>

<span class="sd">   patt = &quot;abc\\*10\\(DD\\)efg</span>

<span class="sd">specifies a minimum number of repetitions.  The previous example must have</span>
<span class="sd">ten or more occurrences of &quot;dd&quot; in it.  So &quot;abcDDefg&quot; would not match,</span>
<span class="sd">but &quot;abcDDDDDDDDDDDDDDDDDDDDefg&quot; would match.  When two numbers are given</span>
<span class="sd">they represent the minimum and the maximum number of repetitions, respectively.</span>
<span class="sd">So the pattern</span>

<span class="sd">   patt = &quot;abc\\*2\\*3\\(DD\\)efg&quot;</span>

<span class="sd">would not match &quot;abcDDefg&quot;, would match &quot;abcDDDDefg&quot; and &quot;abcDDDDDDefg&quot;, and</span>
<span class="sd">would not match abcDDDDDDDDefg&quot;.</span>

<span class="sd">TODO below para not implemented</span>
<span class="sd">The grouping meta-elements must occur just after the start and at the end of</span>
<span class="sd">the repetition pattern itself.  For efficiency, repetition can be limited such</span>
<span class="sd">that it always &quot;breaks out&quot; of the &quot;loop&quot; at the first chance it gets.   This</span>
<span class="sd">occurs when, at the end of a loop, the next element scanned matches the next</span>
<span class="sd">pattern element after the closing repetition meta-element.  So the shortest</span>
<span class="sd">valid repetition sequence followed by some other valid element is always</span>
<span class="sd">chosen.  This restriction essentially requires the end of any repeated-pattern</span>
<span class="sd">segment to be unambiguous (or else no looping-back will occur).</span>

<span class="sd">Pattern-matching Implementation Details</span>
<span class="sd">---------------------------------------</span>

<span class="sd">As noted, meta-keys are inserted and stored in a TrieDict simply as ordinary</span>
<span class="sd">keys.  It is the traversal algorithm in the routine get_nodes_meta which differs</span>
<span class="sd">from the usual get_node algorithm (which finds the node in the trie</span>
<span class="sd">corresponding to a key).  Note first off that the get_nodes_meta routine can</span>
<span class="sd">returns a list of nodes, not just a single node.  This is because multiple</span>
<span class="sd">patterns can match the same query-key.</span>

<span class="sd">The traversal algorithm is the same as usual except when meta-characters are</span>
<span class="sd">encountered.  In this case the state can split into a list of states (similar</span>
<span class="sd">to a nondeterministic automata).  That is, instead of just keeping one</span>
<span class="sd">current-node, we keep a list of them and update each one for each input</span>
<span class="sd">query-key element.  If any current node in the list matches then the key</span>
<span class="sd">matches.  If the set becomes empty without a match then the pattern fails to</span>
<span class="sd">match.</span>

<span class="sd">In the case of a wildcard pattern, suppose the child list of a current node</span>
<span class="sd">includes a begin-wildcard element, i.e., a wildcard is one possible</span>
<span class="sd">continuation.  Keep in mind that there may be multiple different wildcard</span>
<span class="sd">patterns stored in the subtree of the begin-wildcard element.  Now suppose the</span>
<span class="sd">next element of the query-key comes in, and we want to move down the trie.  The</span>
<span class="sd">state splits.  One new state is just the usual child-node from any literal</span>
<span class="sd">continuation which is stored in the tree (as in the non-meta version).  But</span>
<span class="sd">also, the algorithm fast-forwards from the current-node&#39;s begin-wildcard child</span>
<span class="sd">node to the first end-wildcard node in each branch of the subtree beneath it.</span>
<span class="sd">Along the way, it is noted whether the current query-key element matches the</span>
<span class="sd">wildcard.  For each end-wildcard node which matched the query-key element, the</span>
<span class="sd">end-wildcard node is added to the current-node list (and is also checked to see</span>
<span class="sd">if it is an end-node of some pattern).</span>

<span class="sd">In the case of a repetition pattern, suppose the child list of a current node</span>
<span class="sd">includes a begin-repetition element.  In this case the state splits (as before</span>
<span class="sd">with wildcards), with the usual literal-character child node becoming one new</span>
<span class="sd">state.  But also, the algorithm fast forwards to the corresponding</span>
<span class="sd">end-repetition element of each subtree and makes that a new state (we start at</span>
<span class="sd">the end to get zero repetitions).  They also remember their begin-repetition</span>
<span class="sd">point.  On the next query-key element both states continue, one skipping and</span>
<span class="sd">one looping back.</span>

<span class="sd">To handle uniqueness issues (if we want each distinct pattern to be represented</span>
<span class="sd">by the same pattern-string, with the same associated value) the meta-key</span>
<span class="sd">patterns can be preprocessed before they are entered into the TrieDict, to</span>
<span class="sd">canonicalize them.  For character wildcards, at least, the characters can be</span>
<span class="sd">sorted and all continuous sequences can be turned into character ranges.</span>

<span class="sd">Note that we can freely add and remove keys from the tree in the usual way,</span>
<span class="sd">since they are stored just as if they were ordinary strings.</span>

<span class="sd">The pattern-matching algorithm is currently not optimized at all.  For example,</span>
<span class="sd">each time a repetition-loop is encountered it re-processes the entire thing,</span>
<span class="sd">searching forward for the end-group element.  This data could instead be cached</span>
<span class="sd">(such as by having a dict map begin-repetition nodes to the cached data, valid</span>
<span class="sd">until an insertion or deletion invalidates, or the space needs to be freed).</span>
<span class="sd">Overriding the children on repetition loops can use up a lot of space for long</span>
<span class="sd">repetition patterns.  It is hard to avoid going to the end in the</span>
<span class="sd">zero-repetition match form, since the end is a valid continuation At-least-one</span>
<span class="sd">repetition patterns could potentially process from the beginning.  Overriding</span>
<span class="sd">the insert (__setitem__) method to keep pointers to the loop-ends and</span>
<span class="sd">or-sections would speed things up.  A common dict indexed by node ids could be</span>
<span class="sd">used, but deletion would have to del the deleted-node entries.  Then we could</span>
<span class="sd">start zero-repetition states but just set the stacks for the first loop, fixing</span>
<span class="sd">the children in appendChildNode if the stack is not empty.</span>

<span class="sd">How should the next version be implemented?  Based on current understanding</span>
<span class="sd">from this implementation, the insert method for RegexTrieDict should be</span>
<span class="sd">modified to create a virtual trie.  (The delete method also needs to be</span>
<span class="sd">modified to fix the virtual trie on deletes.)  This can be hashed on the ids of</span>
<span class="sd">nodes, for example, to avoid pasting things onto the actual nodes which must</span>
<span class="sd">later be deleted.  The virtual trie can be created by overloading the child</span>
<span class="sd">function for nodes.  Like for states currently, but it can be global and saved.</span>
<span class="sd">The virtual trie should add virtual nodes for close-repetition and open-group</span>
<span class="sd">nodes for &#39;or&#39;s.  This allows the processing for repetitions to keep track of</span>
<span class="sd">the loop stacks, and the processing for &#39;or&#39; sections to keep track of which</span>
<span class="sd">paths were originally together in a common pattern, but otherwise the</span>
<span class="sd">repetitions should just virtually both loop back and break out, and the &#39;or&#39;</span>
<span class="sd">patterns should be flattened down to an &#39;or&#39; for each section starting at the</span>
<span class="sd">initial open-group and then converging back to a common close-group node (but</span>
<span class="sd">note the importance of keeping track of which ones were initially in the same</span>
<span class="sd">pattern to avoid crosstalk amongst the patterns).</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">collections</span> <span class="c"># to use deque and MutableSequence abstract base class</span>
<span class="kn">from</span> <span class="nn">trie_dict</span> <span class="kn">import</span> <span class="n">TrieDict</span><span class="p">,</span> <span class="n">TrieDictNode</span>

<div class="viewcode-block" id="NodeStateData"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateData">[docs]</a><span class="k">class</span> <span class="nc">NodeStateData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;This class is used in pattern-searches.  It is just a fancy data-record,</span>
<span class="sd">    essentially a named tuple.  It holds one state of a multi-state recognizer.</span>
<span class="sd">    The state consists of a node in the trie as well as some extra information</span>
<span class="sd">    for keeping track of loops.  These states locally (for the particular state</span>
<span class="sd">    and search) redefine the children for each node they have visited and</span>
<span class="sd">    followed a child link from.  That particular child is made into the only</span>
<span class="sd">    child.</span>

<span class="sd">    Each branch in the trie represents a different pattern, connected by &quot;or&quot;.</span>
<span class="sd">    The pattern-prefix for a node is always the same; a pattern with a different</span>
<span class="sd">    prefix would end at a different node.  When a choice of moving down the trie</span>
<span class="sd">    is made the prefix is further restricted.  So NodeStateData stores a dict</span>
<span class="sd">    for looking up the children of any visited state, and they are all</span>
<span class="sd">    restricted to the single path that they took previously.  This way, looping</span>
<span class="sd">    backward in a repetition always gives the same pattern prefix.  (States are</span>
<span class="sd">    also split into two or more states, as necessary, and run in parallel</span>
<span class="sd">    essentially as an NFA.)  Patterns within &#39;or&#39; groups inside a repetition</span>
<span class="sd">    need to be treated similarly, since they may match a different section on</span>
<span class="sd">    each repetition.</span>

<span class="sd">    The node attribute holds a node in the trie.  The boolean nodeIsEscape is</span>
<span class="sd">    true for nodes representing the escape element self.escape.  The stacks are</span>
<span class="sd">    used to keep track of looping in repetition patterns.  The</span>
<span class="sd">    boundNodeChildDict is used to overload the children of the node, so that the</span>
<span class="sd">    same path down the trie is always followed in a repetition loop.  The</span>
<span class="sd">    visitedRepNodeIdSet set is a set of the ids all the loopback repetition nodes</span>
<span class="sd">    visited, but it is reset each time a literal element is matches the query</span>
<span class="sd">    element (i.e., on a literal or a wildcard match).  This is used to avoid</span>
<span class="sd">    infinite recursion in processing repetition patterns which match zero</span>
<span class="sd">    elements.</span>

<span class="sd">    A NodeStateData is initialized by passing all the stored items to the</span>
<span class="sd">    initializer, just like initializing a tuple.  Alternately, you can use</span>
<span class="sd">    keyword arguments or just assign values to the fields.&quot;&quot;&quot;</span>

    <span class="c"># Note that we do not inherit from collections.Sequence because then</span>
    <span class="c"># arbitrary attribute assignments are the allowed.  This misses spelling</span>
    <span class="c"># errors and presumably defeats the purpose of __slots__ by having a dict</span>
    <span class="c"># per instance.  Note that the implemented methods are sufficient to loop</span>
    <span class="c"># over NodeStateData objects in for-loops, convert to a tuple or list, etc.</span>
    <span class="c"># If slots are causing problems, like with pickling, you can just globally</span>
    <span class="c"># substitute some other variable name, like _slots, for __slots__ and</span>
    <span class="c"># things should still work (but more space will be used in the trie).</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;node&quot;</span><span class="p">,</span> <span class="s">&quot;nodeIsEscape&quot;</span><span class="p">,</span> <span class="s">&quot;loopbackStack&quot;</span><span class="p">,</span> <span class="s">&quot;loopCounterStack&quot;</span><span class="p">,</span>
                 <span class="s">&quot;loopBoundsStack&quot;</span><span class="p">,</span> <span class="s">&quot;boundNodeChildDict&quot;</span><span class="p">,</span> <span class="s">&quot;visitedRepNodeIdSet&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">valList</span><span class="p">,</span> <span class="o">**</span><span class="n">kwVals</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setVals</span><span class="p">(</span><span class="o">*</span><span class="n">valList</span><span class="p">,</span> <span class="o">**</span><span class="n">kwVals</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="NodeStateData.setVals"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateData.setVals">[docs]</a>    <span class="k">def</span> <span class="nf">setVals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">valList</span><span class="p">,</span> <span class="o">**</span><span class="n">kwVals</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">valList</span><span class="p">:</span> <span class="c"># either list or kwargs, not both</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valList</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__slots__</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">valList</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwVals</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kwVals</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">return</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__slots__</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__slots__</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__slots__</span><span class="p">)</span>

<div class="viewcode-block" id="NodeStateData.copy"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateData.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the state (not a deep copy).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NodeStateData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeIsEscape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loopbackStack</span><span class="p">[:],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">loopCounterStack</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">loopBoundsStack</span><span class="p">[:],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">boundNodeChildDict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">visitedRepNodeIdSet</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="NodeStateData.setChild"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateData.setChild">[docs]</a>    <span class="k">def</span> <span class="nf">setChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childElem</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign the node (default to self.node) to have single child childElem.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span>
        <span class="n">nodeId</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundNodeChildDict</span><span class="p">[</span><span class="n">nodeId</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">childElem</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">childElem</span><span class="p">]}</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="NodeStateData.children"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateData.children">[docs]</a>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;During patern matches the children of a node are temporarily modified,</span>
<span class="sd">        so that ordinary characters in a repetition loop are bound until the</span>
<span class="sd">        loop exits.  To do this, the pattern-match routines use the NodeStateData</span>
<span class="sd">        children method, rather than the node&#39;s children method.  If node is</span>
<span class="sd">        set then that node&#39;s children dict is returned; default is self.node.&quot;&quot;&quot;</span>
        <span class="c"># If the trie is not modified, the ids of nodes will not change.  If it</span>
        <span class="c"># is modified then any search-in-progress becomes invalid anyway.</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span>
        <span class="n">nodeId</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodeId</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundNodeChildDict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundNodeChildDict</span><span class="p">[</span><span class="n">nodeId</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span>

</div></div>
<div class="viewcode-block" id="NodeStateDataList"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateDataList">[docs]</a><span class="k">class</span> <span class="nc">NodeStateDataList</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;This is essentially just a list, used to hold a collection of</span>
<span class="sd">    NodeStateData objects representing the full (nondeterministic) state.  A</span>
<span class="sd">    derived class is used so that additional information can be saved.  The</span>
<span class="sd">    initialization arguments, if any, are the same as for a list.  In</span>
<span class="sd">    particular, this class allows for checking whether or not the state-data is</span>
<span class="sd">    still valid in the underlying trie (there might have been insertions and/or</span>
<span class="sd">    deletions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regexTrieDict</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c"># The list nodeDataList does the real work.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insertCount</span> <span class="o">=</span> <span class="n">regexTrieDict</span><span class="o">.</span><span class="n">insertCount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleteCount</span> <span class="o">=</span> <span class="n">regexTrieDict</span><span class="o">.</span><span class="n">deleteCount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regexTrieDictInstanceId</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">regexTrieDict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regexTrieDict</span> <span class="o">=</span> <span class="n">regexTrieDict</span>
        <span class="k">return</span>

<div class="viewcode-block" id="NodeStateDataList.isValidIn"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateDataList.isValidIn">[docs]</a>    <span class="k">def</span> <span class="nf">isValidIn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regexTrieDict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether or not the state-data stored in a node data list is still</span>
<span class="sd">        valid in the current trie.  If any insertions or deletions have occurred</span>
<span class="sd">        since its creation this routine returns False, otherwise True.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regexTrieDictInstanceId</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">regexTrieDict</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">regexTrieDict</span><span class="o">.</span><span class="n">insertCount</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">insertCount</span> <span class="ow">and</span>
                <span class="n">regexTrieDict</span><span class="o">.</span><span class="n">deleteCount</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">deleteCount</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">)</span>

<div class="viewcode-block" id="NodeStateDataList.insert"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateDataList.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeStateDataList.append"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateDataList.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="NodeStateDataList.appendChildNode"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.NodeStateDataList.appendChildNode">[docs]</a>    <span class="k">def</span> <span class="nf">appendChildNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeData</span><span class="p">,</span> <span class="n">nodeIsEscape</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A utility routine that appends a NodeStateData object for a child of</span>
<span class="sd">        the node in the one passed in.  The child is the one corresponding to the</span>
<span class="sd">        key queryElem.  All other data is kept the same.  Return True if anything</span>
<span class="sd">        actually added.  If the nodeIsEscape argument is not None then the</span>
<span class="sd">        nodeIsEscape value of the nodeDataState is set to that value.  Note that</span>
<span class="sd">        if a NodeStateData instance is added outside of this loop (such as in</span>
<span class="sd">        processing wildcards) that routine must take care of any necessary</span>
<span class="sd">        setChild calls for binding in repetition loops.&quot;&quot;&quot;</span>
        <span class="c"># TODO add a copy=True flag to turn off when not needed, after debug</span>

        <span class="n">childrenDict</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">queryElem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">childrenDict</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

        <span class="n">nodeDataCopy</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># make a copy</span>

        <span class="c"># Fix the overridden children dict of states inside repetition loops</span>
        <span class="c"># to the single child path which is actually traveled down (so later</span>
        <span class="c"># repetitions are for the same pattern in the trie).  Only needed on</span>
        <span class="c"># the first time through, and not for outer-level loops with max of</span>
        <span class="c"># one repetition (which is how &#39;or&#39; groups are treated).  The latter</span>
        <span class="c"># optimization is not currently implemented.  (It doesn&#39;t hurt</span>
        <span class="c"># correctness to always run setChild, but a lot of unnecessary state</span>
        <span class="c"># data is then saved and copied.)</span>
        <span class="k">if</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="p">:</span>  <span class="c"># debug below test, put back later</span>
            <span class="c">#if nodeData.loopCounterStack[-1] == 1 and len(childrenDict) &gt; 1:</span>
            <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span><span class="n">queryElem</span><span class="p">)</span> <span class="c"># fix to one child</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">boundNodeChildDict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># can&#39;t loop back, free the memory</span>
        <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">childrenDict</span><span class="p">[</span><span class="n">queryElem</span><span class="p">]</span>

        <span class="c"># Set nodeIsEscape if that arg is given.</span>
        <span class="k">if</span> <span class="n">nodeIsEscape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">nodeIsEscape</span> <span class="o">=</span> <span class="n">nodeIsEscape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeDataCopy</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>

</div></div>
<div class="viewcode-block" id="MagicElem"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.MagicElem">[docs]</a><span class="k">class</span> <span class="nc">MagicElem</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A special element considered unique (checked by id) and used to</span>
<span class="sd">    represent a null element that doesn&#39;t match anything.  Type doesn&#39;t matter</span>
<span class="sd">    (since no real comparisons are needed).  Not the same as a null string.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s">&quot;(magicElem)&quot;</span>


<span class="c"># TODO maybe add a non-greedy flag which will work on prexix-matches</span>
<span class="c"># and return the first matches only.  Maybe.  Still might be nice to</span>
<span class="c"># have a break-as-soon-as-possible flag, though if the syntax is</span>
<span class="c"># unambiguous the other way won&#39;t branch, anyway.</span>

<span class="c"># TODO add a reset method to the both triedicts (or whatever python dict</span>
<span class="c"># uses for same, if any)</span>
</div>
<div class="viewcode-block" id="RegexTrieDict"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict">[docs]</a><span class="k">class</span> <span class="nc">RegexTrieDict</span><span class="p">(</span><span class="n">TrieDict</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Subclass of the TrieDict class which adds regex processing for patterns</span>
<span class="sd">    stored in the trie.&quot;&quot;&quot;</span>

    <span class="n">magicElem</span> <span class="o">=</span> <span class="n">MagicElem</span> <span class="c"># A static element that is considered unique (by its id).</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RegexTrieDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insertCount</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Used to test if inserts were done.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleteCount</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># Used to test if deletes were done.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Used in sequential meta mode to persist states.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_meta_elems</span><span class="p">()</span> <span class="c"># Set the meta-elems to their default definitions.</span>

<div class="viewcode-block" id="RegexTrieDict.testPatternSequence"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.testPatternSequence">[docs]</a>    <span class="k">def</span> <span class="nf">testPatternSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keySeq</span><span class="p">,</span> <span class="n">raiseErrors</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs some basic tests on pattern sequences.  This routine is always</span>
<span class="sd">        called by the insert method, with raiseErrors=True.  Users can use it to</span>
<span class="sd">        test patterns before inserting them.  By default the routine will just</span>
<span class="sd">        return a boolean value specifying whether the string passes or not.  If</span>
<span class="sd">        raiseErrors=True then the escape-processed version of keySeq is returned</span>
<span class="sd">        (assuming no errors are raised).  Note that simply passing the tests is</span>
<span class="sd">        no guarantee that the pattern is correct, just that it passes these</span>
<span class="sd">        tests.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">foundError</span><span class="p">(</span><span class="n">errorString</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="n">PatternMatchError</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Utility function to raise errors or return bool as appropriate.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">raiseErrors</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="n">exception</span><span class="p">(</span><span class="n">errorString</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">getStringForKeySeq</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Try to get a string representation for keySeq for more-helpful</span>
<span class="sd">            error messages.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">errPatt</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">   &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">keySeq</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span> <span class="n">errPatt</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
            <span class="k">return</span> <span class="n">errPatt</span>

        <span class="k">def</span> <span class="nf">testMatchedOpenClose</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">,</span> <span class="n">closeElem</span><span class="p">,</span> <span class="n">noNest</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Simple test for mismatched open and close group parens.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">escapedKeyElemList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="n">escapedKeyElemList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">closeElem</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">noNest</span> <span class="ow">and</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">escapedKeyElemList</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">def</span> <span class="nf">testNoEmptyOpenClose</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Simple test for open-group paren followed immediately by close-group.</span>
<span class="sd">            Any parLevel in escapedKeyElemList must have at least three elements.&quot;&quot;&quot;</span>
            <span class="n">lastParLevel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">isEscaped</span><span class="p">,</span> <span class="n">parLevel</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">parLevel</span> <span class="o">&gt;</span> <span class="n">lastParLevel</span><span class="p">:</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">parLevel</span> <span class="o">==</span> <span class="n">lastParLevel</span><span class="p">:</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">parLevel</span> <span class="o">&lt;</span> <span class="n">lastParLevel</span>
                   <span class="ow">or</span> <span class="p">(</span><span class="n">parLevel</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="n">lastParLevel</span> <span class="o">=</span> <span class="n">parLevel</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c">#</span>
        <span class="c"># Begin the main body of the method.</span>
        <span class="c">#</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keySeq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">foundError</span><span class="p">(</span><span class="s">&quot;The empty element is not a valid key.&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="o">=</span><span class="ne">KeyError</span><span class="p">)</span>

        <span class="c"># Process the escapes counting open and close wildcard brackets.</span>
        <span class="n">escapedKeyElemList</span> <span class="o">=</span> <span class="n">processElemListForEscapes</span><span class="p">(</span><span class="n">keySeq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span>
                                 <span class="n">openGroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lWildcard</span><span class="p">,</span> <span class="n">closeGroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rWildcard</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">testMatchedOpenClose</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rWildcard</span><span class="p">,</span> <span class="n">noNest</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">foundError</span><span class="p">(</span><span class="s">&quot;Mismatched open and close wildcard brackets in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">getStringForKeySeq</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">testNoEmptyOpenClose</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">):</span>
            <span class="n">foundError</span><span class="p">(</span><span class="s">&quot;Empty open and close wildcard brackets in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">getStringForKeySeq</span><span class="p">())</span>

        <span class="c"># Process the escapes counting open and close group parens.</span>
        <span class="n">escapedKeyElemList</span> <span class="o">=</span> <span class="n">processElemListForEscapes</span><span class="p">(</span><span class="n">keySeq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span>
                                 <span class="n">openGroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">,</span> <span class="n">closeGroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">testMatchedOpenClose</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">):</span>
            <span class="n">foundError</span><span class="p">(</span><span class="s">&quot;Mismatched open and close group elements in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">getStringForKeySeq</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">testNoEmptyOpenClose</span><span class="p">(</span><span class="n">escapedKeyElemList</span><span class="p">):</span>
            <span class="n">foundError</span><span class="p">(</span><span class="s">&quot;Empty open and close group elements in pattern.&quot;</span>
                       <span class="o">+</span> <span class="n">getStringForKeySeq</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">raiseErrors</span><span class="p">:</span> <span class="k">return</span> <span class="n">escapedKeyElemList</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="RegexTrieDict.insert"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keySeq</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the data item in the dict with the key keySeq.  Any existing</span>
<span class="sd">        data at that key is overwritten.  This method is aliased to __setitem__.</span>
<span class="sd">        It overrides the superclass definition and adds some syntax checking on</span>
<span class="sd">        the input patterns.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonicalizeFun</span><span class="p">:</span> <span class="n">keySeq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonicalizeFun</span><span class="p">(</span><span class="n">keySeq</span><span class="p">)</span>

        <span class="n">escapedKeyElemList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">testPatternSequence</span><span class="p">(</span><span class="n">keySeq</span><span class="p">,</span> <span class="n">raiseErrors</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span><span class="p">,</span> <span class="n">_parenCount</span> <span class="ow">in</span> <span class="n">escapedKeyElemList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieDictNode</span><span class="p">()</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieDictNode</span><span class="p">()</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">isLastElemOfKey</span><span class="p">:</span> <span class="c"># Don&#39;t increment if just resetting data.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numKeys</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insertCount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">node</span><span class="o">.</span><span class="n">isLastElemOfKey</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># End of keySeq, isLastElemOfKey is True.</span>
        <span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="RegexTrieDict.delitem"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.delitem">[docs]</a>    <span class="k">def</span> <span class="nf">delitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the stored key and its data.  Raises KeyError if the key wasn&#39;t</span>
<span class="sd">        found in the trie.  If d is a dict, the syntax del d[key] also invokes</span>
<span class="sd">        this function.  This overrides the delete method of the base class to</span>
<span class="sd">        update a deletion counter to test pattern-match state validity.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleteCount</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">TrieDict</span><span class="o">.</span><span class="n">delitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="RegexTrieDict.define_meta_elems"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.define_meta_elems">[docs]</a>    <span class="k">def</span> <span class="nf">define_meta_elems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="n">lGroup</span><span class="o">=</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="n">rGroup</span><span class="o">=</span><span class="s">&quot;)&quot;</span><span class="p">,</span>
                        <span class="n">lWildcard</span><span class="o">=</span><span class="s">&quot;[&quot;</span><span class="p">,</span> <span class="n">rWildcard</span><span class="o">=</span><span class="s">&quot;]&quot;</span><span class="p">,</span> <span class="n">rangeElem</span><span class="o">=</span><span class="s">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">orElem</span><span class="o">=</span><span class="s">&quot;|&quot;</span><span class="p">,</span> <span class="n">wildcardPattMatchFun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">elemToDigitFun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">canonicalizeFun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define the meta-elements in pattern-matching.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="o">=</span> <span class="n">escape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span> <span class="o">=</span> <span class="n">repetition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span> <span class="o">=</span> <span class="n">lGroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span> <span class="o">=</span> <span class="n">rGroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lWildcard</span> <span class="o">=</span> <span class="n">lWildcard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rWildcard</span> <span class="o">=</span> <span class="n">rWildcard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rangeElem</span> <span class="o">=</span> <span class="n">rangeElem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orElem</span> <span class="o">=</span> <span class="n">orElem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">canonicalizeFun</span> <span class="o">=</span> <span class="n">canonicalizeFun</span>
        <span class="k">if</span> <span class="n">wildcardPattMatchFun</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wildcardPattMatchFun</span> <span class="o">=</span> <span class="n">wildcardPattMatchFun</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wildcardPattMatchFun</span> <span class="o">=</span> <span class="n">charPatternMatchTest</span>
        <span class="k">if</span> <span class="n">elemToDigitFun</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elemToDigitFun</span> <span class="o">=</span> <span class="n">elemToDigitFun</span>
        <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">elemToDigitFun</span> <span class="o">=</span> <span class="n">charElemToInt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escapeMetaElems</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">repetition</span><span class="p">,</span> <span class="n">lGroup</span><span class="p">,</span> <span class="n">rGroup</span><span class="p">,</span> <span class="n">lWildcard</span><span class="p">,</span> <span class="n">rWildcard</span><span class="p">,</span> <span class="n">rangeElem</span><span class="p">}</span>
        <span class="k">return</span>

</div>
<div class="viewcode-block" id="RegexTrieDict.getDfsGen"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.getDfsGen">[docs]</a>    <span class="k">def</span> <span class="nf">getDfsGen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtreeRootNode</span><span class="p">,</span> <span class="n">funToApply</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">includeRoot</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="n">yieldOnLeaves</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">yieldOnMatch</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                  <span class="n">stopAtElems</span><span class="o">=</span><span class="p">[],</span> <span class="n">stopAtEscapedElems</span><span class="o">=</span><span class="p">[],</span>
                  <span class="n">stopAtDepth</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">onlyFollowElems</span><span class="o">=</span><span class="p">[],</span>
                  <span class="n">stopIfParenLevelZero</span><span class="o">=</span><span class="p">[],</span> <span class="n">firstParenLevel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">subtreeRootEscaped</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sortChildren</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="n">subtreeRootElem</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">childFun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a generator which will do a depth-first traversal of the trie,</span>
<span class="sd">        starting at node subtreeRootNode.  On each call it returns a list of</span>
<span class="sd">        (nodeElem, node) pairs for each node on some path from the root to a leaf</span>
<span class="sd">        of the tree.  It generates such a list for each path from the root to a</span>
<span class="sd">        leaf (one on each call).  If yieldOnMatch is set True then the current</span>
<span class="sd">        list being constructed on a path down the tree is returned on the first</span>
<span class="sd">        time any match-marked node is encountered, even if the node is not a</span>
<span class="sd">        leaf.  If yieldOnLeaves is set False then yields will only be done on</span>
<span class="sd">        matches.  (If both are False then the routine returns nothing.)</span>

<span class="sd">        If the list stopAtElems contains any elements then nodes for those</span>
<span class="sd">        elements are treated as leaves.  Similarly, stopAtEscapedElems treats</span>
<span class="sd">        escaped nodes for an element in the list to be like leaf nodes.  If</span>
<span class="sd">        stopAtDepth has a positive integer value then nodes at that depth are</span>
<span class="sd">        treated as leaves.  The onlyFollowElems list is like the negation for</span>
<span class="sd">        stopAtElems: it treats everything not on the list like a leaf node (i.e.,</span>
<span class="sd">        it only folows child-links which are on the list).</span>

<span class="sd">        If firstParenLevel is set to a positive integer then that integer will be</span>
<span class="sd">        incremented on each open-group meta-elem (self.lGroup) encountered on a</span>
<span class="sd">        path and decremented on each close-group meta-elem (self.rGroup)</span>
<span class="sd">        encountered on the path.  The default value is zero.  If</span>
<span class="sd">        stopIfParenLevelZero is non-empty then any elements in the list will be</span>
<span class="sd">        treated as leaves if they are encountered when the paren-count equals</span>
<span class="sd">        zero.  Note that paren-counts are updated after the comparison with zero.</span>
<span class="sd">        If the root is a node for a left-paren and firstParenLevel=0 then the</span>
<span class="sd">        matching right-paren is at paren-level zero.</span>

<span class="sd">        If funToApply is defined it will be called for each (nodeElem, node) pair</span>
<span class="sd">        on the returned lists.  The function should take two arguments; the list</span>
<span class="sd">        will contain the function&#39;s return value.  A copy of the node list is</span>
<span class="sd">        returned on each generation, but the nodes are always the actual nodes in</span>
<span class="sd">        the trie.  If includeRoot is True then output from the subtreeRootNode</span>
<span class="sd">        itself will be included in the output (with None as the corresponding</span>
<span class="sd">        nodeElem).</span>

<span class="sd">        If copies is set False then a single node list is used; this may be a</span>
<span class="sd">        little faster, but the returned list will change after each</span>
<span class="sd">        generation-cycle.  If sortChildren is True then the children of</span>
<span class="sd">        each node will be sorted in the dfs search ordering.</span>

<span class="sd">        Setting subtreeRootElem to an element will set that as the element on</span>
<span class="sd">        the returned list corresponding to the subtree root (otherwise it is</span>
<span class="sd">        None.  Sometimes the value is known when the function call is made,</span>
<span class="sd">        and it can be convenient to have a uniform list pattern.</span>

<span class="sd">        If childFun is set to a function then the children of a node are obtained</span>
<span class="sd">        by calling that function with the node as the argument.  This is helpful,</span>
<span class="sd">        for example, in pattern-matches where the child dict is locally modified</span>
<span class="sd">        per state.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">dfsRecursion</span><span class="p">(</span><span class="n">currNodeElem</span><span class="p">,</span> <span class="n">currNode</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">isEscaped</span><span class="p">,</span> <span class="n">parenCount</span><span class="p">):</span>
            <span class="c"># Put the node on the running list of nodes (down current tree path).</span>
            <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">includeRoot</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">funToApply</span><span class="p">:</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">funToApply</span><span class="p">(</span><span class="n">currNodeElem</span><span class="p">,</span> <span class="n">currNode</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currNodeElem</span><span class="p">,</span> <span class="n">currNode</span><span class="p">))</span>
            <span class="c"># Get the current node&#39;s child list and modify it.</span>
            <span class="k">if</span> <span class="n">childFun</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">childDict</span> <span class="o">=</span> <span class="n">childFun</span><span class="p">(</span><span class="n">currNode</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">childDict</span> <span class="o">=</span> <span class="n">currNode</span><span class="o">.</span><span class="n">children</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">childDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">stopAtElems</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">currNodeElem</span><span class="p">:</span> <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">stopAtEscapedElems</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">isEscaped</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">currNodeElem</span><span class="p">:</span> <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isEscaped</span> <span class="ow">and</span> <span class="n">currNodeElem</span> <span class="ow">in</span> <span class="n">stopIfParenLevelZero</span> <span class="ow">and</span>
               <span class="n">parenCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">stopAtDepth</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">==</span> <span class="n">maxDepth</span><span class="p">:</span> <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">onlyFollowElems</span><span class="p">:</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">onlyFollowElems</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sortChildren</span><span class="p">:</span> <span class="n">children</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="c"># Update the paren counter.</span>
            <span class="k">if</span> <span class="n">currNodeElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">:</span> <span class="n">parenCount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">currNodeElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">:</span> <span class="n">parenCount</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c"># Yield the results, according to the selected criteria.</span>
            <span class="n">yieldedAlready</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">copies</span><span class="p">:</span> <span class="n">yieldValue</span> <span class="o">=</span> <span class="n">nodeList</span><span class="p">[:]</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">yieldValue</span> <span class="o">=</span> <span class="n">nodeList</span>
            <span class="k">if</span> <span class="n">yieldOnLeaves</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">children</span><span class="p">:</span> <span class="c"># match only leaves (or pseudo-leaves)</span>
                <span class="k">yield</span> <span class="n">yieldValue</span>
                <span class="n">yieldedAlready</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">yieldOnMatch</span> <span class="ow">and</span> <span class="n">currNode</span><span class="o">.</span><span class="n">isLastElemOfKey</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">yieldedAlready</span><span class="p">:</span> <span class="k">yield</span> <span class="n">yieldValue</span>
            <span class="c"># Set the escape-value to pass to the recursive calls.</span>
            <span class="k">if</span> <span class="n">currNodeElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isEscaped</span><span class="p">:</span> <span class="n">isEscaped</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">isEscaped</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c"># Recurse for each child.</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">dfsRecursion</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">childDict</span><span class="p">[</span><span class="n">elem</span><span class="p">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="n">isEscaped</span><span class="p">,</span> <span class="n">parenCount</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">nodeList</span><span class="p">:</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c"># each child adds one, so pop one</span>

        <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">stopAtDepth</span> <span class="o">!=</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">maxDepth</span> <span class="o">=</span> <span class="n">stopAtDepth</span>
            <span class="n">stopAtDepth</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># because 0 evals to False as a bool</span>

        <span class="k">return</span> <span class="n">dfsRecursion</span><span class="p">(</span><span class="n">subtreeRootElem</span><span class="p">,</span> <span class="n">subtreeRootNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">subtreeRootEscaped</span><span class="p">,</span>
                            <span class="n">firstParenLevel</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RegexTrieDict.get_root_node_data_list"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.get_root_node_data_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_root_node_data_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This routine returns the initial node data list, for the root node.</span>
<span class="sd">        This list is used by getNextNodesMeta to save the state of the</span>
<span class="sd">        pattern-matching between iterations.  Multiple instances are allowed.&quot;&quot;&quot;</span>
        <span class="c"># The tuple of state-information on a NodeDataList is:</span>
        <span class="c">#     (node, nodeIsEscape, loopbackStack, loopCounterStack, loopBoundsStack,</span>
        <span class="c">#                                                       boundNodeChildDict)</span>
        <span class="n">nodeDataList</span> <span class="o">=</span> <span class="n">NodeStateDataList</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">NodeStateData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">{},</span> <span class="nb">set</span><span class="p">())])</span>
        <span class="k">return</span> <span class="n">nodeDataList</span>
</div>
<div class="viewcode-block" id="RegexTrieDict.has_key_meta"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.has_key_meta">[docs]</a>    <span class="k">def</span> <span class="nf">has_key_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keySeq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test of whether the sequence of elements keySeq matches any of the</span>
<span class="sd">        regexp patterns stored in the RegexTrieDict.  Returns the number of</span>
<span class="sd">        matches.  Remember that any literal escapes in the trie must be</span>
<span class="sd">        escaped, but escapes in keySeq are always treated as literal.&quot;&quot;&quot;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">Matcher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">keySeq</span><span class="p">:</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">next_key_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">cannot_match</span><span class="p">():</span> 
                <span class="n">mat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="k">return</span> <span class="mi">0</span> <span class="c"># No more nodes, can&#39;t match.</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">has_key</span><span class="p">()</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span> <span class="c"># Ends match and frees memory.</span>
        <span class="k">return</span> <span class="n">retval</span>
        <span class="c">#### This is the earlier implementation, not using seqmeta mode.</span>
        <span class="c"># self.nodeDataList = self.get_root_node_data_list()</span>
        <span class="c"># </span>
        <span class="c"># for elem in keySeq:</span>
        <span class="c">#     self.nodeDataList = self.getNextNodesMeta(elem, self.nodeDataList)</span>
        <span class="c">#     if not self.nodeDataList: return 0 # no nodes, can&#39;t match</span>

        <span class="c"># tmpNodeDataList = self.getNextNodesMeta(self.magicElem, self.nodeDataList)</span>
        <span class="c"># matchedNodes = [nodeData for nodeData in tmpNodeDataList</span>
        <span class="c">#                                       if nodeData[0].isLastElemOfKey]</span>
        <span class="c"># return len(matchedNodes)</span>
</div>
<div class="viewcode-block" id="RegexTrieDict.get_meta"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.get_meta">[docs]</a>    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keySeq</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the data items of all the stored strings which</span>
<span class="sd">        match the sequence of elements keySeq (based on the regexp patterns</span>
<span class="sd">        stored in the RegexTrieDict).  The default with no matches is to</span>
<span class="sd">        return the empty list.  Remember that any literal escapes in the</span>
<span class="sd">        trie must be escaped, but escapes in keySeq are always treated as</span>
<span class="sd">        literal.&quot;&quot;&quot;</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">Matcher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">keySeq</span><span class="p">:</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">next_key_elem</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">cannot_match</span><span class="p">():</span> 
                <span class="n">mat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">default</span> <span class="c"># No more nodes, can&#39;t match.</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span> <span class="c"># Ends match and frees memory.</span>
        <span class="k">return</span> <span class="n">retval</span>

    <span class="c"># def insert_until_match(self, elem, longest=True, join_elems=True):</span>
    <span class="c">#     &quot;&quot;&quot;This method is useful for using the RegexTrieDict as part of a</span>
    <span class="c">#     lexical scanner.  Returns False on each insertion until it has</span>
    <span class="c">#     identified the longest prefix of the sequence of inserted elements</span>
    <span class="c">#     which matches a pattern stored in the trie.  (If longest=False it stops</span>
    <span class="c">#     after the first match).  When a match is identified it returns a</span>
    <span class="c">#     two-tuple.  The first component contains the sequence of elements that</span>
    <span class="c">#     gave the longest match (i.e., the matching prefix).  If join_elems is</span>
    <span class="c">#     True these elements will be combined using the addition operator;</span>
    <span class="c">#     otherwise it returns a tuple of the elements.  The second component of</span>
    <span class="c">#     the returned tuple will contain a tuple of each data item stored in the</span>
    <span class="c">#     trie for each pattern that the sequence matched.</span>
    <span class="c">#     </span>
    <span class="c">#     This function resets sequential meta mode and uses it to do the</span>
    <span class="c">#     scanning, so using other sequential meta methods during the process</span>
    <span class="c">#     will invalidate the results.&quot;&quot;&quot;</span>

    <span class="c">#     # TODO also consider hybrid approaches with Python regex.  Maybe</span>
    <span class="c">#     # use abstract interface to swap implementation and compare...</span>

    <span class="c">#     # TODO have to save the matched elements and return, or change description above...</span>
    <span class="c">#     # Maybe just return the length of the match as first component?  Could</span>
    <span class="c">#     # save the elements themselves, but that adds complexity and may not</span>
    <span class="c">#     # belong in this class... may return multiple matches if elems are saved</span>
    <span class="c">#     # and re-entered automatically after a match.</span>

    <span class="c">#     if not self.scannerMatchMode:</span>
    <span class="c">#         self.scannerMatchMode = True</span>
    <span class="c">#         self.lastMatchedNodes = []</span>
    <span class="c">#         self.reset_seqmeta()</span>

    <span class="c">#     # Insert the element as a key in sequential meta mode.</span>
    <span class="c">#     self.seqmeta_next_key_elem(elem)</span>

    <span class="c">#     # Get any matches at the current length of inserted elements.</span>
    <span class="c">#     tmpNodeDataList = self.getNextNodesMeta(self.magicElem, self.nodeDataList)</span>

    <span class="c">#     # If no more active patterns, we can return the longest found.</span>
    <span class="c">#     if not tmpNodeDataList:</span>
    <span class="c">#         self.scannerMatchMode = False</span>
    <span class="c">#         self.lastMatchedNodes = None</span>
    <span class="c">#         self.reset_seqmeta()</span>
    <span class="c">#         return [n.node.data for n in self.lastMatchedNodes]</span>

    <span class="c">#     # Find any pattern matches at this length of elements; save nodes if found.</span>
    <span class="c">#     matchedNodes = [nodeData for nodeData in tmpNodeDataList</span>
    <span class="c">#                                           if nodeData[0].isLastElemOfKey]</span>
    <span class="c">#     if matchedNodes: self.lastMatchedNodes = matchedNodes</span>
    <span class="c">#     return False</span>
</div>
    <span class="k">def</span> <span class="nf">_skipNodeDataListEscapes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeDataList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This routines handles pattern-escapes in a list of node-data tuples.</span>
<span class="sd">        This routine is always called by processNodeData as the first step</span>
<span class="sd">        (unless it is called with skipEscapes=False).  For each node on</span>
<span class="sd">        nodeDataList, a parallel node is added for each escape-element child,</span>
<span class="sd">        since that will have to be interpreted specially on the next iteration.</span>
<span class="sd">        We are skipping the escape itself but setting a bool in the nodeData</span>
<span class="sd">        state to remember it.  If escape is the only child of a node in a</span>
<span class="sd">        nodeData tuple then the original nodeData tuple is removed from the list.</span>
<span class="sd">        An ordinary list of NodeData instances is OK to pass as nodeDataList.</span>
<span class="sd">        The return value is a NodeStateDataList.&quot;&quot;&quot;</span>
        <span class="n">escapedNodeDataList</span> <span class="o">=</span> <span class="n">NodeStateDataList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">nodeData</span> <span class="ow">in</span> <span class="n">nodeDataList</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span> <span class="ow">in</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="c"># Note copies of the loop states are used.</span>
                <span class="n">nodeDataCopy</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># TODO can skip copy when single child</span>
                <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">nodeIsEscape</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">escapedNodeDataList</span><span class="o">.</span><span class="n">appendChildNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="n">nodeDataCopy</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span> <span class="c"># escape is only child</span>
            <span class="n">escapedNodeDataList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeData</span><span class="p">)</span> <span class="c"># copy the node over unchanged</span>
        <span class="k">return</span> <span class="n">escapedNodeDataList</span>


<div class="viewcode-block" id="RegexTrieDict.getNextNodesMeta"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.getNextNodesMeta">[docs]</a>    <span class="k">def</span> <span class="nf">getNextNodesMeta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeDataList</span><span class="p">,</span> <span class="n">ignoreValidity</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of next nodes for each node on currNodeList,</span>
<span class="sd">        interpreting any stored pattern-matching meta-elements, when the</span>
<span class="sd">        query-key element queryElem is received.  The nodeDataList should be a</span>
<span class="sd">        NodeStateDataList object.  It stores a list of NodeDataState tuples, each</span>
<span class="sd">        representing a &quot;live&quot; state of the nondeterministic search.  The tuple</span>
<span class="sd">        contains a node in the trie as well as some additional state information.</span>

<span class="sd">        See the routine has_key_meta for a simple example of how this method is</span>
<span class="sd">        used.</span>

<span class="sd">        When queryElem is set to the special value self.magicElem this routine</span>
<span class="sd">        has special behavior defined.  It will simply fast-forward up to the</span>
<span class="sd">        point where that character would have been compared to the next one in</span>
<span class="sd">        the query-pattern.  Then it stops, returning those stop-nodes.  This</span>
<span class="sd">        turns out to be very convenient for skipping closing right-group elements</span>
<span class="sd">        as well as zero-repetition-matching patterns at the end of a larger key</span>
<span class="sd">        pattern.  Recall that to check for a match we need to look at the</span>
<span class="sd">        isLastElemOfKey values at the very end of the stored patterns.  Any</span>
<span class="sd">        nodeDataList elements which immediately precede a comparison with an</span>
<span class="sd">        element or set of elements (a literal character or a wildcard) are left</span>
<span class="sd">        unchanged.  Any others move forward to such a point.  Any well-defined</span>
<span class="sd">        pattern has such an endpoint.&quot;&quot;&quot;</span>

        <span class="c">#print(&quot;\ndebug getNextNodesMeta call, processing query char&quot;, queryElem)</span>
        <span class="c">#print(&quot;*&quot;*30)</span>
        <span class="c">#for nd in nodeDataList:</span>
        <span class="c">#   self.printTree(childFun=nd.children)</span>
        <span class="c">#print(&quot;*&quot;*30)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignoreValidity</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">nodeDataList</span><span class="o">.</span><span class="n">isValidIn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ModifiedTrieError</span><span class="p">(</span><span class="s">&quot;Invalid nodeDataList, trie has changed.&quot;</span><span class="p">)</span>

        <span class="c"># If we are starting a magicElem search, save the current node with the</span>
        <span class="c"># state.  This is to avoid infinite recursion in processing repetitions</span>
        <span class="c"># that match zero times.  The visitedSet is emptied in processNodeData</span>
        <span class="c"># when a valid end-point is reached.  The appendChildNode routine adds</span>
        <span class="c"># any nodes to the set that it processes, and drops any that would</span>
        <span class="c"># loop.</span>
        <span class="c"># TODO consider just turning off all looping-back in handleEndRepetition...</span>
        <span class="c"># just set a switch here and turn back off at end.  No valid endpoint is</span>
        <span class="c"># at beginning of a loop, anyway.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magicElemNoLoop</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># debug xxx</span>
        <span class="k">if</span> <span class="n">queryElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">magicElem</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magicElemNoLoop</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># debug xxx</span>

        <span class="c"># Define the list that will be built-up with next states during the</span>
        <span class="c"># processing.  This object will be the return value of the function.</span>
        <span class="n">nextNodeDataList</span> <span class="o">=</span> <span class="n">NodeStateDataList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">nodeData</span> <span class="ow">in</span> <span class="n">nodeDataList</span><span class="p">:</span>
            <span class="c"># Process the nodeData</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processNodeData</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeData</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nextNodeDataList</span>

</div>
<div class="viewcode-block" id="RegexTrieDict.processNodeData"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.processNodeData">[docs]</a>    <span class="k">def</span> <span class="nf">processNodeData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeData</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">,</span> <span class="n">skipEscapes</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process one nodeData instance, usually from the nodeDataList.  Put the</span>
<span class="sd">        results on nextNodeDataList.  This large routine does most of the work in</span>
<span class="sd">        the processing, and is called recursively when necessary.  Escapes are</span>
<span class="sd">        skipped (generally producing a list of NodeStateData classes) unless</span>
<span class="sd">        skipEscapes is set False.&quot;&quot;&quot;</span>

        <span class="c">#</span>
        <span class="c"># If escapes are to be skipped, recursively process all the resulting nodes.</span>
        <span class="c">#</span>

        <span class="k">if</span> <span class="n">skipEscapes</span><span class="p">:</span>
            <span class="n">nodeDataList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipNodeDataListEscapes</span><span class="p">([</span><span class="n">nodeData</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">nodeDataList</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processNodeData</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">,</span> <span class="n">skipEscapes</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c">#</span>
        <span class="c"># Handle ordinary, non-escaped nodes in the pattern trie.</span>
        <span class="c">#</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">nodeIsEscape</span><span class="p">:</span>

            <span class="n">nodeData</span><span class="o">.</span><span class="n">visitedRepNodeIdSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c"># got a literal elem, reset</span>

            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">queryElem</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magicElem</span><span class="p">):</span>
                <span class="c"># The &quot;magic&quot; element doesn&#39;t match anything, see header comments.</span>
                <span class="n">nextNodeDataList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeData</span><span class="p">)</span> <span class="c"># just keep the node itself</span>

            <span class="k">elif</span> <span class="n">queryElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                <span class="c"># Can&#39;t match because node is neither an escaped escape char nor</span>
                <span class="c"># a meta-pattern.</span>
                <span class="k">pass</span>

            <span class="k">elif</span> <span class="n">queryElem</span> <span class="ow">in</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">():</span>
                <span class="n">nextNodeDataList</span><span class="o">.</span><span class="n">appendChildNode</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeData</span><span class="p">,</span>
                                                 <span class="n">nodeIsEscape</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c">#</span>
        <span class="c"># Handle escaped nodes in the pattern trie, which have special meaning.</span>
        <span class="c">#</span>

        <span class="k">elif</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">nodeIsEscape</span><span class="p">:</span>
            <span class="c"># At a node for an escape-element, see if any meta-element patterns</span>
            <span class="c"># are among its keys.  After the first escape in a pattern we can get</span>
            <span class="c"># a repetition, a left-wildcard bracket, or another escape (to be</span>
            <span class="c"># treated as a literal).  Multiple are possible.  Inside a</span>
            <span class="c"># repetition, which are evaluates as normal sequences, we can also</span>
            <span class="c"># encounter a close-group metacharacter and we have to decide</span>
            <span class="c"># whether or not to loop back.  All other escaped characters at</span>
            <span class="c"># this level are errors.</span>

            <span class="n">nextMetaElems</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

            <span class="c"># Loop through the meta-elems stored at the node and handle each one.</span>
            <span class="k">for</span> <span class="n">metaElem</span> <span class="ow">in</span> <span class="n">nextMetaElems</span><span class="p">:</span>

                <span class="c">#</span>
                <span class="c"># Double escape in a patern matches a single escape in query-key.</span>
                <span class="c">#</span>
                <span class="k">if</span> <span class="n">metaElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">queryElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;got escaped escape, adding to trie as element&quot;</span><span class="p">)</span>
                        <span class="n">nextNodeDataList</span><span class="o">.</span><span class="n">appendChildNode</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeData</span><span class="p">,</span>
                                                         <span class="n">nodeIsEscape</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c"># An escaped escape just doesn&#39;t match, no new nodeData.</span>
                        <span class="k">continue</span>

                <span class="c">#</span>
                <span class="c"># Handle begin-repetitions.</span>
                <span class="c">#</span>
                <span class="k">elif</span> <span class="n">metaElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug processing repetition&quot;</span><span class="p">)</span>
                    <span class="c"># Add the repetition subtree leaves to the nextNodeDataList, and</span>
                    <span class="c"># process them as end-repetition events (generating the loop</span>
                    <span class="c"># back and the continuation.  Note that repetition generally</span>
                    <span class="c"># matches zero times, so the end of every repetition pattern is</span>
                    <span class="c"># a valid continuation point.  So we have to go out to the end</span>
                    <span class="c"># nodes and start states for those possibilities.  We only need</span>
                    <span class="c"># one new state for going through the characters inside the</span>
                    <span class="c"># repetition group, however, so after the first one the others</span>
                    <span class="c"># are processed with noLoop=True.</span>

                    <span class="c"># A repetition element must be followed by an open-group element on</span>
                    <span class="c"># each path following it.  Get a generator for those nodes.</span>
                    <span class="n">dfsGenOpen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDfsGen</span><span class="p">(</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">],</span>
                                     <span class="n">includeRoot</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                     <span class="n">stopAtEscapedElems</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">],</span>
                                     <span class="n">childFun</span><span class="o">=</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">treePathToOpenGroup</span> <span class="ow">in</span> <span class="n">dfsGenOpen</span><span class="p">:</span>
                        <span class="c"># Check some error conditions.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">treePathToOpenGroup</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span> <span class="c"># root, esc, lGroup</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                                <span class="s">&quot;No open-group following a repetition.&quot;</span><span class="p">)</span>
                        <span class="n">lGroupElem</span><span class="p">,</span> <span class="n">lGroupNode</span> <span class="o">=</span> <span class="n">treePathToOpenGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">lGroupEsc</span><span class="p">,</span> <span class="n">lGroupEscNode</span> <span class="o">=</span> <span class="n">treePathToOpenGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                        <span class="c">#print(&quot;   debug treePathToOpenGroup&quot;, [ t[0] for t in</span>
                        <span class="c">#                                          treePathToOpenGroup])</span>
                        <span class="k">if</span> <span class="n">lGroupElem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span> <span class="ow">or</span> <span class="n">lGroupEsc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                                <span class="s">&quot;No open-group element following a repetition element.&quot;</span><span class="p">)</span>
                        <span class="n">iterBounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processRepetitionParams</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span>
                                                                   <span class="n">treePathToOpenGroup</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

                        <span class="c"># If at least one iteration is required then we can avoid having</span>
                        <span class="c"># to find all the closing-group elements for the subtree and</span>
                        <span class="c"># launching new states for each one (they are the zero-repetition</span>
                        <span class="c"># states). We can just start a state and wait and later see which</span>
                        <span class="c"># ones ever reach their end-group loopback points.</span>
                        <span class="k">if</span> <span class="n">iterBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># At least one iteration is required.</span>
                            <span class="k">pass</span> <span class="c"># TODO, just an optimization of what already works</span>

                        <span class="c"># Now, for each opening paren, get a generator for all the closing</span>
                        <span class="c"># parens corresponding to it.</span>
                        <span class="n">dfsGenClose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDfsGen</span><span class="p">(</span><span class="n">lGroupNode</span><span class="p">,</span> <span class="n">includeRoot</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                             <span class="n">copies</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                             <span class="n">stopIfParenLevelZero</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">orElem</span><span class="p">],</span>
                                             <span class="n">firstParenLevel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">childFun</span><span class="o">=</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                        <span class="n">setNoLoop</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># whether to only create a break-state, no loop-state</span>
                        <span class="k">for</span> <span class="n">treePathToCloseGroup</span> <span class="ow">in</span> <span class="n">dfsGenClose</span><span class="p">:</span>
                            <span class="c"># Do some error checks.</span>
                            <span class="k">if</span> <span class="n">treePathToCloseGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orElem</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                                    <span class="s">&quot;Or element without opening paren.&quot;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">treePathToCloseGroup</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span> <span class="c"># root, esc, rGroup</span>
                                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Illegal empty repetition group &quot;</span>
                                                        <span class="s">&quot;or no close-group for repetition.&quot;</span><span class="p">)</span>
                            <span class="n">rGroupElem</span><span class="p">,</span> <span class="n">rGroupNode</span> <span class="o">=</span> <span class="n">treePathToCloseGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">rGroupEsc</span><span class="p">,</span> <span class="n">rGroupEscNode</span> <span class="o">=</span> <span class="n">treePathToCloseGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                            <span class="c">#print(&quot;      debug treePathToCloseGroup&quot;, [ t[0] for t in</span>
                            <span class="c">#                                      treePathToCloseGroup ])</span>
                            <span class="k">if</span> <span class="n">rGroupElem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span> <span class="ow">or</span> <span class="n">rGroupEsc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                                    <span class="s">&quot;No close-group matching a repetition open-group.&quot;</span><span class="p">)</span>

                            <span class="c">#</span>
                            <span class="c"># Push the loopback node on the stack and treat as end repetition.</span>
                            <span class="c">#</span>

                            <span class="n">pushedNodeData</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="c"># Fix the children of nodes for original repetition and beginning</span>
                            <span class="c"># nodes skipped by dfs, for new state, in case nested</span>
                            <span class="c"># repetitions.</span>
                            <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">)</span> <span class="c"># do before node reassign!</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">treePathToOpenGroup</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span> <span class="c"># elem of next, node of current</span>
                                    <span class="n">treePathToOpenGroup</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="o">=</span><span class="n">treePathToOpenGroup</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                            <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">rGroupNode</span>
                            <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">nodeIsEscape</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lGroupNode</span><span class="p">)</span>
                            <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">loopCounterStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">loopBoundsStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iterBounds</span><span class="p">)</span>
                            <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">visitedRepNodeIdSet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">lGroupNode</span><span class="p">))</span>

                            <span class="c"># Process the new pushedNodeData as an end-repetition.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">handleEndRepetition</span><span class="p">(</span>
                                <span class="n">queryElem</span><span class="p">,</span> <span class="n">pushedNodeData</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">,</span>
                                <span class="n">noLoop</span><span class="o">=</span><span class="n">setNoLoop</span><span class="p">)</span>
                            <span class="n">setNoLoop</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># We only need one new state at the beginning.</span>

                <span class="c">#</span>
                <span class="c"># Handle end-repetitions.</span>
                <span class="c">#</span>
                <span class="k">elif</span> <span class="n">metaElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">:</span>
                    <span class="n">nodeDataCopy</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># debug, unnecessary? xxx</span>
                    <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">)</span> <span class="c"># debug, unnecessary? xxx</span>
                    <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handleEndRepetition</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeDataCopy</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">,</span>
                                             <span class="n">refuseRevisits</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

                <span class="c">#</span>
                <span class="c"># Handle beginning of an &quot;or&quot; group.</span>
                <span class="c">#</span>
                <span class="k">elif</span> <span class="n">metaElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug processing an &#39;or&#39; group&quot;</span><span class="p">)</span>
                    <span class="c"># TODO if we&#39;re not inside a loop or guaranteed to break out then</span>
                    <span class="c"># we can just have a single state at each start point, and not</span>
                    <span class="c"># set the children to single-children, either (consider)...</span>

                    <span class="c"># Treat this entire &#39;or&#39; group as a one-repetition loop.  This is</span>
                    <span class="c"># so we know what to do then final rGroup is encountered.  The actual</span>
                    <span class="c"># loopback point isn&#39;t required and is set to a dummy node.  The</span>
                    <span class="c"># continuation point will either be the next node in the tree when the final</span>
                    <span class="c"># rGroup element is processed as the end of a one-repetition loop,</span>
                    <span class="c"># or else it will be calculated when an orElem (&quot;|&quot;) is encountered.</span>

                    <span class="c"># Make a copy of the nodeData state for this start-point.</span>
                    <span class="n">pushedNodeData</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">nodeIsEscape</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">TrieDictNode</span><span class="p">())</span> <span class="c"># dummy, popped later</span>
                    <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">loopCounterStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">loopBoundsStack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">)</span>

                    <span class="c"># Get a generator generating each path to a corresponding close-group.</span>
                    <span class="c"># Note the current implementation is inefficient.</span>
                    <span class="n">currNode</span> <span class="o">=</span> <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">]</span>
                    <span class="n">dfsGenOrGroupEnd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDfsGen</span><span class="p">(</span><span class="n">currNode</span><span class="p">,</span> <span class="n">includeRoot</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                           <span class="n">copies</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stopIfParenLevelZero</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">],</span>
                                           <span class="n">firstParenLevel</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                           <span class="n">childFun</span><span class="o">=</span><span class="n">pushedNodeData</span><span class="o">.</span><span class="n">children</span><span class="p">,</span>
                                           <span class="n">subtreeRootElem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">)</span>

                    <span class="c"># Iterate the generator, creating states for each section of each tree</span>
                    <span class="c"># path.</span>
                    <span class="k">for</span> <span class="n">treePathToEndGroup</span> <span class="ow">in</span> <span class="n">dfsGenOrGroupEnd</span><span class="p">:</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">treePathToEndGroup</span><span class="p">])</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug, queryElem is&quot;</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">)</span>
                        <span class="c"># Do some error checks.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">treePathToEndGroup</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span> <span class="c"># root, esc, rGroup # TODO check</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Illegal empty &#39;or&#39; group &quot;</span>
                                                    <span class="s">&quot;or no close-group for &#39;or&#39;.&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">treePathToEndGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span>
                           <span class="ow">or</span> <span class="n">treePathToEndGroup</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                                <span class="s">&quot;No close-group matching an &#39;or&#39; open-group.&quot;</span><span class="p">)</span>

                        <span class="c"># Fix all the nodes on the path to have one child (for these states).</span>
                        <span class="c"># We make a new copy for each path to the closing rGroup, though.</span>
                        <span class="n">pushedNodeDataCopy</span> <span class="o">=</span> <span class="n">pushedNodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">treePathToEndGroup</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">pushedNodeDataCopy</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span> <span class="c"># elem of next, node of current</span>
                                <span class="n">treePathToEndGroup</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="o">=</span><span class="n">treePathToEndGroup</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                        <span class="c"># Find all the begin-section markers inside the &#39;or&#39; group and start a</span>
                        <span class="c"># new state for each one (i.e., opening paren and all &#39;|&#39;</span>
                        <span class="c"># elements).</span>
                        <span class="n">escaped</span> <span class="o">=</span> <span class="bp">True</span> <span class="c"># The first lGroup is escaped.</span>
                        <span class="n">parenCount</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">treePathToEndGroup</span><span class="p">)):</span>
                            <span class="n">elem</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">treePathToEndGroup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="c"># TODO check that each one has at least something in it....</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">escaped</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">:</span>
                                <span class="n">escaped</span> <span class="o">=</span> <span class="bp">True</span>
                                <span class="k">continue</span>
                            <span class="c"># Always escaped past here.</span>
                            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">:</span> <span class="n">parenCount</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">elif</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">:</span> <span class="n">parenCount</span> <span class="o">-=</span> <span class="mi">1</span>
                            <span class="c"># If not a valid open-group section then continue.</span>
                            <span class="k">if</span> <span class="n">parenCount</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span>
                                          <span class="n">elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orElem</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lGroup</span><span class="p">):</span>
                                <span class="k">continue</span>
                            <span class="c"># Create a state for currNode (copy of general state) and</span>
                            <span class="c"># process it.</span>
                            <span class="n">orSectionBegin</span> <span class="o">=</span> <span class="n">pushedNodeDataCopy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="n">orSectionBegin</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">processNodeData</span><span class="p">(</span>
                                <span class="n">queryElem</span><span class="p">,</span> <span class="n">orSectionBegin</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">)</span>
                            <span class="n">escaped</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="c">#</span>
                <span class="c"># Handle end of non-final end-section of an or-group (an orElem &quot;|&quot;).</span>
                <span class="c">#</span>
                <span class="k">elif</span> <span class="n">metaElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">orElem</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug processing non-final &#39;or&#39; group section&quot;</span><span class="p">)</span>
                    <span class="k">print</span><span class="p">(</span>
                        <span class="s">&quot;   debug nodeData.loopCounterStack is&quot;</span><span class="p">,</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">loopCounterStack</span><span class="p">)</span>
                    <span class="c"># Get a generator for all final rGroup elems at this point.  There</span>
                    <span class="c"># should only be one, since the state was fixed to single-children</span>
                    <span class="c"># when the &#39;or&#39; was first processed.</span>
                    <span class="n">dfsGenOrSectionEnd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDfsGen</span><span class="p">(</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">orElem</span><span class="p">],</span>
                                                        <span class="n">includeRoot</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                                        <span class="n">stopIfParenLevelZero</span><span class="o">=</span><span class="p">[</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">],</span> <span class="n">firstParenLevel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">childFun</span><span class="o">=</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">treePath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dfsGenOrSectionEnd</span><span class="p">):</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;      debug treePathToEndSection in process &#39;or&#39; elem&quot;</span><span class="p">,</span>
                              <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">treePath</span><span class="p">])</span>
                        <span class="c"># Errors checked earlier, when lGroup of the &#39;or&#39; was processed.</span>
                        <span class="n">rGroupElem</span><span class="p">,</span> <span class="n">rGroupNode</span> <span class="o">=</span> <span class="n">treePath</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">nodeDataCopy</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># debug, unneeded?? xxx</span>
                        <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orElem</span><span class="p">)</span> <span class="c"># debug, unnecessary?? xxx</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">handleEndRepetition</span><span class="p">(</span>
                            <span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeDataCopy</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">,</span>
                            <span class="n">replaceNode</span><span class="o">=</span><span class="n">rGroupNode</span><span class="p">)</span>
                        <span class="c"># When &#39;or&#39; is set it should give all nodes for state</span>
                        <span class="c"># single-children</span>
                        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># This is just a consistency-check assertion.</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Failure in &#39;or&#39; child-setting.&quot;</span><span class="p">)</span>

                <span class="c">#</span>
                <span class="c"># Handle wildcards.</span>
                <span class="c">#</span>
                <span class="k">elif</span> <span class="n">metaElem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lWildcard</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug processing wildcard&quot;</span><span class="p">)</span>
                    <span class="c"># Generate all the subtree rWildcard nodes, checking that the</span>
                    <span class="c"># pattern matches.</span>

                    <span class="n">nodeData</span><span class="o">.</span><span class="n">visitedRepNodeIdSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c"># got an actual elem, reset</span>

                    <span class="c"># Magic elem doesn&#39;t match any char; just put current node on</span>
                    <span class="c"># nextNodeDataList (so isLastElemOfKey can be checked).</span>
                    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">queryElem</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magicElem</span><span class="p">):</span>
                        <span class="n">nextNodeDataList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeData</span><span class="p">)</span> <span class="c"># just keep the node itself</span>
                        <span class="k">continue</span> <span class="c"># process the next metaElem in the loop</span>

                    <span class="n">wildcardPattGen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDfsGen</span><span class="p">(</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">lWildcard</span><span class="p">],</span>
                                          <span class="n">includeRoot</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">copies</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                          <span class="n">childFun</span><span class="o">=</span><span class="n">nodeData</span><span class="o">.</span><span class="n">children</span><span class="p">,</span>
                                          <span class="n">stopAtEscapedElems</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rWildcard</span><span class="p">])</span>

                    <span class="k">for</span> <span class="n">wildcardPatt</span> <span class="ow">in</span> <span class="n">wildcardPattGen</span><span class="p">:</span>
                        <span class="c"># print(&quot;      debug wildcard patt&quot;, [ t[0] for t in wildcardPatt</span>
                        <span class="c"># ])</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wildcardPatt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span> <span class="c"># root, some char, esc, rWildcard</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;No closing bracket for wildcard.&quot;</span><span class="p">)</span>
                        <span class="n">rWildcardElem</span><span class="p">,</span> <span class="n">rWildcardNode</span> <span class="o">=</span> <span class="n">wildcardPatt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">escapeElem</span><span class="p">,</span> <span class="n">escapeNode</span> <span class="o">=</span> <span class="n">wildcardPatt</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">rWildcardElem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rWildcard</span> <span class="ow">or</span> <span class="n">escapeElem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;No closing bracket for wildcard.&quot;</span><span class="p">)</span>
                        <span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">wildcardPatt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
                        <span class="c"># If the character matches the wildcard pattern:</span>
                        <span class="c"># 1) Get a copy NodeStateData.</span>
                        <span class="c"># 2) In the NodeDataState, fix all the nodes on the path to the</span>
                        <span class="c">#    end-element to have one child (the new NodeStateData now</span>
                        <span class="c">#    represents just one pattern instance, not the full subtree).</span>
                        <span class="c"># 3) Append the node to nextNodeDataList.</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wildcardPattMatchFun</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">rangeElem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">):</span>
                            <span class="n">nodeDataCopy</span> <span class="o">=</span> <span class="n">nodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lWildcard</span><span class="p">)</span>

                            <span class="c"># Fix the children on the wildcardPatt list to only have</span>
                            <span class="c"># one child.</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wildcardPatt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">setChild</span><span class="p">(</span> <span class="c"># elem of next, node of current</span>
                                    <span class="n">wildcardPatt</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="o">=</span><span class="n">wildcardPatt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                            <span class="c"># Set the other elements and append to nextNodeDataList.</span>
                            <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">rWildcardNode</span> <span class="c"># stacks do not change</span>
                            <span class="n">nodeDataCopy</span><span class="o">.</span><span class="n">nodeIsEscape</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="n">nextNodeDataList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeDataCopy</span><span class="p">)</span>

                <span class="c">#</span>
                <span class="c"># Error condition otherwise.</span>
                <span class="c">#</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># An escape in some pattern isn&#39;t followed by a valid meta-elem,</span>
                    <span class="c"># like r&quot;\Z&quot;.</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                        <span class="s">&quot;Invalid meta-element (unknown escaped element) encountered.&quot;</span>
                        <span class="s">&quot;</span><span class="se">\n</span><span class="s">Query element is: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">queryElem</span><span class="p">)</span> <span class="o">+</span>
                        <span class="s">&quot;</span><span class="se">\n</span><span class="s">Node&#39;s children are:</span><span class="se">\n</span><span class="s">   &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nextMetaElems</span><span class="p">))</span>

        <span class="k">return</span>

</div>
<div class="viewcode-block" id="RegexTrieDict.handleEndRepetition"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.handleEndRepetition">[docs]</a>    <span class="k">def</span> <span class="nf">handleEndRepetition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">,</span> <span class="n">closeParenNodeData</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">,</span>
                            <span class="n">replaceNode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">noLoop</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">noBreak</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                            <span class="n">refuseRevisits</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle reaching the close of a repetition group.  The closeParenNode</span>
<span class="sd">        should be the node corresponding to the closing repetition-group.  If</span>
<span class="sd">        replaceNode is set to a node then it replaces the node in closeParenNodeData</span>
<span class="sd">        as the new node to jump to after a breaking a loop (used in inside sections</span>
<span class="sd">        of &#39;or&#39; patterns).&quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TODO, consider</span>
<span class="sd">        Greedy loops would be useful.  They always match as many loops around</span>
<span class="sd">        as possible, even if that causes the larger pattern to fail.  This avoids</span>
<span class="sd">        some worst-case scenarios.</span>
<span class="sd">  </span>
<span class="sd">        To implement: we need to link/entangle the two states that are produced</span>
<span class="sd">        at the end of a loop.  Then, if the loopback state makes it through</span>
<span class="sd">        another iteration, back to here in handleEndRepetition, it somehow signals</span>
<span class="sd">        that other state to die.  But, if it doesn&#39;t complete another loop, that</span>
<span class="sd">        state goes on.  (Note zero-repetition loops might be a problem...)</span>
<span class="sd">  </span>
<span class="sd">        Similarly, if two &#39;or&#39; sections match we only need to keep one state... NO,</span>
<span class="sd">        it will NOT necessarily result in the same pattern in the end.  The sections</span>
<span class="sd">        can have different numbers of elements, and can have loops, etc.  We&#39;d need</span>
<span class="sd">        to use a greedy or non-greedy rule again.  So the last-exiting match or</span>
<span class="sd">        first-exiting match could kill all the others.  We always come here to exit</span>
<span class="sd">        the &#39;or&#39; sections, since they are treated as loops at the outer level.</span>
<span class="sd">  </span>
<span class="sd">        See partial start commented out below.... one problem is that we need</span>
<span class="sd">        unique IDs for NodeStateData instances, even across copy operations...</span>
<span class="sd">        but do *some* copy operations need to get a new ID????</span>
<span class="sd">  </span>
<span class="sd">  </span>
<span class="sd">        What if we just set the IDs here for the generated NodeStateData copies?</span>
<span class="sd">        Then copy could just preserve it.  Presumably anything derived from a state</span>
<span class="sd">        that is killed should also be killed!  So then we just put the ID on a kill</span>
<span class="sd">        list and at the end of the main routine we go through and remove those states.</span>
<span class="sd">  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug in handleEndRepetition&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">loopbackStack</span> <span class="ow">and</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">loopCounterStack</span>
                <span class="ow">and</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">loopBoundsStack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                <span class="s">&quot;IndexError on a stack pop, probably mismatched parentheses.&quot;</span><span class="p">)</span>

        <span class="c"># Here we branch the state into one branch that repeats the loop,</span>
        <span class="c"># and one that breaks out of the loop.  Note that ordinary lists are</span>
        <span class="c"># OK here, we have already checked validity of the original list and</span>
        <span class="c"># any new NodeStateData instances will be added to nextNodeDataList,</span>
        <span class="c"># which is already a NodeStateDataList.</span>

        <span class="c"># Get some preliminary values needed for conditional tests.</span>
        <span class="n">openParenNode</span> <span class="o">=</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="p">[</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c"># loop back to open-group node</span>
        <span class="n">loopCount</span> <span class="o">=</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">loopCounterStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">loopBoundMin</span><span class="p">,</span> <span class="n">loopBoundMax</span> <span class="o">=</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">loopBoundsStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># The nodeData for breaking out of the loop.  If loopCount is below</span>
        <span class="c"># loopBoundMin then we cannot break the loop yet.</span>
        <span class="c"># TODO: free up the stored boundNodeChildDict for breaks to empty stack level 0.</span>
        <span class="c"># TODO when the boundNodeChildList is set in repetition we don&#39;t need to copy it.</span>
        <span class="k">if</span> <span class="n">loopCount</span> <span class="o">&gt;=</span> <span class="n">loopBoundMin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">noBreak</span><span class="p">:</span>
            <span class="n">breakNodeData</span> <span class="o">=</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">replaceNode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">breakNodeData</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">replaceNode</span>
            <span class="n">breakNodeData</span><span class="o">.</span><span class="n">nodeIsEscape</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">breakNodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">breakNodeData</span><span class="o">.</span><span class="n">loopCounterStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">breakNodeData</span><span class="o">.</span><span class="n">loopBoundsStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">breakNodeDataList</span> <span class="o">=</span> <span class="p">[</span><span class="n">breakNodeData</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">breakNodeDataList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">magicElemNoLoop</span> <span class="ow">or</span> <span class="p">(</span><span class="n">refuseRevisits</span> <span class="ow">and</span>
                                    <span class="nb">id</span><span class="p">(</span><span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                                    <span class="ow">in</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">visitedRepNodeIdSet</span><span class="p">):</span>
            <span class="n">noLoop</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># The nodeData for continuing the loop.  If loopCount is above</span>
        <span class="c"># loopBoundMax then we cannot continue the loop and can only break.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">loopCount</span> <span class="o">&lt;</span> <span class="n">loopBoundMax</span> <span class="ow">or</span> <span class="n">loopBoundMax</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">noLoop</span><span class="p">:</span>
            <span class="n">loopNodeData</span> <span class="o">=</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">loopNodeData</span><span class="o">.</span><span class="n">nodeIsEscape</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">loopNodeData</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">loopNodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="p">[</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c"># loop back to open-group node</span>
            <span class="n">loopNodeData</span><span class="o">.</span><span class="n">loopCounterStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># increment the loop counter</span>
            <span class="n">loopNodeData</span><span class="o">.</span><span class="n">visitedRepNodeIdSet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">loopNodeData</span><span class="o">.</span><span class="n">node</span><span class="p">))</span>
            <span class="n">loopNodeDataList</span> <span class="o">=</span> <span class="p">[</span><span class="n">loopNodeData</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loopNodeDataList</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # &quot;Entangle&quot; any pairs, for greedy repetition-matching.</span>
<span class="sd">        if breakNodeDataList and loopNodeDataList:</span>
<span class="sd">           pairTuple = (id(breakNodeData), id(loopNodeData))</span>
<span class="sd">           if pairTuple in self.entangledStatePairsSet:</span>
<span class="sd">              self.stateKillList.append(....)......consider</span>
<span class="sd">           self.entangledStatePairsSet.add( (id(breakNodeData), id(loopNodeData)) )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Combine any nodes generated.</span>
        <span class="n">nodeDataList</span> <span class="o">=</span> <span class="n">breakNodeDataList</span> <span class="o">+</span> <span class="n">loopNodeDataList</span>

        <span class="c"># Detect problem with ill-formed pattern of a repetition as the only</span>
        <span class="c"># thing inside another repetition.  If the loop&#39;s break-point leads to</span>
        <span class="c"># a close-group and its loopback leads to a repetition then it is the</span>
        <span class="c"># open-repetition for the loop we just broke out of (because open and</span>
        <span class="c"># close groups are strictly nested).  So that is one way to detect an</span>
        <span class="c"># illegal nested repetition with no other elements in the outer</span>
        <span class="c"># repetition.  If not caught, this will cause an infinite recursion.</span>
        <span class="c"># (The infinite recursion occurs because the processing below will</span>
        <span class="c"># immediately process the repetition again, fast-forward to the end,</span>
        <span class="c"># and we&#39;re right back here again.)</span>
        <span class="c">#</span>
        <span class="c"># Note this could be allowed now, since infinite recursions are</span>
        <span class="c"># limited, but keep it as an error since it likely isn&#39;t intended.</span>
        <span class="k">if</span> <span class="n">breakNodeDataList</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">closeParenNode</span> <span class="o">=</span> <span class="n">closeParenNodeData</span><span class="o">.</span><span class="n">node</span>
                <span class="n">closeParenNode</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rGroup</span><span class="p">]</span>
                <span class="n">breakNodeData</span><span class="o">.</span><span class="n">loopbackStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">]</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">]</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Illegal nested repetition pattern with no&quot;</span>
                                        <span class="s">&quot; characters in the outer repetition.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span>
                    <span class="s">&quot;Index error on stack pop, probably mismatched parentheses.&quot;</span><span class="p">)</span>

        <span class="c"># The repetition meta-characters do not count as a character of the</span>
        <span class="c"># literal pattern being matched to queryElem, so run processNodeData on the</span>
        <span class="c"># computed nodes.</span>
        <span class="k">for</span> <span class="n">nodeData</span> <span class="ow">in</span> <span class="n">nodeDataList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">processNodeData</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">nodeData</span><span class="p">,</span> <span class="n">nextNodeDataList</span><span class="p">)</span>

        <span class="k">return</span>
</div>
<div class="viewcode-block" id="RegexTrieDict.processRepetitionParams"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDict.processRepetitionParams">[docs]</a>    <span class="k">def</span> <span class="nf">processRepetitionParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the sequence between the begin-repetition and the open-group</span>
<span class="sd">        that necessarily follows it.  Return a tuple (minIter, maxIter), with</span>
<span class="sd">        -1 for infinite maxIter.&quot;&quot;&quot;</span>
        <span class="n">tupleList</span> <span class="o">=</span> <span class="n">processElemListForEscapes</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">escape</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># The first value if only one, or the second otherwise.</span>
        <span class="n">firstVal</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># The second value, if there is one.</span>
        <span class="n">valSet</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span> <span class="ow">in</span> <span class="n">tupleList</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">repetition</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">valSet</span><span class="p">:</span>
                        <span class="c"># Note first value could default to zero if empty, but that would</span>
                        <span class="c"># add a redundant representation for such patterns.</span>
                        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;No value in first slot of two-place&quot;</span>
                                                <span class="s">&quot; repetition bounds specification.&quot;</span><span class="p">)</span>
                    <span class="n">firstVal</span> <span class="o">=</span> <span class="n">val</span> <span class="c"># a second value will follow</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Bad escaped character in repetition&quot;</span>
                                            <span class="s">&quot; bounds specification.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">digit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elemToDigitFun</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">val</span> <span class="o">+</span> <span class="n">digit</span>
                <span class="n">valSet</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">firstVal</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">firstVal</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="c">#</span>
    <span class="c"># Define a few aliases/synonyms for certain methods above.</span>
    <span class="c">#</span>
</div>
    <span class="sd">&quot;&quot;&quot;Synonym for delitem.&quot;&quot;&quot;</span>
    <span class="n">__delitem__</span> <span class="o">=</span> <span class="n">delitem</span>

    <span class="sd">&quot;&quot;&quot;Synonyms for insert.&quot;&quot;&quot;</span>
    <span class="n">__setitem__</span> <span class="o">=</span> <span class="n">setitem</span> <span class="o">=</span> <span class="n">insert</span>

</div>
<div class="viewcode-block" id="Matcher"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.Matcher">[docs]</a><span class="k">class</span> <span class="nc">Matcher</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insert elements sequentially, and check whether they match any regex</span>
<span class="sd">    patterns stored in the trie.  No trie modifications can be made between</span>
<span class="sd">    inserting any key elements and testing for matches, or ModifiedTrieError</span>
<span class="sd">    will be raised.&quot;&quot;&quot;</span>
    <span class="c"># Should resets be automatic when we get a ModifiedTrieError, or should we</span>
    <span class="c"># just let the error go?  Flag auto_reset_on_triemod?</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regexTrieDict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize with a particular RegexTrieDict instance.&quot;&quot;&quot;</span>
        <span class="c"># Note that we have to deal with patterns that match the empty string.</span>
        <span class="c"># We also want to wait until the last possible chance to do a reset,</span>
        <span class="c"># so that we get a NodeStateDataList for the root that is fresh with</span>
        <span class="c"># respect to any inserts which were done after the initialization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">regexTrieDict</span><span class="p">)</span>

<div class="viewcode-block" id="Matcher.next_key_elem"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.Matcher.next_key_elem">[docs]</a>    <span class="k">def</span> <span class="nf">next_key_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Inserts elem as the next elem of the key sequence.  (Note elem is</span>
<span class="sd">        usually a character if string patterns are stored in the tree.)&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchInProgress</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_to_root</span><span class="p">()</span>
        <span class="c"># Update the list of node data states according to the element elem.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">getNextNodesMeta</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">)</span>
        <span class="k">return</span>
</div>
<div class="viewcode-block" id="Matcher.cannot_match"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.Matcher.cannot_match">[docs]</a>    <span class="k">def</span> <span class="nf">cannot_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">insert_magic</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if no matches are possible with further elements inserted</span>
<span class="sd">        with next_key_elem.  This is determined by whether or not there are any</span>
<span class="sd">        active patterns in the current state.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matcher.reset"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.Matcher.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regexTrieDict</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the Matcher and frees any state memory.  A new trie can</span>
<span class="sd">        optionally be passed in.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regexTrieDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span> <span class="o">=</span> <span class="n">regexTrieDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchInProgress</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Free any memory for the garbage collector.</span>
</div>
    <span class="k">def</span> <span class="nf">_set_to_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility routine to set the state back to the root of the trie.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchInProgress</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">get_root_node_data_list</span><span class="p">()</span>

<div class="viewcode-block" id="Matcher.has_key"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.Matcher.has_key">[docs]</a>    <span class="k">def</span> <span class="nf">has_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests whether the sequence of elements inserted by the</span>
<span class="sd">        next_key_elem function match any of the regexp patterns stored</span>
<span class="sd">        in the RegexTrieDict.  Returns the number of matches.  Remember that</span>
<span class="sd">        any literal escapes in the trie must be escaped, but escapes in keySeq</span>
<span class="sd">        are always treated as literal.&quot;&quot;&quot;</span>
        <span class="c"># See get method for comments on what&#39;s going on here.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchInProgress</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_to_root</span><span class="p">()</span>
        <span class="n">tmpNodeDataList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">getNextNodesMeta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">magicElem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">)</span>
        <span class="n">matchedNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodeData</span> <span class="k">for</span> <span class="n">nodeData</span> <span class="ow">in</span> <span class="n">tmpNodeDataList</span>
                                              <span class="k">if</span> <span class="n">nodeData</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isLastElemOfKey</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchedNodes</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Matcher.get"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.Matcher.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the data items of all the stored strings which</span>
<span class="sd">        match the sequence of elements which have been inserted with the</span>
<span class="sd">        next_key_elem function.  That defines the keySeq and the match</span>
<span class="sd">        is based on the regexp patterns stored in the RegexTrieDict.  The</span>
<span class="sd">        default with no matches is to return the empty list.  Remember that any</span>
<span class="sd">        literal escapes in the trie must be escaped, but escapes in keySeq are</span>
<span class="sd">        always treated as literal.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchInProgress</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_to_root</span><span class="p">()</span>
        <span class="c"># We insert a null magic element, which by definition does not match</span>
        <span class="c"># any element actually in the string.  This has the side-effect of</span>
        <span class="c"># moving us past any self.rGroup closing elements, as well as past any</span>
        <span class="c"># patterns which can match zero times.  Note that inserting the empty</span>
        <span class="c"># keySeq will skip the loop above and go directly to the magic element</span>
        <span class="c"># queryElem below.  Get a temporary state after inserting the</span>
        <span class="c"># magicElem, so that we don&#39;t mess up the persistent self.nodeDataList</span>
        <span class="c"># for later searches.</span>
        <span class="n">tmpNodeDataList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">getNextNodesMeta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rtd</span><span class="o">.</span><span class="n">magicElem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeDataList</span><span class="p">)</span>
        <span class="n">matchedNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodeData</span> <span class="k">for</span> <span class="n">nodeData</span> <span class="ow">in</span> <span class="n">tmpNodeDataList</span>
                                              <span class="k">if</span> <span class="n">nodeData</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isLastElemOfKey</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matchedNodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matchedNodes</span><span class="p">]</span>

</div></div>
<div class="viewcode-block" id="charElemToInt"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.charElemToInt">[docs]</a><span class="k">def</span> <span class="nf">charElemToInt</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This routine is set in defineMetaElems as the default value of</span>
<span class="sd">    elemToDigitFun, which converts elements to digit values.  Used in calculating</span>
<span class="sd">    repetition bounds.  It is the default setting for elemToDigitFun, when</span>
<span class="sd">    the elements are characters.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">intVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Bad digit in repetition bounds specification&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intVal</span>

</div>
<div class="viewcode-block" id="charPatternMatchTest"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.charPatternMatchTest">[docs]</a><span class="k">def</span> <span class="nf">charPatternMatchTest</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">pattList</span><span class="p">,</span> <span class="n">rangeElem</span><span class="p">,</span> <span class="n">escapeElem</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This utility routine does a pattern-match for characters in the wildcard</span>
<span class="sd">    brackets.  It does depend on the elements being characters, since it calls</span>
<span class="sd">    a Python regexp.  This has the advantage of allowing all the</span>
<span class="sd">    special-characters in Python regexp wildcards to be used.  This is the</span>
<span class="sd">    default routine set in defineMetaElems as wildcardPattMatchFun, for when</span>
<span class="sd">    elements are characters.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pattList</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;No pattern in wildcard brackets.&quot;</span><span class="p">)</span>

    <span class="c"># print(&quot;debug charPatternMatchTest, query elem is&quot;, queryElem, &quot;pattList</span>
    <span class="c"># is&quot;, pattList)</span>

    <span class="n">pattTupleList</span> <span class="o">=</span> <span class="n">processElemListForEscapes</span><span class="p">(</span><span class="n">pattList</span><span class="p">,</span> <span class="n">escapeElem</span><span class="p">)</span>
    <span class="c">#print(&quot;debug elemList processed for escapes is&quot;, pattTupleList)</span>
    <span class="n">pythonString</span> <span class="o">=</span> <span class="s">&quot;^[&quot;</span>
    <span class="n">firstChar</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span> <span class="ow">in</span> <span class="n">pattTupleList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">firstChar</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="s">&quot;^&quot;</span><span class="p">:</span>
                <span class="n">pythonString</span> <span class="o">+=</span> <span class="s">&quot;^&quot;</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">!=</span> <span class="s">&quot;-&quot;</span><span class="p">:</span> <span class="n">pythonString</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">&quot;</span>
        <span class="n">pythonString</span> <span class="o">+=</span> <span class="n">elem</span>
        <span class="n">firstChar</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">pythonString</span> <span class="o">+=</span> <span class="s">&quot;]$&quot;</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pythonString</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">)</span>
    <span class="c"># print(&quot;debug charPatternMatchTest, pythonString is&quot;, pythonString,</span>
    <span class="c"># &quot;returning&quot;, bool(retval))</span>
    <span class="k">return</span> <span class="n">retval</span>

</div>
<div class="viewcode-block" id="charRangeTest"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.charRangeTest">[docs]</a><span class="k">def</span> <span class="nf">charRangeTest</span><span class="p">(</span><span class="n">charLower</span><span class="p">,</span> <span class="n">charUpper</span><span class="p">,</span> <span class="n">testChar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if testChar is in the range from char1 to char2, inclusive.</span>
<span class="sd">    Used in testing wildcard patterns in the default with character elements.&quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;debug in charRangeTest, comparing queryElem&quot;</span><span class="p">,</span>
          <span class="n">testChar</span><span class="p">,</span> <span class="s">&quot;with lower range&quot;</span><span class="p">,</span> <span class="n">charLower</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">charLower</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">ord</span><span class="p">(</span><span class="n">charUpper</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Second element in character range greater than lower.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="n">charLower</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">testChar</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">testChar</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">charUpper</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="genericWildcardMatchFun"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.genericWildcardMatchFun">[docs]</a><span class="k">def</span> <span class="nf">genericWildcardMatchFun</span><span class="p">(</span><span class="n">queryElem</span><span class="p">,</span> <span class="n">pattList</span><span class="p">,</span> <span class="n">rangeElem</span><span class="p">,</span> <span class="n">escapeElem</span><span class="p">,</span>
                            <span class="n">rangeTestFun</span><span class="o">=</span><span class="n">charRangeTest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This utility routine does a generic pattern-match in the wildcard</span>
<span class="sd">    brackets.  This routine is for general sequences of elements and does not</span>
<span class="sd">    depend on the elements being characters.  Only the function rangeTestFun</span>
<span class="sd">    needs to be defined.  The argument pattList is the content of a wildcard</span>
<span class="sd">    bracket, as a list of elements.  This function tests whether queryElem</span>
<span class="sd">    matches the character pattern.  To simply redefine the range-test function</span>
<span class="sd">    for elements, use something like:</span>

<span class="sd">       def myPattMatchFun(queryElem, pattList, rangeElem, escapeElem):</span>
<span class="sd">          return genericWildcardMatchFun(queryElem, pattList, rangeElem, escapeElem,</span>
<span class="sd">                                         rangeTestFun=myRangeTestFun)</span>

<span class="sd">    Then in calling defineMetaElems define wildcardPattMatchFun=myPattMatchFun.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#print(&quot;debug processing pattern pattList&quot;, pattList, &quot;for queryElem&quot;, queryElem)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pattList</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;No pattern in wildcard brackets.&quot;</span><span class="p">)</span>

    <span class="n">pattTupleList</span> <span class="o">=</span> <span class="n">processElemListForEscapes</span><span class="p">(</span><span class="n">pattList</span><span class="p">,</span> <span class="n">escapeElem</span><span class="p">)</span>
    <span class="n">foundRangeElem</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">escaped</span> <span class="ow">in</span> <span class="n">pattTupleList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">rangeElem</span><span class="p">:</span>
                <span class="n">foundRangeElem</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;Invalid escaped elem in wildcard pattern.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">foundRangeElem</span><span class="p">:</span>
                <span class="n">foundRangeElem</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">PatternMatchError</span><span class="p">(</span><span class="s">&quot;No elem before range elem in wildcard.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rangeTestFun</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">elem</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rangeTestFun</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">queryElem</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="processElemListForEscapes"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.processElemListForEscapes">[docs]</a><span class="k">def</span> <span class="nf">processElemListForEscapes</span><span class="p">(</span><span class="n">elemList</span><span class="p">,</span> <span class="n">escapeChar</span><span class="p">,</span> <span class="n">openGroup</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">closeGroup</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A utility routine which takes a list of possibly-escaped elements as an</span>
<span class="sd">    argument and returns a list of two-tuples.  The first element of a two-tuple</span>
<span class="sd">    is the actual character, and the second a boolean for whether or not it is</span>
<span class="sd">    escaped.  If openGroup and/or closeGroup is set it returns a three-tuple,</span>
<span class="sd">    where the last element gives the level of parenthesis nesting, starting at zero</span>
<span class="sd">    and increasing.  An open and its corresponding close have the same level.&quot;&quot;&quot;</span>
    <span class="n">escaped</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">tupleList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pCount</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elemList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">escapeChar</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="n">escaped</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="n">boolVal</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">openGroup</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">openGroup</span><span class="p">:</span> <span class="n">pCount</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">boolVal</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">openGroup</span> <span class="ow">or</span> <span class="n">closeGroup</span><span class="p">:</span> <span class="n">tupleList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elem</span><span class="p">,</span> <span class="n">boolVal</span><span class="p">,</span> <span class="n">pCount</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">tupleList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elem</span><span class="p">,</span> <span class="n">boolVal</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="n">escaped</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">closeGroup</span> <span class="ow">and</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">closeGroup</span><span class="p">:</span> <span class="n">pCount</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">tupleList</span>


<span class="c">#</span>
<span class="c"># Exception classes for RegexTrieDict.</span>
<span class="c">#</span>

</div>
<div class="viewcode-block" id="RegexTrieDictError"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.RegexTrieDictError">[docs]</a><span class="k">class</span> <span class="nc">RegexTrieDictError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="PatternMatchError"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.PatternMatchError">[docs]</a><span class="k">class</span> <span class="nc">PatternMatchError</span><span class="p">(</span><span class="n">RegexTrieDictError</span><span class="p">):</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="ModifiedTrieError"><a class="viewcode-back" href="../../wff_language.regex_trie_dict.html#wff_language.regex_trie_dict.ModifiedTrieError">[docs]</a><span class="k">class</span> <span class="nc">ModifiedTrieError</span><span class="p">(</span><span class="n">RegexTrieDictError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c">#</span>
<span class="c"># Run test cases below when invoked as a script.</span>
<span class="c">#</span>
</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pytest_helper</span>
    <span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="s">&quot;test/test_regex_trie_dict.py&quot;</span><span class="p">,</span> <span class="n">pytest_args</span><span class="o">=</span><span class="s">&quot;-v&quot;</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>