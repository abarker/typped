<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>wff_language.pratt_parser &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for wff_language.pratt_parser</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">A general Pratt parser module.</span>

<span class="sd">To use the PrattParser class you need to do these things:</span>

<span class="sd">    - Create an instance of the PrattParser class.  Example:</span>

<span class="sd">          pp = PrattParser()</span>

<span class="sd">    - Define each token that will appear in the language, including a string</span>
<span class="sd">      label and a regex for that kind of token.  If necessary, the appropriate</span>
<span class="sd">      `on_ties` values should be set to break ties in case of equal match</span>
<span class="sd">      lengths (the lexer will always take the longest, with ties broken by</span>
<span class="sd">      any `on_ties` values, defaulting to zero).  Examples:</span>

<span class="sd">          pp.define_token(&quot;number&quot;, r&quot;\d+&quot;)</span>
<span class="sd">          pp.define_token(&quot;lpar&quot;, r&quot;\(&quot;)</span>
<span class="sd">          pp.define_token(&quot;ast&quot;, r&quot;\*&quot;)</span>
<span class="sd">          pp.define_token(&quot;identifier&quot;, r&quot;[a-zA-Z_](?:\w*)&quot;, on_ties=-1)</span>
<span class="sd">    </span>
<span class="sd">    - Define the syntactical elements of the language that you are parsing.</span>
<span class="sd">      Any necessary token labels must have already been defined in the previous</span>
<span class="sd">      step.  The predefined syntax-definition methods of `PrattParser` take as</span>
<span class="sd">      arguments token labels, type information, etc.  They also take a string</span>
<span class="sd">      as a label for the resulting AST node (but this label can be used in any</span>
<span class="sd">      way desired, including in preconditions).  Examples:</span>

<span class="sd">          pp.define_literal(&quot;number_literal&quot;, &quot;number&quot;, val_type=&quot;number&quot;)</span>
<span class="sd">          pp.define_infix_operator(&quot;addition&quot;, &quot;plus&quot;, 10, Assoc.left,</span>
<span class="sd">                           val_type=&quot;number&quot;, arg_types=[&quot;number&quot;,&quot;number&quot;])</span>

<span class="sd">      If the predefined methods are not sufficient you might need to create a</span>
<span class="sd">      subclass of `PrattParser` to provide additional methods.  Note that</span>
<span class="sd">      literals must be defined as syntax, in addition to being defined as</span>
<span class="sd">      tokens.  If typing is to be used then any type information should also be</span>
<span class="sd">      set for the syntax elements.</span>

<span class="sd">    - Pass the parser a string of text to parse and save the resulting token</span>
<span class="sd">      tree.</span>

<span class="sd">          result_tree = pp.parse(&quot;x + (4 + 3)*5&quot;)</span>
<span class="sd">          print(result_tree.tree_repr())</span>

<span class="sd">    - You can optionally evaluate the resulting tree (if evaluate functions</span>
<span class="sd">      were supplied as kwargs for the appropriate methods) or convert it to an</span>
<span class="sd">      AST with a different type of nodes.</span>

<span class="sd">          eval_result = result_tree.evaluate_subtree()</span>
<span class="sd">          ast = result_tree.convert_to_AST(TokenNode_to_AST_converter_fun)</span>

<span class="sd">In reading the code, the correspondence between the naming convention used here</span>
<span class="sd">and Pratt&#39;s original naming conventions is given in this table:</span>

<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| this code                        | Pratt&#39;s terminology      |</span>
<span class="sd">+==================================+==========================+</span>
<span class="sd">| token precedence                 | left binding power, lbp  |</span>
<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| subexpression precedence         | right binding power, rbp |</span>
<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| head handler function            | null denotation, nud     |</span>
<span class="sd">+----------------------------------+--------------------------+</span>
<span class="sd">| tail handler function            | left denotation, led     |</span>
<span class="sd">+----------------------------------+--------------------------+</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">enum_wrapper</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">lexer</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Lexer</span><span class="p">,</span> <span class="n">TokenNode</span><span class="p">,</span> <span class="n">TokenSubclassSymbolTable</span><span class="p">,</span>
                   <span class="n">BufferIndexError</span><span class="p">,</span> <span class="n">LexerException</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pratt_types</span> <span class="kn">import</span> <span class="n">TypeTemplateTable</span><span class="p">,</span> <span class="n">TypeSpec</span><span class="p">,</span> <span class="n">TypeSig</span>

<span class="c"># TODO: Do preconditions really need labels?  Can the users just be left to</span>
<span class="c"># manage their own preconditions, or maybe a separate class can be defined to</span>
<span class="c"># manage them in a dict, maybe with some predefined ones?  Seems like it could</span>
<span class="c"># be separated out, and reduce complexity.  Is equality testing of</span>
<span class="c"># preconditions ever truly required?  If not, why not just use the function</span>
<span class="c"># objects and leave the user to manage their functions however they want.</span>

<span class="c">#</span>
<span class="c"># AST stuff</span>
<span class="c">#</span>

<span class="c"># This AST stuff should all be independent of the rest of the module, so it</span>
<span class="c"># can later be moved out.  Different applications will define it differently.</span>
<span class="c"># For implementing the AST nodes, use a shallow inheritance tree:</span>
<span class="c"># a base node with basic, default operations and specialized nodes for the</span>
<span class="c"># different possible types of AST nodes (maybe even an extra level for</span>
<span class="c"># functions???).</span>

<div class="viewcode-block" id="AST_Node"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node">[docs]</a><span class="k">class</span> <span class="nc">AST_Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The base class for nodes in the abstract syntax tree.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
<div class="viewcode-block" id="AST_Node.append_children"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node.append_children">[docs]</a>    <span class="k">def</span> <span class="nf">append_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">token_nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append all the arguments as children, also setting their parent to self.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">token_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">t</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span></div>
<div class="viewcode-block" id="AST_Node.old_repr"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node.old_repr">[docs]</a>    <span class="k">def</span> <span class="nf">old_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span> <span class="o">==</span> <span class="s">&quot;number&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;[literal {0}]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span> <span class="o">==</span> <span class="s">&quot;lpar&quot;</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;[lpar {0} rpar]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">str_val</span> <span class="o">=</span> <span class="s">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">str_val</span> <span class="o">+=</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">str_val</span> <span class="o">+=</span> <span class="s">&quot;]&quot;</span>
            <span class="k">return</span> <span class="n">str_val</span></div>
<div class="viewcode-block" id="AST_Node.value_repr"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node.value_repr">[docs]</a>    <span class="k">def</span> <span class="nf">value_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>
<div class="viewcode-block" id="AST_Node.label_repr"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node.label_repr">[docs]</a>    <span class="k">def</span> <span class="nf">label_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">)</span></div>
<div class="viewcode-block" id="AST_Node.summary_repr"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node.summary_repr">[docs]</a>    <span class="k">def</span> <span class="nf">summary_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;&gt;&quot;</span></div>
<div class="viewcode-block" id="AST_Node.tree_repr"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node.tree_repr">[docs]</a>    <span class="k">def</span> <span class="nf">tree_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_repr</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">string</span></div>
<div class="viewcode-block" id="AST_Node.string_repr"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_Node.string_repr">[docs]</a>    <span class="k">def</span> <span class="nf">string_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_repr</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;[&quot;</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">string_repr</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;]&quot;</span>
        <span class="k">return</span> <span class="n">string</span></div>
    <span class="n">__repr__</span> <span class="o">=</span> <span class="n">old_repr</span>

<span class="c"># TODO will AST nodes really need to be subclasses defined in a table, or</span>
<span class="c"># can the AST_node constructor (or some predefined method) just take a</span>
<span class="c"># TokenNode as an argument and spit out the corresponding AST node?</span>
<span class="c"># The init function itself could make subclasses of itself, store them</span>
<span class="c"># in a dict if desired, and return an instance -- but that seems weird.</span>
</div>
<div class="viewcode-block" id="AST_NodeTable"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_NodeTable">[docs]</a><span class="k">class</span> <span class="nc">AST_NodeTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Currently a dict of generated classes for tokens, indexed by token_label.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the symbol table.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ast_node_dict</span> <span class="o">=</span> <span class="p">{}</span> 
<div class="viewcode-block" id="AST_NodeTable.get_AST_subclass"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_NodeTable.get_AST_subclass">[docs]</a>    <span class="k">def</span> <span class="nf">get_AST_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the AST node subtype representing ast_label, defining it if </span>
<span class="sd">        necessary.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ast_label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast_node_dict</span><span class="p">:</span>
            <span class="n">AST_Subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast_node_dict</span><span class="p">[</span><span class="n">ast_label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># AST subclass has not been created.</span>
            <span class="k">class</span> <span class="nc">AST_Subclass</span><span class="p">(</span><span class="n">AST_Node</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string_form</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;Argument string_form, if not None, should be a list of</span>
<span class="sd">                    n+1 strings, where n is the number of children.  These strings</span>
<span class="sd">                    will be printed before, between, and after the children nodes</span>
<span class="sd">                    when the string form is produced.&quot;&quot;&quot;</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">AST_Subclass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span> <span class="c"># Call base class __init__.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">string_form</span> <span class="o">=</span> <span class="n">string_form</span>
            <span class="n">AST_Subclass</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">ast_label</span>
            <span class="n">AST_Subclass</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">ast_label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ast_node_dict</span><span class="p">[</span><span class="n">ast_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">AST_Subclass</span>
        <span class="k">return</span> <span class="n">AST_Subclass</span></div>
<div class="viewcode-block" id="AST_NodeTable.get_AST_node"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.AST_NodeTable.get_AST_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_AST_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="n">class_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_AST_subclass</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">ast_label</span><span class="p">)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">class_type</span><span class="p">()</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">value</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">token_label</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">token_label</span>
        <span class="k">return</span> <span class="n">instance</span>


<span class="c">#</span>
<span class="c"># TokenNode</span>
<span class="c">#</span>
</div></div>
<span class="sd">&quot;&quot;&quot; The `TokenNode` base class is defined in `lexer.py`.  It contains some of</span>
<span class="sd">the basic, general methods that apply to tokens and nodes in token trees.</span>
<span class="sd">Methods particular to an application need to be defined in a subclass.  The</span>
<span class="sd">function `create_token_subclass` returns a subclass of `TokenNode` which</span>
<span class="sd">represents tokens with a given token label.  The `PrattParser` class sets this</span>
<span class="sd">function to be used by its `TokenSubclassSymbolTable` instance in order to</span>
<span class="sd">create a token subclass for each kind of token.  Many methods particular to the</span>
<span class="sd">`PrattParser` application are added to the subclass.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="create_token_subclass"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.create_token_subclass">[docs]</a><span class="k">def</span> <span class="nf">create_token_subclass</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;This function is called from the `create_token_subclass` method of</span>
<span class="sd">    `TokenSubclassSymbolTable` when it needs to create a new subclass to begin</span>
<span class="sd">    with.  It should not be called directly.</span>
<span class="sd">    </span>
<span class="sd">    Create and return a new token subclass which will be modified and used</span>
<span class="sd">    to represent a particular kind of token.  Specifically, each scanned token</span>
<span class="sd">    matching the regex defined for tokens with a given token label is</span>
<span class="sd">    represented as an instance of the subclass created by calling this function</span>
<span class="sd">    (with further attributes, such as the token label, added to it).</span>
<span class="sd">    </span>
<span class="sd">    Using a separate subclass for each token label allows for attributes</span>
<span class="sd">    specific to a kind of token (including head and tail handler methods) to</span>
<span class="sd">    later be added to the class itself without conflicts.  This function</span>
<span class="sd">    returns a bare-bones subclass without any head or tail functions, etc.&quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">TokenSubclass</span><span class="p">(</span><span class="n">TokenNode</span><span class="p">):</span>
        <span class="n">handler_funs</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># Handler functions, i.e., head and tail handlers.</span>
        <span class="n">preconditions_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># Registered preconditions for this kind of token.</span>
        <span class="n">static_prec</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># The prec value for this kind of token, with default zero.</span>
        <span class="n">token_label</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Set to the actual value later by create_token_subclass.</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Initialize an instance of the subclass for a token of the kind</span>
<span class="sd">            labeled with `token_label`.  The `value` is the actual parsed</span>
<span class="sd">            string from the text.  This instance represents the token.&quot;&quot;&quot;</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">TokenSubclass</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span> <span class="c"># Call base class __init__.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="c"># Set from lex.token_generator; static value=None.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_type</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># The type of the token (after parsing).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># The full type signature after parsing.</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">prec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return the precedence for the token.  This is currently a static</span>
<span class="sd">            value for each type of token.  Later it may be dynamic value</span>
<span class="sd">            associated with the particular tail function which is selected in a</span>
<span class="sd">            given context.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_prec</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">register_precond_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precond_label</span><span class="p">,</span> <span class="n">precond_fun</span><span class="p">,</span> <span class="n">parser_global</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Save the preconditions function `precond_fun` in a dict keyed by</span>
<span class="sd">            `precond_label`.  If there is already a dict entry for the label,</span>
<span class="sd">            then the new function overwrites the old one (but they should</span>
<span class="sd">            compute the same thing if they have the same label, by definition</span>
<span class="sd">            of the uniqueness of the precondition labels).  The priority is</span>
<span class="sd">            also replaced.  Using labels allows equality between preconditions</span>
<span class="sd">            functions to be easily defined and tested, and allows for</span>
<span class="sd">            commonly-used precondition functions to be predefined.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">parser_global</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">preconditions_dict</span><span class="p">[</span><span class="n">precond_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">precond_fun</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">preconditions_dict</span><span class="p">[</span><span class="n">precond_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">precond_fun</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">unregister_precond_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precond_label</span><span class="p">,</span> <span class="n">parser_global</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Un-registers the precondition label and its associated function.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parser_global</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">preconditions_dict</span><span class="p">[</span><span class="n">precond_label</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">preconditions_dict</span><span class="p">[</span><span class="n">precond_label</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Attempt to unregister a preconditions &quot;</span>
                        <span class="s">&quot;function which is not registered.  The label is &#39;{0}&#39;&quot;</span>
                        <span class="s">&quot;and the token label is &#39;{1}&#39;.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">precond_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">))</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">lookup_precond_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precond_label</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Look up the preconditions function with label &quot;precond_label.&quot;</span>
<span class="sd">            First checks the dict local to the token subclass, and if that</span>
<span class="sd">            fails it checks the parser-global dict.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">precond_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preconditions_dict</span><span class="p">[</span><span class="n">precond_label</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">precond_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">preconditions_dict</span><span class="p">[</span><span class="n">precond_label</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;In function lookup_preconditions: the &quot;</span>
                        <span class="s">&quot; preconditions label &#39;{0}&#39; has not been registered.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">precond_label</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">precond_fun</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">register_handler_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head_or_tail</span><span class="p">,</span> <span class="n">handler_fun</span><span class="p">,</span>
                             <span class="n">precond_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">precond_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">precond_priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">type_sig</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Register a handler function (either head or tail) with the given</span>
<span class="sd">            properties.</span>
<span class="sd">            </span>
<span class="sd">            If no precondition label or function is provided a dummy</span>
<span class="sd">            precondition that always returns `True` will be used.  If</span>
<span class="sd">            `precond_priority` is set it will apply to that dummy function, but</span>
<span class="sd">            this will completely override anything with a lower priority.</span>

<span class="sd">            If `precond_label` is set but `precond_fun` is not then a</span>
<span class="sd">            preconditions function will be assumed to have already been</span>
<span class="sd">            registered for that label.  If `precond_fun` is also provided then</span>
<span class="sd">            it will be registered as a preconditions function with the given</span>
<span class="sd">            label.</span>
<span class="sd">            </span>
<span class="sd">            Data is saved on lists keyed by the value of `head_or_tail`</span>
<span class="sd">            (either `HEAD` or `TAIL`) in a dict, along with any specified</span>
<span class="sd">            precondition information.  The lists are sorted by priority.&quot;&quot;&quot;</span>
            <span class="c"># See if there is already a handler for the case, in which case the</span>
            <span class="c"># type sig is assumed to be overloaded.  There should only ever be</span>
            <span class="c"># one previous handler, at most, since only overloaded type info is</span>
            <span class="c"># retained, nothing else (with the precondition only the first</span>
            <span class="c"># would get called, anyway).</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">prev_handler_list</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler_funs</span><span class="p">[</span><span class="n">head_or_tail</span><span class="p">]</span>
                                                 <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">precond_label</span> <span class="p">]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_handler_list</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="c"># Multiple defs shouldn&#39;t happen.</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">prev_handler_list</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="n">prev_handler_list</span><span class="p">:</span>
                <span class="n">prev_type_sigs</span> <span class="o">=</span> <span class="n">prev_handler_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type_sigs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev_type_sigs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">prev_handler_list</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">overload_on_arg_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Value of self.overload_on_arg_types is False but &quot;</span>
                       <span class="s">&quot;attempt to redefine and possibly set multiple signatures for &quot;</span>
                       <span class="s">&quot;the {0} function for token with label &#39;{1}&#39; with &quot;</span>
                       <span class="s">&quot;preconditions label &#39;{2}&#39;.&quot;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span> <span class="n">precond_label</span><span class="p">))</span>

            <span class="c"># Type info is stored as an attribute of handler funs.</span>
            <span class="c"># For overloading, append the type_sig to pref_type_sigs, saving them all.</span>
            <span class="n">prev_type_sigs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">type_sig</span><span class="p">)</span>
            <span class="n">handler_fun</span><span class="o">.</span><span class="n">type_sigs</span> <span class="o">=</span> <span class="n">prev_type_sigs</span>

            <span class="k">if</span> <span class="n">precond_fun</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register_precond_fun</span><span class="p">(</span><span class="n">precond_label</span><span class="p">,</span> <span class="n">precond_fun</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">precond_label</span><span class="p">:</span>
                <span class="n">precond_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_precond_fun</span><span class="p">(</span><span class="n">precond_label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If neither precond_fun nor precond_label, use dummy True precond</span>
                <span class="k">def</span> <span class="nf">true_fun</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">lookbehind</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
                <span class="n">true_fun</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">precond_priority</span>
                <span class="n">precond_fun</span> <span class="o">=</span> <span class="n">true_fun</span>
                <span class="c"># Default precondition label is a tuple so that no string matches it.</span>
                <span class="n">precond_label</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;always-true-default-precondition&quot;</span><span class="p">,)</span>

            <span class="c"># Get the current list of head or tail handlers for the node, containing the</span>
            <span class="c"># [precond_label, precond_fun, precond_priority, handler_fun] sublists</span>
            <span class="c"># which have already been registered.</span>
            <span class="n">sorted_handler_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler_funs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span> <span class="p">[])</span>

            <span class="c"># Remove any existing handler with the same precondition label.</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_handler_list</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">sorted_handler_list</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">precond_label</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">sorted_handler_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

            <span class="c"># Insert the data in the selected head or tail list, in priority-sorted order.</span>
            <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">precond_label</span><span class="p">,</span> <span class="n">precond_fun</span><span class="p">,</span> <span class="n">precond_priority</span><span class="p">,</span> <span class="n">handler_fun</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sorted_handler_list</span><span class="p">:</span>
                <span class="n">sorted_handler_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">handler_funs</span><span class="p">[</span><span class="n">head_or_tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_handler_list</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_handler_list</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">precond_priority</span> <span class="o">==</span> <span class="n">sorted_handler_list</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">raise_exception_on_precondition_ties</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Two preconditions for the token&quot;</span>
                                <span class="s">&quot; subclass named &#39;{0}&#39; for token with label &#39;{1}&#39; have&quot;</span>
                                <span class="s">&quot; the same priority, {2}.  Their precondition labels&quot;</span>
                                <span class="s">&quot; are &#39;{3}&#39; and &#39;{4}&#39;.  If precondition labels are&quot;</span>
                                <span class="s">&quot; the same there may be a redefinition. Set the flag&quot;</span>
                                <span class="s">&quot; False if you actually want to allow precondition&quot;</span>
                                <span class="s">&quot; ties.&quot;</span> <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span>
                                    <span class="n">precond_priority</span><span class="p">,</span> <span class="n">precond_label</span><span class="p">,</span>
                                    <span class="n">sorted_handler_list</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">precond_priority</span> <span class="o">&gt;=</span> <span class="n">sorted_handler_list</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">sorted_handler_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data_list</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="k">return</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">unregister_handler_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head_or_tail</span><span class="p">,</span>
                                   <span class="n">precond_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">type_sig</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                   <span class="n">all_handlers</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Unregister the previously-registered handler function (head or</span>
<span class="sd">            tail).  If `all_handlers` is set then all head or tail handlers (as</span>
<span class="sd">            selected by `head_or_tail`) are unregistered.  overloads are</span>
<span class="sd">            unregistered.  No error is raised if a matching handler function is</span>
<span class="sd">            not found.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">all_handlers</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler_funs</span><span class="p">[</span><span class="n">head_or_tail</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">pass</span>
                <span class="k">return</span>

            <span class="c"># Item format for sorted_handler_list is:</span>
            <span class="c">#     [precond_label, precond_fun, precond_priority, handler_fun]</span>
            <span class="n">sorted_handler_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler_funs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sorted_handler_list</span><span class="p">:</span> <span class="k">return</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_handler_list</span><span class="p">))):</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">sorted_handler_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">precond_label</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">handler_fun</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">new_handler_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">handler_fun</span><span class="o">.</span><span class="n">type_sigs</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">type_sig</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_handler_sigs</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">sorted_handler_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c"># No type sigs at all, remove item.</span>
                    <span class="k">continue</span>
                <span class="n">handler_fun</span><span class="o">.</span><span class="n">type_sigs</span> <span class="o">=</span> <span class="n">new_handler_sigs</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">lookup_handler_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head_or_tail</span><span class="p">,</span> <span class="n">lex</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lookbehind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                               <span class="n">precond_label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Look up and return the handler function for the given</span>
<span class="sd">            subexpression position in `head_or_tail`, based on the current state.</span>
<span class="sd">            Either the `lex` parameter or the `precond_label` parameter must be</span>
<span class="sd">            set.  If `lex` is set it will be passed to the precondition</span>
<span class="sd">            functions as an argument, and similarly for `lookbehind`.  This</span>
<span class="sd">            method evaluates each preconditions function in the sorted list for</span>
<span class="sd">            the kind of handler and this kind of token, returning the handler</span>
<span class="sd">            function associated with the first one which evaluates to `True`.</span>
<span class="sd">            Raises `NoHandlerFunctionDefined` if no handler function is found.</span>
<span class="sd">            </span>
<span class="sd">            If the parameter `precond_label` is set this method returns the</span>
<span class="sd">            handler function which *would be* returned, assuming that that were</span>
<span class="sd">            the label of the &quot;winning&quot; precondition function.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sorted_handler_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler_funs</span><span class="p">[</span><span class="n">head_or_tail</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;No {0} handler functions at all are defined&quot;</span>
                        <span class="s">&quot; for tokens with token label &#39;{1}&#39;.  Current and token&quot;</span>
                        <span class="s">&quot; value is &#39;{2}&#39;.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">precond_label</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pre_fun_label</span><span class="p">,</span> <span class="n">pre_fun</span><span class="p">,</span> <span class="n">pre_prior</span><span class="p">,</span> <span class="n">handler</span> <span class="ow">in</span> <span class="n">sorted_handler_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pre_fun_label</span> <span class="o">==</span> <span class="n">precond_label</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">pre_fun</span>

            <span class="k">for</span> <span class="n">pre_fun_label</span><span class="p">,</span> <span class="n">pre_fun</span><span class="p">,</span> <span class="n">pre_prior</span><span class="p">,</span> <span class="n">handler</span> <span class="ow">in</span> <span class="n">sorted_handler_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pre_fun</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">lookbehind</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">handler</span>

            <span class="k">raise</span> <span class="n">NoHandlerFunctionDefined</span><span class="p">(</span><span class="s">&quot;No {0} handler function matched the &quot;</span>
                    <span class="s">&quot;preconditions for token with token label &#39;{1}&#39; and value &#39;{2}&#39;.&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">dispatch_and_call_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head_or_tail</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> 
                                      <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lookbehind</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Look up and call the handler function, passing along the arguments.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">head_or_tail</span> <span class="o">==</span> <span class="n">HEAD</span><span class="p">:</span>
                <span class="n">fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_handler_fun</span><span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">lex</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">head_or_tail</span> <span class="o">==</span> <span class="n">TAIL</span><span class="p">:</span>
                <span class="n">fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_handler_fun</span><span class="p">(</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">lookbehind</span><span class="o">=</span><span class="n">lookbehind</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Bad first argument to dispatch_and_call_handler&quot;</span>
                        <span class="s">&quot; function: must be HEAD or TAIL or equivalent.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">process_and_check_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun_object</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">,</span>
                                   <span class="n">typesig_override</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">in_tree</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                   <span class="n">repeat_args</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;This routine should always be called from inside the individual</span>
<span class="sd">            head and tail functions just before they return a value.  It sets</span>
<span class="sd">            some attributes and checks that the actual types match some type</span>
<span class="sd">            signature.</span>
<span class="sd">            </span>
<span class="sd">            The `fun_object` argument should be a reference to the function</span>
<span class="sd">            that called this routine.  This is needed to access signature data</span>
<span class="sd">            which is pasted onto the function object as attributes.  Inside a</span>
<span class="sd">            handler function this function object is referenced simply by the</span>
<span class="sd">            name of the function.</span>
<span class="sd">            </span>
<span class="sd">            The `typesig_override` argument is a `TypeSig` other than `None`</span>
<span class="sd">            then it will be *assigned* to the node as its signature after all</span>
<span class="sd">            checking, overriding any other settings.  This is useful for</span>
<span class="sd">            handling things like parentheses and brackets which inherit the</span>
<span class="sd">            type of their child (assuming they are kept as nodes in the parse</span>
<span class="sd">            tree).</span>
<span class="sd">            </span>
<span class="sd">            If `in_tree` is `False` then the node for this token will not</span>
<span class="sd">            appear in the final token tree: its children will replace it, in</span>
<span class="sd">            order, in its parent node&#39;s list of children.  This does not</span>
<span class="sd">            (currently) work for the root node, which has no parent.</span>
<span class="sd">            </span>
<span class="sd">            Setting `in_tree` to `False` can be useful for things like unary</span>
<span class="sd">            plus and parentheses which are not wanted in the final tree.</span>
<span class="sd">            </span>
<span class="sd">            If `repeat_args` is true then the argument types for defined type</span>
<span class="sd">            signatures will be expanded to match the actual number of</span>
<span class="sd">            arguments, if possible, by repeating them some integer number of</span>
<span class="sd">            times.&quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ast_label</span> <span class="o">=</span> <span class="n">ast_label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_tree</span> <span class="o">=</span> <span class="n">in_tree</span>
            <span class="k">if</span> <span class="n">eval_fun</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_evaluate_subtree_method</span><span class="p">(</span><span class="n">eval_fun</span><span class="p">)</span>
           
            <span class="c"># Process the children to implement in_tree, if set.</span>
            <span class="n">modified_children</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">in_tree</span><span class="p">:</span> <span class="n">modified_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">modified_children</span> <span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">children</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">modified_children</span>

            <span class="c"># Get all the sigs for the node while we have access to fun_object.</span>
            <span class="n">all_sigs</span> <span class="o">=</span> <span class="n">fun_object</span><span class="o">.</span><span class="n">type_sigs</span>

            <span class="c"># Perform the type-checking unless the skip option is set.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">skip_type_checking</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">overload_on_ret_types</span><span class="p">:</span> <span class="c"># One-pass.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_types</span><span class="p">(</span><span class="n">all_sigs</span><span class="p">,</span> <span class="n">repeat_args</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c"># Two-pass.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_types</span><span class="p">(</span><span class="n">all_sigs</span><span class="p">,</span> <span class="n">repeat_args</span><span class="p">,</span> <span class="n">first_pass_of_two</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="c"># If we have a *unique* matching sig, run pass two on the</span>
                    <span class="c"># subtree.  In this case, since the signature is fixed by</span>
                    <span class="c"># argument types (regardless of where the top-down pass</span>
                    <span class="c"># starts from) we can in this case resolve the types in the</span>
                    <span class="c"># subtree early.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">check_types_in_tree_second_pass</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">typesig_override</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">typesig</span> <span class="o">=</span> <span class="n">typesig_override</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_type</span> <span class="o">=</span> <span class="n">typesig_override</span><span class="o">.</span><span class="n">val_type</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">_check_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_sigs</span><span class="p">,</span> <span class="n">repeat_args</span><span class="p">,</span> <span class="n">first_pass_of_two</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Utility function called from `process_and_check_node` to check</span>
<span class="sd">            the actual types against their signatures.  It assumes a single</span>
<span class="sd">            pass unless `first_pass_of_two` is set.  The `all_sigs` argument is</span>
<span class="sd">            a list (or iterable) of all the possible signatures for the</span>
<span class="sd">            node.&quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first_pass_of_two</span><span class="p">:</span>
                <span class="c"># Ordinary case, each child c has a unique c.type_sig already set.</span>
                <span class="n">list_of_child_sig_lists</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">type_sig</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># First pass case, multiple sigs in child&#39;s self.matching_sigs list.</span>
                <span class="n">list_of_child_sig_lists</span> <span class="o">=</span> <span class="p">[</span> <span class="n">c</span><span class="o">.</span><span class="n">matching_sigs</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="p">]</span>

            <span class="c"># Reduce to only the signatures that the types of the children match.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="o">.</span><span class="n">get_all_matching_sigs</span><span class="p">(</span>
                                      <span class="n">all_sigs</span><span class="p">,</span> <span class="n">list_of_child_sig_lists</span><span class="p">,</span>
                                      <span class="n">tnode</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeat_args</span><span class="o">=</span><span class="n">repeat_args</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">first_pass_of_two</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">,</span>
                            <span class="s">&quot;Actual argument types match multiple signatures.&quot;</span><span class="p">)</span>

                <span class="c"># Found a unique signature; set the node&#39;s val_type to its val_type.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Save sig for semantic actions.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="o">.</span><span class="n">val_type</span> <span class="c"># Set the node type.</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;matching_sigs&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">check_types_in_tree_second_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Recursively run the second pass on the token subtree with the</span>
<span class="sd">            `self` node as the root.  Currently still needs to be explicitly</span>
<span class="sd">            called for the root of the final parse tree, from the `PrattParser`</span>
<span class="sd">            method `parse`, as well as from the checking routines here to do</span>
<span class="sd">            partial checks on subtrees which are resolvable.&quot;&quot;&quot;</span>
            <span class="n">unresolved_children</span> <span class="o">=</span> <span class="p">[</span> 
                    <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="s">&quot;matching_sigs&quot;</span><span class="p">)</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_types_pass_two</span><span class="p">()</span> <span class="c"># Call first on self to do top-down.</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">unresolved_children</span><span class="p">:</span> <span class="c"># Recurse on unprocessed children.</span>
                <span class="n">child</span><span class="o">.</span><span class="n">check_types_in_tree_second_pass</span><span class="p">()</span>
            <span class="c"># Delete childrens&#39; matching_sigs lists after they are no longer needed.</span>
            <span class="c"># This also acts as an indicator that the node has been resolved.</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">unresolved_children</span><span class="p">:</span> <span class="nb">delattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&quot;matching_sigs&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">:</span> <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;matching_sigs&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_types_pass_two</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;A second pass is only used when overloading on return types is</span>
<span class="sd">            allowed.  It is a top-down pass where each node chooses a unique</span>
<span class="sd">            final signature for each of its children.  It depends on the</span>
<span class="sd">            node attribute `self.matching_sigs` having been set in the first</span>
<span class="sd">            pass.&quot;&quot;&quot;</span>
            <span class="c"># On FIRST pass: on the way *up* the tree get all the signature</span>
            <span class="c"># types for a node which match in arguments for *some* possible</span>
            <span class="c"># return-type choice of the children.  Same as the one-pass</span>
            <span class="c"># version, but now sets of possibilities are allowed and state is</span>
            <span class="c"># saved for the second pass to use: the list of matching sigs is</span>
            <span class="c"># saved with the node in self.matched_sigs.</span>
            <span class="c">#</span>
            <span class="c"># Summary: first pass, bottom-up, find all sigs that match possible</span>
            <span class="c"># val_types of the node&#39;s children, across all arguments.</span>
            <span class="c">#</span>
            <span class="c"># After the first pass the root should have a unique sig; if not</span>
            <span class="c"># there is ambiguity.  (Each node saved a set of sigs that is</span>
            <span class="c"># satisfiable by some realizable choice of child sigs, and parents</span>
            <span class="c"># can force children to assume any of their possible types).</span>
            <span class="c"># </span>
            <span class="c"># On SECOND pass: On the way *down* the tree, parents choose one</span>
            <span class="c"># sig as final for each child and set it in that child&#39;s node as</span>
            <span class="c"># the new self.matching_sigs.  This should always be a unique sig;</span>
            <span class="c"># otherwise there is ambibuity.  </span>
            <span class="c">#</span>
            <span class="c"># Summary: second pass, top-down, root is unique and parents assign</span>
            <span class="c"># and set the (unique) signature for each of their children.</span>
            <span class="c">#</span>
            <span class="c"># Note that this algorithm works just as well if the second pass is</span>
            <span class="c"># run on each subtree where the root has a unique signature, and</span>
            <span class="c"># the recursion is only down to subtrees with roots having a unique</span>
            <span class="c"># signature.  This yields partial results and some error conditions</span>
            <span class="c"># sooner, and is what is implemented here.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># The root case needs this.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">,</span>
                        <span class="s">&quot;Ambiguous type resolution (second pass).  Possible type &quot;</span>
                        <span class="s">&quot;assignments for the children/arguments of the token node match&quot;</span>
                        <span class="s">&quot; {0} possible node signatures: {1}.  Uniqueness is required.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">))</span>

            <span class="c"># We have a unique signature; set the node&#39;s type attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Save signature for semantic actions.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="o">.</span><span class="n">val_type</span> <span class="c"># Set the type for the node.</span>

            <span class="k">def</span> <span class="nf">get_child_sigs_matching_return_arg_type</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">return_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">matching_sigs</span> 
                        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">val_type</span> <span class="o">==</span> <span class="n">return_type</span> <span class="ow">or</span> <span class="n">return_type</span> <span class="ow">is</span> <span class="bp">None</span> <span class="p">]</span>

            <span class="c"># Update the matching_sigs attribute for each child (should be singleton).</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&quot;matching_sigs&quot;</span><span class="p">):</span> <span class="k">continue</span> <span class="c"># Already resolved.</span>
                <span class="n">matched_sigs</span> <span class="o">=</span> <span class="n">get_child_sigs_matching_return_arg_type</span><span class="p">(</span>
                                                 <span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_sig</span><span class="o">.</span><span class="n">arg_types</span><span class="p">[</span><span class="n">count</span><span class="p">])</span>
                <span class="c"># From the first pass, we know at least one child sig matches.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_sigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="c">#if len(matched_sigs) == 0:</span>
                <span class="c">#    child._raise_type_mismatch_error(matched_sigs,</span>
                <span class="c">#        &quot;Token node has no signatures with return type matching type of &quot;</span>
                <span class="c">#        &quot;parent (pass two). Parent expects type &#39;{0}&#39;.  Defined &quot;</span>
                <span class="c">#        &quot;signatures are: {1}.&quot;.format(self.val_type, child.matching_sigs))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_sigs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c"># Recursion could catch this on the next step, but better err msg.</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">_raise_type_mismatch_error</span><span class="p">(</span><span class="n">matched_sigs</span><span class="p">,</span>
                        <span class="s">&quot;Token node has multiple signatures with return type matching &quot;</span>
                        <span class="s">&quot;type of parent (pass two). Parent expects type &#39;{0}&#39;.  Defined &quot;</span>
                        <span class="s">&quot;signatures are: {1}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">matching_sigs</span><span class="p">))</span>
                <span class="n">child</span><span class="o">.</span><span class="n">matching_sigs</span> <span class="o">=</span> <span class="n">matched_sigs</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">_raise_type_mismatch_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matching_sigs</span><span class="p">,</span> <span class="n">basic_msg</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Raise an error, printing a helpful diagnostic message.&quot;&quot;&quot;</span>
            <span class="n">diagnostic</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;  Current token node has value &#39;{0}&#39; and label &#39;{1}&#39;.  The&quot;</span>
                         <span class="s">&quot; children/arguments have labels and values of {2} and &quot;</span>
                         <span class="s">&quot;types {3}.  The matching signatures &quot;</span>
                         <span class="s">&quot;are {4}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span>
                             <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">summary_repr</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">),</span>
                             <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">val_type</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">),</span> <span class="n">matching_sigs</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">basic_msg</span> <span class="o">+</span> <span class="n">diagnostic</span><span class="p">)</span>

        <span class="c">#</span>
        <span class="c"># Evaluations and semantic actions.</span>
        <span class="c">#</span>

        <span class="c"># TODO TODO TODO The evaluations need to depend on the final type that</span>
        <span class="c"># is resolved.  The eval funs are passed in with a type, and should be</span>
        <span class="c"># stored with that handler function which is set (like the type info</span>
        <span class="c"># itself).  This evaluate interface needs to be re-worked slightly to</span>
        <span class="c"># accomodate that, and the code below that uses the</span>
        <span class="c"># add_evaluate_subtree_method needs to be modified.</span>
        <span class="k">def</span> <span class="nf">add_evaluate_subtree_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Add a method called `evaluate_subtree` to the instance of the class.</span>
<span class="sd">            The function `eval_fun` passed in should take self as its first</span>
<span class="sd">            argument.  It should return the result of evaluating the node,</span>
<span class="sd">            calculated from its own attributes and from the results of calling</span>
<span class="sd">            `c.evaluate_subtree()` for each child `c`.  For example, an addition</span>
<span class="sd">            node would return the results of adding the evaluations from the</span>
<span class="sd">            children.  If this is defined for all the nodes in a tree it can be</span>
<span class="sd">            called from the root to evaluate the full tree.&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_subtree</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">semantic_action</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># TODO decide how to implement and when to call.  Should probably</span>
            <span class="c"># be relative to typesigs/handlers rather than nodes in particular.</span>
            <span class="k">pass</span>

        <span class="c">#</span>
        <span class="c"># Some representations that apply to the subclasses.</span>
        <span class="c">#</span>

        <span class="k">def</span> <span class="nf">summary_repr_with_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="s">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">token_label</span><span class="p">)</span> <span class="o">+</span> 
                    <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> 
                    <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_type</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;&gt;&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">tree_repr_with_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_repr_with_types</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">tree_repr_with_types</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">string</span>

        <span class="k">def</span> <span class="nf">string_repr_with_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_repr_with_types</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;(&quot;</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">string_repr_with_types</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="n">string</span> <span class="o">+=</span> <span class="s">&quot;)&quot;</span>
            <span class="k">return</span> <span class="n">string</span>

    <span class="k">return</span> <span class="n">TokenSubclass</span> <span class="c"># Return from create_token_subclass function.</span>

<span class="c">#</span>
<span class="c"># Parser</span>
<span class="c">#</span>
</div>
<div class="viewcode-block" id="Assoc"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.Assoc">[docs]</a><span class="k">class</span> <span class="nc">Assoc</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An enumeration of the kinds of association for infix operators.&quot;&quot;&quot;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c"># Some convenient constants, which double as strings to use in error messages.</span></div>
<span class="n">HEAD</span> <span class="o">=</span> <span class="s">&quot;head&quot;</span>
<span class="n">TAIL</span> <span class="o">=</span> <span class="s">&quot;tail&quot;</span>

<div class="viewcode-block" id="PrattParser"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser">[docs]</a><span class="k">class</span> <span class="nc">PrattParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A parser object.  Each parser object contains its own symbol table for tokens</span>
<span class="sd">    and its own lexer.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_lookahead_tokens</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">lexer</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                       <span class="n">type_table</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                       <span class="n">skip_type_checking</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                       <span class="n">overload_on_arg_types</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                       <span class="n">overload_on_ret_types</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                       <span class="n">multi_expression</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the parser.  If a Lexer is passed in the parser will use</span>
<span class="sd">        that lexer and its symbol table, otherwise a new one is created.</span>
<span class="sd">        Setting `skip_type_checking=True` is slightly faster if typing is not</span>
<span class="sd">        being used at all.  Setting `overload_on_ret_types` requires an extra</span>
<span class="sd">        walk of the token tree, and implies overloading on argument types.</span>
<span class="sd">        If `multi_expression` is set then multiple expressions will be parsed</span>
<span class="sd">        from the token stream until it reaches the end, and a list of token</span>
<span class="sd">        trees will be returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lexer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span> <span class="o">=</span> <span class="n">lexer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span> <span class="o">=</span> <span class="n">lexer</span><span class="o">.</span><span class="n">symbol_table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span> <span class="o">=</span> <span class="n">TokenSubclassSymbolTable</span><span class="p">(</span>
                                   <span class="n">token_subclassing_fun</span><span class="o">=</span><span class="n">create_token_subclass</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span> <span class="o">=</span> <span class="n">Lexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="p">,</span>
                                         <span class="n">num_lookahead_tokens</span><span class="o">=</span><span class="n">num_lookahead_tokens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">type_table</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span> <span class="o">=</span> <span class="n">type_table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span> <span class="o">=</span> <span class="n">TypeTemplateTable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_lookahead_tokens</span> <span class="o">=</span> <span class="n">num_lookahead_tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span> <span class="c"># To access parser from a lex argument alone.</span>
        <span class="n">preconditions_dict</span> <span class="o">=</span> <span class="p">{}</span> <span class="c"># Registered parser-global preconditions functions.</span>
        <span class="c"># If exceptions are not raised on ties below, the last-set one has precedence.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_exception_on_precondition_ties</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_label</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multi_expression</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># Whether to parse multiple expressions.</span>
        <span class="c"># Type-checking options below; these can be changed between calls to `parse`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_type_checking</span> <span class="o">=</span> <span class="n">skip_type_checking</span> <span class="c"># Skip all type checks, faster.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_arg_types</span> <span class="o">=</span> <span class="n">overload_on_arg_types</span> <span class="c"># Raise error on mult defs?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_ret_types</span> <span class="o">=</span> <span class="n">overload_on_ret_types</span> <span class="c"># Requires extra processing.</span>
        <span class="k">if</span> <span class="n">overload_on_ret_types</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_arg_types</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c">#</span>
    <span class="c"># Methods dealing with tokens.</span>
    <span class="c">#</span>

    <span class="c"># TODO these need undefine methods</span>

<div class="viewcode-block" id="PrattParser.define_token"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_token">[docs]</a>    <span class="k">def</span> <span class="nf">define_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A convenience function; calls the Lexer `define_token` method.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span>
                <span class="n">token_label</span><span class="p">,</span> <span class="n">regex_string</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=</span><span class="n">on_ties</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.undefine_token"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.undefine_token">[docs]</a>    <span class="k">def</span> <span class="nf">undefine_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A convenience function; calls the Lexer `undefine_token` method.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">undefine_token</span><span class="p">(</span><span class="n">token_label</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_begin_and_end_tokens"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_begin_and_end_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">define_begin_and_end_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin_token_label</span><span class="p">,</span> <span class="n">end_token_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls the `Lexer` to define_begin_and_end_tokens.  The subclasses are</span>
<span class="sd">        then given initial head and tail functions for use in the Pratt parser.</span>
<span class="sd">        To use the `PrattParser` this method must be called, not the method</span>
<span class="sd">        of `Lexer` with the same name.  Returns a tuple containing the new begin</span>
<span class="sd">        and end `TokenNode` subclasses.&quot;&quot;&quot;</span>
        <span class="c"># Call lexer to create and register the begin and end tokens.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">define_begin_and_end_tokens</span><span class="p">(</span><span class="n">begin_token_label</span><span class="p">,</span> <span class="n">end_token_label</span><span class="p">)</span>
        <span class="c"># begin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin_token_label</span> <span class="o">=</span> <span class="n">begin_token_label</span>
        <span class="k">def</span> <span class="nf">begin_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Called head of begin token.&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">begin_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Called tail of begin token.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">begin_token_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span>
                               <span class="n">begin_token_label</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">begin_head</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="n">begin_tail</span><span class="p">)</span>
        <span class="c"># end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_token_label</span> <span class="o">=</span> <span class="n">end_token_label</span>
        <span class="k">def</span> <span class="nf">end_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Called head of end token.&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">end_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Called tail of end token.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_token_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span>
                                  <span class="n">end_token_label</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">end_head</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="n">end_tail</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin_token_subclass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_token_subclass</span>
</div>
<div class="viewcode-block" id="PrattParser.define_jop_token"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_jop_token">[docs]</a>    <span class="k">def</span> <span class="nf">define_jop_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jop_token_label</span><span class="p">,</span> <span class="n">ignored_token_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a token for the juxtaposition operator.  This token is not</span>
<span class="sd">        stored in the lexer&#39;s symbol table and has no regex pattern.  An</span>
<span class="sd">        instance is inserted in `recursive_parse` when it is inferred to be</span>
<span class="sd">        present based based on type information in the definition of the</span>
<span class="sd">        juxtaposition operator.  This method must be called before a</span>
<span class="sd">        juxtaposition operator can be used.  The parameter `jop_token_label` is the</span>
<span class="sd">        label for the newly-created token representing the juxtaposition</span>
<span class="sd">        operator.  The `ignored_token_label` parameter is the label of an</span>
<span class="sd">        ignored token which must be present for a jop to be inferred.  Some</span>
<span class="sd">        token is required; usually it will be a token for spaces and tabs.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;A jop token is already defined.  It must be &quot;</span>
                                  <span class="s">&quot;undefined before defining an new one.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_label</span> <span class="o">=</span> <span class="n">jop_token_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jop_ignored_token_label</span> <span class="o">=</span> <span class="n">ignored_token_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">create_token_subclass</span><span class="p">(</span>
                                                           <span class="n">jop_token_label</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">jop_token_subclass</span>
</div>
<div class="viewcode-block" id="PrattParser.modify_token_subclass"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.modify_token_subclass">[docs]</a>    <span class="k">def</span> <span class="nf">modify_token_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                       <span class="n">precond_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">precond_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">precond_priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look up the subclass of base class `TokenNode` corresponding to the</span>
<span class="sd">        label `token_label` (in the symbol table) and modify it.  A token with</span>
<span class="sd">        that label must already be in the symbol table, or an exception will be</span>
<span class="sd">        raised.  Return the modified class. Sets any given head or tail functions</span>
<span class="sd">        as attributes of the class.  If `tail` is set then the prec will also be</span>
<span class="sd">        set unless `prec` is `None`.  For a head `prec` is ignored.  If `tail` is</span>
<span class="sd">        set and `prec` is `None` then the prec value defaults to zero.  If `head`</span>
<span class="sd">        or `tail` is set and `precond_label` is also set then the head or tail</span>
<span class="sd">        function will be associated with the preconditions function for that</span>
<span class="sd">        label.  If `precond_fun` is also set then it will first be registered</span>
<span class="sd">        with the label `precond_label` (which must be present in that case).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg_types</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;The arg_types argument to token_subclass must&quot;</span>
                    <span class="s">&quot; be None or an iterable returning type labels (e.g., a list&quot;</span>
                    <span class="s">&quot; or tuple).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tail</span> <span class="ow">and</span> <span class="n">prec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">prec</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">token_label</span><span class="p">):</span>
            <span class="n">TokenSubclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">get_token_subclass</span><span class="p">(</span><span class="n">token_label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;In call to mod_token_subclass: subclass for&quot;</span>
                    <span class="s">&quot; token labeled &#39;{0}&#39; has not been defined.  Maybe try&quot;</span>
                    <span class="s">&quot; calling `define_token` first.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">token_label</span><span class="p">))</span>
            <span class="c"># This used to just create a subclass, but that can mask errors.</span>
            <span class="c">#TokenSubclass = self.symbol_table.create_token_subclass(token_label)</span>

        <span class="c"># Save a reference to the PrattParser, so nodes can access it if they need to.</span>
        <span class="n">TokenSubclass</span><span class="o">.</span><span class="n">parser_instance</span> <span class="o">=</span> <span class="bp">self</span> <span class="c"># maybe weakref later</span>

        <span class="k">if</span> <span class="n">tail</span><span class="p">:</span> <span class="n">TokenSubclass</span><span class="o">.</span><span class="n">static_prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="c"># Ignore prec for heads; it will stay 0.</span>

        <span class="k">if</span> <span class="n">arg_types</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">type_sig</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span><span class="n">val_type</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">type_sig</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span> 

        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">TokenSubclass</span><span class="o">.</span><span class="n">register_handler_fun</span><span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span>
                               <span class="n">precond_label</span><span class="o">=</span><span class="n">precond_label</span><span class="p">,</span> <span class="n">precond_fun</span><span class="o">=</span><span class="n">precond_fun</span><span class="p">,</span>
                               <span class="n">precond_priority</span><span class="o">=</span><span class="n">precond_priority</span><span class="p">,</span> <span class="n">type_sig</span><span class="o">=</span><span class="n">type_sig</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tail</span><span class="p">:</span>
            <span class="n">TokenSubclass</span><span class="o">.</span><span class="n">register_handler_fun</span><span class="p">(</span><span class="n">TAIL</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span>
                               <span class="n">precond_label</span><span class="o">=</span><span class="n">precond_label</span><span class="p">,</span> <span class="n">precond_fun</span><span class="o">=</span><span class="n">precond_fun</span><span class="p">,</span>
                               <span class="n">precond_priority</span><span class="o">=</span><span class="n">precond_priority</span><span class="p">,</span> <span class="n">type_sig</span><span class="o">=</span><span class="n">type_sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TokenSubclass</span>
</div>
<div class="viewcode-block" id="PrattParser.undefine_handler"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.undefine_handler">[docs]</a>    <span class="k">def</span> <span class="nf">undefine_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">head_or_tail</span><span class="p">,</span> <span class="n">precond_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">all_handlers</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Undefine a head or tail function with the given `token_label`,</span>
<span class="sd">        `precond_label` and type signature.  The `head_or_tail` value should be</span>
<span class="sd">        `HEAD` or `TAIL`.  If `all_precond` is set then all heads and tails for all</span>
<span class="sd">        preconditions will be undefined.  If `all_overloads` then all</span>
<span class="sd">        overloaded type signatures will be undefined.  The token itself is</span>
<span class="sd">        never undefined; use the `undefine_token` method for that.&quot;&quot;&quot;</span>
        <span class="n">TokenSubclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">get_token_subclass</span><span class="p">(</span><span class="n">token_label</span><span class="p">)</span>
        <span class="n">TokenSubclass</span><span class="o">.</span><span class="n">unregister_handler_fun</span><span class="p">(</span><span class="n">head_or_tail</span><span class="p">,</span>
                                         <span class="n">precond_label</span><span class="o">=</span><span class="n">precond_label</span><span class="p">,</span>
                                         <span class="n">type_sig</span><span class="o">=</span><span class="n">TypeSpec</span><span class="p">(</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">),</span>
                                         <span class="n">all_handlers</span><span class="o">=</span><span class="n">all_handlers</span><span class="p">)</span>

    <span class="c">#</span>
    <span class="c"># Methods dealing with types.</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="PrattParser.define_type"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_type">[docs]</a>    <span class="k">def</span> <span class="nf">define_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_name</span><span class="p">,</span> <span class="n">type_params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a type associated with the name `type_name`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span><span class="o">.</span><span class="n">create_typeobject_subclass</span><span class="p">(</span><span class="n">type_name</span><span class="p">,</span> <span class="n">type_params</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.undefine_type"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.undefine_type">[docs]</a>    <span class="k">def</span> <span class="nf">undefine_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_table</span><span class="o">.</span><span class="n">undefine_typeobject_subclass</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>

    <span class="c">#</span>
    <span class="c"># Methods defining syntax elements.</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="PrattParser.define_parser_global_precondition"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_parser_global_precondition">[docs]</a>    <span class="k">def</span> <span class="nf">define_parser_global_precondition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
        <span class="c"># TODO decide if this is a good idea, implement if so, delete otherwise.</span>
        <span class="c"># Is the right level for this, or should it be module level or only</span>
        <span class="c"># token subclass level?  Note that the dict and TokenSubclass method</span>
        <span class="c"># is already implemented.</span>
        <span class="c">#</span>
        <span class="c"># Note that precondition priority is a property of the handler functions</span>
        <span class="c"># using them, not the precondition funs.  If error not set to be raised</span>
        <span class="c"># on ties then last-set one has priority on ties.</span>

    <span class="c"># TODO these can each have a corresponding undefine method; should be easy</span>
    <span class="c"># with undefine_handler method.</span>
</div>
<div class="viewcode-block" id="PrattParser.define_literal"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_literal">[docs]</a>    <span class="k">def</span> <span class="nf">define_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">token_label</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Defines the token with label `token_label` to be a literal in the</span>
<span class="sd">        syntax of the language being parsed.  This method adds a head handler</span>
<span class="sd">        function to the token.  Literals are the leaves of the parse tree; they</span>
<span class="sd">        are things like numbers and variable names in a numerical expression.</span>
<span class="sd">        They always occur as the first (and only) token in a subexpression</span>
<span class="sd">        being evaluated by `recursive_parse`, so they need a head but not a</span>
<span class="sd">        tail.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">head_handler_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">head_handler_literal</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="n">token_label</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">head_handler_literal</span><span class="p">,</span>
                                                            <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_multi_infix_operator"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_multi_infix_operator">[docs]</a>    <span class="k">def</span> <span class="nf">define_multi_infix_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">operator_token_labels</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span>
                                    <span class="n">assoc</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">in_tree</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                    <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># TODO only this type currently supports &quot;in_tree&quot; kwarg.  General and easy</span>
        <span class="c"># mechanism, though.  Test more and add to other methods.</span>
        <span class="c"># Does in-tree keep the first one? how is it defined for this thing?</span>
        <span class="c"># Comma operator is example of in_tree=False, but how does it handle</span>
        <span class="c"># the root??</span>
        <span class="sd">&quot;&quot;&quot;Takes a list of operator token labels and defines a multi-infix</span>
<span class="sd">        operator.  If `repeat=True` it will accept any number of repetitions of</span>
<span class="sd">        the list of operators (but type-checking for that is not implemented</span>
<span class="sd">        yet).  For a single operator, repeating just has the effect of putting</span>
<span class="sd">        the arguments in a flat argument/child list instead of as nested binary</span>
<span class="sd">        operations based on left or right association.  Any argument-checking</span>
<span class="sd">        is done after any node removal, which may affect the types that should</span>
<span class="sd">        be passed-in in the list arg_types of parent constructs.&quot;&quot;&quot;</span>
        <span class="n">recurse_bp</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="k">if</span> <span class="n">assoc</span> <span class="o">==</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">recurse_bp</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">def</span> <span class="nf">tail_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">recurse_bp</span><span class="p">))</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operator_token_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">recurse_bp</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">repeat</span><span class="p">:</span> <span class="k">break</span>
                <span class="c"># Peek ahead and see if we need to loop another time.</span>
                <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span> <span class="o">!=</span> <span class="n">operator_token_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="k">break</span>
                <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">operator_token_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">recurse_bp</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">tail_handler</span><span class="p">,</span>
                         <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">,</span> <span class="n">in_tree</span><span class="o">=</span><span class="n">in_tree</span><span class="p">,</span> <span class="n">repeat_args</span><span class="o">=</span><span class="n">repeat</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="n">operator_token_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prec</span><span class="o">=</span><span class="n">prec</span><span class="p">,</span>
                                <span class="n">tail</span><span class="o">=</span><span class="n">tail_handler</span><span class="p">,</span> <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="n">arg_types</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_infix_operator"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_infix_operator">[docs]</a>    <span class="k">def</span> <span class="nf">define_infix_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">operator_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span>
                              <span class="n">assoc</span><span class="p">,</span> <span class="n">in_tree</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                              <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This just calls the more general method `define_multi_infix_operator`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">define_multi_infix_operator</span><span class="p">(</span><span class="n">ast_label</span><span class="p">,</span> <span class="p">[</span><span class="n">operator_token_label</span><span class="p">],</span> <span class="n">prec</span><span class="p">,</span>
                              <span class="n">assoc</span><span class="p">,</span> <span class="n">in_tree</span><span class="o">=</span><span class="n">in_tree</span><span class="p">,</span>
                              <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="n">arg_types</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="n">eval_fun</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_prefix_operator"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_prefix_operator">[docs]</a>    <span class="k">def</span> <span class="nf">define_prefix_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">operator_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span>
                               <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a prefix operator.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">head_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">prec</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">head_handler</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="n">operator_token_label</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">head_handler</span><span class="p">,</span>
                                <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="n">arg_types</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_postfix_operator"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_postfix_operator">[docs]</a>    <span class="k">def</span> <span class="nf">define_postfix_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">operator_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span>
                                <span class="n">allow_ignored_before</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a postfix operator.  If `allow_ignored_before` is false then</span>
<span class="sd">        no ignored token (usually whitespace) can appear immediately before the</span>
<span class="sd">        operator.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">tail_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_ignored_before</span><span class="p">:</span> <span class="n">PrattParser</span><span class="o">.</span><span class="n">no_ignored_before</span><span class="p">(</span><span class="n">lex</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">tail_handler</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="n">operator_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">prec</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="n">tail_handler</span><span class="p">,</span> 
                                <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="n">arg_types</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_bracket_pair"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_bracket_pair">[docs]</a>    <span class="k">def</span> <span class="nf">define_bracket_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">lbrac_token_label</span><span class="p">,</span> <span class="n">rbrac_token_label</span><span class="p">,</span>
                                                           <span class="n">prec</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a matching bracket grouping operation.  The returned type is</span>
<span class="sd">        set to the type of its single child (i.e., the type of the contents of the</span>
<span class="sd">        brackets).&quot;&quot;&quot;</span>
        <span class="c"># Define a head for the left bracket of the pair.</span>
        <span class="k">def</span> <span class="nf">head_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">prec</span><span class="p">))</span>
            <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">rbrac_token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">head_handler</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">,</span>
                        <span class="n">typesig_override</span><span class="o">=</span><span class="n">TypeSig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val_type</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="n">lbrac_token_label</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="n">head_handler</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_stdfun_lookahead"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_stdfun_lookahead">[docs]</a>    <span class="k">def</span> <span class="nf">define_stdfun_lookahead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">fname_token_label</span><span class="p">,</span> <span class="n">lpar_token_label</span><span class="p">,</span>
                      <span class="n">rpar_token_label</span><span class="p">,</span> <span class="n">comma_token_label</span><span class="p">,</span>
                      <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This definition of stdfun uses lookahead.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">preconditions</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">lookbehind</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Must be followed by a token with label &#39;lpar_token_label&#39;, with no</span>
<span class="sd">            whitespace in-between.&quot;&quot;&quot;</span>
            <span class="n">peek_tok</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">peek_tok</span><span class="o">.</span><span class="n">ignored_before</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span> <span class="o">!=</span> <span class="n">lpar_token_label</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">precond_label</span> <span class="o">=</span> <span class="s">&quot;lpar after, no whitespace between&quot;</span> <span class="c"># Should be a unique label.</span>

        <span class="k">def</span> <span class="nf">head_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">):</span>
            <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">lpar_token_label</span><span class="p">)</span> <span class="c"># We know this will match.</span>
            <span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span> <span class="o">!=</span> <span class="n">rpar_token_label</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span> <span class="o">==</span> <span class="n">comma_token_label</span><span class="p">:</span> 
                    <span class="c"># TODO single utility fun or flag for this if?</span>
                    <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">comma_token_label</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">rpar_token_label</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">head_handler</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">subclass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="n">fname_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                         <span class="n">head</span><span class="o">=</span><span class="n">head_handler</span><span class="p">,</span> <span class="n">precond_label</span><span class="o">=</span><span class="n">precond_label</span><span class="p">,</span>
                         <span class="n">precond_fun</span><span class="o">=</span><span class="n">preconditions</span><span class="p">,</span> <span class="n">precond_priority</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="n">arg_types</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_stdfun_lpar_tail"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_stdfun_lpar_tail">[docs]</a>    <span class="k">def</span> <span class="nf">define_stdfun_lpar_tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">fname_token_label</span><span class="p">,</span> <span class="n">lpar_token_label</span><span class="p">,</span>
                      <span class="n">rpar_token_label</span><span class="p">,</span> <span class="n">comma_token_label</span><span class="p">,</span> <span class="n">prec_of_lpar</span><span class="p">,</span>
                      <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is an alternate version of stdfun that defines lpar as an infix</span>
<span class="sd">        operator (with a tail).  This function works in the usual cases but</span>
<span class="sd">        current version without preconditions may have problems distinguishing</span>
<span class="sd">        &quot;b (&quot; from &quot;b(&quot; when a multiplication jop is set.&quot;&quot;&quot;</span>
        <span class="c"># Could also recognize alternate symbols to divide args (like</span>
        <span class="c"># using &quot;|&quot; in probability and &quot;;&quot; in some cases).</span>
        <span class="k">def</span> <span class="nf">tail_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
            <span class="n">PrattParser</span><span class="o">.</span><span class="n">no_ignored_before</span><span class="p">(</span><span class="n">lex</span><span class="p">)</span> <span class="c"># Nothing between fun name and lpar_token.</span>
            <span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span> <span class="o">!=</span> <span class="n">rpar_token_label</span><span class="p">:</span>
                <span class="n">left</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">prec_of_lpar</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span> <span class="o">==</span> <span class="n">comma_token_label</span><span class="p">:</span> 
                    <span class="c"># TODO single utility fun or flag for this if?</span>
                    <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">comma_token_label</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">PrattParser</span><span class="o">.</span><span class="n">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">rpar_token_label</span><span class="p">)</span>
            <span class="n">left</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">tail_handler</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="n">lpar_token_label</span><span class="p">,</span>
                                         <span class="n">prec</span><span class="o">=</span><span class="n">prec_of_lpar</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="n">tail_handler</span><span class="p">,</span>
                                         <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="n">arg_types</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrattParser.define_jop"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.define_jop">[docs]</a>    <span class="k">def</span> <span class="nf">define_jop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">assoc</span><span class="p">,</span> <span class="n">precond_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                      <span class="n">precond_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">precond_priority</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                      <span class="n">val_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eval_fun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;The function `precond_fun` is called to determine whether or not to</span>
<span class="sd">        infer a juxtaposition operator between the previously-parsed</span>
<span class="sd">        subexpression result and the next token.  This function will be passed</span>
<span class="sd">        the lexer as well as the lookbehind list as arguments.  Note that the</span>
<span class="sd">        `jop_precond` function has access to the type information for the</span>
<span class="sd">        potential left operand but not for the potential right operand.  If</span>
<span class="sd">        this function returns `True` then a jop is inferred and the parse</span>
<span class="sd">        proceeds assuming there is a jop token in the token stream.</span>
<span class="sd">        </span>
<span class="sd">        If `backtrack_on_parse_error` is `True` then any parse error in</span>
<span class="sd">        evaluating the tail of the jop will cause the algorithm to backtrack and</span>
<span class="sd">        proceed without inferring a jop.  If `backtrack_on_type_error` is</span>
<span class="sd">        `True` then any type errors in processing the jop will cause the</span>
<span class="sd">        algorithm to backtrack and proceed without inferring a jop.  Note that</span>
<span class="sd">        careful definition of `jop_precond` can greatly reduce or eliminate the</span>
<span class="sd">        need to backtrack.  Note also that if the juxtaposition operator always</span>
<span class="sd">        resolves to a single type signature based on its argument types then,</span>
<span class="sd">        even if overloading on return types is in effect, the jop can be</span>
<span class="sd">        effectively inferred based on type signature information.&quot;&quot;&quot;</span> 

        <span class="n">recurse_bp</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="k">if</span> <span class="n">assoc</span> <span class="o">==</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">recurse_bp</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">def</span> <span class="nf">tail_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_children</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">recurse_bp</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_and_check_node</span><span class="p">(</span><span class="n">tail_handler</span><span class="p">,</span> <span class="n">ast_label</span><span class="p">,</span> <span class="n">eval_fun</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modify_token_subclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jop_token_label</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="n">prec</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="n">tail_handler</span><span class="p">,</span>
                            <span class="n">precond_label</span><span class="o">=</span><span class="n">precond_label</span><span class="p">,</span> <span class="n">precond_fun</span><span class="o">=</span><span class="n">precond_fun</span><span class="p">,</span>
                            <span class="n">precond_priority</span><span class="o">=</span><span class="n">precond_priority</span><span class="p">,</span>
                            <span class="n">val_type</span><span class="o">=</span><span class="n">val_type</span><span class="p">,</span> <span class="n">arg_types</span><span class="o">=</span><span class="n">arg_types</span><span class="p">)</span>
        
    <span class="c">#</span>
    <span class="c"># Static methods for use inside head and tail functions.</span>
    <span class="c">#</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PrattParser.match_next"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.match_next">[docs]</a>    <span class="k">def</span> <span class="nf">match_next</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">token_label_to_match</span><span class="p">,</span> <span class="n">discard_non_matches</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A utility function that asserts the value of the next token label</span>
<span class="sd">        in `lex` and also consumes the token from the lexer.  If the token</span>
<span class="sd">        label does not match an exception is raised.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">token_label_to_match</span> <span class="o">!=</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Match function expected {0} but found {1}.&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">token_label_to_match</span><span class="p">,</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span><span class="p">))</span>
        <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="c"># Eat the token that was matched.</span>
        <span class="k">return</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PrattParser.in_ignored_tokens"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.in_ignored_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">in_ignored_tokens</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">token_label_to_match</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A utility function to test if a particular token label is among the</span>
<span class="sd">        tokens ignored before the current token.  Returns a boolean value.&quot;&quot;&quot;</span>
        <span class="n">ignored_token_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">token_label</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">ignored_before_list</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">token_label_to_match</span> <span class="ow">in</span> <span class="n">ignored_token_labels</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PrattParser.no_ignored_after"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.no_ignored_after">[docs]</a>    <span class="k">def</span> <span class="nf">no_ignored_after</span><span class="p">(</span><span class="n">lex</span><span class="p">):</span>
        <span class="c"># TODO maybe make just a boolean fun, for localized error handling.</span>
        <span class="sd">&quot;&quot;&quot;Test if any tokens were ignored between current token and lookahead.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">ignored_before</span><span class="p">():</span> <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span>
                <span class="s">&quot;Expected nothing between {0} and previous symbol.&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PrattParser.no_ignored_before"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.no_ignored_before">[docs]</a>    <span class="k">def</span> <span class="nf">no_ignored_before</span><span class="p">(</span><span class="n">lex</span><span class="p">):</span>
        <span class="c"># TODO maybe make just a boolean fun, for localized error handling.</span>
        <span class="sd">&quot;&quot;&quot;Test if any tokens were ignored between previous token and current.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">ignored_before</span><span class="p">():</span> <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span>
                <span class="s">&quot;Expected nothing between {0} and previous symbol.&quot;</span>
                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lex</span><span class="o">.</span><span class="n">token</span><span class="p">))</span>

    <span class="c">#</span>
    <span class="c"># The main parse routines.</span>
    <span class="c">#</span>
</div>
<div class="viewcode-block" id="PrattParser.parse"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The main routine for parsing a full program or expression.  Users of</span>
<span class="sd">        the class should call this method to perform the parsing operations</span>
<span class="sd">        (after defining a grammar, of course).  Returns a token tree or a list</span>
<span class="sd">        of token trees if `multi_expression` is set.&quot;&quot;&quot;</span>

        <span class="n">parse_tree_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">PrattParser</span><span class="o">.</span><span class="n">recursive_parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">parse_tree_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

            <span class="c"># Finalize type-checking for root when overloading on return types.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overload_on_ret_types</span><span class="p">:</span> 
                <span class="n">output</span><span class="o">.</span><span class="n">check_types_in_tree_second_pass</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># See if we reached the end of the token stream.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">is_end_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()):</span> <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_expression</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="n">ParserException</span><span class="p">(</span><span class="s">&quot;Parsing never reached end of expression,&quot;</span>
                    <span class="s">&quot; stopped at current token with label &#39;{0}&#39; and value &quot;</span>
                    <span class="s">&quot;&#39;{1}&#39; before a token with label &#39;{2}&#39; and value &#39;{3}&#39;.&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">token</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> 
                            <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">token_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_expression</span><span class="p">:</span> <span class="k">return</span> <span class="n">parse_tree_list</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">output</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PrattParser.infer_jop_conditions"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.infer_jop_conditions">[docs]</a>    <span class="k">def</span> <span class="nf">infer_jop_conditions</span><span class="p">(</span><span class="n">lex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test whether or not a juxtaposition operator should be inferred in</span>
<span class="sd">        the `recursive_parse` function.&quot;&quot;&quot;</span>

        <span class="c"># Fail if jop undefined.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lex</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="c"># Fail if at end of expression.</span>
        <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">is_end_token</span><span class="p">(</span><span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()):</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="c"># Fail if the ignored token for jop is not present (TODO optional but default.)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lex</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_ignored_token_label</span> 
                <span class="ow">not</span> <span class="ow">in</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">ignored_before_labels</span><span class="p">()):</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="c"># Fail if peek has a tail, since that may be lower-prec operator.</span>
        <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PrattParser.recursive_parse"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.PrattParser.recursive_parse">[docs]</a>    <span class="k">def</span> <span class="nf">recursive_parse</span><span class="p">(</span><span class="n">lex</span><span class="p">,</span> <span class="n">subexp_prec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse a subexpression as defined by token precedences. Return the</span>
<span class="sd">        result of the evaluation.  Recursively builds up the final result in</span>
<span class="sd">        `processed_left`, which is the tree for the part of the full expression</span>
<span class="sd">        to the left.  It is a static method so it can be called from head and</span>
<span class="sd">        tail functions.  Note that the functions `head_dispatcher` and</span>
<span class="sd">        `tail_dispatcher` which are called in the code often recursively call</span>
<span class="sd">        `recursive_parse` again.  Each recursive call inside the function</span>
<span class="sd">        processes a sub-subexpression, again as defined by the token precedences.</span>
<span class="sd">        The list `lookbehind` saves all the previously evaluated subexpressions</span>
<span class="sd">        at this level of recursion (i.e., at the top level in the same</span>
<span class="sd">        subexpression) and passes it to the tail_dispatcher method of the</span>
<span class="sd">        tokens, in case that routine wants to make use of it.  For example, the</span>
<span class="sd">        ordinal position of the token in the top level of the subexpression can</span>
<span class="sd">        be calculated from the length of `lookbehind`.&quot;&quot;&quot;</span>

        <span class="c"># NOTE that with a good, efficient pushback function the modifiable</span>
        <span class="c"># prec for different handler functions might be doable: just do a next</span>
        <span class="c"># then evaluate the prec, then pushback.</span>

        <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">processed_left</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">dispatch_and_call_handler</span><span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">lex</span><span class="p">)</span>
        <span class="n">lookbehind</span> <span class="o">=</span> <span class="p">[</span><span class="n">processed_left</span><span class="p">]</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

            <span class="c"># The main loop, except for the special case when a jop is defined.</span>
            <span class="k">while</span> <span class="n">lex</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>
                <span class="n">curr_token</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">processed_left</span> <span class="o">=</span> <span class="n">curr_token</span><span class="o">.</span><span class="n">dispatch_and_call_handler</span><span class="p">(</span>
                                       <span class="n">TAIL</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">,</span> <span class="n">lookbehind</span><span class="p">)</span>
                <span class="n">lookbehind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed_left</span><span class="p">)</span>

            <span class="c"># Broke out of main loop, determine whether or not to infer a jop.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">PrattParser</span><span class="o">.</span><span class="n">infer_jop_conditions</span><span class="p">(</span><span class="n">lex</span><span class="p">):</span> <span class="k">break</span>

            <span class="c"># Infer a jop, but only if 1) its prec would satisfy the while loop</span>
            <span class="c"># above as an ordinary token and 2) it has a head handler defined</span>
            <span class="c"># in the current conditions.</span>
            <span class="k">if</span> <span class="n">lex</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">subexp_prec</span><span class="p">:</span>
                <span class="c"># Infer a jop: create a subclass instance for the jop token.</span>
                <span class="n">jop_instance</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">parser_instance</span><span class="o">.</span><span class="n">jop_token_subclass</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span> <span class="n">processed_left</span> <span class="o">=</span> <span class="n">jop_instance</span><span class="o">.</span><span class="n">dispatch_and_call_handler</span><span class="p">(</span>
                                       <span class="n">TAIL</span><span class="p">,</span> <span class="n">lex</span><span class="p">,</span> <span class="n">processed_left</span><span class="p">,</span> <span class="n">lookbehind</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">NoHandlerFunctionDefined</span><span class="p">:</span>
                    <span class="k">break</span> <span class="c"># No precondition matches, assume no jop.</span>
                <span class="n">lookbehind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed_left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">processed_left</span>

<span class="c">#</span>
<span class="c"># Exceptions</span>
<span class="c">#</span>
</div></div>
<div class="viewcode-block" id="ParserException"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.ParserException">[docs]</a><span class="k">class</span> <span class="nc">ParserException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General parser errors.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="TypeError"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.TypeError">[docs]</a><span class="k">class</span> <span class="nc">TypeError</span><span class="p">(</span><span class="n">ParserException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error in type matching.&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="NoHandlerFunctionDefined"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.NoHandlerFunctionDefined">[docs]</a><span class="k">class</span> <span class="nc">NoHandlerFunctionDefined</span><span class="p">(</span><span class="n">ParserException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised by dispatcher function if it fails to find a handler function</span>
<span class="sd">    (head or tail, whichever it was looking for).&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c">#</span>
<span class="c"># Local testing.</span>
<span class="c">#</span>

<span class="c"># TOKEN DEFINITIONS #################################################################</span>
</div>
<div class="viewcode-block" id="define_whitespace_tokens"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.define_whitespace_tokens">[docs]</a><span class="k">def</span> <span class="nf">define_whitespace_tokens</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">):</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;space&quot;</span><span class="p">,</span> <span class="s">r&quot;[ \t]+&quot;</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># note + NOT *</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;newline&quot;</span><span class="p">,</span> <span class="s">r&quot;[\n\f\r\v]+&quot;</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># note + NOT *</span>
    <span class="c">#lex_or_pp.define_token(&quot;whitespace&quot;, r&quot;\s+&quot;, ignore=True) # note + NOT *</span>
</div>
<div class="viewcode-block" id="define_basic_tokens"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.define_basic_tokens">[docs]</a><span class="k">def</span> <span class="nf">define_basic_tokens</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">):</span>
    <span class="n">define_whitespace_tokens</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_begin_and_end_tokens</span><span class="p">(</span><span class="s">&quot;begin&quot;</span><span class="p">,</span> <span class="s">&quot;end&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;number&quot;</span><span class="p">,</span> <span class="s">r&quot;\d+&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;imag_number&quot;</span><span class="p">,</span> <span class="s">r&quot;\d+[i]&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;double_ast&quot;</span><span class="p">,</span> <span class="s">r&quot;(?:\*\*|\^)&quot;</span><span class="p">)</span> <span class="c"># Note ^ is defined as synonym.</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;plus&quot;</span><span class="p">,</span> <span class="s">r&quot;\+&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;minus&quot;</span><span class="p">,</span> <span class="s">r&quot;\-&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;fslash&quot;</span><span class="p">,</span> <span class="s">r&quot;/&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;ast&quot;</span><span class="p">,</span> <span class="s">r&quot;\*&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;lpar&quot;</span><span class="p">,</span> <span class="s">r&quot;\(&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;rpar&quot;</span><span class="p">,</span> <span class="s">r&quot;\)&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;comma&quot;</span><span class="p">,</span> <span class="s">r&quot;,&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;bang&quot;</span><span class="p">,</span> <span class="s">r&quot;!&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;question&quot;</span><span class="p">,</span> <span class="s">r&quot;\?&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;colon&quot;</span><span class="p">,</span> <span class="s">r&quot;\:&quot;</span><span class="p">)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;semicolon&quot;</span><span class="p">,</span> <span class="s">r&quot;;&quot;</span><span class="p">)</span>
    <span class="c"># NOTE that we could define the exponentiation function twice, once for a</span>
    <span class="c"># ** token and once for a ^ token.  (They can both be given the same AST</span>
    <span class="c"># label.)  What we do here, instead, is define multiple symbols for a single</span>
    <span class="c"># token, making ^ an alias for **.</span>
</div>
<div class="viewcode-block" id="define_identifier_token"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.define_identifier_token">[docs]</a><span class="k">def</span> <span class="nf">define_identifier_token</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">):</span>
    <span class="c"># The last part of below only needs \w, but good example of pattern.</span>
    <span class="c">#lex_or_pp.define_token(&quot;identifier&quot;, r&quot;[a-zA-Z_](?:[\w|\d]*)&quot;, on_ties=-1)</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;identifier&quot;</span><span class="p">,</span> <span class="s">r&quot;[a-zA-Z_](?:\w*)&quot;</span><span class="p">,</span> <span class="n">on_ties</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="define_default_tokens"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.define_default_tokens">[docs]</a><span class="k">def</span> <span class="nf">define_default_tokens</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Defines some default tokens for testing either a Lexer or a PrattParser.&quot;&quot;&quot;</span>
    <span class="n">define_basic_tokens</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">)</span>
    <span class="n">define_identifier_token</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">)</span>

    <span class="c">#pp.define_infix_operator(&quot;divsign&quot;, u&quot;&quot;) </span>
    <span class="c">#pp.define_infix_operator(&quot;caret&quot;, &quot;^&quot;) </span>
</div>
<div class="viewcode-block" id="define_comment_to_EOL_token"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.define_comment_to_EOL_token">[docs]</a><span class="k">def</span> <span class="nf">define_comment_to_EOL_token</span><span class="p">(</span><span class="n">lex_or_pp</span><span class="p">,</span> <span class="n">begin_string</span><span class="p">):</span>
    <span class="c"># Note that comment_to_endline is non-greedy due to *? symbol.</span>
    <span class="n">lex_or_pp</span><span class="o">.</span><span class="n">define_token</span><span class="p">(</span><span class="s">&quot;comment_to_EOL&quot;</span><span class="p">,</span> <span class="s">r&quot;{0}.*?[\n]&quot;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">begin_string</span><span class="p">),</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="c"># SYNTAX DEFINITIONS ################################################################</span>
</div>
<div class="viewcode-block" id="define_syntax"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.define_syntax">[docs]</a><span class="k">def</span> <span class="nf">define_syntax</span><span class="p">(</span><span class="n">pp</span><span class="p">):</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_literal</span><span class="p">(</span><span class="s">&quot;number_literal&quot;</span><span class="p">,</span> <span class="s">&quot;number&quot;</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_literal</span><span class="p">(</span><span class="s">&quot;imag_number_literal&quot;</span><span class="p">,</span> <span class="s">&quot;imag_number&quot;</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_literal</span><span class="p">(</span><span class="s">&quot;variable_literal&quot;</span><span class="p">,</span> <span class="s">&quot;identifier&quot;</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_stdfun_lookahead</span><span class="p">(</span><span class="s">&quot;stdfun&quot;</span><span class="p">,</span> <span class="s">&quot;identifier&quot;</span><span class="p">,</span> <span class="s">&quot;lpar&quot;</span><span class="p">,</span> <span class="s">&quot;rpar&quot;</span><span class="p">,</span> <span class="s">&quot;comma&quot;</span><span class="p">)</span> 
    <span class="c">#pp.define_stdfun_lpar_tail(&quot;stdfun&quot;, &quot;identifier&quot;, &quot;lpar&quot;, &quot;rpar&quot;, &quot;comma&quot;, 20) # 20 is prec of (</span>

    <span class="c"># TODO failing test below, when it hits unary + operator</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_infix_operator</span><span class="p">(</span><span class="s">&quot;addition&quot;</span><span class="p">,</span> <span class="s">&quot;plus&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="c">#pp.define_infix_operator(&quot;addition&quot;, &quot;plus&quot;, 10, Assoc.left)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_infix_operator</span><span class="p">(</span><span class="s">&quot;subtraction&quot;</span><span class="p">,</span> <span class="s">&quot;minus&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_infix_operator</span><span class="p">(</span><span class="s">&quot;multiplication&quot;</span><span class="p">,</span> <span class="s">&quot;ast&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_infix_operator</span><span class="p">(</span><span class="s">&quot;division&quot;</span><span class="p">,</span> <span class="s">&quot;fslash&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_prefix_operator</span><span class="p">(</span><span class="s">&quot;positive&quot;</span><span class="p">,</span> <span class="s">&quot;plus&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_prefix_operator</span><span class="p">(</span><span class="s">&quot;negative&quot;</span><span class="p">,</span> <span class="s">&quot;minus&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_postfix_operator</span><span class="p">(</span><span class="s">&quot;factorial&quot;</span><span class="p">,</span> <span class="s">&quot;bang&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">allow_ignored_before</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_infix_operator</span><span class="p">(</span><span class="s">&quot;exponentiation&quot;</span><span class="p">,</span> <span class="s">&quot;double_ast&quot;</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_multi_infix_operator</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;question&quot;</span><span class="p">,</span> <span class="s">&quot;colon&quot;</span><span class="p">],</span> <span class="mi">90</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="c"># Note we have two exp operators, and we might want exp() standard fun too...</span>
    <span class="c"># They should probably all have the same AST node which saves how they were</span>
    <span class="c"># originally formatted.</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_bracket_pair</span><span class="p">(</span><span class="s">&quot;paren_brackets&quot;</span><span class="p">,</span> <span class="s">&quot;lpar&quot;</span><span class="p">,</span> <span class="s">&quot;rpar&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c">#pp.define_comma_list(&quot;comma list&quot;, &quot;comma&quot;, 5, Assoc.right)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">define_multi_infix_operator</span><span class="p">(</span><span class="s">&quot;comma list&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;comma&quot;</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                                   <span class="n">in_tree</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">pp</span><span class="o">.</span><span class="n">define_multi_infix_operator</span><span class="p">(</span><span class="s">&quot;statements&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;semicolon&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Assoc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                                   <span class="n">repeat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="c"># TESTS #############################################################################</span>
</div>
<div class="viewcode-block" id="run_and_print"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.run_and_print">[docs]</a><span class="k">def</span> <span class="nf">run_and_print</span><span class="p">(</span><span class="n">prog</span><span class="p">):</span>
    <span class="n">ast_form</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;---------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ast_form</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ast</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">convert_to_AST</span><span class="p">(</span><span class="n">ast_table</span><span class="o">.</span><span class="n">get_AST_node</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">tree_repr</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="run_local_tests"><a class="viewcode-back" href="../../wff_language.pratt_parser.html#wff_language.pratt_parser.run_local_tests">[docs]</a><span class="k">def</span> <span class="nf">run_local_tests</span><span class="p">(</span><span class="n">pp</span><span class="p">):</span>
    <span class="c">#run_and_print(&quot;3+5 // comment \n-30&quot;)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;22, 44 + 44, 55, 44, 55&quot;</span><span class="p">)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;4 * (f(x), 3)&quot;</span><span class="p">)</span>
    <span class="c">#define_comment_to_EOL_token(pp, &quot;//&quot;)</span>
    <span class="c">#run_and_print(&quot;4,3,7+f(3 * 2// comment \n * 3 * 4)&quot;)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;3 + 4 ; egg55a; f(y)&quot;</span><span class="p">)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;+4+5-ccc?4i:5&quot;</span><span class="p">)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;3!&quot;</span><span class="p">)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;f(3!)&quot;</span><span class="p">)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;1+f(x)&quot;</span><span class="p">)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;f( x,y,z)&quot;</span><span class="p">)</span>
    <span class="n">run_and_print</span><span class="p">(</span><span class="s">&quot;+1+ (1+2*3)*3 / 7&quot;</span><span class="p">)</span>
</div>
<span class="n">ast_table</span> <span class="o">=</span> <span class="n">AST_NodeTable</span><span class="p">()</span>
<span class="n">pp</span> <span class="o">=</span> <span class="n">PrattParser</span><span class="p">()</span>
<span class="n">define_default_tokens</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
<span class="n">define_syntax</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>
<span class="n">run_local_tests</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span>


<span class="kn">import</span> <span class="nn">pytest_helper</span>
<span class="n">pytest_helper</span><span class="o">.</span><span class="n">script_run</span><span class="p">(</span><span class="s">&quot;test/test_pratt_parser.py&quot;</span><span class="p">,</span> <span class="n">pytest_args</span><span class="o">=</span><span class="s">&quot;-v&quot;</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>