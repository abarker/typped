<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1.12. wff_language.regex_trie_dict module &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="index.html" />
    <link rel="up" title="2. wff_language package" href="wff_language.html" />
    <link rel="next" title="2.1.13. wff_language.regex_trie_dict_lexer module" href="wff_language.regex_trie_dict_lexer.html" />
    <link rel="prev" title="2.1.11. wff_language.pratt_types module" href="wff_language.pratt_types.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.regex_trie_dict_lexer.html" title="2.1.13. wff_language.regex_trie_dict_lexer module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="wff_language.pratt_types.html" title="2.1.11. wff_language.pratt_types module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" accesskey="U">2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-wff_language.regex_trie_dict">
<span id="wff-language-regex-trie-dict-module"></span><h1>2.1.12. wff_language.regex_trie_dict module<a class="headerlink" href="#module-wff_language.regex_trie_dict" title="Permalink to this headline">¶</a></h1>
<div class="section" id="pattern-matching-in-regextriedict">
<h2>2.1.12.1. Pattern Matching in RegexTrieDict<a class="headerlink" href="#pattern-matching-in-regextriedict" title="Permalink to this headline">¶</a></h2>
<p>The RegexTrieDict also simple built-in pattern-matching capabilities.  To use
these capabilities, you first create a key which contains some special
meta-elements (see below).  Then you insert that key (meta-key) and an
associated value into the TrieDict.  These meta-keys are still treated simply
as ordinary keys by the usual TrieDict operations.  But the TrieDict also has
the special methods has_key_meta, get_meta which interpret the meta-elements.</p>
<p>Calling has_key_meta for a key (an ordinary, non-meta key) returns True if any
current key matches or if any meta-key pattern happens to match as a pattern.
Similarly, get_meta finds any key or meta-key pattern which matches and returns
a tuple of all the data associated with matching items (i.e., associated with
the ordinary key or with the pattern meta-key it matches).</p>
<p>The special meta-symbols are user-defined.  By default the values are defined
for keys which are strings of characters.  The default definitions are:</p>
<p>&lt;TODO update below, some changed&gt;</p>
<blockquote>
<div><dl class="docutils">
<dt>define_meta_elems(escape=&#8221;&#8221;, repetition=&#8221;*&#8221;, lGroup=&#8221;(&#8221;, rGroup=&#8221;)&#8221;,</dt>
<dd>lWildcard=&#8221;[&#8221;, rWildcard=&#8221;]&#8221;, range=&#8221;-&#8221;, rangeTestFun=None)</dd>
</dl>
</div></blockquote>
<p>In order for an element of a key to be interpreted as a meta-symbol it must be
preceded by the defined escape element.  So in a string key the meta-symbols
with their default definitions above would always appear as &#8220;*&#8221;, &#8220;(&#8221;, &#8221;)&#8221;,
&#8220;[&#8221;, &#8220;]&#8221;, and &#8220;-&#8221;.  This is intended to minimize interference with ordinary
key elements.  All specially-interpreted characters must be escaped, without
exception.  As usual a double escape such as &#8220;\&#8221; (or r&#8221;&#8221;) reverts to the
original symbol, as does an escape not followed by one of the defined
meta-elements.</p>
<p>Keep in mind that if a TrieDict is to be used with escaped elements as
meta-elements then all the literal escape-elements in it must be escaped.  Even
the non-pattern keys which are inserted into the TrieDict in that case must
have any escape elements escaped (they are still patterns, just simple ones).
In the queries sequences themselves, however, escape elements are always simply
treated as literals (i.e., no meta-interpretation is ever performed on the
query-key sequences).  So a single escape on a key-query matches an escaped
escape in the stored key-sequences in the Trie.</p>
<p>The meta-level and the object-level are intentionally kept distinct in order to
minimize some of the confusions that can occur (even though there always are
some).  The ordinary dict methods always operate on trie keys as if they were
literals.  To get an extra level of interpretation, the special meta-level
methods must be used.  These operations, however, can be freely mixed.  Patterns
can be inserted and deleted, etc.</p>
<p>Pattern scanning is left-to-right in a key&#8217;s elements (i.e., with string keys
the characters are scanned from left to right).</p>
<p>The language allows single-character wildcards.  As an example with strings,
consider using these patterns as keys:</p>
<blockquote>
<div>patt1 = &#8220;abc[123]def&#8221;
patt2 = &#8220;abc[1-3]def&#8221;</div></blockquote>
<p>The first pattern, patt1, matches abc1def, abd2def, and abc3def.  The second
pattern, patt2, matches the same strings but uses a range specifier.</p>
<p>&lt;TODO note we now let them define the whole wildcard-processing...&gt;
The
boolean-valued function rangeTestFun will be called for the first and last
argument of the range, along with the element to test.  The default
range-function (when the values is set to None in the call to defineMetaElems)
only works for character ranges.</p>
<p>&lt;TODO note that Python patterns are allowed, and test some.&gt;
&lt;TODO note that user can essentially redefine the processing of the part inside
the brackets in any way desired.&gt;</p>
<p>Repetition patterns match zero or more occurrences of the pattern group.  Here
is an example with strings as keys:</p>
<blockquote>
<div>patt1 = &#8220;abc*(DD)efg&#8221;</div></blockquote>
<p>This would match &#8220;abcefg&#8221;, &#8220;abcDDefg&#8221;, abcDDDDefg&#8221;, etc.  The repetition
pattern can also take optional numeric arguments, each separated by another
asterick.  A single numeric argument, like in</p>
<blockquote>
<div>patt = &#8220;abc*10(DD)efg</div></blockquote>
<p>specifies a minimum number of repetitions.  The previous example must have
ten or more occurrences of &#8220;dd&#8221; in it.  So &#8220;abcDDefg&#8221; would not match,
but &#8220;abcDDDDDDDDDDDDDDDDDDDDefg&#8221; would match.  When two numbers are given
they represent the minimum and the maximum number of repetitions, respectively.
So the pattern</p>
<blockquote>
<div>patt = &#8220;abc*2*3(DD)efg&#8221;</div></blockquote>
<p>would not match &#8220;abcDDefg&#8221;, would match &#8220;abcDDDDefg&#8221; and &#8220;abcDDDDDDefg&#8221;, and
would not match abcDDDDDDDDefg&#8221;.</p>
<p>TODO below para not implemented
The grouping meta-elements must occur just after the start and at the end of
the repetition pattern itself.  For efficiency, repetition can be limited such
that it always &#8220;breaks out&#8221; of the &#8220;loop&#8221; at the first chance it gets.   This
occurs when, at the end of a loop, the next element scanned matches the next
pattern element after the closing repetition meta-element.  So the shortest
valid repetition sequence followed by some other valid element is always
chosen.  This restriction essentially requires the end of any repeated-pattern
segment to be unambiguous (or else no looping-back will occur).</p>
</div>
<div class="section" id="pattern-matching-implementation-details">
<h2>2.1.12.2. Pattern-matching Implementation Details<a class="headerlink" href="#pattern-matching-implementation-details" title="Permalink to this headline">¶</a></h2>
<p>As noted, meta-keys are inserted and stored in a TrieDict simply as ordinary
keys.  It is the traversal algorithm in the routine get_nodes_meta which differs
from the usual get_node algorithm (which finds the node in the trie
corresponding to a key).  Note first off that the get_nodes_meta routine can
returns a list of nodes, not just a single node.  This is because multiple
patterns can match the same query-key.</p>
<p>The traversal algorithm is the same as usual except when meta-characters are
encountered.  In this case the state can split into a list of states (similar
to a nondeterministic automata).  That is, instead of just keeping one
current-node, we keep a list of them and update each one for each input
query-key element.  If any current node in the list matches then the key
matches.  If the set becomes empty without a match then the pattern fails to
match.</p>
<p>In the case of a wildcard pattern, suppose the child list of a current node
includes a begin-wildcard element, i.e., a wildcard is one possible
continuation.  Keep in mind that there may be multiple different wildcard
patterns stored in the subtree of the begin-wildcard element.  Now suppose the
next element of the query-key comes in, and we want to move down the trie.  The
state splits.  One new state is just the usual child-node from any literal
continuation which is stored in the tree (as in the non-meta version).  But
also, the algorithm fast-forwards from the current-node&#8217;s begin-wildcard child
node to the first end-wildcard node in each branch of the subtree beneath it.
Along the way, it is noted whether the current query-key element matches the
wildcard.  For each end-wildcard node which matched the query-key element, the
end-wildcard node is added to the current-node list (and is also checked to see
if it is an end-node of some pattern).</p>
<p>In the case of a repetition pattern, suppose the child list of a current node
includes a begin-repetition element.  In this case the state splits (as before
with wildcards), with the usual literal-character child node becoming one new
state.  But also, the algorithm fast forwards to the corresponding
end-repetition element of each subtree and makes that a new state (we start at
the end to get zero repetitions).  They also remember their begin-repetition
point.  On the next query-key element both states continue, one skipping and
one looping back.</p>
<p>To handle uniqueness issues (if we want each distinct pattern to be represented
by the same pattern-string, with the same associated value) the meta-key
patterns can be preprocessed before they are entered into the TrieDict, to
canonicalize them.  For character wildcards, at least, the characters can be
sorted and all continuous sequences can be turned into character ranges.</p>
<p>Note that we can freely add and remove keys from the tree in the usual way,
since they are stored just as if they were ordinary strings.</p>
<p>The pattern-matching algorithm is currently not optimized at all.  For example,
each time a repetition-loop is encountered it re-processes the entire thing,
searching forward for the end-group element.  This data could instead be cached
(such as by having a dict map begin-repetition nodes to the cached data, valid
until an insertion or deletion invalidates, or the space needs to be freed).
Overriding the children on repetition loops can use up a lot of space for long
repetition patterns.  It is hard to avoid going to the end in the
zero-repetition match form, since the end is a valid continuation At-least-one
repetition patterns could potentially process from the beginning.  Overriding
the insert (__setitem__) method to keep pointers to the loop-ends and
or-sections would speed things up.  A common dict indexed by node ids could be
used, but deletion would have to del the deleted-node entries.  Then we could
start zero-repetition states but just set the stacks for the first loop, fixing
the children in appendChildNode if the stack is not empty.</p>
<p>How should the next version be implemented?  Based on current understanding
from this implementation, the insert method for RegexTrieDict should be
modified to create a virtual trie.  (The delete method also needs to be
modified to fix the virtual trie on deletes.)  This can be hashed on the ids of
nodes, for example, to avoid pasting things onto the actual nodes which must
later be deleted.  The virtual trie can be created by overloading the child
function for nodes.  Like for states currently, but it can be global and saved.
The virtual trie should add virtual nodes for close-repetition and open-group
nodes for &#8216;or&#8217;s.  This allows the processing for repetitions to keep track of
the loop stacks, and the processing for &#8216;or&#8217; sections to keep track of which
paths were originally together in a common pattern, but otherwise the
repetitions should just virtually both loop back and break out, and the &#8216;or&#8217;
patterns should be flattened down to an &#8216;or&#8217; for each section starting at the
initial open-group and then converging back to a common close-group node (but
note the importance of keeping track of which ones were initially in the same
pattern to avoid crosstalk amongst the patterns).</p>
<dl class="class">
<dt id="wff_language.regex_trie_dict.MagicElem">
<em class="property">class </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">MagicElem</tt><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#MagicElem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.MagicElem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A special element considered unique (checked by id) and used to
represent a null element that doesn&#8217;t match anything.  Type doesn&#8217;t matter
(since no real comparisons are needed).  Not the same as a null string.</p>
</dd></dl>

<dl class="class">
<dt id="wff_language.regex_trie_dict.Matcher">
<em class="property">class </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">Matcher</tt><big>(</big><em>regexTrieDict</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#Matcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.Matcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Insert elements sequentially, and check whether they match any regex
patterns stored in the trie.  No trie modifications can be made between
inserting any key elements and testing for matches, or ModifiedTrieError
will be raised.</p>
<dl class="method">
<dt id="wff_language.regex_trie_dict.Matcher.cannot_match">
<tt class="descname">cannot_match</tt><big>(</big><em>insert_magic=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#Matcher.cannot_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.Matcher.cannot_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if no matches are possible with further elements inserted
with next_key_elem.  This is determined by whether or not there are any
active patterns in the current state.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.Matcher.get">
<tt class="descname">get</tt><big>(</big><em>default=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#Matcher.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.Matcher.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the data items of all the stored strings which
match the sequence of elements which have been inserted with the
next_key_elem function.  That defines the keySeq and the match
is based on the regexp patterns stored in the RegexTrieDict.  The
default with no matches is to return the empty list.  Remember that any
literal escapes in the trie must be escaped, but escapes in keySeq are
always treated as literal.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.Matcher.has_key">
<tt class="descname">has_key</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#Matcher.has_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.Matcher.has_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the sequence of elements inserted by the
next_key_elem function match any of the regexp patterns stored
in the RegexTrieDict.  Returns the number of matches.  Remember that
any literal escapes in the trie must be escaped, but escapes in keySeq
are always treated as literal.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.Matcher.next_key_elem">
<tt class="descname">next_key_elem</tt><big>(</big><em>elem</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#Matcher.next_key_elem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.Matcher.next_key_elem" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts elem as the next elem of the key sequence.  (Note elem is
usually a character if string patterns are stored in the tree.)</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.Matcher.reset">
<tt class="descname">reset</tt><big>(</big><em>regexTrieDict=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#Matcher.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.Matcher.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the Matcher and frees any state memory.  A new trie can
optionally be passed in.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="wff_language.regex_trie_dict.ModifiedTrieError">
<em class="property">exception </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">ModifiedTrieError</tt><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#ModifiedTrieError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.ModifiedTrieError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#wff_language.regex_trie_dict.RegexTrieDictError" title="wff_language.regex_trie_dict.RegexTrieDictError"><tt class="xref py py-class docutils literal"><span class="pre">wff_language.regex_trie_dict.RegexTrieDictError</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="wff_language.regex_trie_dict.NodeStateData">
<em class="property">class </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">NodeStateData</tt><big>(</big><em>*valList</em>, <em>**kwVals</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is used in pattern-searches.  It is just a fancy data-record,
essentially a named tuple.  It holds one state of a multi-state recognizer.
The state consists of a node in the trie as well as some extra information
for keeping track of loops.  These states locally (for the particular state
and search) redefine the children for each node they have visited and
followed a child link from.  That particular child is made into the only
child.</p>
<p>Each branch in the trie represents a different pattern, connected by &#8220;or&#8221;.
The pattern-prefix for a node is always the same; a pattern with a different
prefix would end at a different node.  When a choice of moving down the trie
is made the prefix is further restricted.  So NodeStateData stores a dict
for looking up the children of any visited state, and they are all
restricted to the single path that they took previously.  This way, looping
backward in a repetition always gives the same pattern prefix.  (States are
also split into two or more states, as necessary, and run in parallel
essentially as an NFA.)  Patterns within &#8216;or&#8217; groups inside a repetition
need to be treated similarly, since they may match a different section on
each repetition.</p>
<p>The node attribute holds a node in the trie.  The boolean nodeIsEscape is
true for nodes representing the escape element self.escape.  The stacks are
used to keep track of looping in repetition patterns.  The
boundNodeChildDict is used to overload the children of the node, so that the
same path down the trie is always followed in a repetition loop.  The
visitedRepNodeIdSet set is a set of the ids all the loopback repetition nodes
visited, but it is reset each time a literal element is matches the query
element (i.e., on a literal or a wildcard match).  This is used to avoid
infinite recursion in processing repetition patterns which match zero
elements.</p>
<p>A NodeStateData is initialized by passing all the stored items to the
initializer, just like initializing a tuple.  Alternately, you can use
keyword arguments or just assign values to the fields.</p>
<dl class="attribute">
<dt id="wff_language.regex_trie_dict.NodeStateData.boundNodeChildDict">
<tt class="descname">boundNodeChildDict</tt><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.boundNodeChildDict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateData.children">
<tt class="descname">children</tt><big>(</big><em>node=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateData.children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.children" title="Permalink to this definition">¶</a></dt>
<dd><p>During patern matches the children of a node are temporarily modified,
so that ordinary characters in a repetition loop are bound until the
loop exits.  To do this, the pattern-match routines use the NodeStateData
children method, rather than the node&#8217;s children method.  If node is
set then that node&#8217;s children dict is returned; default is self.node.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateData.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateData.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the state (not a deep copy).</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.regex_trie_dict.NodeStateData.loopBoundsStack">
<tt class="descname">loopBoundsStack</tt><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.loopBoundsStack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.regex_trie_dict.NodeStateData.loopCounterStack">
<tt class="descname">loopCounterStack</tt><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.loopCounterStack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.regex_trie_dict.NodeStateData.loopbackStack">
<tt class="descname">loopbackStack</tt><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.loopbackStack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.regex_trie_dict.NodeStateData.node">
<tt class="descname">node</tt><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.regex_trie_dict.NodeStateData.nodeIsEscape">
<tt class="descname">nodeIsEscape</tt><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.nodeIsEscape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateData.setChild">
<tt class="descname">setChild</tt><big>(</big><em>childElem</em>, <em>node=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateData.setChild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.setChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign the node (default to self.node) to have single child childElem.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateData.setVals">
<tt class="descname">setVals</tt><big>(</big><em>*valList</em>, <em>**kwVals</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateData.setVals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.setVals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.regex_trie_dict.NodeStateData.visitedRepNodeIdSet">
<tt class="descname">visitedRepNodeIdSet</tt><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateData.visitedRepNodeIdSet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="wff_language.regex_trie_dict.NodeStateDataList">
<em class="property">class </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">NodeStateDataList</tt><big>(</big><em>regexTrieDict</em>, <em>*arg</em>, <em>**kwds</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateDataList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateDataList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">_abcoll.MutableSequence</span></tt></p>
<p>This is essentially just a list, used to hold a collection of
NodeStateData objects representing the full (nondeterministic) state.  A
derived class is used so that additional information can be saved.  The
initialization arguments, if any, are the same as for a list.  In
particular, this class allows for checking whether or not the state-data is
still valid in the underlying trie (there might have been insertions and/or
deletions.</p>
<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateDataList.append">
<tt class="descname">append</tt><big>(</big><em>item</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateDataList.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateDataList.append" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateDataList.appendChildNode">
<tt class="descname">appendChildNode</tt><big>(</big><em>queryElem</em>, <em>nodeData</em>, <em>nodeIsEscape=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateDataList.appendChildNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateDataList.appendChildNode" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility routine that appends a NodeStateData object for a child of
the node in the one passed in.  The child is the one corresponding to the
key queryElem.  All other data is kept the same.  Return True if anything
actually added.  If the nodeIsEscape argument is not None then the
nodeIsEscape value of the nodeDataState is set to that value.  Note that
if a NodeStateData instance is added outside of this loop (such as in
processing wildcards) that routine must take care of any necessary
setChild calls for binding in repetition loops.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateDataList.insert">
<tt class="descname">insert</tt><big>(</big><em>index</em>, <em>obj</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateDataList.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateDataList.insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.NodeStateDataList.isValidIn">
<tt class="descname">isValidIn</tt><big>(</big><em>regexTrieDict</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#NodeStateDataList.isValidIn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.NodeStateDataList.isValidIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether or not the state-data stored in a node data list is still
valid in the current trie.  If any insertions or deletions have occurred
since its creation this routine returns False, otherwise True.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="wff_language.regex_trie_dict.PatternMatchError">
<em class="property">exception </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">PatternMatchError</tt><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#PatternMatchError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.PatternMatchError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#wff_language.regex_trie_dict.RegexTrieDictError" title="wff_language.regex_trie_dict.RegexTrieDictError"><tt class="xref py py-class docutils literal"><span class="pre">wff_language.regex_trie_dict.RegexTrieDictError</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="wff_language.regex_trie_dict.RegexTrieDict">
<em class="property">class </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">RegexTrieDict</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">trie_dict.TrieDict</span></tt></p>
<p>Subclass of the TrieDict class which adds regex processing for patterns
stored in the trie.</p>
<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.define_meta_elems">
<tt class="descname">define_meta_elems</tt><big>(</big><em>escape='\'</em>, <em>repetition='*'</em>, <em>lGroup='('</em>, <em>rGroup=')'</em>, <em>lWildcard='['</em>, <em>rWildcard=']'</em>, <em>rangeElem='-'</em>, <em>orElem='|'</em>, <em>wildcardPattMatchFun=None</em>, <em>elemToDigitFun=None</em>, <em>canonicalizeFun=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.define_meta_elems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.define_meta_elems" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the meta-elements in pattern-matching.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.delitem">
<tt class="descname">delitem</tt><big>(</big><em>key</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.delitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.delitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the stored key and its data.  Raises KeyError if the key wasn&#8217;t
found in the trie.  If d is a dict, the syntax del d[key] also invokes
this function.  This overrides the delete method of the base class to
update a deletion counter to test pattern-match state validity.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.getDfsGen">
<tt class="descname">getDfsGen</tt><big>(</big><em>subtreeRootNode</em>, <em>funToApply=None</em>, <em>includeRoot=False</em>, <em>yieldOnLeaves=True</em>, <em>yieldOnMatch=False</em>, <em>copies=True</em>, <em>stopAtElems=</em>, <span class="optional">[</span><span class="optional">]</span><em>stopAtEscapedElems=</em>, <span class="optional">[</span><span class="optional">]</span><em>stopAtDepth=False</em>, <em>onlyFollowElems=</em>, <span class="optional">[</span><span class="optional">]</span><em>stopIfParenLevelZero=</em>, <span class="optional">[</span><span class="optional">]</span><em>firstParenLevel=0</em>, <em>subtreeRootEscaped=False</em>, <em>sortChildren=False</em>, <em>subtreeRootElem=None</em>, <em>childFun=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.getDfsGen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.getDfsGen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generator which will do a depth-first traversal of the trie,
starting at node subtreeRootNode.  On each call it returns a list of
(nodeElem, node) pairs for each node on some path from the root to a leaf
of the tree.  It generates such a list for each path from the root to a
leaf (one on each call).  If yieldOnMatch is set True then the current
list being constructed on a path down the tree is returned on the first
time any match-marked node is encountered, even if the node is not a
leaf.  If yieldOnLeaves is set False then yields will only be done on
matches.  (If both are False then the routine returns nothing.)</p>
<p>If the list stopAtElems contains any elements then nodes for those
elements are treated as leaves.  Similarly, stopAtEscapedElems treats
escaped nodes for an element in the list to be like leaf nodes.  If
stopAtDepth has a positive integer value then nodes at that depth are
treated as leaves.  The onlyFollowElems list is like the negation for
stopAtElems: it treats everything not on the list like a leaf node (i.e.,
it only folows child-links which are on the list).</p>
<p>If firstParenLevel is set to a positive integer then that integer will be
incremented on each open-group meta-elem (self.lGroup) encountered on a
path and decremented on each close-group meta-elem (self.rGroup)
encountered on the path.  The default value is zero.  If
stopIfParenLevelZero is non-empty then any elements in the list will be
treated as leaves if they are encountered when the paren-count equals
zero.  Note that paren-counts are updated after the comparison with zero.
If the root is a node for a left-paren and firstParenLevel=0 then the
matching right-paren is at paren-level zero.</p>
<p>If funToApply is defined it will be called for each (nodeElem, node) pair
on the returned lists.  The function should take two arguments; the list
will contain the function&#8217;s return value.  A copy of the node list is
returned on each generation, but the nodes are always the actual nodes in
the trie.  If includeRoot is True then output from the subtreeRootNode
itself will be included in the output (with None as the corresponding
nodeElem).</p>
<p>If copies is set False then a single node list is used; this may be a
little faster, but the returned list will change after each
generation-cycle.  If sortChildren is True then the children of
each node will be sorted in the dfs search ordering.</p>
<p>Setting subtreeRootElem to an element will set that as the element on
the returned list corresponding to the subtree root (otherwise it is
None.  Sometimes the value is known when the function call is made,
and it can be convenient to have a uniform list pattern.</p>
<p>If childFun is set to a function then the children of a node are obtained
by calling that function with the node as the argument.  This is helpful,
for example, in pattern-matches where the child dict is locally modified
per state.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.getNextNodesMeta">
<tt class="descname">getNextNodesMeta</tt><big>(</big><em>queryElem</em>, <em>nodeDataList</em>, <em>ignoreValidity=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.getNextNodesMeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.getNextNodesMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of next nodes for each node on currNodeList,
interpreting any stored pattern-matching meta-elements, when the
query-key element queryElem is received.  The nodeDataList should be a
NodeStateDataList object.  It stores a list of NodeDataState tuples, each
representing a &#8220;live&#8221; state of the nondeterministic search.  The tuple
contains a node in the trie as well as some additional state information.</p>
<p>See the routine has_key_meta for a simple example of how this method is
used.</p>
<p>When queryElem is set to the special value self.magicElem this routine
has special behavior defined.  It will simply fast-forward up to the
point where that character would have been compared to the next one in
the query-pattern.  Then it stops, returning those stop-nodes.  This
turns out to be very convenient for skipping closing right-group elements
as well as zero-repetition-matching patterns at the end of a larger key
pattern.  Recall that to check for a match we need to look at the
isLastElemOfKey values at the very end of the stored patterns.  Any
nodeDataList elements which immediately precede a comparison with an
element or set of elements (a literal character or a wildcard) are left
unchanged.  Any others move forward to such a point.  Any well-defined
pattern has such an endpoint.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.get_meta">
<tt class="descname">get_meta</tt><big>(</big><em>keySeq</em>, <em>default=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.get_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.get_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the data items of all the stored strings which
match the sequence of elements keySeq (based on the regexp patterns
stored in the RegexTrieDict).  The default with no matches is to
return the empty list.  Remember that any literal escapes in the
trie must be escaped, but escapes in keySeq are always treated as
literal.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.get_root_node_data_list">
<tt class="descname">get_root_node_data_list</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.get_root_node_data_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.get_root_node_data_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine returns the initial node data list, for the root node.
This list is used by getNextNodesMeta to save the state of the
pattern-matching between iterations.  Multiple instances are allowed.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.handleEndRepetition">
<tt class="descname">handleEndRepetition</tt><big>(</big><em>queryElem</em>, <em>closeParenNodeData</em>, <em>nextNodeDataList</em>, <em>replaceNode=None</em>, <em>noLoop=False</em>, <em>noBreak=False</em>, <em>refuseRevisits=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.handleEndRepetition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.handleEndRepetition" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle reaching the close of a repetition group.  The closeParenNode
should be the node corresponding to the closing repetition-group.  If
replaceNode is set to a node then it replaces the node in closeParenNodeData
as the new node to jump to after a breaking a loop (used in inside sections
of &#8216;or&#8217; patterns).</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.has_key_meta">
<tt class="descname">has_key_meta</tt><big>(</big><em>keySeq</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.has_key_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.has_key_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Test of whether the sequence of elements keySeq matches any of the
regexp patterns stored in the RegexTrieDict.  Returns the number of
matches.  Remember that any literal escapes in the trie must be
escaped, but escapes in keySeq are always treated as literal.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.insert">
<tt class="descname">insert</tt><big>(</big><em>keySeq</em>, <em>data=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the data item in the dict with the key keySeq.  Any existing
data at that key is overwritten.  This method is aliased to __setitem__.
It overrides the superclass definition and adds some syntax checking on
the input patterns.</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.magicElem">
<tt class="descname">magicElem</tt><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.magicElem" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#wff_language.regex_trie_dict.MagicElem" title="wff_language.regex_trie_dict.MagicElem"><tt class="xref py py-class docutils literal"><span class="pre">MagicElem</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.processNodeData">
<tt class="descname">processNodeData</tt><big>(</big><em>queryElem</em>, <em>nodeData</em>, <em>nextNodeDataList</em>, <em>skipEscapes=True</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.processNodeData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.processNodeData" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one nodeData instance, usually from the nodeDataList.  Put the
results on nextNodeDataList.  This large routine does most of the work in
the processing, and is called recursively when necessary.  Escapes are
skipped (generally producing a list of NodeStateData classes) unless
skipEscapes is set False.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.processRepetitionParams">
<tt class="descname">processRepetitionParams</tt><big>(</big><em>seq</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.processRepetitionParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.processRepetitionParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the sequence between the begin-repetition and the open-group
that necessarily follows it.  Return a tuple (minIter, maxIter), with
-1 for infinite maxIter.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.setitem">
<tt class="descname">setitem</tt><big>(</big><em>keySeq</em>, <em>data=None</em><big>)</big><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.setitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the data item in the dict with the key keySeq.  Any existing
data at that key is overwritten.  This method is aliased to __setitem__.
It overrides the superclass definition and adds some syntax checking on
the input patterns.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.regex_trie_dict.RegexTrieDict.testPatternSequence">
<tt class="descname">testPatternSequence</tt><big>(</big><em>keySeq</em>, <em>raiseErrors=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDict.testPatternSequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDict.testPatternSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs some basic tests on pattern sequences.  This routine is always
called by the insert method, with raiseErrors=True.  Users can use it to
test patterns before inserting them.  By default the routine will just
return a boolean value specifying whether the string passes or not.  If
raiseErrors=True then the escape-processed version of keySeq is returned
(assuming no errors are raised).  Note that simply passing the tests is
no guarantee that the pattern is correct, just that it passes these
tests.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="wff_language.regex_trie_dict.RegexTrieDictError">
<em class="property">exception </em><tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">RegexTrieDictError</tt><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#RegexTrieDictError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.RegexTrieDictError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="wff_language.regex_trie_dict.charElemToInt">
<tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">charElemToInt</tt><big>(</big><em>elem</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#charElemToInt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.charElemToInt" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine is set in defineMetaElems as the default value of
elemToDigitFun, which converts elements to digit values.  Used in calculating
repetition bounds.  It is the default setting for elemToDigitFun, when
the elements are characters.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.regex_trie_dict.charPatternMatchTest">
<tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">charPatternMatchTest</tt><big>(</big><em>queryElem</em>, <em>pattList</em>, <em>rangeElem</em>, <em>escapeElem</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#charPatternMatchTest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.charPatternMatchTest" title="Permalink to this definition">¶</a></dt>
<dd><p>This utility routine does a pattern-match for characters in the wildcard
brackets.  It does depend on the elements being characters, since it calls
a Python regexp.  This has the advantage of allowing all the
special-characters in Python regexp wildcards to be used.  This is the
default routine set in defineMetaElems as wildcardPattMatchFun, for when
elements are characters.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.regex_trie_dict.charRangeTest">
<tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">charRangeTest</tt><big>(</big><em>charLower</em>, <em>charUpper</em>, <em>testChar</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#charRangeTest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.charRangeTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if testChar is in the range from char1 to char2, inclusive.
Used in testing wildcard patterns in the default with character elements.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.regex_trie_dict.genericWildcardMatchFun">
<tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">genericWildcardMatchFun</tt><big>(</big><em>queryElem</em>, <em>pattList</em>, <em>rangeElem</em>, <em>escapeElem</em>, <em>rangeTestFun=&lt;function charRangeTest at 0x2b6b49aa99b0&gt;</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#genericWildcardMatchFun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.genericWildcardMatchFun" title="Permalink to this definition">¶</a></dt>
<dd><p>This utility routine does a generic pattern-match in the wildcard
brackets.  This routine is for general sequences of elements and does not
depend on the elements being characters.  Only the function rangeTestFun
needs to be defined.  The argument pattList is the content of a wildcard
bracket, as a list of elements.  This function tests whether queryElem
matches the character pattern.  To simply redefine the range-test function
for elements, use something like:</p>
<blockquote>
<div><dl class="docutils">
<dt>def myPattMatchFun(queryElem, pattList, rangeElem, escapeElem):</dt>
<dd><dl class="first last docutils">
<dt>return genericWildcardMatchFun(queryElem, pattList, rangeElem, escapeElem,</dt>
<dd>rangeTestFun=myRangeTestFun)</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Then in calling defineMetaElems define wildcardPattMatchFun=myPattMatchFun.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.regex_trie_dict.processElemListForEscapes">
<tt class="descclassname">wff_language.regex_trie_dict.</tt><tt class="descname">processElemListForEscapes</tt><big>(</big><em>elemList</em>, <em>escapeChar</em>, <em>openGroup=None</em>, <em>closeGroup=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/regex_trie_dict.html#processElemListForEscapes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.regex_trie_dict.processElemListForEscapes" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility routine which takes a list of possibly-escaped elements as an
argument and returns a list of two-tuples.  The first element of a two-tuple
is the actual character, and the second a boolean for whether or not it is
escaped.  If openGroup and/or closeGroup is set it returns a three-tuple,
where the last element gives the level of parenthesis nesting, starting at zero
and increasing.  An open and its corresponding close have the same level.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2.1.12. wff_language.regex_trie_dict module</a><ul>
<li><a class="reference internal" href="#pattern-matching-in-regextriedict">2.1.12.1. Pattern Matching in RegexTrieDict</a></li>
<li><a class="reference internal" href="#pattern-matching-implementation-details">2.1.12.2. Pattern-matching Implementation Details</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="wff_language.pratt_types.html"
                        title="previous chapter">2.1.11. wff_language.pratt_types module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="wff_language.regex_trie_dict_lexer.html"
                        title="next chapter">2.1.13. wff_language.regex_trie_dict_lexer module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/wff_language.regex_trie_dict.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.regex_trie_dict_lexer.html" title="2.1.13. wff_language.regex_trie_dict_lexer module"
             >next</a> |</li>
        <li class="right" >
          <a href="wff_language.pratt_types.html" title="2.1.11. wff_language.pratt_types module"
             >previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" >2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>