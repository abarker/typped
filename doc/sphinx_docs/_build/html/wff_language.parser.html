<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1.9. wff_language.parser module &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="index.html" />
    <link rel="up" title="2. wff_language package" href="wff_language.html" />
    <link rel="next" title="2.1.10. wff_language.pratt_parser module" href="wff_language.pratt_parser.html" />
    <link rel="prev" title="2.1.8. wff_language.parse_tree module" href="wff_language.parse_tree.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.pratt_parser.html" title="2.1.10. wff_language.pratt_parser module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="wff_language.parse_tree.html" title="2.1.8. wff_language.parse_tree module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" accesskey="U">2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-wff_language.parser">
<span id="wff-language-parser-module"></span><h1>2.1.9. wff_language.parser module<a class="headerlink" href="#module-wff_language.parser" title="Permalink to this headline">¶</a></h1>
<p>The parser and grammar definition.  Note that we only lexically analyze a few
different sorts of tokens and identifiers, since vars, consts, funs, etc., can
be defined dynamically in the language (and their namespaces intersect).</p>
<p>In a left-to-right recursive descent parser with arbitrary lookahead we could
try to update the lexer on the fly to recognize the exact collection of symbols
which have been defined.  But resolving overloaded operators can require
backtracking.  When backtracking is required that could also require setting
and unsetting the attributes of the tokens in the LanguageData symbol table,
which would be cumbersome to implement and slow.  So we lexically analyze a few
sorts of tokens and then later resolve on-the-fly what types of tokens they
really are.  But consider, since ambiguity resolution is better.</p>
<p>Really consider using the TreeRecognizer as the lexer, dynamically updated.
with reasonably fast inserts and deletes.  What does the algorithm really
require?  We would need to store multiple signatures with functions when
overloading is allowed.  This works OK when all vars, funs, etc. <em>must</em> be
defined before appearing.  But the usual convention allows them to just appear,
or to be taken as some default type in a typed system.  This could require a
simple DFA in the lexer.  Requiring all the vars, etc. to be defined first
would get around this problem <em>except</em> in the defining statements themselves.
A parallel DFA could perhaps be used, or we could just read up to a delimiter
when it is known exactly where an identifier must occur.  We then have the
model where the parser updates the symbol table as it goes, and this also
updates the TreeRecognizer class (as a part of LanguageData, perhaps) which
the lexer then uses to do its business.</p>
<p>Note that we assume all language elements other than parens and commas and a
few other grammatical characters and commands are identifiers in a common
namespace, each declared via a declaration and thus known in the languageData
symbol table as far as its type, etc.  Only infix and prefix function names are
allowed to contain the &#8220;usual&#8221; operator symbols, and std functions can only
contain them after the first character(???ambig).  This is so that common infix
and prefix functions can often be written without having to leave whitespace
between them and their operands when the the operators both begin and end with
an operator character.  An exception is when prefix and infix functions
concatenate to form another valid operator, as in x - -y versus x &#8211; y.
Otherwise operators cannot be juxtaposed</p>
<p>x +54* 5  x+54*5  can&#8217;t allow non-operator inside or ambiguous again!</p>
<p>For NOW, we can just restrict all operator characters to infix and prefix
operators.  Consider more: it depends on the lexical analyzer that is used,
since a more exact lexical analyzer has less ambiguity.</p>
<dl class="class">
<dt id="wff_language.parser.Command">
<em class="property">class </em><tt class="descclassname">wff_language.parser.</tt><tt class="descname">Command</tt><a class="headerlink" href="#wff_language.parser.Command" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></p>
<p>Command(defType, defTypeConvert, defTypeAlias, defQuant, defConst, defVar, defStdFun, defPreFun, defInfFun)</p>
<dl class="attribute">
<dt id="wff_language.parser.Command.defConst">
<tt class="descname">defConst</tt><a class="headerlink" href="#wff_language.parser.Command.defConst" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 4</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defInfFun">
<tt class="descname">defInfFun</tt><a class="headerlink" href="#wff_language.parser.Command.defInfFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 8</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defPreFun">
<tt class="descname">defPreFun</tt><a class="headerlink" href="#wff_language.parser.Command.defPreFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 7</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defQuant">
<tt class="descname">defQuant</tt><a class="headerlink" href="#wff_language.parser.Command.defQuant" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defStdFun">
<tt class="descname">defStdFun</tt><a class="headerlink" href="#wff_language.parser.Command.defStdFun" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 6</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defType">
<tt class="descname">defType</tt><a class="headerlink" href="#wff_language.parser.Command.defType" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defTypeAlias">
<tt class="descname">defTypeAlias</tt><a class="headerlink" href="#wff_language.parser.Command.defTypeAlias" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defTypeConvert">
<tt class="descname">defTypeConvert</tt><a class="headerlink" href="#wff_language.parser.Command.defTypeConvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="wff_language.parser.Command.defVar">
<tt class="descname">defVar</tt><a class="headerlink" href="#wff_language.parser.Command.defVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 5</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="wff_language.parser.ParseError">
<em class="property">exception </em><tt class="descclassname">wff_language.parser.</tt><tt class="descname">ParseError</tt><big>(</big><em>message</em><big>)</big><a class="reference internal" href="_modules/wff_language/parser.html#ParseError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.ParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>Exception raised when a parse error occurs, returning a message.
Later we may want to save line numbers, too, for better error reporting.</p>
</dd></dl>

<dl class="class">
<dt id="wff_language.parser.Parser">
<em class="property">class </em><tt class="descclassname">wff_language.parser.</tt><tt class="descname">Parser</tt><a class="reference internal" href="_modules/wff_language/parser.html#Parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is the parser for the full language.</p>
<dl class="method">
<dt id="wff_language.parser.Parser.atomicTypedForm">
<tt class="descname">atomicTypedForm</tt><big>(</big><em>nSpace</em>, <em>rType</em><big>)</big><a class="reference internal" href="_modules/wff_language/parser.html#Parser.atomicTypedForm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.Parser.atomicTypedForm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.parser.Parser.command">
<tt class="descname">command</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/parser.html#Parser.command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.Parser.command" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.parser.Parser.gwff">
<tt class="descname">gwff</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/parser.html#Parser.gwff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.Parser.gwff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.parser.Parser.multiline">
<tt class="descname">multiline</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/parser.html#Parser.multiline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.Parser.multiline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.parser.Parser.typedForm">
<tt class="descname">typedForm</tt><big>(</big><em>nSpace</em>, <em>rType</em><big>)</big><a class="reference internal" href="_modules/wff_language/parser.html#Parser.typedForm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.Parser.typedForm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.parser.Parser.wellFormedLine">
<tt class="descname">wellFormedLine</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/parser.html#Parser.wellFormedLine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.parser.Parser.wellFormedLine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="data">
<dt id="wff_language.parser.comm">
<tt class="descclassname">wff_language.parser.</tt><tt class="descname">comm</tt><em class="property"> = Command(defType='DefType', defTypeConvert='DefTypeConvert', defTypeAlias='DefTypeAlias', defQuant='DefQuant', defConst='DefConst', defVar='DefVar', defStdFun='DefStdFun', defPreFun='DefPreFun', defInfFun='DefInfFun')</em><a class="headerlink" href="#wff_language.parser.comm" title="Permalink to this definition">¶</a></dt>
<dd><p># An identifier1 is the namespace for a variable, constant, or type but this
# intersects with the other spaces so it is not definite.  Pick these off first.</p>
<p># An identifier2 is an infix or prefix function name.
identUnknownFirstRe = lbrac + escapeSpecial(&#8220;a-zA-Z~!&#64;#$%^&amp;*_+=|?&lt;&gt;&#8221;) + rbrac
identUnknownRestRe  = lbrac + escapeSpecial(&#8220;a-zA-Z~!&#64;#$%^&amp;*_+=|?&lt;&gt;0-9&#8221;) + rbrac
identUnknownRe = identUnknownFirstRe + lpar + identUnknownRestRe + ast + rpar</p>
<p>operatorRe = lbrac + escapeSpecial(&#8220;~!&#64;#$%^&amp;*_+=|?&lt;&gt;&#8221;) + rbrac
identKnownOpRe = operatorRe+identifierUnknownRe+operatorRe
numberRe = r&#8221;[0-9]+(.*)([0-9]+)?&#8221; # not currently used
commands = [&#8220;DefType&#8221;,&#8221;DefTypeConversion&#8221;,&#8221;DefTypeAlias&#8221;,&#8221;DefQuant&#8221;,</p>
<blockquote>
<div>&#8220;DefConst&#8221;, &#8220;DefVar&#8221;,&#8221;DefStdFun&#8221;,&#8221;DefPrefixFun&#8221;,&#8221;DefInfixFun&#8221;]</div></blockquote>
<p>matchAllNonWhitespaceRe = r&#8221;[^s]&#8221;</p>
<p># do we really want a parser class?  what should it do?  Maybe get used
# by a language or theory class to implement a method, without making
# into a class proper??  Consider.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="wff_language.parse_tree.html"
                        title="previous chapter">2.1.8. wff_language.parse_tree module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="wff_language.pratt_parser.html"
                        title="next chapter">2.1.10. wff_language.pratt_parser module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/wff_language.parser.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.pratt_parser.html" title="2.1.10. wff_language.pratt_parser module"
             >next</a> |</li>
        <li class="right" >
          <a href="wff_language.parse_tree.html" title="2.1.8. wff_language.parse_tree module"
             >previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" >2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>