<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1.19. wff_language.trie_dict module &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="index.html" />
    <link rel="up" title="2. wff_language package" href="wff_language.html" />
    <link rel="prev" title="2.1.18. wff_language.theory_interface module" href="wff_language.theory_interface.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.theory_interface.html" title="2.1.18. wff_language.theory_interface module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" accesskey="U">2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-wff_language.trie_dict">
<span id="wff-language-trie-dict-module"></span><h1>2.1.19. wff_language.trie_dict module<a class="headerlink" href="#module-wff_language.trie_dict" title="Permalink to this headline">¶</a></h1>
<p>The TrieDict data structure is based on keys which are sequences of elements
(i.e., the keys are iterable and can be concatenated with &#8220;+&#8221;).  It provides an
efficient way to recognize or map key-sequences of (hashable) items in time
linear with the length of the sequence.  For example, a sequence of characters
forming a string can be recognized or mapped to some output in linear time.  A
TrieDict can be used either as a dict or as a set (like using only the has_key
part of a dict).  Inserting and deleting key-sequences from the tree is also
linear in the length of the key-sequence.</p>
<p>In the usual applications, elements are characters and sequences are strings.
This module is written generically, however, so that arbitrary hashable objects
can be used as the elements.  Iterable sequences these elements are the items
stored in the TrieDict.  Except for pattern-matching, arbitrary sequences of
arbitrary hashable elements can be inserted and deleted freely in the TrieDict.
(When regexp pattern-matching is to be used the default assumes characters and
sequences are strings, but that can be changed.)</p>
<p>The keys method assumes that the plus operator combines elements, but setting
asLists=True returns the list version without attempting the &#8220;addition.&#8221;</p>
<p>The usage of a TrieDict is as follows.  First create an empty TrieDict:</p>
<blockquote>
<div>td = TrieDict()</div></blockquote>
<p>Now insert some items.  The insert method inserts a key and an optional second
argument (default is None) which is the value associated with the key.
Alternately, the dict-style bracket notation can be used.  Any iterable items
which iterate over hashable elements can be inserted.  The nodes of the trie
will be built up from the pieces obtained by iterating over each inserted item.
In the case of strings, iteration gives the individual characters.</p>
<blockquote>
<div>td.insert(&#8220;egg&#8221;)
td.insert(&#8220;r&#8221;, &#8220;what_r_maps_to&#8221;)
td[&#8220;s&#8221;] = &#8220;what_s_maps_to&#8221; # bracket indexing is supported
td.insert(&#8220;eggbert&#8221;)</div></blockquote>
<p>The above creates a tree with some reduncancy on the &#8220;egg&#8221; prefix.
To test if a key is in the trie, use the usual has_key method, as
with a dict:</p>
<blockquote>
<div>if td.has_key(&#8220;egg&#8221;): print(&#8216;Correct, &#8220;egg&#8221; is stored&#8217;)
else: print(&#8216;Incorrect, &#8220;egg&#8221; is stored&#8217;)</div></blockquote>
<p>Many of the basic dict operations can be applied, but the full interface is not
currently supported.</p>
<p>Note that this data structure is called a &#8220;trie.&#8221;  For this application the
basic implementation here is sufficient and allows for more control over the
interface and implementation.  There are, however, several different Python
packages available (optimized for efficiency in various ways):</p>
<blockquote>
<div><a class="reference external" href="https://en.wikipedia.org/wiki/Trie">https://en.wikipedia.org/wiki/Trie</a>
<a class="reference external" href="http://kmike.ru/python-data-structures/">http://kmike.ru/python-data-structures/</a></div></blockquote>
<p>For usual dict applications the standard hashed dict would be faster.  The
TrieDict data structure is especially good for the case where keys are
concatenations of hashable objects, such as in a lexical analyzer to tokenize
character strings.</p>
<p>The data structure in this implementation makes heavy use of Python&#8217;s built-in
dict.  It is basically just a dict of dicts of dicts, etc., arranged into a
tree.  In the case of a string the characters of the string are used as the
keys to walk down the tree.  Each tree node holds a value that the input which
stops there is mapped to.  In a lexical analyzer application each tree node can
holds a boolean accept/reject value according to whether a test-word is a key
in the dict (when it terminates at that node it is either recognized or not).</p>
<dl class="class">
<dt id="wff_language.trie_dict.TrieDict">
<em class="property">class </em><tt class="descclassname">wff_language.trie_dict.</tt><tt class="descname">TrieDict</tt><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">_abcoll.MutableMapping</span></tt></p>
<p>This is a dict where the keys are made up of sequences of elements.  It
is stored as a tree from the root with each element of a key indexing some
child node.  The sequence of elements is a walk down the tree.  In a lexical
analysis application the tokens are strings and the elements (sequences of
which make up tokens) are characters.</p>
<p>The data structure can be queried element by element, finding the shortest
or longest match in a sequence.  These results from insertSeqElem
are stored and returned to the user as a deque, since pops on both ends may
be useful.</p>
<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the tree to its initial condition, empty of any stored strings.
Any meta-element redefinitions are retained.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.delitem">
<tt class="descname">delitem</tt><big>(</big><em>key</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.delitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.delitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the stored key and its data.  Raises KeyError if the key wasn&#8217;t
found in the trie.  If d is a dict, the syntax del d[key] also invokes
this function.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.get">
<tt class="descname">get</tt><big>(</big><em>keySeq</em>, <em>default=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the data element stored with key keySeq, returning the default
if the key is not in the dict.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.getDfsGen">
<tt class="descname">getDfsGen</tt><big>(</big><em>subtreeRootNode</em>, <em>funToApply=None</em>, <em>includeRoot=False</em>, <em>yieldOnLeaves=True</em>, <em>yieldOnMatch=False</em>, <em>copies=True</em>, <em>stopAtElems=</em>, <span class="optional">[</span><span class="optional">]</span><em>stopAtDepth=False</em>, <em>onlyFollowElems=</em>, <span class="optional">[</span><span class="optional">]</span><em>sortChildren=False</em>, <em>subtreeRootElem=None</em>, <em>childFun=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.getDfsGen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.getDfsGen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generator which will do a depth-first traversal of the trie,
starting at node subtreeRootNode.  On each call it returns a list of
(nodeElem, node) pairs for each node on some path from the root to a leaf
of the tree.  It generates such a list for each path from the root to a
leaf (one on each call).  If yieldOnMatch is set True then the current
list being constructed on a path down the tree is returned on the first
time any match-marked node is encountered, even if the node is not a
leaf.  If yieldOnLeaves is set False then yields will only be done on
matches.  (If both are False then the routine returns nothing.)</p>
<p>If the list stopAtElems contains any elements then nodes for those
elements are treated as leaves.  If stopAtDepth has a positive integer
value then nodes at that depth are treated as leaves.  The
onlyFollowElems list is like the negation for stopAtElems: it treats
everything not on the list like a leaf node (i.e., it only folows
child-links which are on the list).</p>
<p>If funToApply is defined it will be called for each (nodeElem, node) pair
on the returned lists.  The function should take two arguments; the list
will contain the function&#8217;s return value.  A copy of the node list is
returned on each generation, but the nodes are always the actual nodes in
the trie.  If includeRoot is True then output from the subtreeRootNode
itself will be included in the output (with None as the corresponding
nodeElem).</p>
<p>If copies is set False then a single node list is used; this may be a
little faster, but the returned list will change after each
generation-cycle.  If sortChildren is True then the children of
each node will be sorted in the dfs search ordering.</p>
<p>Setting subtreeRootElem to an element will set that as the element on
the returned list corresponding to the subtree root (otherwise it is
None.  Sometimes the value is known when the function call is made,
and it can be convenient to have a uniform list pattern.</p>
<p>If childFun is set to a function then the children of a node are obtained
by calling that function with the node as the argument.  This is helpful,
for example, in pattern-matches where the child dict is locally modified
per state.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.getNextNode">
<tt class="descname">getNextNode</tt><big>(</big><em>queryElem</em>, <em>node</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.getNextNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.getNextNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next node in the trie from node when the key-query element
queryElem is received.  This routine treats meta-characters as ordinary
characters.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.getNode">
<tt class="descname">getNode</tt><big>(</big><em>keySeq</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.getNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.getNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the node indexed by using the sequence keySeq as the key.  Does
not test whether isLastElemOfKey is True, so it also returns a node for any prefix
of a key.  Returns None if there is no corresponding node.  This is
mainly used by other methods to walk down the tree to find a keyed
node.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.has_key">
<tt class="descname">has_key</tt><big>(</big><em>keySeq</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.has_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.has_key" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean for whether the string is stored; doesn&#8217;t handle anything else
such as multiple matches or longest prefix match.  Leaves the tree and all
saved data unaltered.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.insert">
<tt class="descname">insert</tt><big>(</big><em>keySeq</em>, <em>data=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the data item in the dict with the key keySeq.  Any existing
data at that key is overwritten.  This method is aliased to __setitem__.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.isPrefixOfKey">
<tt class="descname">isPrefixOfKey</tt><big>(</big><em>seq</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.isPrefixOfKey"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.isPrefixOfKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the sequence seq a prefix of some key-sequence in the trie?
Equality is considered a prefix.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.items">
<tt class="descname">items</tt><big>(</big><em>asLists=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.items"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all the (keys,value) tuples stored in the trie.  Note
that the plus operator is assumed to be overloaded to combine separate
elements into a single key.  Setting asLists=True can be used to return
the keys as lists of elements, without attempting to combine them.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.iteritems">
<tt class="descname">iteritems</tt><big>(</big><em>asLists=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.iteritems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator over the items in the trie, see the items method for details.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.iterkeys">
<tt class="descname">iterkeys</tt><big>(</big><em>asLists=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.iterkeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.iterkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator over the keys in the trie, see the keys method for details.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.itervalues">
<tt class="descname">itervalues</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.itervalues"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.itervalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all the values stored in the trie.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.keys">
<tt class="descname">keys</tt><big>(</big><em>asLists=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all the keys stored in the trie.  Note that the plus
operator is assumed to be overloaded to combine separate elements into a
single key.  Setting asLists=True can be used to return the keys as lists
of elements, without attempting to combine them.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.numChildren">
<tt class="descname">numChildren</tt><big>(</big><em>node</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.numChildren"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.numChildren" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of children at a node in the tree, i.e., the number of child
nodes which are indexed by keys in its dict.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.printTree">
<tt class="descname">printTree</tt><big>(</big><em>node=0</em>, <em>depth=0</em>, <em>separation=1</em>, <em>childFun=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.printTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.printTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Print out a representation of the stored tree of keys.  Useful for
debugging.  Call with default arguments to get the full tree.
The variable separation can be increased to increase the space
between printed elements on a line.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.setitem">
<tt class="descname">setitem</tt><big>(</big><em>keySeq</em>, <em>data=None</em><big>)</big><a class="headerlink" href="#wff_language.trie_dict.TrieDict.setitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the data item in the dict with the key keySeq.  Any existing
data at that key is overwritten.  This method is aliased to __setitem__.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.someKeyIsPrefix">
<tt class="descname">someKeyIsPrefix</tt><big>(</big><em>seq</em><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.someKeyIsPrefix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.someKeyIsPrefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Very efficient determination of whether some key in the TrieDict
is a prefix of the sequence seq.  Equality is considered a prefix.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.trie_dict.TrieDict.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDict.values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDict.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all the values stored in the trie.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="wff_language.trie_dict.TrieDictNode">
<em class="property">class </em><tt class="descclassname">wff_language.trie_dict.</tt><tt class="descname">TrieDictNode</tt><a class="reference internal" href="_modules/wff_language/trie_dict.html#TrieDictNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.trie_dict.TrieDictNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class is used internally, as the nodes of the tree.  It is just used as
a record to hold the child data, match information, and arbitrary node data.</p>
<dl class="attribute">
<dt id="wff_language.trie_dict.TrieDictNode.children">
<tt class="descname">children</tt><a class="headerlink" href="#wff_language.trie_dict.TrieDictNode.children" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.trie_dict.TrieDictNode.data">
<tt class="descname">data</tt><a class="headerlink" href="#wff_language.trie_dict.TrieDictNode.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.trie_dict.TrieDictNode.isLastElemOfKey">
<tt class="descname">isLastElemOfKey</tt><a class="headerlink" href="#wff_language.trie_dict.TrieDictNode.isLastElemOfKey" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="wff_language.theory_interface.html"
                        title="previous chapter">2.1.18. wff_language.theory_interface module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/wff_language.trie_dict.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.theory_interface.html" title="2.1.18. wff_language.theory_interface module"
             >previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" >2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>