<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>typped.builtin_parse_methods module &#8212; Typped  documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Typped  documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-typped.builtin_parse_methods">
<span id="typped-builtin-parse-methods-module"></span><h1>typped.builtin_parse_methods module<a class="headerlink" href="#module-typped.builtin_parse_methods" title="Permalink to this headline">¶</a></h1>
<p>TODO: Decide soon if this is a good idea, or else delete.  Copies
still in main module.</p>
<p>These functions can be in both the typped namespace and the PrattParser
namespace... change the parser arg to &#8220;parser&#8221; in this file...</p>
<p>Built-in parsing methods of the <cite>PrattParser</cite> class.</p>
<table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">This code</th>
<th class="head">Pratt&#8217;s terminology</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>token precedence</td>
<td>left binding power, lbp</td>
</tr>
<tr class="row-odd"><td>subexpression precedence</td>
<td>right binding power, rbp</td>
</tr>
<tr class="row-even"><td>head handler function</td>
<td>null denotation, nud</td>
</tr>
<tr class="row-odd"><td>tail handler function</td>
<td>left denotation, led</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="typped.builtin_parse_methods.def_literal">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_literal</code><span class="sig-paren">(</span><em>parser</em>, <em>token_label</em>, <em>val_type=None</em>, <em>construct_label=None</em>, <em>precond_fun=None</em>, <em>precond_priority=1</em>, <em>typesig_override_fun=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_literal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_literal" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the token with label <cite>token_label</cite> to be a literal in the
syntax of the language being parsed.  This method adds a head handler
function to the token.  Literal tokens are the leaves of the expression
trees; they are things like numbers and variable names in a numerical
expression.  They always occur as the first (and only) token in a
subexpression being evaluated by <cite>recursive_parse</cite>, so they need a head
handler but not a tail handler.  (Though note that the token itparser
might also have a tail handler.)</p>
<p>A function <cite>typesig_override_fun</cite> can be passed in, taking a token and
a lexer as its two arguments and returning a <cite>TypeSig</cite> object.  If it
is set then it will be called from the head handler and the type
signature of the node will be assigned the returned signature.  Can be
useful for dynamic typing such as when identifiers in an interpreted
language are generic variables.</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_multi_literals">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_multi_literals</code><span class="sig-paren">(</span><em>parser</em>, <em>tuple_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_multi_literals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_multi_literals" title="Permalink to this definition">¶</a></dt>
<dd><p>An interface to the <cite>def_literal</cite> method which takes a list of
tuples.  The <cite>def_literal</cite> method will be called for each tuple, unpacked
in the order in the tuple.  Unspecified optional arguments get their default
values.</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_infix_multi_op">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_infix_multi_op</code><span class="sig-paren">(</span><em>parser</em>, <em>operator_token_labels</em>, <em>prec</em>, <em>assoc</em>, <em>repeat=False</em>, <em>not_in_tree=False</em>, <em>construct_label=None</em>, <em>precond_fun=None</em>, <em>precond_priority=0</em>, <em>val_type=None</em>, <em>arg_types=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_infix_multi_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_infix_multi_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of operator token labels and defines a multi-infix
operator.</p>
<p>If <cite>repeat=True</cite> it will accept any number of repetitions of
the list of operators (but type-checking for that is not implemented
yet).  For a single operator, repeating just has the effect of putting
the arguments in a flat argument/child list instead of as nested binary
operations based on left or right association.  Any argument-checking
is done after any node removal, which may affect the types that should
be passed-in in the list arg_types of parent constructs.</p>
<p>If <cite>not_in_tree</cite> is false.......</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_infix_op">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_infix_op</code><span class="sig-paren">(</span><em>parser</em>, <em>operator_token_label</em>, <em>prec</em>, <em>assoc</em>, <em>not_in_tree=False</em>, <em>construct_label=None</em>, <em>precond_fun=None</em>, <em>precond_priority=0</em>, <em>val_type=None</em>, <em>arg_types=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_infix_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_infix_op" title="Permalink to this definition">¶</a></dt>
<dd><p>This just calls the more general method <cite>def_multi_infix_op</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_prefix_op">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_prefix_op</code><span class="sig-paren">(</span><em>parser</em>, <em>operator_token_label</em>, <em>prec</em>, <em>construct_label=None</em>, <em>precond_fun=None</em>, <em>precond_priority=0</em>, <em>val_type=None</em>, <em>arg_types=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_prefix_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_prefix_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a prefix operator.  Note that head handlers do not have
precedences, only tail handlers.  (With respect to the looping in
<cite>recursive_parse</cite> it wouldn&#8217;t make a difference.)  But, within the head
handler, the call to <cite>recursive_parse</cite> can be made with a nonzero
precedence.  This allows setting a precedence to determine the argument
expressions that the prefix operators grabs up (or doesn&#8217;t).</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_postfix_op">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_postfix_op</code><span class="sig-paren">(</span><em>parser</em>, <em>operator_token_label</em>, <em>prec</em>, <em>allow_ignored_before=True</em>, <em>construct_label=None</em>, <em>precond_fun=None</em>, <em>precond_priority=0</em>, <em>val_type=None</em>, <em>arg_types=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_postfix_op"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_postfix_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a postfix operator.  If <cite>allow_ignored_before</cite> is false then
no ignored token (usually whitespace) can appear immediately before the
operator.</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_bracket_pair">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_bracket_pair</code><span class="sig-paren">(</span><em>parser</em>, <em>lbrac_token_label</em>, <em>rbrac_token_label</em>, <em>construct_label=None</em>, <em>precond_fun=None</em>, <em>precond_priority=0</em>, <em>eval_fun=None</em>, <em>ast_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_bracket_pair"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_bracket_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a matching bracket grouping operation.  The returned type is
set to the type of its single child (i.e., the type of the contents of
the brackets).  Defines a head handler for the left bracket token, so
effectively gets the highest evaluation precedence.  As far as types,
it is treated as a function that takes one argument of wildcard type
and returns whatever type the argument has.</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_stdfun">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_stdfun</code><span class="sig-paren">(</span><em>parser</em>, <em>fname_token_label</em>, <em>lpar_token_label</em>, <em>rpar_token_label</em>, <em>comma_token_label</em>, <em>precond_priority=1</em>, <em>val_type=None</em>, <em>arg_types=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em>, <em>num_args=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_stdfun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_stdfun" title="Permalink to this definition">¶</a></dt>
<dd><p>This definition of stdfun uses lookahead to the opening paren or
bracket token.</p>
<p>Note that all tokens must be defined as literal tokens except
<cite>fname_token_label</cite> (which ends up as the root of the function
evaluation subtree).  If the latter is also a literal token then
<cite>precond_priority</cite> may need to be increased to give this use priority.</p>
<p>The <cite>num_args</cite> parameter is optional for specifying the number of
arguments when typing is not being used.  If it is set to a nonnegative
number then it will automatically set <cite>arg_types</cite> to the corresponding
list of <cite>None</cite> values; if <cite>arg_types</cite> is set then it is ignored.</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_stdfun_lpar_tail">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_stdfun_lpar_tail</code><span class="sig-paren">(</span><em>parser</em>, <em>fname_token_label</em>, <em>lpar_token_label</em>, <em>rpar_token_label</em>, <em>comma_token_label</em>, <em>prec_of_lpar</em>, <em>val_type=None</em>, <em>arg_types=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em>, <em>num_args=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_stdfun_lpar_tail"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_stdfun_lpar_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternate version of stdfun that defines lpar as an infix
operator (i.e., with a tail handler).  This function works in the usual cases
but the current version without preconditions may have problems distinguishing
&#8220;b (&#8221; from &#8220;b(&#8221; when a multiplication jop is set.  The lookahead version
<cite>def_stdfun</cite> is usually preferred.  This method assumes type checking is on
if <cite>num_arg</cite> is set.</p>
</dd></dl>

<dl class="function">
<dt id="typped.builtin_parse_methods.def_jop">
<code class="descclassname">typped.builtin_parse_methods.</code><code class="descname">def_jop</code><span class="sig-paren">(</span><em>parser</em>, <em>prec</em>, <em>assoc</em>, <em>construct_label=None</em>, <em>precond_fun=None</em>, <em>precond_priority=None</em>, <em>val_type=None</em>, <em>arg_types=None</em>, <em>eval_fun=None</em>, <em>ast_data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/typped/builtin_parse_methods.html#def_jop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#typped.builtin_parse_methods.def_jop" title="Permalink to this definition">¶</a></dt>
<dd><p>The function <cite>precond_fun</cite> is called to determine whether or not to
infer a juxtaposition operator between the previously-parsed
subexpression result and the next token.  This function will be passed
the lexer as well as the lookbehind list as arguments.  Note that the
<cite>jop_precond</cite> function has access to the type information for the
potential left operand but not for the potential right operand.  If
this function returns <cite>True</cite> then a jop is inferred and the parse
proceeds assuming there is a jop token in the token stream.</p>
<p>Note that if the juxtaposition operator always resolves to a single
type signature based on its argument types then, even if overloading on
return types is in effect, the jop can be effectively inferred based on
type signature information.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/typped.pratt_builtin_parse_methods.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Typped  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.8.
    </div>
  </body>
</html>