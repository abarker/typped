<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1.5. wff_language.interfaces module &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="index.html" />
    <link rel="up" title="2. wff_language package" href="wff_language.html" />
    <link rel="next" title="2.1.6. wff_language.language_data module" href="wff_language.language_data.html" />
    <link rel="prev" title="2.1.4. wff_language.external_program_calls module" href="wff_language.external_program_calls.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.language_data.html" title="2.1.6. wff_language.language_data module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="wff_language.external_program_calls.html" title="2.1.4. wff_language.external_program_calls module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" accesskey="U">2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-wff_language.interfaces">
<span id="wff-language-interfaces-module"></span><h1>2.1.5. wff_language.interfaces module<a class="headerlink" href="#module-wff_language.interfaces" title="Permalink to this headline">Â¶</a></h1>
<p>This module defines the <cite>implements</cite> function which assigns an implementation
to an interface definition, checking that the implementation satisfies the
requirements of the interface.  It also provides the <cite>abstract()</cite> function which
is called in place of implementation code in interface methods.</p>
<p>The implementation of the <cite>implements</cite> here function is quite simple: the
function call</p>
<blockquote>
<div>implements(implementation_name, interface_name)</div></blockquote>
<p>is essentially just an assignment</p>
<blockquote>
<div>interface_name = implementation_name</div></blockquote>
<p>in the same namespace, which then works via duck typing.  Note, though, that
the order is reversed from assignment to match the intuitive interpretation
&#8220;argument one implements argument two.&#8221;</p>
<p>The only loss of efficiency is the small checking-time overhead before the
assignment is made.  This should work for any class that provides an interface
of fixed attributes.  There are some restrictions that follow from this simple
mechanism.</p>
<p>Below is an example using a stack interface S with two implementations LS and
LLS.  The boxed things are the values of the variable names below them.  The
notation &#8220;&lt;Obj1&gt; &#8211;&gt; &lt;Obj2&gt;&#8221; means that one object &lt;Obj1&gt; has saved a reference
to another object &lt;Obj2&gt;.</p>
<blockquote>
<div><dl class="docutils">
<dt>class S(object):</dt>
<dd>&lt;public methods of a stack, with abstract() as the implementation&gt;</dd>
<dt>class LS(object):</dt>
<dd>&lt;actual implementation of S&#8217;s stack methods (using lists)&gt;</dd>
<dt>class LLS(object):</dt>
<dd>&lt;actual implementation of S&#8217;s stack methods (using linked lists)&gt;</dd>
</dl>
<p>&#8212;&#8212;&#8212;       &#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8211;
<a href="#id3"><span class="problematic" id="id4">|&lt;S_Obj&gt;|</span></a>       <a href="#id5"><span class="problematic" id="id6">|&lt;LS_Obj&gt;|</span></a>      <a href="#id7"><span class="problematic" id="id8">|&lt;LLS_Obj&gt;|</span></a>
&#8212;&#8212;&#8212;       &#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8211;
S               LS              LLS</p>
<p>implements(LS, S)</p>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8211;
<a href="#id9"><span class="problematic" id="id10">|&lt;LS_Obj&gt; &#8211;&gt; &lt;S_Obj&gt;|</span></a>      <a href="#id11"><span class="problematic" id="id12">|&lt;LS_Obj&gt; &#8211;&gt; &lt;S_Obj&gt;|</span></a>      <a href="#id13"><span class="problematic" id="id14">|&lt;LLS_Obj&gt;|</span></a>
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8211;
S                           LS                          LLS</p>
<p>implements(LLS, S)</p>
<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;     &#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
<a href="#id15"><span class="problematic" id="id16">|&lt;LLS_Obj&gt; &#8211;&gt; &lt;S_Obj&gt;|</span></a>     <a href="#id17"><span class="problematic" id="id18">|&lt;LS_Obj&gt;|</span></a>      <a href="#id19"><span class="problematic" id="id20">|&lt;LLS_Obj&gt; &#8211;&gt; &lt;S_Obj&gt;|</span></a>
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;     &#8212;&#8212;&#8212;-      &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
S                           LS              LLS</p>
</div></blockquote>
<p>Notice that we cannot have two implementations of the same interface at the
same time, because S can only be assigned to reference one object at a time
(then making use of duck typing to implement the calls to its interface).  So
the link from LS to &lt;S_Obj&gt; is deleted when the second <cite>implements</cite> call is
made.  S now references &lt;LLS_Obj&gt; with a backlink to its definitional object
&lt;S_Obj&gt;.  The link back to the original definitional object is saved precisely
so that these kind of reassignments can be made to work, since in the second
call to implements S actually references &lt;LS_Obj&gt;.</p>
<p>Aliases to interface definitions are considered to be <em>different</em> interface
definitions, not aliases.  This is because it is difficult to check that
variable S is used rather than, say, an alias such as from the assignment AS =
S.  Then implements(LS, AS) in the first line would set the implementation of
AS to be &lt;LS_Obj&gt;, but S would still point to &lt;S_Obj&gt;, so this fails from a
syntactic perspective.</p>
<hr class="docutils" />
<p>We could maybe restrict S to not have any aliases by checking the reference
count of its object, and we can also restrict interfaces to necessarily be
defined in the same module where implements is called.  Bad idea.</p>
<p>One way is to look at the globals() dict, keyed on variable names and
returning their assignments.  See also <a class="reference external" href="http://stackoverflow.com/questions/8875202">http://stackoverflow.com/questions/8875202</a>
We can use the S.__name__ attribute to get the string &#8220;S&#8221;.  We can use the
globals dict to look up what S is currently referencing.</p>
<p>Note that we cannot have multiple interfaces with the same implementation
if we are storing the original interface with the implementation as an
attribute.  At the least we&#8217;d need to modify how that is done.</p>
<blockquote>
<div><p>Strange idea: what if we just copy over all the methods and attributes from
LS onto S, saving the old ones somewhere, maybe with a name-prefix on their
attributes.  Or maybe keep a deep copy of S.  Then, any references,
anywhere, just work.  We can check the methods and attributes as we do it.
We still only get one implementation, but it can be changed.
- see file in scratch directory... seems to work for most attributes, don&#8217;t</p>
<blockquote>
<div>know what complications it might cause.</div></blockquote>
<p>Another strange idea: what if you overloaded the = operator on interfaces
to actually be a deep copy?  Wasteful, perhaps, but would it work?  No,
can&#8217;t overload = in Python.</p>
</div></blockquote>
<p>Which one is the case:</p>
<blockquote>
<div><ul class="simple">
<li>Note that it is irrelevant whether <cite>implements</cite> is being called from module</li>
</ul>
<p>scope, function scope, or class scope.  The <cite>interface_name</cite> argument which
occurs on the l.h.s. of the assignment is always a defined interface name
in correct usage &#8211; even when it has been redefined to point to an
implementation object.  The name will assigned in whatever scope it is in.
(How to check correct usage?)</p>
<p>What if you assign an implementation to an interface that then goes out of
scope, and the implementation then points to a dead object as its interface
(dangling reference)?  The implementation might be global and the interface
could be local in a function, for example.  It is best to always define
interfaces at global scope to avoid those problems. (Can that be enforced?
Probably.)</p>
<ul class="simple">
<li>Note that we need to notice if <cite>implements</cite> is being called from module</li>
</ul>
<p>scope or function or class scope, since in the former case we need to look
up the module, and in the latter case we can just do the assignment (since
the scope doesn&#8217;t extend beyond the current module).  This should be
transparent to a user.</p>
</div></blockquote>
<p>Reassignments are slightly more complicated, since in that case the
<cite>interface_name</cite> passed in has already been set to a previous
<cite>implementation_name</cite>.  Thus the <cite>implements</cite> function needs some way to look
up the original interface which was set to have that implementation.</p>
<p>To handle reassignments the <cite>implements</cite> function just pastes a reference to
the original interface onto every implementation it sets, as an attribute
called <cite>_implementing_interface</cite>.  If an interface argument has that attribute
set then the value of that argument will be assigned to the implementation
name, rather than the actual object passed in.  Note that this imposes the
slight restriction that implementations must have a __dict__ to allow
an attribute to be assigned.</p>
<p>The <cite>_implementing_interface</cite> attribute is never modified after it is set
(unless <cite>implements</cite> is called again to set it to implement a different
interface).  The user can do so if desired, but it should not be necessary.  If
it is set to anything which evaluates to False it will be ignored.</p>
<p>Implementations are restricted to only implement one interface at a time.  On
reassignment the previous interface name is set back to its original class
definition.  Interfaces can, however, have more than one implementation.</p>
<p>This follows from the implementation as assignment, where we need a single
implementation to assign to the interface name.  On a reassignment we would not
know which implementation to choose.  Actually, the reference is still there
if you define an implementation to implement another interface.  But we need a
unique interface to assign, so reassignment in the second case will not do what
is expected (remember the interface name gets assigned the implementation
object with a link back to the original interface).  Reassignment without the
restriction will mess up the original interface if someone wants to use it
(they will get a different interface, the last one that the implementation
was assigned to use).</p>
<p>What about subclassing?  Is that affected?  Does that look at the methods, etc.,
before any instances are made?</p>
<dl class="docutils">
<dt>&#8211; update &#8211;&gt; Why not just go ahead and let there be multiple implementations?</dt>
<dd><p class="first">Let namespaces take care of things.  Assume that the user knows
the namespaces and knows that the implements just sets a reference
with some magic checking added.</p>
<p>What really needs to be modified is that the name of the
interface saved in the table should be the full packages-module-name</p>
<blockquote>
<div>__package__ + __name__  (joined as appropriate)</div></blockquote>
<p>name of the interface, not just the local name.  Then the problem
goes away.  It may work already, as implemented.  Check.</p>
<p>If they did an import from somewhere, they must have wanted
whatever was set in that namespace.</p>
<p class="last">If nothing else, you can paste on some identifier attribute
whenever some object is set which indexes back.</p>
</dd>
</dl>
<p>Older:</p>
<blockquote>
<div><p>Note that the implements call must be made in the same module as the interface.
The implementation can be in an arbitrary location.  The interface definition
also needs to be in the global scope of the module in which it is defined
(since that&#8217;s where it will be redefined to point to the implementation).</p>
<p>We have to limit to one interface per implementation (since when we get a
pointer to an implementation we have to recover the unique interface in order
to reassign its name, unless we restrict to exactly one implements call for any
interface).  If you really must you could make a copy and modify the __name__
of one of them.</p>
<p>All the above restrictions are checked at runtime.</p>
<p>You can redefine an implementation within a module, for what that&#8217;s worth.</p>
<p>Note that with this variable-redefinition method of implementing interfaces
there can only be one implementation defined at a time.  Any call to implements
will change the definition, and all users will get the last one that was
dynamically assigned.  Note that if you make an alias reference to the
interface you get a reference to the current implementation which will not be
updated when the original is updated.  Implements can be called for it, though,
to change the implementation assigned to it.</p>
<p>If we know that the implements function is called at the global level of the
same module where the interface is defined at the global level then we always
know that any module which imported the interface variable (&#8216;from egg_interface
import egg&#8217;) will get a reference to the final implementation set within the
module and not to the interface itself.  (This is not considering possible
weird mutually recursive calls where you import something in the middle of a
file which then imports the file.)</p>
<p>This restriction on calling the implements function could possibly be loosened
by requiring that the interface definition be private within its module (as
private as Python allows).  Then at least no one could import the name directly
in an import <a href="#id1"><span class="problematic" id="id2">*</span></a>, but they would have to know better than to import by name class
name starting with an underscore (it always has to be accessed in its module
scope, where it was redefined).  You could look at the __name__ and see if it
starts with an underscore to enforce this.</p>
<p>References would be less of a problem if there were a level of indirection on
the interface, linking to the implementation.  That adds a layer of overhead in
method calls, etc., however, and the syntax might be difficult to arrange to
look simple (maybe decorators).  The current approach only has a small startup
overhead cost.</p>
<p>(Note that we could paste some additional info onto the interface and
implementation themselves when they are registered here...)</p>
</div></blockquote>
<dl class="exception">
<dt id="wff_language.interfaces.InterfaceError">
<em class="property">exception </em><tt class="descclassname">wff_language.interfaces.</tt><tt class="descname">InterfaceError</tt><a class="reference internal" href="_modules/wff_language/interfaces.html#InterfaceError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.interfaces.InterfaceError" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="wff_language.interfaces.abstract">
<tt class="descclassname">wff_language.interfaces.</tt><tt class="descname">abstract</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/interfaces.html#abstract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.interfaces.abstract" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Dummy function to be called for methods of interfaces.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.interfaces.get_object_info">
<tt class="descclassname">wff_language.interfaces.</tt><tt class="descname">get_object_info</tt><big>(</big><em>obj</em><big>)</big><a class="reference internal" href="_modules/wff_language/interfaces.html#get_object_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.interfaces.get_object_info" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get basic name and module information about the object.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.interfaces.implements">
<tt class="descclassname">wff_language.interfaces.</tt><tt class="descname">implements</tt><big>(</big><em>implementation</em>, <em>interface</em><big>)</big><a class="reference internal" href="_modules/wff_language/interfaces.html#implements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.interfaces.implements" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Assign <cite>implementation</cite> as an implementation of the interface <cite>interface</cite>.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="wff_language.external_program_calls.html"
                        title="previous chapter">2.1.4. wff_language.external_program_calls module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="wff_language.language_data.html"
                        title="next chapter">2.1.6. wff_language.language_data module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/wff_language.interfaces.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.language_data.html" title="2.1.6. wff_language.language_data module"
             >next</a> |</li>
        <li class="right" >
          <a href="wff_language.external_program_calls.html" title="2.1.4. wff_language.external_program_calls module"
             >previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" >2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>