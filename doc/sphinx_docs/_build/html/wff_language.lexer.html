<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1.7. wff_language.lexer module &mdash; Skolem  documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Skolem  documentation" href="index.html" />
    <link rel="up" title="2. wff_language package" href="wff_language.html" />
    <link rel="next" title="2.1.8. wff_language.parse_tree module" href="wff_language.parse_tree.html" />
    <link rel="prev" title="2.1.6. wff_language.language_data module" href="wff_language.language_data.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.parse_tree.html" title="2.1.8. wff_language.parse_tree module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="wff_language.language_data.html" title="2.1.6. wff_language.language_data module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" accesskey="U">2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-wff_language.lexer">
<span id="wff-language-lexer-module"></span><h1>2.1.7. wff_language.lexer module<a class="headerlink" href="#module-wff_language.lexer" title="Permalink to this headline">¶</a></h1>
<p>A general lexer/scanner module.</p>
<dl class="exception">
<dt id="wff_language.lexer.BufferIndexError">
<em class="property">exception </em><tt class="descclassname">wff_language.lexer.</tt><tt class="descname">BufferIndexError</tt><a class="reference internal" href="_modules/wff_language/lexer.html#BufferIndexError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.BufferIndexError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.IndexError</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="wff_language.lexer.GenTokenState">
<em class="property">class </em><tt class="descclassname">wff_language.lexer.</tt><tt class="descname">GenTokenState</tt><a class="reference internal" href="_modules/wff_language/lexer.html#GenTokenState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.GenTokenState" title="Permalink to this definition">¶</a></dt>
<dd><p>The state of the token_generator program execution.</p>
<dl class="attribute">
<dt id="wff_language.lexer.GenTokenState.end">
<tt class="descname">end</tt><em class="property"> = 2</em><a class="headerlink" href="#wff_language.lexer.GenTokenState.end" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.lexer.GenTokenState.ordinary">
<tt class="descname">ordinary</tt><em class="property"> = 1</em><a class="headerlink" href="#wff_language.lexer.GenTokenState.ordinary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.lexer.GenTokenState.uninitialized">
<tt class="descname">uninitialized</tt><em class="property"> = 3</em><a class="headerlink" href="#wff_language.lexer.GenTokenState.uninitialized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="wff_language.lexer.Lexer">
<em class="property">class </em><tt class="descclassname">wff_language.lexer.</tt><tt class="descname">Lexer</tt><big>(</big><em>symbol_table=None</em>, <em>num_lookahead_tokens=2</em>, <em>max_go_back_tokens=None</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Scans the program and returns the tokens, represented by instances of
<cite>TokenNode</cite> subclass instances. There is one subclass for each kind of
token, i.e., for each token label.  These subclasses themselves are assumed
to have been created before any scanning operation which can return an
instance, via the <cite>define_token</cite> method.</p>
<p>Token strings are assumed to have both a begin and an end token, defined
via the <cite>define_begin_and_end_tokens</cite> method.  These token types act as
sentinels at the beginning and end of the token stream.  Exactly one end
token will be returned by <cite>next</cite>; any further calls to <cite>next</cite> raise
<cite>StopIteration</cite>.</p>
<p>The scanning is independent of the order in which tokens are defined.  The
longest match over all token patterns will always be the one selected.  In
case of ties the <cite>on_ties</cite> value (passed to <cite>define_token</cite>) is used to
break it.  If that fails a <cite>LexerException</cite> is raised.</p>
<p>If no symbol table is passed into <cite>__init__</cite> the <cite>Lexer</cite> will create its
own empty one.</p>
<dl class="attribute">
<dt id="wff_language.lexer.Lexer.ERROR_MSG_TEXT_SNIPPET_SIZE">
<tt class="descname">ERROR_MSG_TEXT_SNIPPET_SIZE</tt><em class="property"> = 40</em><a class="headerlink" href="#wff_language.lexer.Lexer.ERROR_MSG_TEXT_SNIPPET_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.curr_token_is_begin">
<tt class="descname">curr_token_is_begin</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.curr_token_is_begin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.curr_token_is_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <cite>self.token</cite> (the last one returned by the <cite>next</cite> method) is
the begin token.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.curr_token_is_end">
<tt class="descname">curr_token_is_end</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.curr_token_is_end"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.curr_token_is_end" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <cite>self.token</cite> (the last one returned by the <cite>next</cite> method) is
the end token.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.curr_token_is_first">
<tt class="descname">curr_token_is_first</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.curr_token_is_first"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.curr_token_is_first" title="Permalink to this definition">¶</a></dt>
<dd><p>True if <cite>self.token</cite> (the last one returned by the <cite>next</cite> function)
is the first actual token in the currently-set program text.  Resetting
the text resets this.  This value is also set as the attribute
<cite>is_first</cite> on all returned tokens.  This is useful, for example, for
finding indentation levels (along with <cite>ignored_before_curr</cite>).</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.define_begin_and_end_tokens">
<tt class="descname">define_begin_and_end_tokens</tt><big>(</big><em>begin_token_label</em>, <em>end_token_label</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.define_begin_and_end_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.define_begin_and_end_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sentinel tokens at the beginning and end of the token
stream.  This method must be called before using the Lexer.  Returns
a tuple of the new begin and end token subclasses.  These tokens do not
need to be defined with <cite>define_token</cite> because they are never actually
scanned in the program text (which would require the regex pattern).</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.define_token">
<tt class="descname">define_token</tt><big>(</big><em>token_label</em>, <em>regex_string</em>, <em>ignore=False</em>, <em>on_ties=0</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.define_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.define_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a token and the regex to recognize it.  The label
<cite>token_label</cite> is the label for the kind of token.  Setting
<cite>ignore=True</cite> will cause all such tokens to be ignored (except that
they will be placed on the <cite>ignored_before</cite> list of the non-ignored
token that they precede).  In case of ties for the longest match in
scanning, the integer <cite>on_ties</cite> values are used to break the ties.  If
any two are still equal an exception will be raised.  Returns the new
token subclass.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.define_unstored_token">
<tt class="descname">define_unstored_token</tt><big>(</big><em>token_label</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.define_unstored_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.define_unstored_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a token that is not stored in the symbol table dict, and which
has no regex pattern.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.go_back">
<tt class="descname">go_back</tt><big>(</big><em>num_toks=1</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.go_back"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.go_back" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows the lexer to go back in time by <cite>num_toks</cite>
tokens.  Going back one with <cite>go_back(1)</cite> or just <cite>go_back()</cite> results
in the current token being set to a re-scanned version of the previous
token.  The text being parsed is restored to the state before those
<cite>num_toks</cite> previous tokens were scanned, and the farthest one back is
immediately re-scanned.  Lookahead tokens in the buffer are also
re-scanned.  This operation is different from the usual pushback
operations because the program text is re-scanned, rather than simply
backing up to already-scanned tokens.</p>
<p>Values of <cite>num_toks</cite> less than one apply to the current token and
loohahead tokens.  Calling <cite>go_back(0)</cite> re-scans the current token and
all tokens in the lookahead buffer; <cite>go_back(-1)</cite> re-scans only the
tokens in the buffer ahead of the current token.  Values greater than
one go farther back in the token stream.  Attempts to go back before
the beginning of the program text go back to the beginning and stop
there.</p>
<p>This method returns the current token after any re-scanning.</p>
<p>This kind of backup method can be necessary when the token definitions
themselves are dynamically changed, such as by a semantic action.  For
example, a declaration for the string &#8220;my_fun&#8221; as a variable might
dynamically add a token for that new variable, which would then stop it
from matching a general identifier with an on_ties value set to, say,
-1.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.ignored_before_curr">
<tt class="descname">ignored_before_curr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.ignored_before_curr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.ignored_before_curr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all tokens ignored just before <cite>self.token</cite> (the
last token returned by the <cite>next</cite> function).  Useful for enforcing
things like syntactic whitespace requirements, along with
<cite>curr_token_is_first</cite>. This list is also set as the attribute
<cite>ignored_before_tokens</cite> on all returned tokens.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.is_begin_token">
<tt class="descname">is_begin_token</tt><big>(</big><em>token</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.is_begin_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.is_begin_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the token is the end token.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.is_defined_token_label">
<tt class="descname">is_defined_token_label</tt><big>(</big><em>token</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.is_defined_token_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.is_defined_token_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if <cite>token</cite> is currently defined as a token label.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.is_end_token">
<tt class="descname">is_end_token</tt><big>(</big><em>token</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.is_end_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.is_end_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether <cite>token</cite> is the end token.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.next">
<tt class="descname">next</tt><big>(</big><em>num=1</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next token, consuming from the token stream.  Also sets
<cite>self.token</cite> to the return value.  Returns one end token and raises
<cite>StopIteration</cite> on a <cite>next</cite> after that end token.  If <cite>num</cite> is greater
than one a list of the tokens is returned (this list is cut short if
the first end token is encountered, and so will never generate
<cite>StopIteration</cite>).  This method adds buffering on top of the lower-level
routine <cite>token_generator</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.peek">
<tt class="descname">peek</tt><big>(</big><em>num_toks=1</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.peek"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.peek" title="Permalink to this definition">¶</a></dt>
<dd><p>Peek ahead in the token stream without consuming any tokens.  Note
that the argument is the actual number of tokens ahead to peek.  I.e.,
the indexing starts at 1. (You can consider 0 to mean to peek at
the current token, and that also works.)  Peeking beyond the end
of the buffer raises <cite>BufferIndexError</cite>, a subclass of <cite>IndexError</cite>.
A peek within the buffer size is always valid, and returns an end
token for all peeks from the first end token and beyond.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.set_text">
<tt class="descname">set_text</tt><big>(</big><em>program</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.set_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.set_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Users should call this method to pass in the program text (or other
text) which is to be lexically scanned.  The parameter <cite>program</cite> should
be a string.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.token_generator">
<tt class="descname">token_generator</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.token_generator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.token_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine generates tokens from the program text in
<cite>self.program</cite>.  It does not modify the program itself, but keeps slice
indices in a list <cite>self.prog_unprocessed</cite> indexing the unprocessed
part.  That slice can be externally modified (the <cite>go_back</cite> routine
does this).</p>
<p>This is a lower-level function used by <cite>next</cite> to do the real work.  All
the token subclasses should have been defined and stored in the the
<cite>TokenSubclassSymbolTable</cite>.  Regexes defined for tokens are repeatedly
matched at the beinning of the string <cite>program</cite>.  When a winning_index
is found it is stripped off the beginning of the unprocessed slice of
<cite>program</cite> and the generator waits for the next call.  For each
winning_index the token subclass is looked up in the
<cite>TokenSubclassSymbolTable</cite> object and an instance of that subclass is
yielded to represent the token.  Every token processed is represented
by a unique new instance of the appropriate subclass of <cite>TokenNode</cite>.</p>
<p>This generator has two states which can be set class-globally to alter
the state of the generator.  The states are <cite>GenTokenState.ordinary</cite>
for ordinary scanning execution, and <cite>GenTokenState.end</cite> when all the
tokens have been read and the generator keeps returning nothing but end
tokens.  The end state is normally entered when the program text
becomes empty.  If that variable is later is set to have text again the
state switches back to ordinary.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.Lexer.undefine_token">
<tt class="descname">undefine_token</tt><big>(</big><em>token_label</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#Lexer.undefine_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.Lexer.undefine_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Undefine the token corresponding to <cite>token_label</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="wff_language.lexer.LexerException">
<em class="property">exception </em><tt class="descclassname">wff_language.lexer.</tt><tt class="descname">LexerException</tt><a class="reference internal" href="_modules/wff_language/lexer.html#LexerException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.LexerException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="wff_language.lexer.TokenNode">
<em class="property">class </em><tt class="descclassname">wff_language.lexer.</tt><tt class="descname">TokenNode</tt><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The base class for token objects.</p>
<dl class="method">
<dt id="wff_language.lexer.TokenNode.append_children">
<tt class="descname">append_children</tt><big>(</big><em>*token_nodes</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.append_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.append_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Append all the arguments as children, also setting their parent to self.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.convert_to_AST">
<tt class="descname">convert_to_AST</tt><big>(</big><em>convert_TokenNode_to_AST_node_fun</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.convert_to_AST"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.convert_to_AST" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this on the root node.  Converts the token tree to an abstract
syntax tree.  This basically converts the nodes one-to-one to a more
convenient type of node for the AST of a given application.  The
function <cite>convert_TokenNode_to_AST_node_fun</cite> should take one argument,
a <cite>TokenNode</cite> instance, and return an AST node instance for the
corresponding AST node.  Note that <cite>ast_label</cite> is an attribute of all
<cite>TokenNode</cite> instances in the final tree.  Any other attributes can be
copied over.  The AST nodes are only assumed to have an append_children
method which appends a child AST node.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.ignored_before">
<tt class="descname">ignored_before</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.ignored_before"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.ignored_before" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of tokens which were ignored just before this token.
This can be used, for example, to make sure that there is whitespace
between two tokens which require whitespace between them.  It can also
be used to find the level of indentation before a token.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.ignored_before_labels">
<tt class="descname">ignored_before_labels</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.ignored_before_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.ignored_before_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of token labels of tokens which were ignored just
before this token.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.label_repr">
<tt class="descname">label_repr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.label_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.label_repr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.old_repr">
<tt class="descname">old_repr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.old_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.old_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>This old representation is kept because it is used in some tests.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.original_text">
<tt class="descname">original_text</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.original_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.original_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the original text that was read in lexing the token, including
any ignored text.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.string_repr">
<tt class="descname">string_repr</tt><big>(</big><em>only_vals=False</em>, <em>only_labels=False</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.string_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.string_repr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.summary_repr">
<tt class="descname">summary_repr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.summary_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.summary_repr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="wff_language.lexer.TokenNode.token_label">
<tt class="descname">token_label</tt><em class="property"> = None</em><a class="headerlink" href="#wff_language.lexer.TokenNode.token_label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.tree_repr">
<tt class="descname">tree_repr</tt><big>(</big><em>indent=''</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.tree_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.tree_repr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenNode.value_repr">
<tt class="descname">value_repr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenNode.value_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenNode.value_repr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="wff_language.lexer.TokenSubclassSymbolTable">
<em class="property">class </em><tt class="descclassname">wff_language.lexer.</tt><tt class="descname">TokenSubclassSymbolTable</tt><big>(</big><em>token_subclassing_fun=&lt;function create_token_subclass at 0x2b6b488b6848&gt;</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenSubclassSymbolTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenSubclassSymbolTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is mainly used by the <cite>Lexer</cite> class.  A symbol table holding
subclasses of the <cite>TokenNode</cite> class for each token label defined in a <cite>Lexer</cite>
instance.</p>
<dl class="method">
<dt id="wff_language.lexer.TokenSubclassSymbolTable.create_token_subclass">
<tt class="descname">create_token_subclass</tt><big>(</big><em>token_label</em>, <em>store_in_dict=True</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenSubclassSymbolTable.create_token_subclass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenSubclassSymbolTable.create_token_subclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a subclass for tokens with label <cite>token_label</cite> and store it
in the symbol table.  Return the new subclass.  Raises a <cite>LexerException</cite>
if a subclass for <cite>token_label</cite> has already been created.  If
<cite>store_in_dict</cite> is <cite>False</cite> then the token is not stored.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenSubclassSymbolTable.get_token_subclass">
<tt class="descname">get_token_subclass</tt><big>(</big><em>token_label</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenSubclassSymbolTable.get_token_subclass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenSubclassSymbolTable.get_token_subclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up the subclasses of base class <cite>TokenNode</cite> corresponding to
<cite>token_label</cite> in the symbol table and return it.  Raises a
<cite>LexerException</cite> if no subclass is found for the token label.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenSubclassSymbolTable.has_key">
<tt class="descname">has_key</tt><big>(</big><em>token_label</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenSubclassSymbolTable.has_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenSubclassSymbolTable.has_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a token subclass for <cite>token_label</cite> has been stored.</p>
</dd></dl>

<dl class="method">
<dt id="wff_language.lexer.TokenSubclassSymbolTable.undefine_token_subclass">
<tt class="descname">undefine_token_subclass</tt><big>(</big><em>token_label</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#TokenSubclassSymbolTable.undefine_token_subclass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.TokenSubclassSymbolTable.undefine_token_subclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-define the token with label token_label.  The <cite>TokenNode</cite> subclass
previously associated with that label is removed from the dictionary.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="wff_language.lexer.create_token_subclass">
<tt class="descclassname">wff_language.lexer.</tt><tt class="descname">create_token_subclass</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#create_token_subclass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.create_token_subclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new token subclass representing tokens with label
<cite>token_label</cite>.  This is called from the <cite>create_token_subclass</cite> method  of
<cite>TokenSubclassSymbolTable</cite> when it needs to create a new one to start with.
This function should not be called directly, since attributes (like the
token label and a new subclass name) need to be added to the generated
subclass.</p>
<p>This function is the default argument to the <cite>token_subclassing_fun</cite>
keyword argument of the initializer for <cite>TokenSubclassSymbolTable</cite>.  Users
can define their own such function in order to add methods particular to
their application (the PrattParser class does this).</p>
<p>Using a separate subclass for each token label allows for attributes and
methods specific to a kind of token to be pasted onto the class itself
without conflicts.  For example, the PrattParser subclass adds nud and led
methods which are specific to a given token label.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.lexer.define_basic_tokens">
<tt class="descclassname">wff_language.lexer.</tt><tt class="descname">define_basic_tokens</tt><big>(</big><em>lex_or_pp</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#define_basic_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.define_basic_tokens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="wff_language.lexer.define_comment_to_EOL_token">
<tt class="descclassname">wff_language.lexer.</tt><tt class="descname">define_comment_to_EOL_token</tt><big>(</big><em>lex_or_pp</em>, <em>begin_string</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#define_comment_to_EOL_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.define_comment_to_EOL_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="wff_language.lexer.define_default_tokens">
<tt class="descclassname">wff_language.lexer.</tt><tt class="descname">define_default_tokens</tt><big>(</big><em>lex_or_pp</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#define_default_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.define_default_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines some default tokens for testing either a Lexer or a PrattParser.</p>
</dd></dl>

<dl class="function">
<dt id="wff_language.lexer.define_identifier_token">
<tt class="descclassname">wff_language.lexer.</tt><tt class="descname">define_identifier_token</tt><big>(</big><em>lex_or_pp</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#define_identifier_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.define_identifier_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="wff_language.lexer.define_whitespace_tokens">
<tt class="descclassname">wff_language.lexer.</tt><tt class="descname">define_whitespace_tokens</tt><big>(</big><em>lex_or_pp</em><big>)</big><a class="reference internal" href="_modules/wff_language/lexer.html#define_whitespace_tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#wff_language.lexer.define_whitespace_tokens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="wff_language.language_data.html"
                        title="previous chapter">2.1.6. wff_language.language_data module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="wff_language.parse_tree.html"
                        title="next chapter">2.1.8. wff_language.parse_tree module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/wff_language.lexer.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wff_language.parse_tree.html" title="2.1.8. wff_language.parse_tree module"
             >next</a> |</li>
        <li class="right" >
          <a href="wff_language.language_data.html" title="2.1.6. wff_language.language_data module"
             >previous</a> |</li>
        <li><a href="index.html">Skolem  documentation</a> &raquo;</li>
          <li><a href="wff_language.html" >2. wff_language package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Allen Barker.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>